<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Qué miras Bobo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Qué miras Bobo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Qué miras Bobo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="fengcai">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Qué miras Bobo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="https://github.com/leo710aka/bk/blob/main/DT1.jpg?raw=true">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Qué miras Bobo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-面试_组件" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/10/11/%E9%9D%A2%E8%AF%95_%E7%BB%84%E4%BB%B6/" class="article-date">
  <time class="dt-published" datetime="2023-10-11T03:11:00.000Z" itemprop="datePublished">2023-10-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/10/11/%E9%9D%A2%E8%AF%95_%E7%BB%84%E4%BB%B6/">面 逝 | 组件</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><ul>
<li><p>SQL 语言类别。</p>
<ol>
<li>DDL（数据定义语言）：DDL 用于定义和管理数据库对象（如表、索引、视图等）；<br>  <code>CREATE TABLE</code>：创建表。 <code>ALTER TABLE</code>：修改表结构。<code>DROP TABLE</code>：删除表。<code>CREATE INDEX</code>：创建索引。</li>
<li>DML（数据操作语言）：DML 用于对数据库中的数据进行操作；<br>  <code>SELECT</code>：查询数据。 <code>INSERT</code>：插入数据。 <code>UPDATE</code>：更新数据。  - <code>DELETE</code>：删除数据。</li>
<li>DCL（数据控制语言）：管理数据库对象的访问权限， <code>GRANT</code>：授予用户访问权限、<code>REVOKE</code>：回收用户访问权限 等。</li>
<li>TCL（事务控制语言）：用于管理数据库的事务，常用的命令包括 <code>COMMIT</code>：提交事务、 <code>ROLLBACK</code>：回滚事务、 <code>SAVEPOINT</code>：设置保存点，用于部分回滚。</li>
</ol>
</li>
<li><p>MySQL 数据类型</p>
<ol>
<li>数值类型：<ul>
<li>整数类型：<code>INT</code>（整数，4字节）  <code>TINYINT</code>（小整数，1字节） <code>SMALLINT</code>（小整数，2字节）  <code>MEDIUMINT</code>（中等整数，3字节）    <code>BIGINT</code>（大整数，8字节）</li>
<li>浮点数类型：<code>FLOAT</code>（单精度浮点数）  <code>DOUBLE</code>（双精度浮点数）</li>
<li>定点数类型：<code>DECIMAL</code>（定点数）</li>
</ul>
</li>
<li>日期和时间类型：<code>DATE</code>（日期）；<code>TIME</code>（时间）<code>DATETIME</code>（日期和时间，包括秒） <code>TIMESTAMP</code>（日期和时间，包括秒，通常用于记录数据的修改时间）</li>
<li>字符串类型：<code>CHAR</code>（定长字符串）； <code>VARCHAR</code>（变长字符串）；<code>TEXT</code>（较小的文本） <code>MEDIUMTEXT</code>（中等大小的文本）  <code>LONGTEXT</code>（较大的文本）<ul>
<li>CHAR 和 VAVARCHAR 的区别？<br> 1、CHAR 和 VAVARCHAR 类型在存储和检索方面有所不同<br> 2、CHAR 列长度固定为创建表时声明的长度，长度值范围是 1 到 255 当 CHAR值被存储时，它们被用空格填充到特定长度，检索 CHAR 值时需删除尾随空格。</li>
</ul>
</li>
<li>二进制类型：  <code>BINARY</code>（定长二进制字符串）   <code>VARBINARY</code>（变长二进制字符串） <code>BLOB</code>（较小的二进制数据）  <code>MEDIUMBLOB</code>（中等大小的二进制数据） <code>LONGBLOB</code>（较大的二进制数据）<ul>
<li>BLOB 和 TEXT 的区别。<ol>
<li>存储内容： <code>BLOB</code> 存储二进制数据，不进行字符集的转换。  <code>TEXT</code> 存储字符数据，会根据字符集进行相应转换</li>
<li>大小限制： <code>BLOB</code> 可以存储更大的二进制数据。  <code>TEXT</code> 可以存储更大的字符数据。</li>
<li>排序和比较： <code>BLOB</code> 进行二进制排序和比较。  <code>TEXT</code> 进行字符集排序和比较。</li>
<li>用途：  <code>BLOB</code> 适用存储图像、音频、视频等二进制文件。<code>TEXT</code> 适用存储文本文档、HTML、XML 等字符数据。</li>
</ol>
</li>
</ul>
</li>
<li>其他类型： <code>ENUM</code>（枚举类型） <code>SET</code>（集合类型）</li>
</ol>
</li>
<li><p>MySQL 里记录货币用什么字段类型好？</p>
<ul>
<li>在记录货币金额时，一般建议使用 DECIMAL 类型。DECIMAL 类型是一种精确的定点数类型，提供了更可靠的精确度，确保不会发生舍入误差,适合用于存储货币等需要精确计算的数值。</li>
<li>避免使用浮点数类型（如 FLOAT 或 DOUBLE）来表示货币金额，因为浮点数在计算中可能存在精度问题。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 9(precision)代表将被用于存储值的总的小数位数，而 2(scale)代表将被用于存储小数点后的位数。 </span></span><br><span class="line"><span class="comment">-- salary 列中的值的范围是从-9999999.99 到9999999.99。</span></span><br><span class="line">salary <span class="type">DECIMAL</span>(<span class="number">9</span>,<span class="number">2</span>)  </span><br></pre></td></tr></table></figure></li>
<li><strong>为表中得字段选择合适得数据类型</strong>：<br>  字段类型优先级: 整形&gt;date,time&gt;enum,char&gt;varchar&gt;blob,text<br>  优先考虑数字类型，其次是日期或者二进制类型，最后是字符串类型，同级别的数据类型，应该优先选择占用空间小的</li>
</ul>
</li>
<li><p>MySQL 中 <code>IN</code>、<code>EXISTS</code> 和 <code>LIKE</code> 的作用和用法，如何优化 <code>DISTINCT</code>？</p>
<ul>
<li><strong>IN</strong>：用于在 <code>WHERE</code> 子句中筛选出符合指定值列表中任一值的数据行。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询出 `id` 字段值为 1、2 或 3 的用户数据行</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure></li>
<li><strong>EXISTS</strong>：用于检查子查询是否返回任何行，如果子查询返回至少一行数据，则 <code>EXISTS</code> 返回 true；否则返回 false。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 上述示例会查询出至少有一笔订单关联的产品数据行</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products p <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> orders o <span class="keyword">WHERE</span> o.product_id <span class="operator">=</span> p.id);</span><br></pre></td></tr></table></figure></li>
<li><strong>LIKE</strong>：用于在 <code>WHERE</code> 子句中进行模糊查询，通常配合通配符使用包括 <code>%</code>（匹配任意长度的字符串）和 <code>_</code>（匹配单个字符）  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 上述示例会查询出名称以 &quot;apple&quot; 开头的产品数据行</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;apple%&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li>DISTINCT 在所有列上转换为 GROUP BY，并与 ORDER BY 子句结合使用。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> t1.a <span class="keyword">FROM</span> t1,t2 <span class="keyword">where</span> t1.a<span class="operator">=</span>t2.a;</span><br><span class="line"><span class="comment">-- 转换为等效的 GROUP BY 查询：</span></span><br><span class="line"><span class="keyword">SELECT</span> t1.a <span class="keyword">FROM</span> t1, t2 <span class="keyword">WHERE</span> t1.a <span class="operator">=</span> t2.a <span class="keyword">GROUP</span> <span class="keyword">BY</span> t1.a;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>什么是通用 SQL 函数？<br>1、CONCATAT(A, B) – 连接两个字符串值以创建单个字符串输出。通常用于将两个或多个字段合并为一个字段。<br>2、FORMATAT(X, D)- 格式化数字 X 到 D 有效数字。<br>3、CURRDATATE(), CURRTIME()- 返回当前日期或时间。<br>4、NOW（） – 将当前日期和时间作为一个值返回。<br>5、MONTH（），DAYAY（），YEAR（），WEEK（），WEEKDAYAY（） – 从日期值中提取给定数据。<br>6、HOUR（），MINUTE（），SECOND（） – 从时间值中提取给定数据。<br>7、DATATEDIFF（A，B） – 确定两个日期之间的差异，通常用于计算年龄<br>8、SUBTIMES（A，B） – 确定两次之间的差异。<br>9、FROMDAYAYS（INT） – 将整数天数转换为日期值</p>
</li>
<li><p><strong>一条 sql 的执行过程。</strong></p>
<ol>
<li>连接层：客户端是否与mysql连接。</li>
<li>server层：mysql8.0前会在缓存中查询是否执行过此sql，命中则直接返回；8.0后取消了这个机制。</li>
<li>语法解析器：对接收到的 SQL 语句进行解析，以检查其语法和语义是否正确。如果 SQL 语句有语法错误或违反数据库模式的约束，系统会返回相应的错误信息。</li>
<li>编译、优化SQL 语句：解析后，DBMS 将 SQL 语句编译成一个可执行的查询计划 explain。这个计划是一个数据结构，描述了如何从数据库中获取或操作数据。在编译阶段，DBMS 可能会对查询计划进行优化，以提高执行效率。优化过程包括选择合适的索引、调整连接顺序等。</li>
<li>执行器：DBMS 根据优化后的查询计划执行 SQL 语句，去存储引擎层读取数据库中的数据。这包括从磁盘读取数据，使用索引加速查询，应用过滤条件等。<br>  执行器执行前，会检查mysql的innodb的buffer pool的缓存，，未命中要先查db。select直接查询buffer pool，dml（增删改）还要设计日志，，，</li>
<li>存储引擎：如 innodb、myisam、memory都会向上层提供查询接口。</li>
<li><strong>返回结果：</strong> 执行完成后，DBMS 将结果返回给用户。结果可能是查询的结果集、执行成功的消息，或者在出现错误时的错误信息。</li>
</ol>
</li>
<li><p>Mysql引擎 如何把硬盘上的数据查到？</p>
<ol>
<li><strong>解析 SQL 语句：</strong> MySQL 首先解析查询语句，检查语法和语义，确保查询是合法的。</li>
<li><strong>查询优化：</strong> MySQL 会对查询进行优化，生成一个查询执行计划。</li>
<li><strong>执行查询计划：</strong> MySQL 数据库引擎按照优化后的执行计划执行查询。这涉及从硬盘读取数据。</li>
<li><strong>使用索引：</strong> 如果查询中使用了索引，并且优化器认为使用索引更有效，MySQL 将使用索引来快速定位和检索数据。索引通常存储在磁盘上，但在需要时会被加载到内存中，以提高查询速度。<br>  <strong>索引的使用发生在磁盘 I&#x2F;O 操作之前。</strong></li>
<li><strong>读取数据块：</strong> 如果数据没有在内存中，MySQL 数据库引擎将从磁盘读取数据块（通常是页）到内存中。<br>  MySQL将数据以页(Page)为单位组织在磁盘上。一页通常包含多条记录，每页的大小是固定的。MySQL从磁盘上读取整个页，而不仅仅是所需的单个记录。读磁盘是一次 I&#x2F;0 操作，MySQL 使用一种称为预读的技术，一次性读取多个相邻的数据块，以提高性能。<br>  首先，MySQL 发送读取请求到存储设备（硬盘），包括要读取的数据块的位置信息（例如磁盘上的扇区或页）以及读取的数量。磁盘根据请求移动磁头到指定的位置。这个过程称为磁盘寻道，寻道时间是磁盘 I&#x2F;O 中的主要时间消耗部分。一旦磁头到达目标轨道，磁盘开始旋转，以便将所需的数据块转到磁头下方，磁盘开始传输数据到内存中。 </li>
<li><strong>缓存：</strong> MySQL 使用缓存来存储经常访问的数据块，这样在后续查询中可以更快地访问这些数据。这包括查询结果的缓存、索引缓存和数据缓存等。使用一个称为InnoDB Buffer Pool的缓存池来存储数据页。</li>
<li><strong>返回结果：</strong> 当查询完成时，MySQL 将结果返回给用户。</li>
</ol>
</li>
<li><p>数据库存储引擎</p>
<ul>
<li>数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以 获得特定的功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎。<br>  存储引擎主要有： 1. MyIsam, 2. InnoDB, 3. Memory, 4. Archive, 5. Federated</li>
<li>InnoDB：底层存储结构为B+树， B树的每个节点对应innodb的一个page， page大小是固定的，一般设为 16k。其中非叶子节点只有键值，叶子节点包含完成数据、、适用场景：<br>  1）经常更新的表，适合处理多重并发的更新请求。<br>  2）支持事务。<br>  3）可以从灾难中恢复（通过 bin-log 日志等）。<br>  4）外键约束。只有他支持外键。<br>  5）支持自动增加列属性 auto_increment。</li>
<li>MyIASM：是 MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当 NSERT(插入)或 UPDATATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。<br>  ISAM 执行读取操作的速度很快，而且不占用大量的内存和存储资源。在设计之初就预想数据组织成有固定长度的记录，按顺序存储的。 —ISAM 是一种静态索引结构。缺点是它不 支持事务处理。</li>
<li>Memery 就是将数据放在内存中，数据处理速度很快，但是安全性不⾼。</li>
</ul>
</li>
<li><p><strong>MyISAM 和 InnoDB</strong> 有什么区别？<br>（1）MyISAM 只支持表级别的锁粒度，InnoDB 支持行级别的锁粒度。<br>（2）MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别。<br>（3）MyISAM 不支持外键，而 InnoDB 支持。<br>（4）MyISAM 不支持 MVCC，而 InnoDB 支持。<br>（5）虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。<br>（6）MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。<br>（7）InnoDB 的性能比 MyISAM 更强大。</p>
</li>
<li><p>索引、、<br>在 MySQL 中，索引是一种特殊的数据结构，用于加快数据库表中数据的检索速度。索引在数据库表中的一个或多个列上创建，可以将这些列的值快速映射到实际数据的物理位置。<br>索引（Index）是帮助 MySQL 高效获取数据的数据结构。 常见的查询算法,顺序查找,二分查找,二叉排序树查找,哈希散列法,分块查找,平衡多路搜索树 B 树（B-tree） ，索引是对数据库表中一个或多个列的值进行排序的结构，建立索引有助于快速获取信息。<br>你也可以这样理解：索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库 mysql。<br>索引并非是越多越好，创建索引也需要耗费资源，一是增加了数据库的存储空间，二是在插入和删除时要花费较多的时间维护索引<br>索引加快数据库的检索速度<br>索引降低了插入、删除、修改等维护任务的速度<br>唯一索引可以确保每一行数据的唯一性<br>通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能<br>索引需要占物理和数据空间</p>
</li>
<li><p>索引有哪些种类。</p>
<ul>
<li>从数据结构维度进⾏分类:<br>  B+树索引:所有数据存储在叶⼦节点，复杂度为O(logn)，适合范围查询。<br>  哈希索引:适合等值查询，检索效率⾼，⼀次到位<br>  全⽂索引: MyISAM 和 InnoDB 中都⽀持使⽤全⽂索引，⼀般在⽂本类型char，text，varchar 类型上创建<br>  R-Tree 索引:⽤来对 GIS 数据类型创建 SPATIAL 索引</li>
<li>从物理存储维度进⾏分类:<br>  聚集索引:数据存储与索引⼀起存放，叶⼦节点会存储⼀整⾏记录，找到索引也就找到了数据。<br>  ⾮聚集索引:数据存储与索引分开存放，叶⼦节点不存储数据，存储的是数据⾏地址。</li>
<li>从逻辑维度进⾏分类:<br>  主键索引:⼀种特殊的唯⼀索引，不允许有空值。<br>  普通索引:MySQL中基本索引类型，允许空值和重复值<br>  联合索引:多个字段创建的索引，使⽤时遵循最左前缀原则<br>  唯⼀索引:索引列中的值必须是唯⼀的，但是允许为空值<br>  空间索引:MySQL5.7之后⽀持空间索引，在空间索引这⽅⾯遵循OpenGIS⼏何数据模</li>
</ul>
</li>
<li><p>主键？聚集索引，非聚集索引？</p>
<ul>
<li>主键：主键是一种用于唯一标识表中每一行数据的列或列组合。主键列的值必须唯一且不为空（NULL）。在InnoDB中，主键索引是表的物理排序顺序，它是表的聚集索引。如果表没有显式定义主键，InnoDB会选择一个合适的唯一非空索引来充当主键索引。</li>
<li>聚集索引：在MySQL中，聚集索引决定了数据在磁盘上的物理存储顺序，即数据的存储顺序与索引顺序一致。在InnoDB存储引擎中，主键索引就是一个聚集索引。如果表没有显式定义主键，则InnoDB会选择一个唯一非空的索引来充当聚集索引。</li>
<li>非聚集索引：非聚集索引在磁盘上维护索引键和对应数据行的引用，索引键的顺序与实际数据行的物理存储顺序无关。在MySQL中，除了InnoDB存储引擎的聚集索引（主键索引），其他索引都是非聚集索引，例如普通索引或唯一索引。</li>
</ul>
</li>
<li><p>InnoDB 建议为大部分表使用默认的自增主键的主要原因</p>
<ol>
<li><strong>聚簇索引：</strong> InnoDB 表的主键是聚簇索引（Clustered Index），这意味着数据行的物理顺序与聚簇索引的顺序一致。使用自增主键作为聚簇索引可以确保新插入的数据按顺序添加到表的末尾，减少数据页的分裂和碎片，提高数据的顺序性。</li>
<li><strong>插入性能：</strong> 自增主键的顺序性有助于提高插入性能。因为数据行按主键的顺序插入，新的数据行往往直接添加到表末尾，而不会导致页面的分裂和数据的重新排序。</li>
<li><strong>查询性能：</strong> 使用自增主键作为聚簇索引可以提高范围查询和排序查询的性能，因为相关数据在物理上是相邻存储的。</li>
<li><strong>减少索引大小：</strong> 自增主键通常是整数，占用的空间相对较小。相比于使用其他类型的主键，这可以减少非聚簇索引的大小，提高缓存的效率，减少磁盘 I&#x2F;O。</li>
<li><strong>减少碎片：</strong> 自增主键的插入顺序有助于减少数据页的分裂和碎片，减小了表的维护成本。</li>
</ol>
</li>
<li><p>什么时候需要创建索引？<br>表的主关键字：⾃动建⽴唯⼀索引<br>直接条件查询的字段：经常⽤于WHERE查询条件的字段，这样能够提⾼整个表的查询速度<br>查询中与其它表关联的字段：例如字段建⽴了外键关系<br>查询中排序的字段：排序的字段如果通过索引去访问将⼤⼤提⾼排序速度<br>唯⼀性约束列： 如果某列具有唯⼀性约束，那么为了确保数据的唯⼀性，可以在这些列上创建唯⼀索引。<br>⼤表中的关键列： 在⼤表中，如果查询的效率变得很低，可以考虑在关键列上创建索引。</p>
</li>
<li><p>什么时候不需要创建索引？<br>⼩表： 对⼩表创建索引可能会带来额外的开销，因为在⼩数据集中扫描整个表可能⽐使⽤索引更快。<br>频繁的插⼊、更新和删除操作： 索引的维护成本会随着数据的插⼊、更新和删除操作⽽增加。如果表经常被修改，过多的索引可能会影响性能。<br>数据重复且分布平均的表字段：假如⼀个表有10万⾏记录，性别只有男和⼥两种值，且每个值的分布概率⼤约为50%，那么对这种字段建索引⼀般不会提⾼数据库的查询速度。<br>很少被查询的列： 如果某列很少被⽤于查询条件，那么为它创建索引可能没有明显的性能提升。<br>查询结果总⾏数较少的表： 如果查询的结果集总⾏数很少，使⽤索引可能不会有太⼤的性能提升。</p>
</li>
<li><p>常见索引原则</p>
<ol>
<li>选择唯一性索引，唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。</li>
<li>为经常需要排序、分组和联合操作的字段建立索引。</li>
<li>为常用作为查询条件的字段建立索引。</li>
<li>限制索引的数目：越多的索引，会使更新表变得很浪费时间。尽量使用数据量少的索引</li>
<li>如果索引的值很长，那么查询的速度会受到影响。尽量使用前缀来索引</li>
<li>如果索引字段的值很长，最好使用值的前缀来索引。</li>
<li>删除不再使用或者很少使用的索引</li>
<li>最左前缀匹配原则，非常重要的原则。</li>
<li>尽量选择区分度高的列作为索引区分度的公式是表示字段不重复的比例</li>
<li>索引列不能参与计算，保持列“干净”：带函数的查询不参与索引。</li>
<li>尽量的扩展索引，不要新建索引</li>
</ol>
</li>
<li><p>最左前缀匹配原则</p>
<ul>
<li>在使用复合索引（composite index）时，如果查询条件中使用了索引的第一个列作为条件，那么数据库可以利用这个索引来加速查询；但如果查询条件中只使用了索引的前几个列，而没有使用索引的第一个列作为条件，那么数据库无法利用这个索引来加速查询。</li>
<li>具体来说，假设有一个复合索引 <code>(col1, col2, col3)</code>，这个索引按照 <code>col1</code>、<code>col2</code>、<code>col3</code> 的顺序排列。根据最左前缀匹配原则，以下情况适用：<br>  1.当查询条件中包含了索引的第一个列 <code>col1</code> 时，数据库可以使用索引来加速查询。例如：  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> col1 <span class="operator">=</span> <span class="string">&#x27;value&#x27;</span>;</span><br></pre></td></tr></table></figure>
  2.当查询条件中包含了索引的前几个列 <code>col1</code>、<code>col2</code> 时，数据库也可以使用索引来加速查询。例如：  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> col1 <span class="operator">=</span> <span class="string">&#x27;value1&#x27;</span> <span class="keyword">AND</span> col2 <span class="operator">=</span> <span class="string">&#x27;value2&#x27;</span>;</span><br></pre></td></tr></table></figure>
  3.如果查询条件中包含了索引的所有列 <code>col1</code>、<code>col2</code>、<code>col3</code> 并且按照索引的顺序出现，那么可以触发索引。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> col1 <span class="operator">=</span> <span class="string">&#x27;value1&#x27;</span> <span class="keyword">AND</span> col2 <span class="operator">=</span> <span class="string">&#x27;value2&#x27;</span> <span class="keyword">AND</span> col3 <span class="operator">=</span> <span class="string">&#x27;value3&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li>但是，如果查询条件中只使用了索引的后几个列，而没有使用索引的第一个列作为条件，则无法利用这个索引加速查询。如：  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> col2 <span class="operator">=</span> <span class="string">&#x27;value2&#x27;</span> <span class="keyword">AND</span> col3 <span class="operator">=</span> <span class="string">&#x27;value3&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>覆盖索引？回表查询？</p>
<ul>
<li>覆盖索引是指一个查询语句所需的数据可以从索引中直接获取，而无需访问表格中的实际数据行。这种情况下，索引“覆盖”了查询的所有需要的列。覆盖索引的优势在于可以减少磁盘 I&#x2F;O 和内存的消耗，因为不需要额外的表格访问。</li>
<li>回表查询指的是在使用索引的情况下，通过索引定位到主键，然后再根据主键的值去表中检索数据的过程。这通常发生在覆盖索引（Covering Index）无法满足查询需求时。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> products (</span><br><span class="line">    product_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    product_name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    price <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    quantity <span class="type">INT</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 为 product_name 列创建索引 idx_product_name</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_product_name <span class="keyword">ON</span> products (product_name);</span><br><span class="line"><span class="comment">-- 假设我们有一条数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> products (product_id, product_name, price, quantity) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;Laptop&#x27;</span>, <span class="number">999.99</span>, <span class="number">50</span>);</span><br><span class="line"><span class="comment">-- 现在，如果我们执行以下查询：</span></span><br><span class="line"><span class="keyword">SELECT</span> product_name, price <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> product_name <span class="operator">=</span> <span class="string">&#x27;Laptop&#x27;</span>;</span><br><span class="line"><span class="comment">-- 从索引中获取的列 product_name，但 price 列不在查询的列中，MySQL 将执行回表查询</span></span><br><span class="line"><span class="comment">-- MySQL 首先使用索引 idx_product_name 找到匹配 Laptop 的行，获取到对应的 product_id(主键)，然后根据 product_id 到表格中检索完整的行数据以获取 price 值</span></span><br><span class="line"><span class="comment">-- 这种情况下，如果我们希望避免回表查询，可以考虑创建一个覆盖索引，将查询语句中需要的所有列都包含在索引中，便无需执行额外的回表查询</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_product_name_covering <span class="keyword">ON</span> products (product_name, price);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>B+ Tree(InnoDB)索引</strong></p>
<ul>
<li>数据分块存储，每一块称为一页。所有的值都是按顺序存储的，并且每一个叶子到根的距离相同。</li>
<li>非叶节点存储数据的边界，叶子节点存储指向数据行的指针。通过边界缩小数据的范围，从而避免全表扫描，加快了查找的速度。</li>
<li>B+ 树索引是一种索引结构，通常用于数据库管理系统中作为数据的索引方式。它可以用作聚集索引或非聚集索引，并不是严格意义上的主键索引。在数据库中，B+树索引在不同存储引擎下，例如在InnoDB中作为主键索引（聚集索引）使用，或作为其他索引（非聚集索引）的实现。  <img src="https://leo710aka.github.io/bk/job5.png" width="550" height="300" alt=""></li>
</ul>
</li>
<li><p>B树 与 B+树 的区别</p>
<ul>
<li>B树：节点从小到大排序，一个节点可存多个元素</li>
<li>B+树：拥有B树的特点，叶子结点间有指针，叶子结点存储了所有的元素</li>
<li>B树和B+树，一般都是应用在文件系统和数据库系统中，用来减少磁盘IO带来的性能损耗。<br>  以Mysql中的InnoDB为例，当我们通过select语句去查询一条数据时，InnoDB需要从磁盘上去读取数据，这个过程会涉及到磁盘IO以及磁盘的随机IO（如图所示）我们知道磁盘IO的性能是特别低的，特别是随机磁盘IO。因为，磁盘IO的工作原理是，首先系统会把数据逻辑地址传给磁盘，磁盘控制电路按照寻址逻辑把逻辑地址翻译成物理地址，也就是确定要读取的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要把磁头放在这个扇区的上面，为了实现这一个点，磁盘会不断旋转，把目标扇区旋转到磁头下面，使得磁头找到对应的磁道，这里涉及到寻道事件以及旋转时间<br>  很明显，磁盘IO这个过程的性能开销是非常大的，特别是查询的数据量比较多的情况下。所以在InnoDB中，干脆对存储在磁盘块上的数据建立一个索引，然后把索引数据以及索引列对应的磁盘地址，以B+树的方式来存储。如图所示，当我们需要查询目标数据的时候，根据索引从B+树中查找目标数据即可，由于B+树分路较多，所以只需要较少次数的磁盘IO就能查找到。</li>
</ul>
</li>
<li><p>为什么 MySQL 的索引要使用 B+ 树而不是其它树形结构？</p>
<ul>
<li>B 树是一种多路平衡树，用这种存储结构来存储大量数据，它的整个高度会相比二叉树来说，会矮很多。<br>  而对于数据库来说，所有的数据必然都是存储在磁盘上的，而磁盘 IO 的效率实际上是很低的，特别是在随机磁盘 IO 的情况下效率更低。所以树的高度能够决定磁盘 IO 的次数，磁盘 IO 次数越少，对于性能的提升就越大，这也是为什么采用 B 树作为索引存储结构的原因。  <img src="https://leo710aka.github.io/bk/job7.png" width="550" height="300" alt=""></li>
<li>对于 B 树，不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致 IO 操作变多，查询性能变低。在 Mysql 的 InnoDB 存储引擎里面用了一种增强的 B 树结构，也就是 B+树来作为索引和数据的存储结构。  <img src="https://leo710aka.github.io/bk/job8.png" width="600" height="300" alt=""></li>
<li>使用 B+树来实现索引的原因，我认为有几个方面。<ol>
<li>B+树非叶子节点不存储数据，所以每一层能够存储的索引数量会增加，意味着 B+树在层高相同的情况下存储的数据量要比 B 树要多，使得磁盘 IO 次数更少。</li>
<li>在 Mysql 里面，范围查询是一个比较常用的操作，而 B+树的所有存储在叶子节点的数据使用了双向链表来关联，所以在查询的时候只需查两个节点进行遍历就行，而 B 树需要获取所有节点，所以 B+树在范围查询上效率更高。</li>
<li>在数据检索方面，由于所有的数据都存储在叶子节点，所以 B+树的 IO 次数会更加稳定一些。</li>
<li>叶子节点存储所有数据，所以 B+树的全局扫描能力更强一些，它只需要扫描叶子节点。但是 B 树需要遍历整个树。<br>  另外，基于 B+树这样一种结构，如果采用自增的整型数据作为主键，还能更好的避免增加数据的时候，带来叶子节点分裂导致的大量运算的问题。</li>
</ol>
</li>
</ul>
</li>
<li><p>为什么选择 B+Tree 而不是红黑树？</p>
<ul>
<li>红黑树等平衡树也可以用来实现索引,但是文件系统及数据库系统,普遍采用 B+ Tree作为索引结构这是因为其访问磁盘数据有更高的性能。我主要从两个点来回答</li>
<li>第一点：对于一个数据库来说 存储的数据量会比较多，导致索引也很大 因此需要将索引存储在磁盘，但是磁盘的 IO 操作又非常耗，所以提高索引效率的关键在于减少磁盘 IO 的次数。相同节点个数 的 B+Tree 的高度更小，树的高度基本决定了磁盘的 IO 次数 ，所以使用 B+Tree 性能要高很多</li>
<li>第二点：B+Tree 有个特点是相邻的数据在物理上也是相邻的，因为 B+Tree 的 node 的大小设为一个页，而一个节点上存有多个相邻的关键字和分支信息，每个节点只需要一次 IO就能完全载入，相当于一次 IO 载入了多个相邻的关键字和分支，而红黑树不具有这个特性，红黑树中大小相邻的数据，在物理结构上可能距离相差很大。由于程序的局部性原理，如果我们在索引中采用了预加载的技术，每次磁盘访问的时候除了将访问到的页加载到磁盘，我们还可以基于局部性原理加载，几页相邻的数据到内存中，而这个加载是不需要消耗多余磁盘 IO 时间的。<br>  因此 基于局部性原理，以及 B+Tree 存储结构物理上的特性，所以 B+Tree 的索引性能比红黑树要好很多。</li>
</ul>
</li>
<li><p>在数据库的表上建立了 <code>(time DESC, name DESC)</code> 的复合索引，什么情况下失效&#x2F;生效？</p>
<ol>
<li><strong>索引生效的情况：</strong><ul>
<li><strong>查询条件涉及到两个字段：</strong> 当查询条件涉及到索引的两个字段时，复合索引可以生效。例如：查询条件包括了 <code>time</code> 和 <code>name</code>，而且与索引的顺序一致，因此该复合索引可以被有效利用。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> your_table <span class="keyword">WHERE</span> <span class="type">time</span> <span class="operator">&gt;</span> <span class="string">&#x27;2022-01-01&#x27;</span> <span class="keyword">AND</span> name <span class="operator">=</span> <span class="string">&#x27;John&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">time</span> <span class="keyword">DESC</span>, name <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>查询条件只涉及到部分字段：</strong> 当查询条件只涉及到索引的一部分字段时，也可能会使用到该复合索引。例如：查询条件只包含了 <code>time</code> 字段，但由于 <code>time</code> 是索引的第一个字段，所以该索引可能仍然生效。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> your_table <span class="keyword">WHERE</span> <span class="type">time</span> <span class="operator">&gt;</span> <span class="string">&#x27;2022-01-01&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">time</span> <span class="keyword">DESC</span>, name <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>索引不生效的情况：</strong><ul>
<li><strong>查询条件没有使用到索引的前缀：</strong> 如果查询条件中没有使用到索引的前缀字段，那么复合索引可能不会被使用。例如：查询条件只包含了 <code>name</code> 字段，没用到 <code>time</code> 字段，因此 <code>(time DESC, name DESC)</code> 这个复合索引可能不被使用  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> your_table <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;John&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">time</span> <span class="keyword">DESC</span>, name <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>查询条件的顺序不符合索引的顺序：</strong> 复合索引的顺序很重要，如果查询条件的顺序与索引的顺序不一致，索引可能无法被有效利用。例如：虽然包含了索引的两个字段，但查询条件的顺序与索引的顺序不一致，因此索引可能不会被使用。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> your_table <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;John&#x27;</span> <span class="keyword">AND</span> <span class="type">time</span> <span class="operator">&gt;</span> <span class="string">&#x27;2022-01-01&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">time</span> <span class="keyword">DESC</span>, name <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><p>MySQL 索引失效的几种情况</p>
<ol>
<li>OR 语句前后没有同时使用索引。要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="operator">!</span><span class="comment">-- 生效的情况 --&gt;</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> your_table <span class="keyword">WHERE</span> <span class="type">time</span> <span class="operator">&gt;</span> <span class="string">&#x27;2022-01-01&#x27;</span> <span class="keyword">OR</span> name <span class="operator">=</span> <span class="string">&#x27;John&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">time</span> <span class="keyword">DESC</span>, name <span class="keyword">DESC</span>;</span><br><span class="line"><span class="operator">&lt;</span><span class="operator">!</span><span class="comment">-- 不生效的情况 --&gt;</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> your_table <span class="keyword">WHERE</span> <span class="type">time</span> <span class="operator">&gt;</span> <span class="string">&#x27;2022-01-01&#x27;</span> <span class="keyword">OR</span> other_column <span class="operator">=</span> <span class="string">&#x27;some_value&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">time</span> <span class="keyword">DESC</span>, name <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li>
<li>复合索引未用左列字段。对于复合索引，如果不使用前列，后续列也将无法使用。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> your_table <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;John&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">time</span> <span class="keyword">DESC</span>, name <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li>
<li>like以%开头；模糊匹配  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> your_table <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%John&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">time</span> <span class="keyword">DESC</span>, name <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li>
<li>需要类型转换。存在索引列的数据类型隐形转换，则用不上索引。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> your_table <span class="keyword">WHERE</span> <span class="built_in">CAST</span>(<span class="type">time</span> <span class="keyword">AS</span> <span class="type">VARCHAR</span>) <span class="operator">=</span> <span class="string">&#x27;2022-01-01&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">time</span> <span class="keyword">DESC</span>, name <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li>
<li>where中索引列有数学运算。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> your_table <span class="keyword">WHERE</span> <span class="type">time</span> <span class="operator">*</span> <span class="number">2</span> <span class="operator">=</span> <span class="string">&#x27;2022-01-01&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">time</span> <span class="keyword">DESC</span>, name <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li>
<li>where中索引列使用了函数。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> your_table <span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(<span class="type">time</span>) <span class="operator">=</span> <span class="number">2022</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">time</span> <span class="keyword">DESC</span>, name <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li>
<li>如果mysql觉得全表扫描更快时（数据少）。</li>
</ol>
</li>
<li><p>联合索引（Composite Index）</p>
<ul>
<li>也称为复合索引，是指同时包含多个列的索引，它可以更加精确地定位数据，提高查询的效率。<br>  通常情况下，一个表中可能存在多个需要经常用于查询的列，使用联合索引可以将这些列组合起来，建立一个复合索引。在查询时，如果查询条件同时包含联合索引中的多个列，数据库可以直接使用索引定位到符合条件的行，避免了全表扫描，提高了查询效率。<br>  需要注意的是，在使用联合索引时，需要考虑索引的顺序。通常情况下，应该将最常用于查询的字段放在索引的前面，这样可以更加有效地利用索引。另外，联合索引也存在一些限制。由于索引是按照索引列的顺序建立的，因此只有在查询条件中包含索引的最左侧的列时，MySQL 才能利用这个索引。如果查询条件中包含的列不是索引的最左侧列，那么 MySQL 就无法使用这个索引。<br>  此外，由于联合索引包含多个列，因此其维护成本也相对较高。如果经常更新其中一个列的值，可能会导致索引的重建，影响数据库的性能。因此，在建立联合索引时，应该根据具体的应用场景，权衡利弊，避免滥用。</li>
<li>如何使用联合索引？<br>  1、联合索引的最左前缀匹配指的是where条件一定要有联合索引的第一个字段<br>  2、是否走联合索引与where条件的顺序无关，只与字段有关</li>
<li>联合索引的最左前缀匹配原则<br>  最左前缀匹配原则指的是，在使用联合索引时，MySQL 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询（如 &gt;、&lt;）才会停止匹配。对于 &gt;&#x3D;、&lt;&#x3D;、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配。所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。</li>
<li>联合索引的作用？<br>  1、减少io操作的开销和磁盘空间的开销；<br>  2、提升性能。索引列越多，通过索引筛选出的数据越少。<br>  3、覆盖索引。直接通过遍历索引取得数据，无需回表。<br>  提高查询效率：联合索引可以加速对多列数据的查询，对于联合索引中包含的列，可以同时使用它们进行筛选，减少了查询的数据量，提高了查询效率。<br>  减少磁盘IO：联合索引可以将多个列的数据存储在一起，减少了需要读取的磁盘块数，从而降低了IO的开销。<br>  优化排序操作：如果查询需要按照联合索引中的多个列进行排序，联合索引可以避免对多个独立索引的排序操作，从而提高排序操作的效率</li>
</ul>
</li>
<li><p><strong>MySQL 最左前缀索引的底层原理</strong>、、<br>涉及到 B-Tree 索引结构以及 MySQL 的查询优化器。<br>B-Tree 索引是一种常见的索引结构，用于快速检索数据库中的数据。在 B-Tree 索引中，数据按照键值有序存储，每个节点包含多个键值和对应的指针。MySQL 使用 B-Tree 索引来实现各种索引类型，包括最左前缀索引。<br>当你创建一个多列索引时，MySQL 实际上会创建一个按照指定列顺序建立的 B-Tree 索引。这个索引会按照指定的列值顺序存储数据，因此在查询时，如果查询条件只涉及到索引的最左前缀列，MySQL 就可以利用这个索引来加速查询。<br>？？？</p>
</li>
<li><p>简单描述 MySQL 中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响？（从读写两方面）<br>索引是一种特殊的文件(InnoDB 数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。<br>普通索引(由关键字 KEY 或 INDEX 定义的索引)的唯一任务是加快对数据的访问速度。索引可以极大的提高数据的查询速度，但是会降低插入、删除、更新表的速度，因为在执行这些写操作时还要操作索引文件。普通索引允许被索引的数据列包含重复的值。<br>如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字 UNIQUE 把它定义为一个唯一索引。唯一索引可以保证数据记录的唯一性。<br>主键，是一种特殊的唯一索引，在一张表中只能定义一个主键索引，用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建。<br>索引可以覆盖多个数据列，如像 INDEX(columnA, columnB)索引，这就是联合索引。</p>
</li>
<li><p><code>EXPLAIN</code> 执行计划</p>
<ul>
<li>通过分析 EXPLAIN 返回的执行计划，可以了解查询的优化情况，如是否使用了索引、是否进行了全表扫描等。对于需要优化的查询，可以根据执行计划进行优化，例如添加适当的索引、调整查询语句等。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> customers <span class="keyword">WHERE</span> city <span class="operator">=</span> <span class="string">&#x27;New York&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li>执行计划中的信息通常包括以下内容：<ul>
<li>id：查询步骤的标识符。</li>
<li>select_type：查询类型，如 SIMPLE、PRIMARY、SUBQUERY 等。</li>
<li>table：查询涉及的表。</li>
<li>type：访问类型，如 ALL、INDEX、RANGE 等，表示数据库如何访问表中的数据。</li>
<li>possible_keys：可能用到的索引。</li>
<li>key：实际使用的索引。</li>
<li>rows：估计的返回行数。</li>
<li>Extra：其他信息，如使用了临时表、使用了文件排序等。</li>
</ul>
</li>
</ul>
</li>
<li><p>SQL 优化？</p>
<ul>
<li>优化查询语句、、<ol>
<li><strong>选择需要的列而不是使用 <code>SELECT *</code>：</strong></li>
<li><strong>减少子查询，使用关联查询：</strong>   尽量使用关联查询（LEFT JOIN、RIGHT JOIN、INNER JOIN）替代子查询，以提高查询效率。使用 JOIN 操作来代替手动创建的临时表，提高查询效率。</li>
<li><strong>避免使用 IN 或 NOT IN，使用 EXISTS 或关联查询：</strong> 以提高查询性能。</li>
<li><strong>使用 UNION 或 UNION ALL 代替 OR 查询：</strong> 特别是当确定没有重复数据时，使用 UNION ALL 更为效率。</li>
<li><strong>选择合适的字段属性：</strong> 尽可能减少定义字段宽度，设置合适的数据类型。尽量把字段设置 NOT NULL，例如’省份’、’性别’最好适用 ENUM</li>
</ol>
</li>
<li>基于索引查询、、<ol>
<li>为常用的查询条件和连接条件创建索引，以加速查询速度。确保数据库引擎能够充分利用索引。</li>
<li><strong>避免对索引列进行函数或运算：</strong>  尽量避免在索引列上使用函数或运算，以确保索引的有效使用。</li>
<li><strong>WHERE 子句中的 LIKE 使用 % 放在右边：</strong>   在使用 LIKE 操作时，尽量将 % 放在右边，以便索引的有效使用。</li>
<li><strong>尽量使用 SQL 语句用到的索引完成排序：</strong>  避免使用文件排序的方式。</li>
<li><strong>避免在 WHERE 子句中使用 !&#x3D; 或 &lt;&gt; 操作符：</strong>  以免引擎放弃使用索引而进行全表扫描。</li>
<li><strong>避免在 WHERE 子句中对字段进行 NULL 值判断：</strong>可以设置默认值或使用其他方式，以免引擎放弃使用索引而进行全表扫描。如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：select id from t where num&#x3D;0</li>
</ol>
</li>
<li>数据库事务、、<ol>
<li><strong>事务处理和锁定表优化：</strong>    合理使用事务处理，避免锁定表的情况，以提高数据库并发性能。</li>
</ol>
</li>
</ul>
</li>
<li><p>MySQL 优化？</p>
<ul>
<li>硬件和操作系统层面的优化<br>  硬件层面来说，影响 Mysql 性能的因素有，CPU、可用内存大小、磁盘读写速度、网络带宽从操作系层面来说，应用文件句柄数、操作系统网络的配置都会影响到 Mysql 性能。这部分的优化一般由 DBA 或者运维工程师去完成。在硬件基础资源的优化中，我们重点应该关注服务本身承载的体量，然后提出合理的指标要求，避免出现资源浪费！</li>
<li>架构设计层面的优化<br>  MySQL 是一个磁盘 IO 访问量非常频繁的关系型数据库，在高并发和高性能的场景中承受巨大的并发压力，<br>  1、搭建 Mysql 主从集群，单个 Mysql 服务容易单点故障，一旦服务器宕机，将会导致依赖 Mysql 数据库的应用全部无法响应。 主从集群或者主主集群可以保证服务的高可用性。<br>  2、读写分离设计，在读多写少的场景中，通过读写分离的方案，可以避免读写冲突导致的性能影响？？<br>  3、引入分库分表机制，通过分库可以降低单个服务器节点的 IO 压力，通过分表的方式可以降低单表数据量，从而提升 sql 查询的效率。<br>  4、针对热点数据，可以引入更为高效的分布式数据库，比如 Redis、MongoDB 等，他们可以很好的缓解 Mysql 的访问压力，同时还能提升数据检索性能。</li>
<li>MySQL 程序配置优化<br>  对于 Mysql 数据库本身的优化，一般是通过 Mysql 中的配置文件 my.cnf 来完成的，比如。<br>  Mysql5.7 版本默认的最大连接数是 151 个，这个值可以在 my.cnf 中修改。binlog 日志，默认是不开启。缓存池 bufferpoll 的默认大小配置等。<br>  由于这些配置一般都和用户安装的硬件环境以及使用场景有关系，因此这些配置官方只会提供一个默认值，具体情况还得由使用者来修改。<br>  关于配置项的修改，需要关注两个方面。1. 配置的作用域，分为会话级别和全局；2. 是否支持 热加载<br>  因此，针对这两个点，我们需要注意的是：1. 全局参数的设定对于已经存在的会话无法生效; 2. 会话参数的设定随着会话的销毁而失效; 3. 全局类的统一配置建议配置在默认配置文件中，否则重启服务会导致配置失效</li>
<li>表结构和索引的优化<br>  主要可以下面这些方面去优化分库分表、读写分离、为字段选择合适的数据类型、适当的反范式设计，适当冗余设计、为查询操作创建必要的索引但是要避免索引滥用、尽可能使用 Not Null。</li>
<li>？？？ SQL 优化<br>  第一、慢 SQL 的定位和排查我们可以通过慢查询日志和慢查询日志分析工具得到有问题的 SQL 列表。<br>  第二、执行计划分析针对慢 SQL，我们可以使用关键字 explain 来查看当前 sql 的执行计划.可以重点关注type key rows filterd 等字段 ，从而定位该 SQL 执行慢的根本原因。再有的放矢的进行优化<br>  第三、使用 show profile 工具Show Profile 是 MySQL 提供的可以用来分析当前会话中，SQL 语句资源消耗情况的工具，可用于 SQL 调优的测量。在当前会话中.默认情况下处于 show profile 是关闭状态，打开之后保存最近 15 次的运行结果。针对运行慢的 SQL，通过 profile 工具进行详细分析.可以得到 SQL 执行过程中所有的资源开销情况. 如 IO 开销,CPU 开销,内存开销等.</li>
</ul>
</li>
<li><p>什么是内联接、左外联接、右外联接、全连接？<br>内联接（Inner Join）：匹配2张表中相关联的记录。<br>左外联接（Left Outer Join）：除了匹配2张表中相关联的记录，还会匹配左表中剩余的记录，右表中未匹配到的字段用NULL表示。<br>右外联接（Right Outer Join）：除了匹配2张表中相关联的记录，还会匹配右表中剩余的记录，左表未匹配到的字段用NULL表示。<br>全连接（Full Join 或 Full Outer Join）：在使用全连接时，无论左表和右表是否存在匹配，都会返回两个表中所有的行，并在没有匹配的行处填充 NULL 值。</p>
</li>
<li><p>drop、delete与truncate的区别<br>SQL中的drop、delete、truncate都表示删除，但是三者有一些差别<br>delete 和 truncate 只删除表的数据不删除表的结构速度,一般来说: drop&gt; truncate &gt;delete<br>delete 语句是 <strong>dml</strong>,这个操作会放到rollback segement中，事务提交之后才生效；如果有相应的trigger,执行的时候将被触发.<br>truncate,drop是 <strong>ddl</strong>, 操作立即生效，原数据不放到rollbacksegment中,不能回滚. 操作不触发trigger</p>
</li>
<li><p>部分依赖和传递依赖。</p>
<ol>
<li><strong>部分依赖：</strong>发生在一个表的主键（Primary Key）中包含了多个字段，但是其中的某些字段并不完全依赖于主键的所有部分。简言之，某个非主键字段只依赖于主键的一部分。<br>  举例：考虑一个订单表，主键是订单号和商品编号（OrderID, ProductID），如果订单表中还有商品名称（ProductName），而商品名称仅依赖于商品编号而不依赖于订单号，那么商品名称对于订单表来说就是一个部分依赖。</li>
<li><strong>传递依赖：</strong>发生在一个非主键字段依赖于其他非主键字段，而这些其他非主键字段又依赖于主键。简言之，某个非主键字段依赖于其他非主键字段，而这些其他字段依赖于主键。<br>  举例：考虑员工表，主键是员工编号(EmployeeID)，表中包含了部门编号(DepartmentID）)和部门名称(DepartmentName)。如果部门名称依赖于部门编号，而部门编号又依赖于员工编号，那么部门名称对于员工表来说就是一个传递依赖。</li>
</ol>
</li>
<li><p>范式：解决部分依赖和传递依赖的一种方法是通过数据库范式化，通常是将表拆分成更小的表。</p>
<ul>
<li>范式理论是为了解决四种异常。不符合范式的关系（表的属性的组合），会产生很多异常：1、冗余数据。2、修改异常: 修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。3、删除异常: 删除一个信息，那么也会丢失其它信息。4、插入异常: 例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li>
<li>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。<ol>
<li>第一范式 (1NF)：属性不可分。</li>
<li>第二范式 (2NF)：每个非主属性完全函数依赖于键码。可以通过分解来满足。（一张表分解成多张表）</li>
<li>第三范式 (3NF)：非主属性不传递函数依赖于键码。可以进行分解。</li>
</ol>
</li>
<li>如何通俗地理解三个范式？<br>  第一范式：1NF 是对属性的原子性约束，要求属性具有原子性，不可再分解；<br>  第二范式：2NF 是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性；<br>  第三范式：3NF 是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。</li>
</ul>
</li>
<li><p>什么是基本表？什么是<strong>视图</strong>？游标是什么？<br>基本表是本身独立存在的表，在 SQL 中一个关系就对应一个表。<br>视图本身不独立存储在数据库中，是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，视图是从一个或几个基本表导出的表，视图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。<br>游标：是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。</p>
</li>
<li><p>事务、、</p>
<ul>
<li>事务（Transaction）是一组数据库操作，它们形成一个逻辑工作单元，要么全部成功执行，要么全部失败回滚。事务的目的是保证数据库的一致性和完整性，确保在多个操作中要么全部成功，要么全部失败，不会留下中间状态。</li>
<li>事务的特性：通常被称为 <strong>ACID</strong> 特性<ul>
<li><strong>原子性（Atomicity）</strong> 事务是一个完整的操作。事务的各步操作是不可分的（原子的）；要么都执行，要么都不执行。</li>
<li><strong>一致性（Consistency）</strong>当事务完成时，数据必须处于一致状态。</li>
<li><strong>隔离性（Isolation）</strong> 对数据进行修改的所有并发事务是彼此隔离的， 这表明事务必须是独立的，它不应以任何方式依赖于或影响其他事务。</li>
<li><strong>永久性（Durability）</strong> 事务完成后，它对数据库的修改被永久保持，事务日志能够保持事务的永久性</li>
</ul>
</li>
<li>事务的隔离性<ul>
<li>并发异常：第一类丢失更新、第二类丢失更新脏读、不可重复读、幻读</li>
<li>隔离级别：Read Uncommitted、Read Conmitted、Repeatable Read、Serializable</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>并发事务带来哪些问题?</strong><br>  在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>
<ul>
<li>脏读（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li>
<li>丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修。 例如：事务1读取某表中的数据A&#x3D;20，事务2也读取A&#x3D;20，事务1修改A&#x3D;A-1，事务2也修改A&#x3D;A-1，最终结果A&#x3D;19，事务1的修改被丢失。</li>
<li>不可重复读（Unrepeatableread）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li>
<li>幻读（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。不可重复读和幻读区别：不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了</li>
</ul>
</li>
<li><p>SQL 标准定义的<strong>四个事务隔离级别有哪些?</strong></p>
<ul>
<li>READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能导致脏读、幻读或不可重复读。</li>
<li>READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍可能发生。 </li>
<li><strong>REPEATATATABLE-READ(可重复读)<strong>： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍可能发生（特点情况下）、、</strong>InnoDB 存储引擎的默认支持的隔离级别是 【可重复读】</strong>。</li>
<li>SERIALIZABLE(可串行化)：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读</li>
</ul>
</li>
<li><p>MySQL的事务隔离级别与锁的关系、、</p>
<ul>
<li>MySQL 中的事务隔离级别通过不同类型的锁（共享锁、排它锁等）以及锁的粒度（行级锁、表级锁等）来实现对事务的隔离，保证了事务在并发环境下的正确执行。选择合适的事务隔离级别需要根据具体业务需求和性能要求进行权衡。<ol>
<li><strong>读未提交（Read Uncommitted）</strong>：不涉及锁的机制，允许事务读取其他事务未提交的数据，可能会出现脏读。</li>
<li><strong>读提交（Read Committed）</strong>：使用共享锁（Shared Locks）和瞬时的排他锁（Exclusive Locks）来实现；<ul>
<li>当一个事务读取数据时，会对数据进行共享锁定，这样其他事务可以读取相同的数据，但不能修改。</li>
<li>当一个事务修改数据时，会对数据进行排他锁定，这样其他事务不能读取也不能修改相同的数据，直到该事务提交或回滚。</li>
</ul>
</li>
<li><strong>可重复读（Repeatable Read）</strong>：使用共享锁（Shared Locks）和持久的排他锁（Exclusive Locks）来实现；<ul>
<li>当一个事务读取数据时，会对数据进行共享锁定，这样其他事务可以读取相同的数据，但不能修改。</li>
<li>当一个事务修改数据时，会对数据进行持久的排他锁定，直到该事务提交或回滚，其他事务都不能读取或修改相同的数据。</li>
</ul>
</li>
<li><strong>串行化（Serializable）</strong>：<ul>
<li>MySQL 会对读取的数据行和写入的数据行都进行（行级）排它锁，确保事务串行执行，避免了幻读的问题。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="comment">-- 对某个数据进行读取时，其他事务无法对该数据进行写入或者读取的操作，直到该事务完成读取操作</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> <span class="keyword">condition</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="comment">-- 在这里进行读取和处理操作</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li>隔离级别越低，锁机制越不严格，事务请求的锁越少，并发性越高，性能开销也越小</li>
<li>InnoDB 默认支持的隔离级别是REPEATATATABLE-READ（可重读），在 分布式事务 的情况下一般会用到 SERIALIZABLE(可串行化) 隔离级别。</li>
</ul>
</li>
<li><p>MySQL 支持事务吗？<br>在缺省模式下，MySQL 是 autocommit 模式的，所有的数据库更新操作都会即时提交，所以 MySQL 默认不支持事务。<br>但是如果你的 MySQL 表类型是使用 InnoDB TaTables 或 BDB tables 的话，你的MySQL 就可以使用事务处理,在非autocommit 模式下，你必须使用 COMMIT 来提交你的更改，或者用 ROLLBACK来回滚你的更改。</p>
</li>
<li><p>？？？Innodb是如何实现事务的<br>Innodb通过BufferPool，LogBuffer，Redo Log，undoLog来实现事务，以一个update语句为例:<br>1.Innodb在收到一个update语句后，会先根据条件找到数据所在的页，并将该页缓存在BufferPool中<br>2.执行update语句，修改BufferPool中的数据，也就是内存中的数据<br>3.针对update语句生成一个Redo Log对象，并存入LogBuffer中<br>4.针对update语句生成undolog日志，用于事务回滚<br>5.如果事务提交，那么则把Redo Log对象进行持久化，后续还有其他机制将BufferPool中所修改的数据页持久化到磁盘中<br>6.如果事务回滚，则利用undolog日志进行回滚</p>
</li>
<li><p>innoDB 如何解决幻读？<br>1、Mysql 有四种事务隔离级别，其中 InnoDB 在 RR（可重复读）的隔离级别下，解决了幻读的问题（在特定的情况下会出现幻读的问题。具体什么情况下会出现幻读呢？？？<br>2、幻读是指在同一个事务中，前后两次查询相同的范围时，得到的结果不一致<br>3、InnoDB 引入了间隙锁和 next-key Lock 机制来解决幻读问题？？</p>
</li>
<li><p>MySQL 单表为什么不要超过 2千万条 时最优？</p>
<ul>
<li>查询性能：随着数据量的增加，查询可能变得更慢，特别是在没有合适索引支持的情况下。大表需要更多的计算资源和时间来处理查询，可能导致性能下降。</li>
<li>索引和缓存：维护大表的索引和缓存可能会变得更加困难。索引的大小随着数据量的增加而增加，这可能导致索引扫描变慢，同时也会增加对内存的需求。<br>  1、一个高度为 3 的 B+ 树可以存放： 1170X1170X16&#x3D;21902400 条这样的记录,即2千万多些，通过主键查询一条数据，只需要3次磁盘IO访问，当超出2千万条时，索引树高度为4。<br>  2、mysql都有缓存，树高度为3时，第一层和第二层的数据都在缓存，高度为3查询效率很快，但是超过高度4时，查询效率就急速下降了。</li>
<li>锁和并发：在执行更新或删除操作时，数据库可能需要对表进行锁定，以确保数据的一致性。大表的锁定可能会阻塞其他操作，影响并发性能。</li>
</ul>
</li>
<li><p>分表、、</p>
<ul>
<li>分表是一种应对大表数据量的常见方法。通过将大表拆分为多个小表（分区），可以减轻数据库管理系统的负担，提高查询性能和管理效率。分表可以根据业务逻辑或特定的列值进行拆分，例如按时间范围、地理区域等方式进行分区。</li>
<li>在考虑分表之前，建议进行以下操作：<br>  优化查询和索引：确保数据库表有适当的索引来支持常见的查询，并优化查询语句以提高性能。<br>  限定数据的范围：务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；<br>  ？？？读&#x2F;写分离：经典的数据库拆分方案，主库负责写，从库负责读；<br>  垂直和水平分割：考虑将大表进行垂直切分（按列拆分）或水平切分（按行拆分）以减少单个表的数据量。<br>  使用分区：针对数据库支持的分区功能，可以考虑根据特定的标准将表分成多个逻辑分区。<br>  数据库优化：定期清理无用数据、重新构建索引、优化数据库配置等，以提高数据库的整体性能。</li>
</ul>
</li>
<li><p>分库分表之后,id 主键如何处理？？？<br>因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要一个全局唯一的 id 来支持。生成全局 id 有下面这几种方式：<br>UUID：不适合作为主键，因为太长了并且无序不可读，查询效率低。比较适合用于生成唯一的名字的标示比如文件的名字。<br>数据库自增 id : 两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。这种方式生成的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。<br>利用 redis 生成 id : 性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更加复杂，可用性降低，编码更加复杂，增加了系统成本。</p>
</li>
</ul>
<h3 id="Mysql锁、、"><a href="#Mysql锁、、" class="headerlink" title="Mysql锁、、"></a>Mysql锁、、</h3><ul>
<li><p>什么是锁？<br>答：数据库是一个多用户使用的共享资源。当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。加锁是实现数据库并发控制的一个非常重要的技术。当事务在对某个数据对象进行操作前，先向系统发出请求，对其加锁。加锁后事务就对该数据对象有了一定的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作。</p>
</li>
<li><p><strong>锁的类型</strong>（按类型）</p>
<ul>
<li>悲观锁：悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加锁，只有自己把数据读完了，才允许别人修改那部分数据，或者反过来说，就是自己修改某条数据的时候，不允许别人读取该数据，只有的整个事务提交了，才释放自己加上的锁，允许其他用户访问那部分数据。<ul>
<li>悲观锁所说的加“锁”，其实分为几种锁，分别是： 排它锁（写锁）和共享锁（读锁） 。</li>
</ul>
</li>
<li>乐观锁：乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据；悲观锁就刚好相反，觉得自己读数据库的时候，别人可能刚好在写自己刚读的数据，其实就是持一种比较保守的态度；<ul>
<li>时间戳：时间戳就是不加锁，通过时间戳来控制并发出现的问题。在数据库表中单独加一列时间戳，比如“TimeStamp”， 每次读出来的时候，把该字段也读出来，当写回去的时候，把该字段加1，提交之前 ，跟数据库的该字段比较一次，如果比数据库的值大的话，就允许保存，否则不允许保存，这种处理方法虽然不使用数据库系统提供的锁机制，但是这种方法可以大大提高数据库处理的并发量</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>锁的类型</strong>（按粒度）</p>
<ol>
<li>全局锁：锁定数据库中所有的表（数据备份）</li>
<li>表级锁：对当前操作的整张表加锁，它实现简单，开销小、加锁快，发生锁冲突的概率高、并发度低，不会出现死锁；被大部分 MySQL 引擎支持。最常使用的 MYISAM 与 INNODB 都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。        <ul>
<li>表锁：锁住整张表，粒度较大</li>
<li>元数据锁：防止 DML 和 DDL 冲突</li>
<li>意向锁：避免加锁是一行一行查看行锁加锁情况，解决上述低效的问题<ul>
<li>意向共享锁 (IS): 表级，准备加共享锁</li>
<li>意向排他锁 (Ix) : 表级，准备加排他锁</li>
</ul>
</li>
</ul>
</li>
<li>行级锁：开销大、加锁慢，发生锁冲突的概率低、并发度高，会出现死锁<ul>
<li>行级锁是一种排他锁，防止其他事务修改此行；在使用以下语句时， Oracle 会自动应用行级锁：<ol>
<li>INSERT、 UPDATATE、 DELETE、 SELECT … FOR UPDATATE [OF columns] [WAWAIT n | NOWAWAIT];</li>
<li>SELECT … FOR UPDATATE 语句允许用户一次锁定多条记录进行更新</li>
<li>使用 COMMIT 或 ROLLBACK 语句释放锁。</li>
</ol>
</li>
<li>共享锁 (s) : 行级，读取一行</li>
<li>排他锁 (x) : 行级，更新一行</li>
<li>间隙锁 (NK) : 行级，使用范围条件时</li>
</ul>
</li>
</ol>
</li>
<li><p>加锁、、</p>
<ul>
<li>对范围内不存在的记录加锁。一是为了防止幻读，二是为了满足恢复和复制的需要</li>
<li>增加行级锁之前，InnoDB会自动给表加意向锁</li>
<li>执行DML语句（update、delete和insert）时，InnoDB会自动给数据加排他锁</li>
<li>执行DQL语句时：<ul>
<li>通常情况下，单纯的select不会加锁，因为InnoDB默认的隔离级别是可重复读，使用MVCC来避免加锁</li>
<li>共享锁 (s) :SELECT … FROM … WHERE … LOCK IN SHARE MODE</li>
<li>排他锁 (x) :SELECT … FROM … WHERE … FOR UPDATE;</li>
<li>间隙锁 (NK) : 上述sQ采用范围条件时，InnoDB对不存在的记录自动增加间隙锁</li>
</ul>
</li>
</ul>
</li>
<li><p>数据库并发策略<br>并发控制一般采用三种方法，分别是乐观锁和悲观锁以及时间戳。</p>
</li>
<li><p>？？？锁的优化策略<br>1、读写分离<br>2、分段加锁<br>3、减少锁持有的时间<br>4.多个线程尽量以相同的顺序去获取资源不能将锁的粒度过于细化，不然可能会出现线程的加锁和释放次数过多，反而效率不如一次加一把大锁。</p>
</li>
<li><p>存储过程。什么是存储过程？用什么来调用？<br>一组为了完成特定功能的 SQL 语句集，存储在数据库中，经过第一次编译后再次调用不需要再次编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。如果某次操作需要执行多次 SQL，使用存储过程比单纯 SQL 语句执行要快。存储过程是数据库中的一个重要对象。</p>
</li>
<li><p>存储过程优化思路</p>
<ol>
<li>尽量利用一些 sql 语句来替代一些小循环，例如聚合函数，求平均函数等。</li>
<li>中间结果存放于临时表，加索引。</li>
<li>少用游标。sql 是个集合语言，对于集合运算具有较高性能。而 cursors 是过程运算。比如对一个 100 万行的数据进行查询。游标需要读表 100 万次，而不使用游标则只需要少量几次读取。</li>
<li>事务越短越好。 sqlserver 支持并发操作。如果事务过多过长，或者隔离级别过高，都会造成并发操作的阻塞，死锁。导致查询极慢，cpu 占用率极地。</li>
<li>使用 try-catch 处理错误异常。6. 查找语句尽量不要放在循环内</li>
</ol>
</li>
<li><p>SQL 注入、、</p>
<ul>
<li>产生的原因：程序开发过程中不注意规范书写 sql 语句和对特殊字符进行过滤，导致客户端可以通过全局变量 POST 和 GET 提交一些 sql 语句正常执行。</li>
<li>类型：1、恶意拼接查询 2、利用注释执行非法命令 3、传入非法参数 4、添加额外条件</li>
<li>如何避免 SQL 注入？<br>  1、过滤输入内容，校验字符串：在数据提交到数据库之前，就把用户输入中的不合法字符剔除掉。<br>  2、参数化查询：参数化查询目前被视作是预防 SQL 注入攻击最有效的方法。指在设计与数据库连接并访问数据时，在需要填入数值或数据的地方，使用参数（Parameter）来给值。</li>
</ul>
</li>
<li><p>MVCC 机制、、？？？</p>
<ul>
<li>MVCC（Multi-Version Concurrency Control）多版本并发控制，⽤于管理多个事务同时访问和修改数据库的数据，⽽不会导致数据不⼀致或冲突。MVCC的核⼼思想是每个事务在数据库中看到的数据版本是事务开始时的⼀个快照，⽽不是实际的最新版本。这使得多个事务可以并发执⾏，⽽不会互相⼲扰。<br>  MySQL的隔离性可以通过锁和MVCC来实现，MVCC适合在⼀些锁性能较为差的情况下使⽤，提⾼效率。</li>
<li>如何实现：每⼀个 UndoLog ⽇志中都有⼀个 roll_pointer （回滚指针）⽤于指向上⼀个版本的 Undo Log 。这样对于每⼀条记录就会构成⼀个版本链，⽤于记录所有的修改，每⼀次进⾏新的修改后，新的 Undo Log 会放在版本链的头部。</li>
<li>在我们进⾏查询的时候应该查询哪个版本呢？这时候就可以通过 ReadView 来实现。在事务SELECT查询数据时，就会构造⼀个 ReadView ，它包含了版本链的统计信息：<br>  m_ids 当前活跃的所有事务id（所有未提交的事务）<br>  min_trx_id 版本链尾的id<br>  max_trx_id 下⼀个将要分配的事务id（版本链头事务id+1）<br>  creator_trx_id 创建这个ReadView的事务的id 查询规则：<br>  该版本是否为当前事务创建（读取⾃⼰修改的数据），如果是就返回，否则进⼊下⼀个判断<br>  该版本的事务id是否⼩于min_trx_id（在ReadView创建之前，数据已经提交），可以直接访问<br>  该版本的事务id是否⼤于max_trx_id（在ReadView创建后，该版本才开启），不能被访问<br>  该版本事务id在[min_trx_id, max_trx_id]之间，则判断当前版本事务id是否在m_ids中，如果不在，说明事务已经提交可以访问，否则不能访问。</li>
<li>对 MVCC 的理解。<ul>
<li>对于 MVCC 的理解，我觉得可以先从数据库的三种并发场景说起：<br>  第一种：读读就是线程 A 与线程 B 同时在进行读操作，这种情况下不会出现任何并发问题。<br>  第二种：读写就是线程 A 与线程 B 在同一时刻分别进行读和写操作。这种情况下，可能会对数据库中的数据造成以下问题：事物隔离性问题，出现脏读，幻读，不可重复读的问题<br>  第三种：写写就是线程 A 与线程 B 同时进行写操作。这种情况下可能会存在数据更新丢失的问题。而 MVCC 就是为了解决事务操作中并发安全性问题的无锁并发控制技术全称为Multi-Version Concurrency Control ，也就是多版本并发控制。它是通过数据库记录中的隐式字段，undo 日志 ，Read View 来实现的。</li>
<li>MVCC 主要解决了三个问题<br>  第一个：通过 MVCC 可以解决读写并发阻塞问题从而提升数据并发处理能力<br>  第二个：MVCC 采用了乐观锁的方式实现，降低了死锁的概率<br>  第三个：解决了一致性读的问题。也就是事务启动时根据某个条件读取到的数据，直到事务结束时，再次执行相同条件，还是读到同一份数据，不会发生变化。而我们在使用 MVCC 时一般会根据业务场景来选择组合搭配乐观锁或悲观锁。这两个组合中，MVCC 用来解决读写冲突，乐观锁或者悲观锁解决写写冲突从而最大程度的提高数据库并发性能。以上就是我的对 MVCC 的理解。</li>
</ul>
</li>
</ul>
</li>
<li><p>Mysql日志</p>
<ul>
<li>binlog(归档⽇志) 是 Server 层⽣成的⽇志，主要⽤于数据备份（宕机后的恢复工作）和主从复制, 解决数据库和缓存之间一致性可以用canal？？组件去监听binlog</li>
<li>redolog 是 Innodb 物理⽇志，记录了某个数据⻚做了什么修改，每当执⾏⼀个事务就会产⽣⼀条或者多条物理⽇志。<br>  如果发送宕机，对读取到内存中的bufferpool中的数据没有同步到硬盘mysql中，使用redolog来同步，保证事务的一致性。</li>
<li>undolog 是 Innodb 逻辑⽇志，用于记录数据修改前的信息（记录对数据库操作的逆操作，事务回滚时逆操作恢复原数据）比如我们删除一条数据的时候，就会在undolog日志文件中新增一条delete语句； 实现了事务中的原⼦性，主要⽤于事务回滚和MVCC。</li>
<li>relaylog 中继⽇志，⽤于主从复制场景下， slave 通过io线程拷⻉master的 binlog 后本地⽣成的⽇志</li>
</ul>
</li>
<li><p>当MySQL的日志空间不足时，可能会导致以下影响：</p>
<ol>
<li>写入操作： 日志（例如二进制日志和事务日志）是用来记录数据库的写入操作的，如果日志空间不足，数据库可能无法正常写入事务日志，导致事务无法提交。这可能会导致写入操作被阻塞或失败。</li>
<li>查询操作： 查询操作通常不直接受到日志空间不足的影响。然而，如果写入操作因为日志空间不足而受阻，可能会导致查询操作因为等待事务完成而变慢。</li>
<li>备份操作： 备份通常会涉及到数据库的日志文件。如果日志空间不足，可能会影响备份的正常执行。备份通常需要确保数据库的一致性，而事务日志在这个过程中是至关重要的。</li>
</ol>
</li>
<li><p>MySQL 数据库作发布系统的存储，一天五万条以上的增量，预计运维三年，怎么优化？<br>1、设计良好的数据库结构，允许部分数据冗余，尽量避免 join 查询，提高效率。<br>2、选择合适的表字段数据类型和存储引擎，适当的添加索引。<br>3、MySQL 库主从读写分离。<br>4、找规律分表，减少单表中的数据量提高查询速度。<br>5、添加缓存机制，比如 memcached，apc 等。<br>6、不经常改动的页面，生成静态页面。<br>7、书写高效率的 SQL。比如 SELECT * FROM TATABEL 改为 SELECT field_1,field_2, field_3 FROM TATABLE.</p>
</li>
<li><p>数据库如何处理大数据量？</p>
<ul>
<li>分区：一份数据文件拆分多个磁盘文件存储，隔离数据访问。相当于做了负载均衡。</li>
<li>水平分库&#x2F;表，各个库和表的结构一模一样。<br>  垂直分库&#x2F;表，各个库和表的结构不一样。</li>
<li>读写分离：主机负责写，从机负责读。</li>
</ul>
</li>
<li><p>MySQL主从、、</p>
<ul>
<li>主是主库的意思，从是从库的意思。数据库主库对外提供读写的操作，从库对外提供读的操作。</li>
<li>数据库为什么需要主从架构呢?<ul>
<li>高可用，实时灾备，用于故障切换。比如主库挂了，可以切从库。</li>
<li>读写分离，提供查询服务，减少主库压力，提升性能</li>
<li>备份数据，避免影响业务。</li>
</ul>
</li>
<li>主从复制原理，简言之，分三步曲进行:<ul>
<li>主数据库有个 <code>bin 1og</code> 二进制文件，纪录了所有增删改 sQL语句。(binlog线程)</li>
<li>从数据库把主数据库的 <code>bin 1og</code> 文件的 sQL 语句复制到自己的中继日志 <code>relay 1og</code> (io线程)</li>
<li>从数据库的 <code>relay 1og</code> 重做日志文件，再执行一次这些sql语句。(Sql执行线程)</li>
</ul>
</li>
<li>怎么保证主从一致？<br>  我们学习数据库的主从复制原理后，了解到从库拿到并执行主库的binlog日志，就可以保持数据与主库一致了。这是为什么呢?哪些情况会导致不一致呢?<ul>
<li>1 长链接<br>  主库和从库在同步数据的过程中断怎么办呢，数据不就会丢失了嘛。因此主库与从库之间维持了一个长链接，主库内部有一个线程，专门服务于从库的这个长链接的。</li>
<li>2 bintog格式<br>  binlog 日志有三种格式，分别是statement，row和mixed。<br>  如果是 statement 格式，binlog记录的是SQL的原文，如果主库和从库选的索引不一致，可能会导致主库不一致。<br>  如何解决这个问题呢？可以把binlog格式修改为 row。row 格式的 binlog 日志，记录的不是SQL原文，而是两个 event:Table_map 和 Delete_rows 。Table_map event说明要操作的表，Delete_rows event用于定义要删除的行为:记录删除的具体行数。row 格式的binlog记录的就是要删除的主键ID信息,因此不会出现主从不一致的问题。<br>  但是如果SQL删除10万行数据，使用row格式就会很占空间的，10万条数据都在binlog里面写binlog的时候也很耗I0。但是 statement 格式的binlog可能会导致数据不一致，因此设计MySQL的大叔想了一个折中的方案， mixed 格式的binlog。所谓的mixed格式其实就是 row 和statement 格式混合使用，当MySQL判断可能数据不一致时，就用row 格式，否则使用就用statement 格式。</li>
</ul>
</li>
<li>主从延迟、、</li>
<li>高可用方案<ul>
<li>双机主备：两台机器A和B，A为主库，负责读写，B为备库，只备份数据。如果A库发生故障，B库成为主库负责读写。修复故障后，A成为备库，主库B同步数据到备库A</li>
<li>一主一从：两台机器A和B，A为主库，负责读写，B为从库，负责读数据。如果A库发生故障，B库成为主库负责读写。修复故障后，A成为从库，主库B同步数据到从库A</li>
<li>一主多从：多个从库支持读，分担了主库的压力，明显提升了读的并发度。但只有台主机写，因此写的并发度不高</li>
<li>MariaDB同步多主机：有代理层实现负载均衡，多个数据库可以同时进行读写操作；各个数据库之间可以通过 Galera Replication 方法进行数据同步，每个库理论上数据是完全一致的。数据库不支持过大。</li>
<li>数据库中间件：mycat分片存储，每个分片配置一主多从的集群。优点:解决高并发高数据量的高可用方案；缺点:维护成本比较大。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>

<h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><ul>
<li><p>什么是 Mybatis？<br>1、Mybatis 是一个开源的<strong>Java持久层框架</strong>，半 ORM（对象关系映射）框架，它内部封装了  JDBC，开发时只需要关注 SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement 等繁杂的过程。程序员直接编写原生态 sql，可以严格控制 sql 执行性能，灵活度高。（JDBC（Java Database Connectivity）是 Java 语言用于与关系型数据库进行交互的一种标准接口。JDBC 提供了一组 Java API，允许开发者通过 Java 代码来执行 SQL 查询、更新数据库、以及处理数据库事务等操作。）<br>2、MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO 映射成数据库中的记录，避免了几乎所有的  JDBC 代码和手动设置参数以及获取结果集。<br>3、通过 xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过 java 对象和 statement 中 sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为  java 对象并返回。（从执行 sql 到返回 result 的过程）。</p>
</li>
<li><p>ORM，DAO，持久层？<br>ORM 和 DAO 是持久层的实现方式，ORM 和 DAO 通常一起协同工作，以实现数据的持久化和访问。持久层包括了使用 ORM 框架进行对象和数据库映射的方式，以及使用 DAO 设计模式封装数据访问操作的方式。DAO 提供了数据访问的通用接口，业务逻辑层通过 DAO 来进行数据访问，从而实现了持久层的解耦。</p>
</li>
<li><p>一般 JDBC 执行 SQL 查询或更新操作的流程涉及以下步骤：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 加载数据库驱动</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>); </span><br><span class="line"><span class="comment">//2. 建立数据库连接</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/xx&quot;</span>, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;password&quot;</span>);</span><br><span class="line"><span class="comment">//3. 创建 Statement 或 PreparedStatement 对象</span></span><br><span class="line"><span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line"><span class="comment">//4. 执行 SQL 语句</span></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery(<span class="string">&quot;SELECT * FROM yy&quot;</span>);</span><br><span class="line"><span class="comment">//5. 处理结果集（如果有）</span></span><br><span class="line"><span class="keyword">while</span> (resultSet.next()) &#123; <span class="comment">// 处理查询结果</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6. 关闭资源：方法关闭 ResultSet、Statement 和 Connection 对象，释放数据库连接和资源。</span></span><br><span class="line">resultSet.close();</span><br><span class="line">statement.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure>
</li>
<li><p>Mybatis执行流程<img src="https://leo710aka.github.io/bk/job13.png" width="750" height="300" alt=""></p>
</li>
</ul>
<ol>
<li>加载配置文件：MyBatis 首先会加载配置文件（通常是 XML 格式的），该配置文件包含了数据源信息、SQL 映射文件的位置、全局配置等。</li>
<li>解析配置文件：MyBatis 会解析加载的配置文件，将配置信息存储在相应的配置对象中，比如数据源对象、全局配置对象、SQL 映射配置对象等。</li>
<li>创建 SqlSessionFactory：根据解析得到的配置信息，MyBatis 创建一个 SqlSessionFactory 对象，该对象是一个线程安全的工厂类，用于创建 SqlSession 对象。</li>
<li>创建 SqlSession：通过 SqlSessionFactory 创建 SqlSession 对象，SqlSession 提供了执行 SQL 操作的方法，比如查询、插入、更新等。每个线程都应该有自己的 SqlSession 实例，SqlSession 不是线程安全的，因此通常在方法内部创建和关闭。</li>
<li>解析 Mapper 文件：在执行 SQL 操作之前，MyBatis 会解析 Mapper 文件，Mapper 文件中定义了 SQL 语句的映射关系，包括 SQL 语句、参数映射、结果映射等。</li>
<li>执行 SQL 操作：通过 SqlSession 执行 SQL 操作，MyBatis 提供了多种方法来执行 SQL，比如 selectOne、selectList、insert、update、delete 等。</li>
<li>映射结果：执行 SQL 操作后，MyBatis 将结果映射为 Java 对象，根据 Mapper 文件中的配置将查询结果映射为 Java 对象，并返回给调用者。</li>
<li>关闭资源：在完成所有操作后，需要关闭 SqlSession，释放数据库连接和其他资源，以避免资源泄露和性能问题。</li>
</ol>
<ul>
<li><p>Mybatis的优缺点，适用场合。</p>
<ul>
<li>优点:<br>  1.基于 SQL 编程，相当灵活，不会对应用程序或者数据库的现有设计成任何影响，SQL 写在 XML 里，解除 sql 与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态 SQL 语句，并可重用。<br>  2.与 JDBC 相比，减少了 50%以上的代码量，消除了JDBC 大量几余的代码，不需要手动开关连接;<br>  3.很好的与各种数据库兼容(因为 Myatis 使用JDBC 来连接数据库，所以只要 JDBC 支持的数据库 MyBatis 都支持)。<br>  4.能够与Spring 很好的集成;<br>  5.提供映射标签，支持对象与数据库的 ORM 字段关系映射;提供对象关系映射标签，支持对象关系组件维护。</li>
<li>缺点:<br>  1.SQL 语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL 语句的功底有一定要求.<br>  2.SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</li>
<li>MyBatis 框架适用场合<br>  1、MyBatis 专注于 SQL 本身，是一个足够灵活的 DAO 层解决方案。<br>  2、对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis 将是不错的选择。</li>
</ul>
</li>
<li><p><strong>#{} 与 ${} 的区别？</strong></p>
<ul>
<li>两种占位符，都是实现动态sql的方式，可以把参数传递到xml中，执行操作前，mybatis会对这两个占位符进行动态解析<ol>
<li><code>#&#123;&#125;</code>（预编译）：<code>#&#123;&#125;</code> 是 MyBatis 的预处理语法，会在 SQL 中使用占位符 <code>?</code> 的形式，通过预编译的方式来处理参数，可以有效防止 SQL 注入攻击。使用 <code>#&#123;&#125;</code> 时，MyBatis 会将传入的参数值转义并进行预编译，同时会根据参数的类型决定使用不同的 JDBC 类型。这种方式可以确保 SQL 的安全性。</li>
<li><code>$&#123;&#125;</code>（拼接字符串）：<code>$&#123;&#125;</code> 是 MyBatis 的字符串替换语法，会直接将传入的参数值以字符串的形式拼接到 SQL 语句中。使用 <code>$&#123;&#125;</code> 时，需要注意潜在的 SQL 注入风险，因为参数值会直接替换到 SQL 语句中，不会进行预编译。</li>
</ol>
</li>
<li>#{} 适用于参数值，防止 SQL 注入，用于预编译。${} 适用于非参数值，直接将参数值拼接到 SQL 语句中。</li>
<li>在开发中，推荐使用 #{} 来处理参数，以保障 SQL 的安全性。${} 的使用应谨慎，尽量避免直接将用户输入的数据用于 <code>$&#123;&#125;</code> 形式的参数。</li>
</ul>
</li>
<li><p>当实体类中的属性名和表中的字段名不一样，怎么办 ？</p>
<ol>
<li>使用注解映射：ORM 框架（如 Hibernate）提供了注解（如 @Column）来映射实体类属性和数据库表字段之间的关系。<br>  可以在实体类的属性上使用注解，指定属性与表字段的映射关系  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;my_table&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyEntity</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;column_name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// other fields and methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  优点：灵活，可以通过注解直接在实体类中定义映射关系，不需要修改数据库表结构。<br>  缺点：如果数据库表结构已经存在，需要在实体类中添加注解进行映射，可能会导致代码中出现大量注解。</li>
<li>通过在查询的 sql 语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="keyword">select</span> id<span class="operator">=</span>”selectorder” parametertype<span class="operator">=</span>”<span class="type">int</span>” resultetype<span class="operator">=</span>”me.gacl.domain.order”<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">select</span> order_id id, order_no orderno ,order_price price form orders <span class="keyword">where</span> order_id<span class="operator">=</span>#&#123;id&#125;;</span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">select</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>通过 resultMap 映射字段名和实体类属性名的一一对应的关系。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="keyword">select</span> id<span class="operator">=</span>&quot;getOrder&quot; parameterType<span class="operator">=</span>&quot;int&quot; resultMap<span class="operator">=</span>&quot;orderresultmap&quot;<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> orders <span class="keyword">where</span> order_id<span class="operator">=</span>#&#123;id&#125;</span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">select</span><span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span>resultMap type<span class="operator">=</span>”me.gacl.domain.order” id<span class="operator">=</span>”orderresultmap”<span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span><span class="operator">!</span>–用 id 属性来映射主键字段–<span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span>id property<span class="operator">=</span>”id” <span class="keyword">column</span><span class="operator">=</span>”order_id”<span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span><span class="operator">!</span>–用 <span class="keyword">result</span> 属性来映射非主键字段，property 为实体类属性名，<span class="keyword">column</span>为数据表中的属性–<span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span><span class="keyword">result</span> property <span class="operator">=</span> “orderno” <span class="keyword">column</span> <span class="operator">=</span>”order_no”<span class="operator">/</span><span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span><span class="keyword">result</span> property<span class="operator">=</span>”price” <span class="keyword">column</span><span class="operator">=</span>”order_price” <span class="operator">/</span><span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span>reslutMap<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
  优点：将映射关系从代码中分离出来，使得配置更加灵活。<br>  缺点：需要额外的配置文件，增加了维护成本。</li>
</ol>
</li>
<li><p>???通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？<br>Dao 接口里的方法，参数不同时，方法能重载吗？Dao 接口即 Mapper 接口。接口的全限名，就是映射文件中的 namespace 的值；接口的方法名，就是映射文件中 Mapper 的 Statement的 id 值；接口方法内的参数，就是传递给 sql 的参数。Mapper 接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个 MapperStatement。在 Mybatis 中，每一个<br>，，、、</p>
</li>
<li><p>Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？</p>
<ul>
<li>延迟加载的意思是：就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。Mybatis支持一对一关联对象和一对多关联集合对象的延迟加载<br>  在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled&#x3D;truelfalse，默认是关闭的</li>
<li>延迟加载的底层原理<br>  1.使用 CGLIB 创建目标对象的代理对象<br>  2.当调用目标方法时，进入拦截器invoke方法，发现目标方法是null值，执行sql查询<br>  3.获取数据以后，调用set方法设置属性值，再继续查询目标方法，就有值了</li>
</ul>
</li>
<li><p>Mybatis 的一级、二级缓存</p>
<ul>
<li>一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。</li>
<li>二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态),可在它的映射文件中配置 ； </li>
<li>对于缓存数据更新机制，当某一个作用域(一级缓存 Session&#x2F;二级缓存Namespaces)的进行了 C&#x2F;U&#x2F;D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</li>
</ul>
</li>
<li><p>Mybatis是怎么分页的？</p>
<ul>
<li>逻辑分页：先查出数据，如何自己编写逻辑实现分页；</li>
<li>物理分页：使用mysql提供的分页关键词limit</li>
<li>Mybatis提供了 3 种分页方式：<ol>
<li>mybatis mapper配置文件写分页sql，直接在select语句里面加limit</li>
<li>？？使用mybatis提供的RowBounds对象，实现内存级的分页</li>
<li>？？基于mybatis中的Interceptor拦截器，在select语句执行之前动态拼接分页关键字</li>
</ol>
</li>
</ul>
</li>
<li><p>千万级数据量，分页查询优化、、<br>不要 select * from Table limit 90000, 10<br>而先 select id from Table limit 90000, 10，再根据 select * from Table where id &#x3D; id</p>
</li>
</ul>
<hr>


<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><ul>
<li><p>什么是 Redis?</p>
<ul>
<li>Redis 是完全开源免费的，遵守 BSD 协议，是一个高性能的 key-value 数据库。 Redis是一种NoSQL。<br>  NoSQL（Not Only SQL）是一种用于存储和检索非结构化或半结构化数据的数据库系统，主要包括以下几种类型：<br>  1、键值存储数据库（Key-Value Stores）包括Redis、Amazon DynamoDB和Riak。<br>  2、文档型数据库：存储的是类似于JSON或XML格式的文档，可以使用键来检索。示例包括MongoDB和Couchbase。<br>  3、图形数据库：以图形结构存储数据，用于处理复杂的关系和连接。示例包括Neo4j和Amazon Neptune。<br>  4、搜索引擎：搜索引擎允许用户通过关键字搜索文本数据。示例包括Elasticsearch和Apache Solr。</li>
<li>Redis 与其他 key-value 缓存产品有以下三个特点：<br>  Redis 支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。<br>  Redis 不仅仅支持简单的 key-value 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。<br>  Redis 支持数据的备份，即 master-slave 模式的数据备份。</li>
<li>Redis 优势<br>  性能极高；Redis 能读的速度是 110000 次&#x2F;s,写的速度是 81000 次&#x2F;s 。<br>  丰富的数据类型,Redis 支持二进制案例的 Strings, Lists, Hashes,Sets 及Ordered Sets 数据类型操作。<br>  原子:Redis 的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。通过 MULTI 和 EXEC指令包起来。<br>  丰富的特性 – Redis 还支持 publish&#x2F;subscribe, 通知, key 过期等等特性。</li>
</ul>
</li>
<li><p>为什么要用Redis？<br>无论Redis、MySQL、HDFS、HBase都是存储数据的地方，因为设计理念的不同，我们会根据不同的应用场景使用不同的存储。像Redis一般我们会把它用作于缓存（当然，日常有的应用场景比较简单，用个HashMap也能解决很多的问题了<br>1、高性能：首先，它是纯内存操作，内存本身就很快。其次，它是单线程的，Redis服务器核心是基于非阻塞的IO多路复用机制，单线程避免了多线程的频繁上下文切换问题<br>2、高可靠：主从复制，哨兵机制<br>3、高拓展：数据发片，负载均衡</p>
</li>
<li><p><strong>Redis 为什么这么快？</strong></p>
<ol>
<li>Redis 的大部分操作都在内存中完成，并且采用了高效的数据结构(压缩表、跳跃表等方式降低了时间复杂读，同时还提供了不同时间复杂度的数据类型)，因此 Redis 瓶颈可能是机器的内存或者网络带宽，而并非 CPU，既然 CPU 不是瓶颈，那么自然就采用单线程的解决方案了;</li>
<li>Redis 采用单线程模型可以避免了多线程之间的竞争，省去了多线程切换的时间和性能上的开销，而且也不会导致死锁问题；</li>
<li>Redis 采用了 I&#x2F;0 多路复用机制处理大量的客户端 Socket 请求，I0 多路复用机制是指一个线程处理多个I0流，就是我们经常听到的 select&#x2F;epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket.内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。</li>
<li>Redis支持丰富的数据结构，包括字符串、哈希、列表、集合、有序集合等，每种数据结构都针对不同的应用场景进行了优化，能够更高效地处理各种数据操作。</li>
</ol>
</li>
<li><p>Redis 是单进程单线程的？<br>Redis 是单进程单线程的，redis 利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。 </p>
</li>
<li><p>Redis网络多路I&#x2F;O复用？？</p>
<ul>
<li>多路复用是一种提高 I&#x2F;O 效率的技术，它可以同时监听多个文件描述符的 I&#x2F;O 事件，并且在有事件发生时立即通知应用程序，从而避免了轮询的开销。在 Redis 中，网络 I&#x2F;O 多路复用主要涉及到客户端与服务端之间的通信，使用类似 epoll 的事件驱动机制来处理网络 I&#x2F;O 多路复用，通过监听套接字上的事件并采用非阻塞 I&#x2F;O 模式，实现了高效的网络通信和并发处理能力。</li>
</ul>
<ol>
<li><strong>事件驱动模型</strong>：<ul>
<li>Redis 使用事件驱动模型来处理网络 I&#x2F;O，通过监听套接字上的读写事件，实现异步的网络通信。</li>
<li>在客户端连接到 Redis 服务器时，服务器会将该客户端的套接字加入到事件驱动器中进行监听。</li>
</ul>
</li>
<li><strong>epoll 机制</strong>：<ul>
<li>在 Linux 系统中，Redis 使用 epoll 作为网络 I&#x2F;O 多路复用的实现机制之一。</li>
<li>epoll 是一种高效的 I&#x2F;O 多路复用技术，可以同时监控多个文件描述符的 I&#x2F;O 事件，并将有事件发生的文件描述符返回给应用程序处理。</li>
<li>Redis 使用 epoll_wait 函数来等待套接字上的事件，并在事件发生时处理对应的网络 I&#x2F;O 操作。</li>
</ul>
</li>
<li><strong>非阻塞 I&#x2F;O</strong>：<ul>
<li>Redis 使用了非阻塞 I&#x2F;O 模式来处理套接字的读写操作，这样可以避免在等待数据到达时线程被阻塞，提高了系统的并发处理能力。</li>
<li>当客户端发送数据给 Redis 服务器时，服务器会尽可能地读取数据，而不是等待数据全部到达再进行处理。</li>
</ul>
</li>
<li><strong>事件循环</strong>：<ul>
<li>Redis 的服务器主循环是一个事件驱动的循环，不断地监听客户端套接字上的事件并处理。</li>
<li>当有新的连接请求、数据到达、连接断开等事件发生时，服务器会相应地调用相应的处理函数来处理这些事件。</li>
</ul>
</li>
</ol>
</li>
<li><p>Redis 常见性能问题和解决方案？<br>(1) Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件<br>(2) 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次<br>(3) 为了主从复制的速度和连接的稳定性， Master 和 Slave 最好在同一个局域网内<br>(4) 尽量避免在压力很大的主库上增加从库<br>(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即： Master &lt;- Slave1 &lt;- Slave2 &lt;-Slave3…</p>
</li>
<li><p>Redis的教据结构有？</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>key</th>
<th>string</th>
<th>hash</th>
<th>list</th>
<th>set</th>
<th>sorted set</th>
<th>bitmap</th>
<th>hyperloglog</th>
</tr>
</thead>
<tbody><tr>
<td>最大存储数据量</td>
<td>512M</td>
<td>512M</td>
<td>2^32 - 1</td>
<td>2^32 - 1</td>
<td>2^32 -1</td>
<td></td>
<td>512M</td>
<td>12K</td>
</tr>
</tbody></table>
</li>
<li><p>Redis数据结构分别有哪些典型的应用场景？</p>
<ol>
<li>字符串：可以用来做最简单的数据，可以颂存某个简单的字符串，也可以存某个json格式的字符审，Redis分布式的实现就利用了这种数据结构，还包括可以实现计数器、Session共享、分布式ID</li>
<li>哈希表：可以用来存储一些key-value对，更适合用来存储对象，统计类数据，购物车</li>
<li>列表：Redis的列表通过命令的组合，既可以当做栈，也可以当做队列来使用，可以用来缓存类似微信公众号、微博等消息流教据，文章列表，消息队列</li>
<li>集合：和列表类似，也可以存储多个元素，但是不能重复，集合可以进行交集、并集、差集损作，从而可以实现类似，我和某人共同关注的人、朋友画点赞等功能</li>
<li>有序集合：集合是无序的，有序集合可以设置顺序，可以用来实现排行榜功能，按时间播放量点击</li>
</ol>
</li>
<li><p>Redis 中 String 的底层实现、、</p>
<ul>
<li>Redis底层是C实现的，Redis中String是一种动态字符串类型，它的底层实现就是 SDS。每个字符串对象（string object）都有对应的 SDS 结构，存储在内存中。</li>
<li>SDS 是 Redis 自己实现的字符串抽象数据结构，当 Redis 执行字符串操作如 SET、GET、APPEND 等操作，实际上是对 SDS 结构进行操作，包括修改长度、扩展空间、拷贝数据等操作。相较于 C 语言的原生字符串，SDS 具有以下优势：<ol>
<li><strong>O(1) 复杂度的长度计算</strong>：SDS 不需要每次计算字符串长度，因为它在结构中记录了字符串的长度，因此获取字符串长度的操作是 O(1) 复杂度的。</li>
<li><strong>空间预分配</strong>：SDS 在空间分配时会预留额外的空间，以减少字符串增长时频繁地重新分配内存的次数，从而提高性能。</li>
<li><strong>修改操作的高效性</strong>：SDS 通过记录字符串的长度，可以直接修改字符串内容，而无需像 C 语言原生字符串那样，重新计算长度和分配内存。</li>
</ol>
</li>
<li>SDS 的结构如下所示：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> len;        <span class="comment">// 字符串长度</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>;       <span class="comment">// 未使用空间长度</span></span><br><span class="line">    <span class="type">char</span> buf[];     <span class="comment">// 字符串数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Zset底层实现</p>
<ul>
<li>压缩列表：普通数组+列表长度+尾部偏移量+列表元素个数+列表结束标识，对于非首尾节点仍然使用遍历逐个查询</li>
<li>跳表：根据有序列表元素值，加多级索引以快速查找。时间复杂度为O(logn)（相当于二分查找）</li>
<li>什么时候采用跳表呢？<br>  1.有序集合保存的元素数量小于128个<br>  2.有序集合保存的所有元素的长度小于 64字节</li>
<li>zset为什么用跳表而不用二叉树或者红黑树呢？<br>  红黑树不支持范围查找，且构造起来比跳表复杂</li>
</ul>
</li>
<li><p>Redis为什么不用b+树？MySQL为什么不用跳表？<br>这个问题在于 Redis是直接操作内存的并不需要磁盘io，跳表明显是更快更简单的方式；而MySQL需要去读取io，所以mysql要使用b+树的方式减少磁盘io</p>
</li>
<li><p>Redis 应用场景。</p>
<ol>
<li>缓存层。防止所有的请求打到DB，做过多的IO</li>
<li>分布式锁。正常的 Threadlocal 是单进程JVM内的一个锁，不能对所有的服务起到同步的效果，所有用redis抽象出来做一个集群，这种分布式锁是全局可见的</li>
<li>作消息队列。redis发布&#x2F;订阅模式，类似与消息队列。</li>
</ol>
</li>
<li><p>如何使用 Redis 做异步队列么？？？<br>一般使用 list 结构作为队列，rpush生产消息，lpop消费消息。当 lpop没有消息的时候，要适当 sleep一会再重试。<br>可不可以不用 sleep 呢？ list 还有个指令叫 blpop，在没有消息的时候，它会阻塞住直到消息到来。<br>能不能生产一次消费多次呢？使用 pub&#x2F;sub 主题订阅者模式，可以实现 1:N 的消息队列。<br>pub&#x2F;sub 有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 RabbitMQ等。<br>redis 如何实现延时队列？使用sortedset，拿时间戳作为score，消息内容作为 key 调用 zadd 来生产消息，消费者用 zrangebyscore 指令获取 N 秒前的数据轮询处理。</p>
</li>
<li><p>Redis持久化。</p>
<ul>
<li>Redis是基于内存的，假设不做任何操作，只要Redis服务器重启（或者中途故障挂掉了）那内存的数据就会没掉。所以Redis提供了持久化机制给我们用，分别是RDB和AOF。通过持久化机制把内存中的数据同步到硬盘文件来保证数据持久化。当Redis重启后通过把硬盘文件重新加载到内存，就能达到恢复数据的目的。</li>
<li>RDB：Redis默认的持久化方式。根据我们自己配置的时间或者手动去执行BGSAVE或SAVE命令，Redis就会去（fork一个子进程来）生成RDB文件。<br>  RDB是按照一定的时间周期策略把内存的数据以快照的形式保存到硬盘的二进制文件，Redis可以通过这个文件在启动的时候来还原我们的数据。即Snapshot快照存储，对应产生的数据文件为dump.rdb，通过配置文件中的save参数来定义快照的周期。（ 快照可以是其所表示的数据的一个副本，也可以是数据的一个复制品。）</li>
<li>AOF：Redis会将每一个收到的写命令都通过Write函数追加到文件最后，类似于MySQL的binlog。当Redis重启是会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。<br>  <a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv28294981/?spm_id_from=333.999.0.0&jump_opus=1">https://www.bilibili.com/read/cv28294981/?spm_id_from=333.999.0.0&amp;jump_opus=1</a></li>
</ul>
</li>
<li><p>缓存雪崩、缓存击穿、缓存穿透</p>
<ol>
<li>缓存穿透<ul>
<li>缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。</li>
<li>解决办法：<ul>
<li>1、最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。</li>
<li>2、另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库。</li>
<li><strong>5TB的硬盘上放满了数据，请写一个算法将这些数据进行排重。如果这些数据是一些32bit大小的数据该如何解决？如果是64bit的呢？</strong><br>  对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。</li>
</ul>
</li>
<li><strong>Bitmap：典型的就是哈希表</strong>；缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了 </li>
<li><strong>布隆过滤器（推荐）：</strong>就是引入了 k(k&gt;1) 个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。<br> 它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。</li>
</ul>
</li>
<li>缓存击穿<ul>
<li>场景：一份热点数据，它的访问量非常大。在其缓存失效瞬间，大量请求直达存储层，导致服务崩溃</li>
<li>解决方案：<br> 1、分布式锁：对数据的访问加互斥锁，当一个线程访问该数据时，其他线程只能等待这个线程访问过后，缓存中的数据将被重建，届时其他线程就可以直接从缓存取值.<br> 2、永不过期：不设置过期时间，所以不会出现上述问题，这是“物理”上的不过期。为每个value设置逻辑过期时间，当发现该值逻辑过期时，使用单独的线程重建缓存.</li>
</ul>
</li>
<li>缓存雪崩 <ul>
<li>我们可以简单的理解为：由于原有缓存失效，新缓存未到期间(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。</li>
<li>解决办法：<br> 1、加锁：大多数系统设计者考虑用加锁（最多的）或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。<br> 2、设置随机值：将缓存失效时间分散开。</li>
</ul>
</li>
</ol>
</li>
<li><p>？？？分布式锁、、</p>
<ul>
<li>场景：修改时，经常需要先将数据读取到内存，在内存中修改后再存回去。在分布式应用中，可能多个进程同时执行上述操作，而读取和修改非原子操作，所以会产生冲突。增加分布式锁，可以解决此类问题.</li>
<li>基本原理：<ol>
<li>同步锁：在多个线程都能访问到的地方，做一个标记，标识该数据的访问权限。</li>
<li>分布式锁：在多个进程？？？都能访问到的地方，做一个标记，标识该数据的访问权限</li>
</ol>
</li>
<li>实现方式：1、基于数据库实现分布式锁 2、基于Redis实现分布式锁 3、基于zookeeper实现分布式锁<br>  具体做法：？？？    先拿 setnx 来争抢锁，抢到之后，再用 expire 给锁加一个过期时间防止锁忘记了释放。</li>
<li>分布式锁实现？？？<br>  实现分布式锁可以通过数据库 redis zookeeper。<br>  redis setnx是最简单的一种。可以满足基本使用但有些特性和场景没法满足 比如不可重入 不可重试  锁过期删除的一些问题。redisson是在redis基础上也实现了分布式锁，解决了这几个问题就是redisson里面的可重入锁，比如解决不可重入用的是hash结构解决。解决不可重试基于redis的发布订阅。解决锁过期删除基于自己实现的一个看门狗机制。但是redisson这把可重入锁还有一些问题，比如主从时宕机的问题，redisson里面又可以通过有联锁啊 红锁啊解决。不过setnx基本上可以应用于分布式锁了，有一些业务上需要满足一些锁的需求的时候可以考虑更复杂的实现<br>  支付宝一面：如何基于Redis实现分布式锁？？？<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/y8kAflIenRpa4zIwCP_8iA">https://mp.weixin.qq.com/s/y8kAflIenRpa4zIwCP_8iA</a></li>
</ul>
</li>
<li><p>缓存预热、缓存更新、缓存降级</p>
<ol>
<li>缓存预热<br>  系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！<br>  解决思路：1、直接写个缓存刷新页面，上线时手工操作下；2、数据量不大，可以在项目启动的时候自动进行加载；3、定时刷新缓存</li>
<li>缓存更新<br>  除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：<br>  （1）定时去清理过期的缓存；<br>  （2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。<br>  两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡</li>
<li>？？缓存降级<br>  当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。<br>  降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。以参考日志级别设置预案：<br>  （1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；<br>  （2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；<br>  （3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；<br>  （4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户</li>
</ol>
</li>
<li><p>热点数据和冷数据？<br><strong>数据更新前至少读取两次</strong>，缓存才有意义。对于热点数据，比如生日祝福模块中当天的寿星列表，缓存以后可能读取数十万次，同时信息修改频率不高。这个是最基本的策略，若缓存还没有起作用就失效就没有太大价值了。<br>那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到Redis缓存，减少数据库压力</p>
</li>
<li><p>过期策略。</p>
<ul>
<li>Redis会把设置了过期时间的key放入一个独立的字典里，过期时并不会立刻删除，通过如下两种策略来删除过期的key:<br>  1、惰性删除：客户端访问某个key时，Redis会检查该key是否过期，若过期则删除。(问题: 有些键值对可能已过期,但是由于没有再被访问,导致未被删除,因而占用内存)。<br>  2、定期扫描：Redis默认每秒执行10次过期扫描 (配置hz选项) ，扫描策略如下 (1). 从过期字典中随机选择20个key; (2)删除这20个key中已过期的key; (3)如果过期的key的比例超过25%，则重复步骤(1)</li>
<li><strong>为什么不用定时删除策略?</strong><br>  定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.</li>
<li><strong>定期删除+惰性删除是如何工作的呢?</strong><br>  定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。</li>
<li><strong>采用定期删除+惰性删除就没其他问题了么?</strong><br>  不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。在redis.conf中有一行配置</li>
</ul>
</li>
<li><p>淘汰策略。<br>当Redis占用内存超出最大限制(maxmemory)时，可采用如下策略(maxmemory-policy)淘汰一些数据以腾出空间继续提供读写服务:<br>noeviction：对可能导致增大内存的命令返回错误 (大多数写命令，DEL除外)<br>volatile-ttl：在设置了过期时间的key中，选择剩余寿命(TTI) 最短的key，将其淘汰<br>volatile-lru：在设置了过期时间的kev中，选择最少使用的kev (LRu) ，将其淘汰:<br>volatile-random：在设置了过期时间的key中，随机选择一些key，将其淘汰;<br>allkeys-lru：在所有的ke中，选择最少使用的key (LRu) ，将其淘汰<br>allkeys-random：在所有的key中，随机选择一些key，将其淘汰<br>(这里其实还有volatile-lfu、allkeys-lfu，所谓&#x3D;&#x3D;LFU算法&#x3D;&#x3D;，就是先考虑键值对访问的次数，优先淘汰访问次数少的键值对，对于访问次数相同的键值对，再选择最近久未被访问的键值对进行淘汰(也就是LRU算法))<br>LRU算法：维护一个链表，用于顺序存储被访问过的key。在访问数据时，最新访问过的kev将被移动到表头, 即最近访问的key在表头，最少访问的key在表尾。</p>
</li>
<li><p>？？Redis事务。<br>Redis事务功能是通过 MULTI、EXEC、DISCARD 和 WAWATATCH 四个原语实现的<br>Redis会将一个事务中的所有命令序列化，然后按顺序执行。<br>1.redis 不支持回滚。在事务失败时不进行回滚，而是继续执行余下的命令，所以 Redis 的内部可以保持简单且快速。<br>2.如果在一个事务中的命令出现错误，那么所有的命令都不会执行；<br>3.如果在一个事务中出现运行错误，那么正确的命令会被执行。<br>1）MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。<br>2）EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值 nil 。<br>3）通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。<br>4）WAWATATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令</p>
</li>
<li><p>为什么Redis的操作是原子性的，怎么保证原子性的？<br>对于Redis而言，命令的原子性指的是：一个操作的不可以再分，操作要么执行，要么不执行。<br>Redis的操作之所以是原子性的，是因为Redis是单线程的。Redis本身提供的所有API都是原子操作，Redis中的事务其实是要保证批量操作的原子性。<br>多个命令在并发中也是原子性的吗？不一定，将get和set改成单命令操作，？？？incr 。使用Redis的事务，或者使用Redis+Lua&#x3D;&#x3D;的方式实现。</p>
</li>
<li><p>Redis 的同步机制了解么？<br>Redis 可以使用主从同步，从从同步。第一次同步时，主节点做一次 bgsave，并同时将后续修改操作记录到内存 buffer，待完成后将 rdb文件全量同步到复制节点，复制节点接受完成后将 rdb 镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。 </p>
</li>
<li><p>Redis 多节点部署主要有以下几种方式。</p>
<ol>
<li>主从复制（Master-Slave Replication）：主从复制是 Redis 的基本高可用性架构。一个 Redis 主节点可以拥有多个从节点，主节点负责写操作和同步数据到从节点，从节点负责复制主节点的数据。当主节点不可用时，可以选择一个从节点提升为主节点，实现故障切换。</li>
<li>哨兵模式（Redis Sentinel）：Redis Sentinel 是用于监控 Redis 实例并支持自动故障转移的组件。它可以监控多个 Redis 主从复制集群，当主节点不可用时，自动将一个从节点晋升为新的主节点，保证服务的可用性。哨兵模式提供了更强大的故障检测和自动切换功能。</li>
<li>集群模式（Redis Cluster）：Redis Cluster 是 Redis 提供的分布式解决方案，用于在多个节点之间分片存储数据。Redis Cluster 将数据分成多个槽（slot），每个槽可以分配给集群中的不同节点。它支持横向扩展、高可用性和自动数据分片。当集群中的某个节点不可用时，可以通过复制和重新分片来保证服务的可用性。</li>
<li>第三方解决方案：除了 Redis 官方提供的方案外，还有一些第三方解决方案可以用于构建 Redis 的多节点部署，比如一些代理软件或者中间件，它们提供了更多高级功能，比如自动负载均衡、故障转移等。</li>
</ol>
</li>
<li><p>Redis 集群</p>
<ul>
<li>1、主从复制：Redis 集群中的每个节点通常都有主节点和若干个从节点。主节点负责处理写操作和部分读操作，而从节点负责复制主节点的数据，用于读操作和故障恢复。主从复制可以提高系统的可用性和容错能力。Redis Sentinal 着眼于高可用，在 master 宕机时会自动将 slave 提升为master，继续提供服务。</li>
<li>2、数据分片：Redis 集群通过分片机制将数据分布到多个节点上。每个节点负责一部分数据的存储和处理。这样可以提高系统的并发处理能力和数据存储容量。Redis Cluster 着眼于扩展性，在单个 redis 内存不足时，使用 Cluster 进行分片存储。</li>
<li>3、数据同步：在 Redis 集群中，数据同步是保证数据一致性的关键。主节点将写操作同步到从节点，确保数据在各个节点之间的同步。在读操作时，可以从主节点或者从节点读取数据，但要注意可能存在数据的延迟和不一致性。</li>
<li>Redis 集群的主从复制模型是怎样的？<br>  为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有 N-1 个复制品. </li>
<li>场景：查询一个字符串类型数据为什么花了5秒？<br>  Redis 集群中的某个节点网络连接不稳定或者网络延迟较高，或者某个节点数据负载较高。<br>  如果查询的数据正好位于 Redis 集群中的某个分片，而该分片的主节点或者从节点负载较高或者网络延迟较高，会导致查询时间变长。</li>
<li>Redis 集群会有写操作丢失吗： Redis 并不能保证数据的强一致性，实际中集群在特定的条件下可能会丢失写操作。</li>
<li>集群之间是如何复制的：异步复制 </li>
<li>集群最大节点个数是多少： 6384 个 </li>
<li>集群如何选择数据库：Redis 集群目前无法做数据库选择，默认在 0 数据库。</li>
</ul>
</li>
<li><p>Redis 和 Mysql 如何保证数据一致？<br>1、先更新 Mysql，再更新 Redis，如果更新 Redis失败，可能仍然不一致<br>2、先删除 Redis缓存数据，再更新 MySql，再次查询的时候在将数据添加到缓存中，这种方案能解决方案1的问题，但是在高并发下性能较低，而且仍然会出现数据不一致的问题：比如线程1删除了Redis缓存数据，正在更新 MySql，此时另外一个查询再查询，那么就会把 MySql中老数据又查到 Redis中<br>3、<strong>延时双删，</strong>步聚是：先删除 Redis存数，再更新 MySql，延迟几百毫秒除 Redis存数据，这样就算在更新 MySql时，有其他线程读了Mysql，把老数据读到了 Redis中，那么也会被制除掉，从而把数据保持一致<br>4、如果需要在极端情况下仍然保证 Redis 和 Mysql 的数据一致性，就只能采用最<strong>终一致性方案</strong>。比如基于 RocketMQ 的可靠性消息通信，来实现最终一致性：把（更新redis）失败的请求写入MQ事务消息，然后异步重试，确保成功。还可以直接通过 Canal 组件，监控 Mysql 中 binlog 的日志，把更新后的数据同步到 Redis 里面。？？</p>
</li>
</ul>
<hr>

<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><ul>
<li><p>消息队列 mq</p>
<ul>
<li>消息队列 Message Queue，简称 MQ。是一种应用间的通信方式，主要由三个部分组成。<ul>
<li>生产者：Producer，消息的产生者与调用端，主要负责消息所承载的业务信息的实例化，是一个队列的发起方</li>
<li>代理：Broker，主要的处理单元，负责消息的存储、投递、及各种队列附加功能的实现，是消息队列最核心的组成部分</li>
<li>消费者：Consumer，一个消息队列的终端，也是消息的调用端，具体是根据消息承载的信息，处理各种业务逻辑。</li>
</ul>
</li>
<li>mq理解<ul>
<li>消息路由<ul>
<li>路由器的类型和绑定规则</li>
</ul>
</li>
<li>消息不丢失<ul>
<li>消息确认机制<ul>
<li>配置合适的消息TTL</li>
<li>备份队列</li>
</ul>
</li>
</ul>
</li>
<li>消息消费<ul>
<li>顺序消费<ul>
<li>消息优先级</li>
<li>单线程消费</li>
</ul>
</li>
<li>重复消费<ul>
<li>durable参数：true</li>
<li>deliveryMode参数：1为非持久，2为持久化</li>
</ul>
</li>
</ul>
</li>
<li>消息持久化</li>
</ul>
</li>
<li>mq应用<ul>
<li>异步处理</li>
<li>应用解耦</li>
<li>流量削峰<ul>
<li>限速</li>
<li>死性队列</li>
<li>消息优先级</li>
<li>公平分发</li>
<li>限流</li>
<li>延迟队列</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>消息队列的应用场景较多，常用的可以分为三种：</p>
<ul>
<li><strong>异步处理：</strong>主要应用于对实时性要求不严格的场景，比如：用户注册发送验证码、下单通知、发送优惠券等等。服务方只需要把协商好的消息发送到消息队列，剩下的由消费消息的服务去处理，不用等待消费服务返回结果。</li>
<li><strong>应用解耦：</strong>可以看作是把相关但耦合度不高的系统联系起来。比如订单系统与 WMS、EHR 系统，有关联但不哪么紧密，每个系统之间只需要把约定的消息发送到 MQ，另外的系统去消费即可。解决了各个系统可以采用不同的架构、语言来实现，从而大大增加了系统的灵活性。</li>
<li><strong>流量削峰：</strong>一般应用在大流量入口且短时间内业务需求处理不完的服务中心，为了权衡高可用，把大量的并行任务发送到 MQ 中，依据 MQ 的存储及分发功能，平稳的处理后续的业务，起到一个大流量缓冲的作用。</li>
</ul>
</li>
<li><p>如何进行消息队列选型?</p>
<ul>
<li>Kafka：日志分析、大数据采集<ul>
<li>一种高吞吐量、分布式、基于发布&#x2F;订阅的消息系统，最初由 LinkedIn 公司开发，使用Scala 语言编写，目前是 Apache 的开源项目。</li>
<li>优点: 各吐量非常大，性能非常好，集群高可用。</li>
<li>缺点:会丢数据，功能比较单一</li>
</ul>
</li>
<li>RabbitMQ：小规模场景<ul>
<li>是什么：采用 AMQP 高级消息队列协议的一种消息队列技术,最大的特点就是消费并不需要确保提供方存在,实现了服务之间的高度解耦</li>
<li>优点: 消息可靠性高，功能全面。</li>
<li>缺点:吞吐量比较低，消息积累会严重影响性能。erlang语言不好定制.</li>
</ul>
</li>
<li>RocketMQ：几乎是全场景<ul>
<li>优点:高吞吐、高性能、高可用，功能非常全面。</li>
<li>缺点:开源版功能不如云上商业版。官方文档和周边生态还不够成熟。客户端只支持java。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><ul>
<li><p>kafka <a target="_blank" rel="noopener" href="https://www.yuque.com/itwanger/gykdzg/ngd5g3glaxii4h6g">https://www.yuque.com/itwanger/gykdzg/ngd5g3glaxii4h6g</a> udd1</p>
</li>
<li><p>Kafka 优缺点？</p>
<ul>
<li>优点<br>  高性能、高吞吐量、低延迟:Kafka 生产和消费消息的速度都达到每秒10万级高可用:所有消息持久化存储到磁盘，并支持数据备份防止数据丢失<br>  高并发:支持数千个客户端同时读写<br>  容错性:允许集群中节点失败(若副本数量为n，则允许 n-1 个节点失败)<br>  高扩展性:Kafka 集群支持热伸缩，无须停机</li>
<li>缺点<br>  没有完整的监控工具集<br>  不支持通配符主题选择</li>
</ul>
</li>
<li><p>kafka 架构？</p>
<ul>
<li>Kafka 将消息以 topic 为单位进行归纳，发布消息的程序称为 Producer，消费消息的程序称为 Consumer。它是以集群的方式运行，可以由一个或多个服务组成，每个服务叫做一个 Broker，Producer 通过网络将消息发送到 kafka 集群，集群向消费者提供消息，broker 在中间起到一个代理保存消息的中转站。</li>
<li>kafka 组成：<ol>
<li>Producer：消息生产者，发布消息到Kafka集群的终端或服务</li>
<li>Broker：<strong>一个 Kafka 节点就是一个 Broker，多个Broker可组成一个Kafka 集群</strong><br>  如果某个 Topic 下有n个Partition 且集群有n个Broker，那么每个 Broker会存储该 Topic 下的一个 Partition<br>  如果某个 Topic 下有n个Partition 且集群中有 m+n个Broker，那么只有n个Broker会存储该Topic下的一个Partition<br>  如果某个 Topic 下有n个Partition 且集群中的Broker数量小于 n，那么一个 Broker 会存储该 Topic 下的一或多个 Partition，这种情况尽量避免，会导致集群数据不均衡</li>
<li>Topic：逻辑概念，消息主题，每条发布到Kafka集群的消息都会归集于此，<strong>Kafka是面向Topic 的</strong></li>
<li>Partition：是Topic在物理上的分区，从Partition消费信息。一个Topic可以分为多个Partition，每个Partition是一个有序的不可变的记录序列。单一主题中的分区有序，但无法保证主题中所有分区的消息有序。</li>
<li>Consumer：从Kafka集群中消费消息的终端或服务</li>
<li>Consumer Group：每个Consumer都属于一个Consumer Group，每条消息只能被Consumer Group中的一个Consumer消费，但可以被多个Consumer Group消费。</li>
<li>Zookeeper：Kafka 通过Zookeeper来存储集群中的 meta 消息（0.9版本后，将消息偏移量offset存储本地）  <img src="https://github.com/leo710aka/bk/blob/main/job14.png?raw=true" width="550" height="300" alt=""></li>
</ol>
</li>
</ul>
</li>
<li><p>如何判断一个 Broker 是否还有效<br>1.Broker必须可以维护和ZooKeeper的连接，Zookeeper通过心跳机制检查每个结点的连接<br>2.如果Broker是个Follower，它必须能及时同步Leader的写操作，延时不能太久。</p>
</li>
<li><p>kafka分区，partition</p>
<ul>
<li>分区的概念<br>  主题是一个逻辑上的概念，还可以细分为多个分区，一个分区只属于单个主题，很多时候也会把分区称为主题分区(Topic-Partition)。同一主题下的不同分区包含的消息是不同的，分区在存储层面可以看做一个可追加的 日志文件 ，消息在被追加到分区日志文件的时候都会分配一个特定的偏移量(offset)。</li>
<li>offset：是消息在分区中的唯一标识，表示在分区中消费到消息的位置；<br>  kafka 通过它来保证消息在分区内的顺序性，不过 offset 并不跨越分区，也就是说，kafka保证的是分区有序而不是主题有序。</li>
<li>在分区中又引入了多副本(replica)的概念，通过增加副本数量可以提高容灾能力。同一分区的不同副本中保存的是相同的消息。副本之间是一主多从的关系，其中主副本负责读写，从副本只负责消息同步。副本处于不同的broker中，当主副本出现异常，便会在从副本中提升一个为主副本。</li>
<li>Kafka 中分区的原则？？？<br>  1.指明Partition的情况下，直接将指明的值作为Partition值<br>  2.没有指明Partition值但有 key 的情况下，将 key 的 Hash 值与 topic的Partition值进行取余得到Partition值<br>  3.既没有Partition值又没有 key 值的情况下，第一次调用时随机生成一个整数(后面每次调用在这个整数上自增)，将这个值与Topic可用的Partition总数取余得到Parittion值，也就是常说的round-robin 算法</li>
<li>Kafka 为什么要把消息分区<br>  1.方便在集群中扩展，每个 Partition 可用通过调整以适应它所在的机器，而一个Topic又可以有多个Partition组成，因此整个集群就可以适应任意大小的数据了<br>  2.可以提高并发，因为可以以Partition为单位进行读写</li>
</ul>
</li>
<li><p>kafka 消费模式</p>
<ol>
<li><strong>发布-订阅模式</strong>：<ul>
<li>在发布-订阅模式中，消息被发送到一个主题（Topic），而每个消费者都可以独立地订阅这个主题并接收消息。</li>
<li>Push 模式：一种主动推送的方式，即消息生产者（Publisher）将消息直接推送给感兴趣的订阅者（Subscriber）。<br> 这种模式下，订阅者无需主动拉取消息，而是等待消息被推送过来。因此，消息的发送和接收是异步的。</li>
<li>Pull 模式：一种被动获取的方式，即订阅者需要主动向消息服务器请求消息，然后消息服务器才会将消息发送给订阅者。<br> 在这种模式下，订阅者需要周期性地或者根据需要发起拉取消息的请求，消息的发送和接收是同步的。</li>
</ul>
</li>
<li><strong>消费者组模式</strong>：<ul>
<li>在消费者组模式中，多个消费者被组织成一个消费者组（Consumer Group），并且每个分区（Partition）只能被同一个消费者组中的一个消费者处理。</li>
<li>当一个新的消费者加入消费者组时，它会负责消费未被分配的分区。</li>
<li>这种模式可以实现消息的负载均衡和水平扩展，适合于处理大量消息的情况。</li>
</ul>
</li>
</ol>
</li>
<li><p>Kafka是如何保证消息不丢失</p>
<ul>
<li>生产者发送消息到Brocker丢失<br>  设置异步发送，发送失败使用回调进行记录或重发；失败重试，参数配置，可以设置重试次数</li>
<li>消息在Brocker中存储丢失<br>  发送确认设置acks&#x3D;all，让所有的副本都参与保存数据后确认（设置acks&#x3D;1时，只要leader节点收到消息，生产者就会收到一个来自服务器的成功响应）</li>
<li>（发送到Broker之后，走的是操作系统缓存，在异步刷盘（保存到硬盘）这个过程还有可能丢失）</li>
<li>消费者从Brocker接收消息丢失<br>  关闭自动提交偏移量，开启手动提交偏移量；提交方式，最好是同步+异步提交</li>
</ul>
</li>
<li><p>kafka 消费重复数据？</p>
<ul>
<li>原因：<br>  1、服务宕机，5秒钟内没有提交offerset;<br>  2、5分钟内没消费完partition数据，触发reblance</li>
<li>解决：<br>  1、关闭自动提交偏移量，开启手动提交偏移量提交方式，最好是同步+异步提交，<br>  2、提升消费端性能避免触发balance：异步消费、挑战消费时长、减少一次性从broker拉取的消息条数<br>  3、幂等方案：对消费的消息生成md5存到redis，再存入时比对</li>
</ul>
</li>
<li><p>Kafa 中如何保证顺序消费</p>
<ul>
<li>问题原因：<br>  一个topic的数据可能存储在不同的分区Partition 中，Kafka 的消费单元是 Partition，同一个 Partition 使用 offset 作为唯一标识保证顺序性。但这只是保证了在Partition 内部的顺序性而不是 Topic 中的顺序，如果消费者关联了多个分区，不能保证顺序性。</li>
<li>解决方法：（普通情况下）只需要把相同userld&#x2F;orderld发送到相同的partition，因为一个partition由（一个消费者组的）一个Consumer消费<ul>
<li>发送消息时指定分区号</li>
<li>发送消息时按照相同的业务设置相同的key</li>
</ul>
</li>
</ul>
</li>
<li><p>kafka高可用？</p>
<ul>
<li>可以从两个层面回答，第一个是集群，第二个是复制机制集群:<ul>
<li>一个kafka集群由多个broker实例组成，即使某一台宕机，也不耽误其他broker继续对外提供服务复制机制:</li>
<li>一个topic有多个分区，每个分区有多个副本，有一个leader，其余的是follower，副本存储在不同的broker中所有的分区副本的内容是都是相同的，如果leader发生故障时，会自动将其中一个follower提升为leader，保证了系统的容错性、高可用性</li>
</ul>
</li>
<li>ISR(in-syncreplica)机制：需要同步复制保存的folower<br>  分区副本分为了两类，一个是ISR，与leader副本同步保存数据，另外一个普通的副本，是异步同步数据，当leader挂掉之后，会优先从ISR副本列表中选取一个作为leader</li>
</ul>
</li>
<li><p>kafka 如何实现高性能？</p>
<ul>
<li>消息分区:不受单台服务器的限制，可以不受限的处理更多的数据；我们往一个Topic发送消息或者读取消息时，实际内部是多个Partition在并行处理</li>
<li>顺序读写:磁盘顺序读写，提升读写效率</li>
<li>页缓存:把磁盘中的数据缓存到内存中，把对磁盘的访问变为对内存的访问</li>
<li>零拷贝:减少上下文切换及数据拷贝？？在读写数据中也减少CPU拷贝文件的次数</li>
<li>消息压缩:减少磁盘I0和网络I0</li>
<li>分批发送:将消息打包批量发送，减少网络开销</li>
</ul>
</li>
<li><p>kafka消息积压问题</p>
<ul>
<li>消息积压根本原因是：生产者的生产速度，大于消费者的消费速度。consumer还来不及从PageCache中消费消息，producer就已经生产消息把容量占完了，只能把PageCache中的消息保存到硬盘中，consumer要到硬盘中取出未消费的消息、、</li>
<li>遇到消息积压问题时，我们需要先排查，是不是有bug产生了。如果不是bug，我们可以优化一下消费的逻辑，比如之前是一条一条消息消费处理的话，我们可以确认是不是可以优为批量处理消息。如果还是慢，我们可以考虑水平扩容，增加Topic的队列数，和消费组机器的数量，提升整体消费能力。</li>
<li>如果是bug导致几百万消息持续积压几小时，需要解决bug，临时紧急扩容，大概思路如下:<ol>
<li>先修复consumer消费者的问题，以确保其恢复消费速度，然后将现有consumer 都停掉。</li>
<li>新建一个 topic:partition 是原来的 10 倍，临时建立好原先10倍的queue 数量。</li>
<li>然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的10倍数量的queue。</li>
<li>接着临时征用 10倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queke 资源和 consumer 资源扩大 10倍，以正常的 10倍速度来消费数据。</li>
<li>等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>

<h2 id="网-络"><a href="#网-络" class="headerlink" title="网 络"></a>网 络</h2><ul>
<li><p>计算机网络：<a target="_blank" rel="noopener" href="https://leo710aka.github.io/2022/02/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">https://leo710aka.github.io/2022/02/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</a></p>
</li>
<li><p>浏览器发出一个请求到收到响应经历了哪些步骤?<br>1，浏览器解析用户输入的URL，生成一个HTTP格式的请求<br>2，先根据URL域名从本地hosts文件查找是否有映射IP，如果没有就将域名发送给电脑所配置的DNS进行域名解析，得到IP地址<br>3，浏览器通过操作系统将请求通过四层网络协议发送出去<br>4，途中可能会经过各种路由器、交换机，最终到达服务器<br>5，服务器收到请求后，根据请求所指定的端口，将请求传递给绑定了该端口的应用程序，比如8080被tomcat占用了<br>6，tomcat接收到请求数据后，按照http协议的格式进行解析，解析得到所要访问的servlet<br>7，然后servlet来处理这个请求，如果是pringMVC中的DispatcherServet，那么则会找到对应的Controller中的方法，并执行该方法得到结果<br>8，Tomcat得到响应结果后封装成HTTP响应的格式，并再次通过网络发送给浏览器所在的服务器<br>9，浏览器所在的服务器拿到结果后再传递给浏览器，浏览器则负责解析并洁染</p>
</li>
<li><p>介绍 TCP&#x2F;IP 模型。</p>
<ol>
<li><strong>链路层（Link Layer）：</strong>负责物理介质上的数据传输，处理硬件相关的问题。主要包括网络驱动、接口卡、物理介质等。作用：实现原始比特流的传输，通过物理链路进行直接通信。</li>
<li><strong>网络层（Internet Layer）：</strong>提供数据包在不同网络之间的传输和路由。主要包括IP、ICMP等。作用：实现不同网络之间的通信，处理数据包的寻址和路由问题。</li>
<li><strong>传输层（Transport Layer）：</strong>提供端到端的通信，处理数据流控制、差错校验和恢复等问题。主要包括TCP和UDP。作用：确保数据的可靠传输，处理数据的分段、排序和重组。</li>
<li><strong>应用层（Application Layer）：</strong> 提供网络服务和应用软件之间的接口。包括各种应用层协议，如HTTP、FTP、SMTP等。作用：为用户提供网络服务，支持各种应用软件的运行。</li>
</ol>
</li>
<li><p>OSI七层模型从底层到顶层分别是：</p>
<ol>
<li><strong>物理层（Physical Layer）：</strong> 定义物理设备和传输媒体的规范，如电缆、光纤、网卡等。</li>
<li><strong>数据链路层（Data Link Layer）：</strong> 提供可靠的点对点通信，处理相邻节点之间的数据链路错误和流控制。</li>
<li><strong>网络层（Network Layer）：</strong> 负责在整个网络中找到数据的最佳路径，处理不同网络上的路由和转发。</li>
<li><strong>传输层（Transport Layer）：</strong> 提供端到端的通信，负责数据的可靠传输，处理流量控制和差错恢复。</li>
<li><strong>会话层（Session Layer）：</strong> 管理用户会话和数据交换，提供对话控制和管理。</li>
<li><strong>表示层（Presentation Layer）：</strong> 负责数据格式的转换、加密和压缩，确保一个系统的应用层能理解另一个系统的数据。</li>
<li><strong>应用层（Application Layer）：</strong> 提供用户接口和网络服务，是用户直接与网络交互的地方，包括文件传输、电子邮件、远程登录等。</li>
</ol>
</li>
<li><p>HTTP请求常⻅的状态码和字段</p>
<ul>
<li>常见的HTTP状态码：<br>  <strong>1xx（信息性状态码）：</strong>  100 Continue：继续。客户端应继续其请求。<br>  <strong>2xx（成功状态码）：</strong>  200 OK：请求成功。一般用于GET和POST请求。 201 Created：已创建。成功请求并创建了新的资源。  204 No Content：无内容。服务器成功处理请求，但没有返回任何内容。<br>  <strong>3xx（重定向状态码）：</strong>  301 Moved Permanently：永久重定向。请求的资源已被永久移动到新位置。 302 Found：临时重定向。请求的资源临时移动到新位置。<br>  <strong>4xx（客户端错误状态码）：</strong>  400 Bad Request：请求无效。服务器无法理解请求的语法。401 Unauthorized：未授权。需要身份验证或权限不足。 403 Forbidden：禁止访问。服务器理解请求，但拒绝执行。 404 Not Found：请求的资源不存在。<br>  <strong>5xx（服务器错误状态码）：</strong>  500 Internal Server Error：服务器内部错误。通用错误消息，服务器遇到意外的情况。  502 Bad Gateway：网关错误。服务器作为网关或代理，从上游服务器接收到无效的响应。 503 Service Unavailable：服务不可用。服务器目前无法处理请求。</li>
<li>常见的HTTP字段：<ol>
<li><strong>通用字段：</strong> Cache-Control：控制缓存行为。 Connection：控制是否保持连接。Date：表示消息创建时间。</li>
<li><strong>请求字段：</strong>  Host：指定被请求资源的主机名和端口号。User-Agent：表示客户端信息。</li>
<li><strong>响应字段：</strong>  Server：表示服务器信息。 Content-Type：指定响应内容的MIME类型。Content-Length：响应内容长度。</li>
<li><strong>实体字段：</strong>ETag：用于检测资源是否发生改变。 Last-Modified：表示资源的最后修改时间。</li>
</ol>
</li>
</ul>
</li>
<li><p>HTTP中的主要方法及其作用：</p>
<ol>
<li>GET：从服务器获取资源。GET 方法请求指定的资源，并返回响应主体。它只用于检索数据，而不会修改服务器状态。</li>
<li>POST：向服务器提交数据。POST 方法用于向服务器提交数据，通常用于创建新资源、提交表单数据、上传文件等操作。</li>
<li>PUT：向服务器存储资源。PUT 方法用于向服务器上传或更新指定的资源，通常用于更新现有资源的内容。</li>
<li>DELETE：从服务器删除资源。DELETE 方法用于请求服务器删除指定的资源。</li>
<li>PATCH：对资源进行局部更新。PATCH 方法用于对现有资源进行局部更新，只更新部分内容而不是整个资源。</li>
<li>HEAD：获取资源的元数据。HEAD 方法类似于 GET 方法，但只返回资源的头部信息而不返回响应主体，通常用于获取资源的元数据，如大小、类型等。</li>
<li>OPTIONS：获取服务器支持的方法。OPTIONS 方法用于请求服务器列出对指定资源支持的 HTTP 方法列表，以及其他一些元数据信息。</li>
<li>TRACE：追踪请求的传输路径。TRACE 方法用于测试发送到服务器的请求在其传输路径上的变化，通常用于诊断和调试。</li>
<li>CONNECT：与目标服务器建立代理连接。CONNECT 方法用于建立客户端与目标服务器之间的代理连接，通常用于建立安全的TLS&#x2F;SSL连接。</li>
</ol>
</li>
<li><p>HTTP1.0 和 HTTP1.1 的区别？</p>
<ol>
<li>⻓连接<br>  HTTP1.1 ⽀持⻓连接，每⼀个TCP连接上可以传送多个HTTP请求和响应，默认开启 Connection:Keep-Alive；<br>  HTTP1.0 默认为短连接，每次请求都需要建⽴⼀个TCP连接。</li>
<li>缓存<br>  HTTP1.0 主要使⽤ If-Modified-Since&#x2F;Expires 来做为缓存判断的标准<br>  HTTP1.1 则引⼊了更多的缓存控制策略，如 Entity tag &#x2F; If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li>
<li>管道化：基于 HTTP1.1 的⻓连接，使得请求管线化成为可能。管线化使得请求能够“并⾏”传输，但是响应必须按照请求发出的顺序依次返回，性能在⼀定程度上得到改善</li>
<li>增加Host字段： 使得⼀个服务器能够⽤来创建多个 Web 站点。</li>
<li>状态码： 新增了24个错误状态响应码</li>
<li>带宽优化<br>  HTTP1.0 中，存在⼀些浪费带宽的现象，例如客户端只是需要某个对象的⼀部分，⽽服务器却将整个对象送过来了，并且不⽀持断点续传功能<br>  HTTP1.1 则在请求头引⼊了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content）</li>
</ol>
</li>
<li><p>HTTP2.0 与 HTTP1.1 的区别？</p>
<ol>
<li>⼆进制分帧：在应⽤层 （HTTP&#x2F;2.0） 和传输层（TCP or UDP） 之间增加⼀个⼆进制分帧层，从⽽突破 HTTP1.1 的性能限制，改进传输性能，实现低延迟和⾼吞吐量。</li>
<li>多路复⽤（MultiPlexing）：允许同时通过单⼀的 HTTP&#x2F;2 连接发起多重的请求-响应消息，这个强⼤的功能则是基于“⼆进制分帧”的特性。</li>
<li>⾸部压缩： HTTP1.1 不⽀持 header 数据的压缩，HTTP&#x2F;2.0 使⽤ HPACK 算法对 header  的数据进⾏压缩，这样数据体积⼩了，在⽹络上传输就会更快。⾼效的压缩算法可以很⼤的压缩 heeader ，减少发送包的数量从⽽降低延迟。</li>
<li>服务端推送（server push）： 在 HTTP&#x2F;2 中，服务器可以对客户端的⼀个请求发送多个响应，即服务器可以额外的向客户端推送资源，⽽⽆需客户端明确的请求。</li>
</ol>
</li>
<li><p>??<strong>HTTPS的⼯作原理？(https是怎么建⽴连接的)</strong></p>
<ol>
<li>⾸先，客户端向服务器端发送请求报⽂，请求与服务端建⽴连接。</li>
<li>服务端产⽣⼀对公私钥，然后将⾃⼰的公钥发送给CA机构，CA机构也有⼀对公私钥，然后CA机构使⽤⾃⼰的私钥将服务端发送过来的公钥进⾏加密，产⽣⼀个CA数字证书。</li>
<li>服务端响应客户端的请求，将CA机构⽣成的数字证书发送给客户端。</li>
<li>客户端将服务端发送过来的数字证书进⾏解析(因为浏览器产商跟CA机构有合作，所以浏览器中已经保存了⼤部分CA机构的密钥，⽤于对服务端发送过来的数字证书进⾏解密)，验证这个数字证书是否合法，如果不合法，会发送⼀个警告。如果合法，取出服务端⽣成的公钥。</li>
<li>客户端取出公钥并⽣成⼀个随机码key（其实就是对称加密中的密钥）</li>
<li>客户端将加密后的随机码key发送给服务端，作为接下来的对称加密的密钥</li>
<li>服务端接收到随机码key后，使⽤⾃⼰的私钥对它进⾏解密，然后获得到随机码key。</li>
<li>服务端使⽤随机码key对传输的数据进⾏加密，在传输加密后的内容给客户端</li>
<li>客户端使⽤⾃⼰⽣成的随机码key解密服务端发送过来的数据，之后，客户端和服务端通过对称加密传输数据，随机码Key作为传输的密钥。</li>
</ol>
</li>
<li><p><strong>HTTPS与HTTP的区别</strong><br>HTTP 是明⽂传输，⽽ HTTPS 通过 SSL\TLS 进⾏了加密<br>HTTP 的端⼝号是 80，HTTPS 是 443<br>HTTPS 需要到 CA 申请证书<br>HTTP 的连接简单，是⽆状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进⾏加密传输、身份认证的安全的⽹络协议。</p>
</li>
<li><p>常⻅的请求⽅式？GET 和 POST 请求的区别？</p>
<ol>
<li>作⽤不同： GET⽤于从服务端获取资源，POST⼀般⽤来向服务器端提交数据</li>
<li>参数传递⽅式不同： GET请求的参数⼀般写在URL中，且只接受ASCII字符；POST请求参数⼀般放在请求体中，对于数据类型也没有限制</li>
<li>安全性不同： 因为参数传递⽅式的不同，所以两者安全性不同，GET请求的参数直接暴露在URL中，所以更不安全，不能⽤来传递敏感信息。</li>
<li>参数⻓度限制不同<br>  GET传送的数据量较⼩，不能⼤于2KB。POST传送的数据量较⼤，⼀般被默认为不受限制。<br>  HTTP 协议没有 Body 和 URL 的⻓度限制，对 URL 限制的⼤多是浏览器和服务器的原因。</li>
<li>编码⽅式不同<br>  GET 请求只能进⾏ URL 编码（application&#x2F;x-www-form-urlencoded）<br>  POST ⽀持多种编码⽅式（application&#x2F;x-www-form-urlencoded 或 multipart&#x2F;form-data。为⼆进制数据使⽤多种编码。）</li>
<li>缓存机制不同<br>  GET 请求会被浏览器主动cache，⽽ POST 不会，除⾮⼿动设置。<br>  GET 请求参数会被完整保留在浏览器历史记录⾥，⽽ POST 中的参数不会被保留。<br>  GET 产⽣的 URL 地址可以被 保存为书签，⽽ POST 不可以。<br>  GET 在浏览器回退时是⽆害的，⽽ POST 会再次提交请求。</li>
<li>时间消耗不同<br>  GET 产⽣⼀个 TCP 数据包；POST 产⽣两个 TCP 数据包。<br>  对于 GET ⽅式的请求，浏览器会把 header 和 data ⼀并发送出去，服务器响应 200（返回数据）；⽽对于 POST，浏览器先发送 Header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）</li>
<li>幂等：意思是多次执⾏相同的操作，结果都是「相同」的。<br>  GET ⽅法就是安全且幂等的，因为它是「只读」操作，⽆论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。<br>  POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。</li>
</ol>
</li>
<li><p>？？什么是强缓存和协商缓存</p>
<ul>
<li>缓存可以解决什么问题：<br>  减少不必要的⽹络传输，节约带宽<br>  更快的加载⻚⾯<br>  减少服务器负载，避免服务过载的情况出现</li>
<li>强缓存：浏览器判断请求的⽬标资源是否有效命中强缓存，如果命中，则可以直接从内存中读取⽬标资源，⽆需与服务器做任何通讯。<ul>
<li>Expires强缓存 ：设置⼀个强缓存时间，此时间范围内，从内存中读取缓存并返回，因为 Expires 判断强缓存过期的机制是获取本地时间戳，与之前拿到的资源⽂件中的Expires字段的时间做⽐较。来判断是否需要对服务器发起请求。这⾥有⼀个巨⼤的漏洞：“如果我本地时间不准咋办？”所以⽬前已经被废弃了。</li>
<li>Cache-Control强缓存 ： http1.1 中增加该字段，只要在资源的响应头上写上需要缓 存多久就好了，单位是秒。 Cache-Control:max-age&#x3D;N , 有max-age、s-maxage、     no-cache、no-store、private、public这六个属性。<br>  max-age决定客户端资源被缓存多久。    s-maxage决定代理服务器缓存的时⻓。    no-cache表示是强制进⾏协商缓存。    no-store是表示禁⽌任何缓存策略。    public表示资源既可以被浏览器缓存也可以被代理服务器缓存。    private表示资源只能被浏览器缓存，默认为private</li>
</ul>
</li>
<li>基于 last-modified 的协商缓存<br>  ⾸先需要在服务器端读出⽂件修改时间，将读出来的修改时间赋给响应头的last-modified字段。最后设置Cache-control:no-cache，当客户端读取到last-modified的时候，会在下次的请求标头中携带⼀个字段:If-ModifiedSince，⽽这个请求头中的If-Modified-Since就是服务器第⼀次修改时候给他的时间。之后每次对该资源的请求，都会带上If-Modified-Since这个字段，⽽服务端就需要拿到这个时间并再次读取该资源的修改时间，让他们两个做⼀个⽐对来决定是读取缓存还是返回新的资源。<br>  缺点：<br>  因为是更具⽂件修改时间来判断的，所以，在⽂件内容本身不修改的情况下，依然有可能更新⽂件修改时间（⽐如修改⽂件名再改回来），这样，就有可能⽂件内容明明没有修改，但是缓存依然失效了。当⽂件在极短时间内完成修改的时候（⽐如⼏百毫秒）。因为⽂件修改时间记录的最⼩单位是秒，所以，如果⽂件在⼏百毫秒内完成修改的话，⽂件修改时间不会改变，这样，即使⽂件内容修改了，依然不会返回新的⽂件。</li>
<li>基于 ETag 的协商缓存：<br>  将原先协商缓存的⽐较时间戳的形式修改成了⽐较⽂件指纹（根    据⽂件内容计算出的唯⼀哈希值）。第⼀次请求某资源的时候，服务端读取⽂件并计算出⽂件指纹，将⽂件指纹放在响应头的 Etag字段中跟资源⼀起返回给客户端。第⼆次请求某资源的时候，客户端⾃动从缓存中读取出上⼀次服务端返回的ETag也就是⽂件指纹。并赋给请求头的if-None-Match字段，让上⼀次的⽂件指纹跟随请求⼀起回到服务端。<br>  服务端拿到请求头中的if-None-Match字段值（也就是上⼀次的⽂件指纹），并再次读取⽬标资源并⽣成⽂件指纹，两个指纹做对⽐。如果两个⽂件指纹完全吻合，说明⽂件没有被改变，则直接返回304状态码和⼀个空的响应体并return。如果两个⽂件指纹不吻合，则说明⽂件被更改，那么将新的⽂件指纹重新存储到响应头的ETag中并返回给客户端。<br>  缺点：<br>  ETag需要计算⽂件指纹这样意味着，服务端需要更多的计算开销。。如果⽂件尺⼨⼤，数量多，并且计算频繁，那么ETag的计算就会影响服务器的性能。显然，ETag在这样的场景下就不是很适合。ETag有强验证和弱验证，所谓将强验证，ETag⽣成的哈希码深⼊到每个字节。哪怕⽂件中只有⼀个字节改变了，也会⽣成不同的哈希值，它可以保证⽂件内容绝对的不变。但是，强验证⾮常消耗计算量。ETag还有⼀个弱验证，弱验证是提取⽂件的部分属性来⽣成哈希值。因为不必精确到每个字节，所以他的整体速度会⽐强验证快，但是准确率不⾼。会降低协商缓存的有效性。</li>
<li>有哈希值的⽂件设置强缓存即可。没有哈希值的⽂件（⽐如index.html）设置协商缓存。</li>
</ul>
</li>
<li><p>DNS、、</p>
<ul>
<li>DNS（Domain Name System）域名管理系统，是当⽤户使⽤浏览器访问⽹址之后，使⽤的第⼀个重要协议。DNS 要解决的是域名和 IP 地址的映射问题。</li>
<li>查询过程：<ol>
<li>⾸先⽤户在浏览器输⼊URL地址后，会先查询浏览器缓存是否有该域名对应的IP地址。</li>
<li>如果浏览器缓存中没有，会去计算机本地的Host⽂件中查询是否有对应的缓存。</li>
<li>如果Host⽂件中也没有则会向本地的DNS解析器（通常由你的互联⽹服务提供商（ISP）提供）发送⼀个DNS查询请求。</li>
<li>如果本地DNS解析器没有缓存该域名的解析记录，它会向根DNS服务器发出查询请求。根DNS服务器并不负责解析域名，但它能告诉本地DNS解析器应该向哪个顶级域（.com&#x2F;.net&#x2F;.org）的DNS服务器继续查询。</li>
<li>本地DNS解析器接着向指定的顶级域DNS服务器发出查询请求。顶级域DNS服务器也不负责具体的域名解析，但它能告诉本地DNS解析器应该前往哪个权威DNS服务器查询下⼀步的信息。</li>
<li>本地DNS解析器最后向权威DNS服务器发送查询请求。 权威DNS服务器是负责存储特定域名和IP地址映射的服务器。当权威DNS服务器收到查询请求时，它会查找”example.com”域名对应的IP地址，并将结果返回给本地DNS解析器。</li>
<li>本地DNS解析器将收到的IP地址返回给浏览器，并且还会将域名解析结果缓存在本地，以便下次访问时更快地响应</li>
</ol>
</li>
</ul>
</li>
<li><p>HTTP多个TCP连接怎么实现？？？<br>多个tcp连接是靠某些服务器对 Connection: keep-alive 的 Header 进⾏了⽀持。简⽽⾔之，完成这个 HTTP 请求之后，不要断开 HTTP 请求使⽤的 TCP 连接。这样的好处是连接可以被重新使⽤，之后发送 HTTP 请求的时候不需要重新建⽴ TCP 连接，以及如果维持连接，那么 SSL 的开销也可以避免</p>
</li>
<li><p>TCP的三次握手和四次挥手</p>
<ul>
<li>在建立TCP连接时，需要通过三次握手来建立，过程是:<br>  1，客户端向服务端发送一个SYN<br>  2，服务端接收到SYN后，给客户端发送一个SYN_ACK<br>  3，客户端接收到SYN_ACK后，再给服务端发送一个ACK</li>
<li>在断开TCP连接时，需要通过四次挥手来断开，过程是<br>  1，客户端向服务端发送FIN<br>  2，服务端接收FIN后，向客户燃发送ACK，表示我接收到了断开连接的请求，客户端你可以不发数据了，不过服务端这边可能还有数据正在处理<br>  3，服务端处理完所有数据后，向客户端发送FIN，表示服务端现在可以断开连接<br>  4，客户端收到服务端的FIN，向服务端发送ACK，表示客户端也会断开连接了</li>
</ul>
</li>
<li><p><strong>三次握⼿的过程，以及为什么是三次，⽽不是四次，两次？</strong></p>
<ul>
<li>三次握⼿的过程如下：<ol>
<li>客户端向服务器发送 SYN 报⽂、初始化序列号 ISN（seq&#x3D;x），然后客户端进⼊ SYN_SEND 状态，等待服务器确认。</li>
<li>服务端发送 ACK 确认服务端的 SYN 报⽂ (ack&#x3D;x+1) 同时发出⼀个 SYN 报⽂，带上⾃⼰的初始化序列号 （seq&#x3D;y ），然后服务端进⼊ SYN_RECV 状态。</li>
<li>客户端接收到服务端的 SYN、ACK 报⽂，ACK确认服务端的 SYNC 报⽂ （ACK&#x3D;y+1） ，然后客户端和服务器端都进⼊ ESTABLISHED 状态，完成 TCP 三次握⼿</li>
</ol>
</li>
<li>为什么不是四次握⼿？ 为什么不能两次握⼿？<br>  因为三次握⼿才能保证双⽅具有接收和发送的能⼒。 两次握⼿可能导致资源的浪费，由于没有第三次握⼿，服务端就⽆法确认客户端是否收到了⾃⼰的回复，所以每收到⼀个 SYN ，服务器都会主动去建⽴⼀个连接, ⽽四次握⼿可以优化为三次。</li>
</ul>
</li>
<li><p><strong>四次挥⼿的过程，以及为什么是四次？</strong></p>
<ul>
<li>四次挥⼿的过程：<ol>
<li>客户端发送⼀个 FIN 报⽂给服务端，表示⾃⼰要断开数据传送，报⽂中会指定⼀个序列号 (seq&#x3D;x) 。然后,客户端进⼊ FIN-WAIT-1 状态。</li>
<li>服务端收到 FIN 报⽂后，回复 ACK 报⽂给客户端，且把客户端的序列号值 +1 ，作为ACK + 1 报⽂的序列号 (seq&#x3D;x+1) 然后，服务端进⼊ CLOSE-WAIT (seq&#x3D;x+1) 状态，客户端进⼊ FIN-WAIT-2 状态。</li>
<li>服务端也要断开连接时，发送 FIN 报⽂给客户端，且指定⼀个序列号 (seq&#x3D;y+1) ，随后服务端进⼊ LAST-ACK 状态。</li>
<li>客户端收到 FIN 报⽂后，发出 ACK 报⽂进⾏应答，并把服务端的序列号值 +1 作为 ACK 报⽂序列号 (seq&#x3D;y+2) 。此时客户端进⼊ TIME-WAIT 状态。服务端在收到客户端的 ACK 报⽂后进⼊ CLOSE 状态。如果客户端等待 2MSL 没有收到回复，才关闭连接</li>
</ol>
</li>
<li>为什么是四次挥⼿？<br>  TCP 是全双⼯通信，可以双向传输数据。任何⼀⽅都可以在数据传送结束后发出连接释放的通知，待对⽅确认后进⼊半关闭状态。 当另⼀⽅也没有数据再发送的时候，则发出连接释放通知，对⽅确认后才会完全关闭了 TCP 连接。 总结：两次握⼿可以释放⼀端到另⼀端的 TCP 连接，完全释放连接⼀共需要四次握⼿</li>
<li>为什么会有 <code>TIME_WAIT</code> 状态？发生在客户端还是服务端？<ol>
<li>确保数据可靠传输：在四次挥手中，最后一次挥手由服务端发送 <code>FIN</code> 报文给客户端，表示服务端已经关闭了连接。此时客户端进入 <code>TIME_WAIT</code> 状态，等待一段时间（通常是2倍的最大报文段生存时间（MSL）），确保服务端接收到最后一个 <code>ACK</code> 报文，以保证数据的可靠传输。</li>
<li>处理可能的重传数据包：在网络中可能会出现一些延迟到达的数据包或者服务端未收到客户端的确认报文的情况。如果客户端在收到服务端的 <code>FIN</code> 报文后直接关闭连接而不进入 <code>TIME_WAIT</code> 状态，那么如果服务端在关闭连接后的一段时间内重传了 <code>FIN</code> 报文，客户端就无法正确处理这个重传的 <code>FIN</code> 报文，可能会导致连接异常。<br> <code>TIME_WAIT</code> 状态一般在客户端设置。这是因为在 TCP 协议中，客户端主动发起连接并主动关闭连接的情况比较常见，因此客户端需要等待一段时间确保连接关闭的可靠性。服务端在关闭连接后会直接进入 <code>CLOSED</code> 状态，不需要等待，因为服务端已经没有发送数据的需求，只需等待客户端的最后一个 <code>ACK</code> 确认即可。通常，操作系统会对 <code>TIME_WAIT</code> 状态的持续时间进行配置，以便合理利用系统资源并确保连接关闭的可靠性。</li>
</ol>
</li>
</ul>
</li>
<li><p>TCP与UDP的概念，特点，区别和对应的使⽤场景？</p>
<ul>
<li>TCP与UDP的概念<br>  TCP（传输控制协议）是⼀种⾯向连接的、可靠的、基于字节流的传输层通信协议。<br>  UDP（⽤户数据报协议）为应⽤程序提供了⼀种⽆需建⽴连接就可以发送封装的IP数据包的⽅法。</li>
<li>特点<br>  TCP：⾯向连接，传输可靠，传输形式为字节流，传输效率慢，所需资源多。<br>  UDP：⽆连接、传输不可靠、传输形式为数据报⽂段，传输效率快，所需资源少。</li>
<li>区别<ol>
<li>连接：TCP 是⾯向连接的传输层协议，传输数据前先要建⽴连接。UDP 是不需要连接，即刻传输数据。</li>
<li>服务对象：TCP 是⼀对⼀的两点服务，即⼀条连接只有两个端点。UDP ⽀持⼀对⼀、⼀对多、多对多的交互通信</li>
<li>是否有状态：TCP 传输是有状态的，它会去记录⾃⼰发送消息的状态⽐如消息是否发送了、是否被接收了等等，⽽ UDP 是⽆状态的。</li>
<li>可靠性：TCP可靠交付数据，数据可以⽆差错、不丢失、不重复、按需到达。UDP尽最⼤努⼒，不保证可靠交付数据。<br>  TCP在传递数据之前，会有三次握⼿来建⽴连接；在数据传递时，有确认、窗⼝、重传、拥塞控制机制，保证数据传输的安全性。UDP数据传递不需要给出任何确认，且不保证数据不丢失及到达顺序；没有拥塞控制，即使⽹络⾮常拥堵了，也不会影响 UDP 的发送速率。</li>
<li>⾸部开销：TCP ⾸部⻓度较⻓，会有⼀定的开销，⾸部在没有使⽤「选项」字段时是 20 个字节，如果使⽤了「选项」字段则会变⻓的 (20 ~ 60字节)。UDP ⾸部只有 8 个字节，并且是固定不变的，开销较⼩。</li>
<li>传输⽅式：TCP 是⾯向字节流的，UDP ⾯向报⽂。TCP 是流式传输，没有边界，但保证顺序和可靠。UDP 是⼀个包⼀个包的发送，是有边界的，但可能丢包和乱序。</li>
<li>传输效率：由于TCP 传输的时候多了连接、确认重传等机制，所以TCP 的传输效率要⽐UDP 低。</li>
<li>分⽚不同：<ul>
<li>TCP 的数据⼤⼩如果⼤于 MSS ⼤⼩，则会在传输层进⾏分⽚，⽬标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了⼀个分⽚，只需要传输丢失的这个分⽚。</li>
<li>UDP 的数据⼤⼩如果⼤于 MTU ⼤⼩，则会在 IP 层进⾏分⽚，⽬标主机收到后，在 IP 层组装完数据，接着再传给传输层，但是如果中途丢了⼀个分⽚，在实现可靠传输的 UDP 时则就需要重传所有的数据包，这样传输效率⾮常差，所以通常 UDP 的报⽂应该⼩于 MTU。</li>
</ul>
</li>
</ol>
</li>
<li>对应的使⽤场景<br>  TCP常⽤于要求通信数据可靠场景（如⽹⻚浏览、⽂件传输、邮件传输、远程登录、数据库操作等）。<br>  UDP常⽤于要求通信速度⾼场景（如域名转换、视频直播、实时游戏等）。</li>
</ul>
</li>
<li><p>TCP 的 Keepalive 和 HTTP 的 Keep-Alive 是⼀个东⻄吗？</p>
<ul>
<li>HTTP 的 Keep-Alive，是由应⽤层（⽤户态） 实现的，称为 HTTP ⻓连接；<br>  每次请求都要经历这样的过程：建⽴ TCP -&gt; 请求资源 -&gt; 响应资源 -&gt; 释放连接，这就是HTTP短连接，但是这样每次建⽴连接都只能请求⼀次资源，所以HTTP 的 Keep-Alive实现了使⽤同⼀个 TCP 连接来发送和接收多个 HTTP 请求&#x2F;应答，避免了连接建⽴和释放的开销，就就是 HTTP ⻓连接。</li>
<li>TCP 的 Keepalive，是由 TCP 层（内核态） 实现的，称为 TCP 保活机制；通俗地说，就是TCP有⼀个定时任务做倒计时，超时后会触发任务，内容是发送⼀个探测报⽂给对端，⽤来判断对端是否存活。</li>
</ul>
</li>
<li><p>TCP连接如何确保可靠性？</p>
<ol>
<li>数据块⼤⼩控制： 应⽤数据被分割成TCP认为最合适发送的数据块，再传输给⽹络层，数据块被称为报⽂段或段。</li>
<li>序列号：TCP给每个数据包指定序列号，接收⽅根据序列号对数据包进⾏排序，并根据序列号对数据包去重。</li>
<li>校验和：TCP将保持它⾸部和数据的校验和。这是⼀个端到端的检验和，⽬的是检测数据在传输中的任何变化。若收到报⽂的检验和有差错，TCP将丢弃这个报⽂段和不确认收到此报⽂段。</li>
<li>流量控制： TCP连接的每⼀⽅都有固定⼤⼩的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收⽅来不及处理发送⽅的数据，能提示发送⽅降低发送的速率，防⽌包丢失。TCP利⽤滑动窗⼝实现流量控制。</li>
<li>拥塞控制： 当⽹络拥塞时，减少数据的发送。</li>
<li>确认应答： 通过 ARQ 协议实现。基本原理是每发完⼀个分组就停⽌发送，等待对⽅确认。如果没收到确认，会重发数据包，直到确认后再发下⼀个分组。</li>
<li>超时重传： 当TCP发出⼀个数据段后，它启动⼀个定时器，等待⽬的端确认收到这个报⽂段。如果不能及时收到⼀个确认，将重发这个报⽂段。</li>
</ol>
</li>
<li><p>既然提到了拥塞控制，那你能说说说拥塞控制是怎么实现的嘛<br>  拥塞控制算法主要有以下⼏种：</p>
<ol>
<li>慢启动：  在连接刚开始时，发送⽅会逐渐增加发送窗⼝⼤⼩，从⽽以指数增⻓的速度增加发送的数据量。</li>
<li>拥塞避免： ⼀旦慢启动阶段过去，发送⽅进⼊拥塞避免阶段。在这个阶段，发送⽅逐渐增加发送窗⼝的⼤⼩，但增加速率较慢，避免过快增加导致⽹络拥塞。</li>
<li>超时重传： 如果发送⽅在超时时间内未收到确认，它会认为数据包丢失，并重传这些数据包。这是拥塞控制的最后⼿段，⽤于检测和处理⽹络中的丢包或拥塞情况。当⽹络出现拥塞，也就是会发⽣数据包重传</li>
<li>快速重传（Fast Retransmit）和快速恢复（Fast Recovery）： 当发送⽅发送的数据包丢失或⽹络出现拥塞时，接收⽅会发送重复确认（duplicate ACK）通知 发送⽅有数据包丢失。当发送⽅收到⼀定数量的重复确认时，它会⽴即重传丢失的数据包，⽽不是等待超时。这样可以减少⽹络的拥塞程度。</li>
<li>拥塞窗⼝调整：   发送⽅根据⽹络的拥塞程度动态调整发送窗⼝的⼤⼩，通过监测⽹络延迟和丢包情况来确定合适的发送速率，以避免⽹络拥塞。</li>
</ol>
</li>
<li><p>TCP 传送数据的过程、、</p>
<ol>
<li>建立连接：在 TCP 通信开始前，发送方和接收方需要通过三次握手建立连接。这个过程包括发送方发送 SYN 报文段给接收方，接收方回复 SYN+ACK 报文段给发送方，最后发送方发送 ACK 报文段给接收方，建立起双向的通信连接。</li>
<li>数据分割：发送方将应用层的数据流分割成适当大小的数据块，每个数据块称为一个报文段（Segment），每个报文段都带有序列号，用于标识数据的顺序。（TCP 基于字节流传输，这种字节流传输的方式是在 TCP 协议的抽象层面上实现的，实际传输时，TCP 使用报文段作为传输单位来保证数据的可靠传输。）</li>
<li>发送数据：发送方根据 TCP 的滑动窗口机制和拥塞控制算法，将报文段发送给接收方。发送方根据接收方的确认情况和网络情况动态调整发送速率和窗口大小，确保数据的可靠传输和网络的稳定性。</li>
<li>接收数据：接收方接收到报文段后，会进行确认，即发送 ACK 报文段给发送方，确认接收到的数据。如果有丢失或损坏的数据，接收方会要求发送方重新发送数据。</li>
<li>数据重组：接收方根据报文段的序列号和数据部分将数据重组成完整的数据流，然后交给应用层进行处理。</li>
<li>连接关闭：当数据传输完成后，发送方和接收方会通过四次挥手的方式关闭连接。发送方发送 FIN 报文段给接收方，表示不再发送数据；接收方回复 ACK 报文段确认，并发送 FIN 报文段给发送方；发送方再次发送 ACK 报文段给接收方，完成连接关闭。</li>
</ol>
</li>
<li><p>Cookie 和 Session 是什么？有什么区别？</p>
<ul>
<li>都⽤于管理⽤户的状态和身份, Cookie 通过在客户端记录信息确定⽤户身份， Session 在服务器端记录信息确定⽤户身份。</li>
<li>Cookie：是存储在⽤户浏览器中的⼩型⽂本⽂件，⼀般为⼏ KB，⽤于在⽤户和服务器之间传递数据。通常，服务器会将⼀个或多个 Cookie 发送到⽤户浏览器，然后浏览器将这些 Cookie 存储在本地。<br>  服务器在接收到来⾃客户端浏览器的请求之后，就能够通过分析存放于请求头的Cookie得到客户端特有的信息，从⽽动态⽣成与该客户端相对应的内容。</li>
<li>Session：客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是 Session，主要⽤于维护⽤户登录状态、存储⽤户的临时数据和上下⽂信息等。存储容量较⼤，通常没有固定限制，取决于服务器的配置和资源。</li>
<li>安全性：由于 Cookie 存储在⽤户浏览器中，因此可以被⽤户读取和篡改。相⽐之下，Session 数据存储在服务器上，更难被⽤户访问和修改。</li>
<li>传输⽅式：Cookie 在每次 HTTP 请求中都会被⾃动发送到服务器，⽽ Session ID 通常通过 Cookie 或 URL 参数传递。</li>
</ul>
</li>
<li><p>WEB 负载均衡方案。<br>是通过合理分配网络流量，将请求均匀分发到多个服务器上，以提高系统的性能、可用性和可伸缩性。<br>1、硬件负载均衡：通常是专门设计用于处理负载均衡任务的设备。这些设备可以位于网络流量的前端，根据预定义的算法和策略将请求分发给后端的多个服务器。硬件负载均衡的优势在于它可以处理大量的并发连接，同时提供高性能和低延迟。<strong>性能优越：</strong> 硬件负载均衡器通常具有高性能的硬件处理能力，能够应对大量请求。<strong>丰富的算法：</strong> 支持多种负载均衡算法，如轮询、加权轮询、最小连接数等。<strong>高可用性：</strong> 支持冗余配置，以确保负载均衡设备本身的高可用性。<br>2、软件负载均衡：通常是通过在服务器上运行特定的负载均衡软件来实现的，这些软件可以在普通服务器上运行，也可以部署在云环境中。软件负载均衡器通常提供一系列配置选项，以便根据特定需求进行定制。<br>3、DNS负载均衡：可以将域名映射到多个IP地址，实现流量的分发。DNS负载均衡的优点在于其简单性和低成本，但在实际应用中可能会受到DNS缓存的影响，导致流量分发不均匀。<br>4、网络负载均衡：通过网络设备（如交换机、路由器）进行流量分发。这种方式通常涉及更底层的网络配置，可以在不同层次上实现负载均衡。<br>适用于需要处理大规模流量的场景。配置和管理较为复杂，需要深入理解网络结构。</p>
</li>
<li><p>192.168.1.0 分成 4 个子网，子网掩码是什么？</p>
<ul>
<li>子网掩码不能单独存在，它必须结合IP地址一起使用。IP地址我们都知道是计算机在网络内的唯一标识，而子网掩码顾名思义是用于划分子网的<br>  子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。子网掩码是一个32位地址，用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上，还是在远程网上。</li>
<li>默认的子网掩码255.255.255.0：将该子网掩码的二进制由24个1和8个0组成，8个0表示该子网掩码划分出的子网容量为256（2的8次方），也就是说192.168.1.0-255都在同一个子网中，这256个地址中可用地址只有254个，因为规定每个子网的第一个IP地址为网段地址，最后一个IP地址为广播地址，都不可用。</li>
<li>某个小型公司有四个部门，每个部门各40台计算机接入公司局域网交换机，如果要在192.168.1.0网段为每个部门划分子网，子网掩码应该怎么设置，每个子网的地址范围分别是什么？<ul>
<li>192.168.1.0网段共256个地址，划分4个子网，每个子网需要64个地址；64是2的6次方，子网掩码应该以6个0结尾，剩下的用1补齐，由26个1和6个0组成，转换成十进制是255.255.255.192；</li>
<li>每个子网共64个IP地址，掐头去尾后可用地址只有62个，第1个子网的可用IP地址范围是：192.168.1.1-62，第2个子网可用IP地址范围是192.168.1.65-126，第3个子网的可用IP地址范围是：192.168.1.129-190，第4个子网可用IP地址范围是192.168.1.193-254；</li>
<li>各部门计算机按照上面各子网的IP地址范围进行设置，所有计算机的子网掩码都必须设置为255.255.255.192，设置完毕后各部门内的计算机能正常联网，不同部门间的计算机无法直接联通。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>

<h2 id="操-作-系-统"><a href="#操-作-系-统" class="headerlink" title="操 作 系 统"></a>操 作 系 统</h2><ul>
<li><p>进程与线程？</p>
<ul>
<li>进程是程序的执行实例，拥有独立的内存空间和系统资源，是操作系统进行资源分配和调度的基本单位。是系统进⾏资源分配和调度的基本单位。</li>
<li>线程 Thread 是进程内的独立执行单元，共享相同的内存空间和资源，是进程的子执行单元。是操作系统能够进⾏运算调度的最⼩单位。<br>  线程⼀个进程⾄少有⼀个线程，⼀个进程可以运⾏多个线程，这些线程共享同⼀块内存。</li>
<li>资源开销：<br>  进程：由于每个进程都有独⽴的内存空间，创建和销毁进程的开销较⼤。进程间切换需要保存和恢复整个进程的状态，因此上下⽂切换的开销较⾼。<br>  线程：线程共享相同的内存空间，创建和销毁线程的开销较⼩。线程间切换只需要保存和恢复少量的线程上下⽂，因此上下⽂切换的开销较⼩。</li>
<li>？？通信与同步：<br>  进程：由于进程间相互隔离，进程之间的通信需要使⽤⼀些特殊机制，如管道、消息队列、共享    内存等。<br>  线程：由于线程共享相同的内存空间，它们之间可以直接访问共享数据，线程间通信更加⽅便。</li>
<li>安全性：<br>  进程：由于进程间相互隔离，⼀个进程的崩溃不会直接影响其他进程的稳定性。<br>  线程：由于线程共享相同的内存空间，⼀个线程的错误可能会影响整个进程的稳定性。</li>
</ul>
</li>
<li><p>为什么进程切换比线程切换开销大？</p>
<ol>
<li><strong>地址空间切换：</strong> 进程拥有独立的地址空间，进程切换时需要切换地址空间，包括虚拟内存、页表等，而线程之间共享地址空间，线程切换时不需要这种开销。</li>
<li><strong>资源切换：</strong> 进程拥有独立的资源，如文件描述符、堆栈、全局变量等，进程切换时需要保存和恢复这些资源，而线程之间共享资源，线程切换时开销较小。</li>
<li><strong>上下文切换：</strong> 进程切换时需要保存和恢复更多的上下文信息，包括进程控制块（PCB）、寄存器、栈指针等，而线程切换时只需保存和恢复部分上下文信息。</li>
<li><strong>系统调用开销：</strong> 进程切换时可能需要进行系统调用，如切换到内核态、更新进程状态等，而线程切换时可以在用户态完成。</li>
<li><strong>同步和通信开销：</strong> 进程之间的通信和同步需要额外的开销，如信号量、消息队列等，而线程之间可以通过共享内存等更高效的方式进行通信和同步。</li>
</ol>
</li>
<li><p>进程调度算法你了解多少？<br>  进程调度算法是操作系统中⽤来管理和调度进程（也称为任务或作业）执⾏的⽅法。这些算法决定了在多任务环境下，如何为各个进程分配 CPU 时间，以实现公平性、⾼吞吐量、低延迟等不同的调度⽬标。</p>
<ol>
<li>先来先服务调度算法： 按照进程到达的先后顺序进⾏调度，即最早到达的进程先执⾏，直到完成或阻塞。</li>
<li>最短作业优先调度算法：    优先选择运⾏时间最短的进程来运⾏</li>
<li>⾼响应⽐优先调度算法：    综合考虑等待时间和服务时间的⽐率，选择具有最⾼响应⽐的进程来执⾏</li>
<li>时间⽚轮转调度算法：    将 CPU 时间划分为时间⽚（时间量），每个进程在⼀个时间⽚内运⾏，然后切换到下⼀个进程。</li>
<li>最⾼优先级调度算法：    为每个进程分配⼀个优先级，优先级较⾼的进程先执⾏。这可能导致低优先级进程⻓时间等待，    可能引发饥饿问题。</li>
<li>多级反馈队列调度算法：    将进程划分为多个队列，每个队列具有不同的优先级，进程在队列之间移动。具有更⾼优先级的 队列的进程会更早执⾏，⽽⻓时间等待的进程会被提升到更⾼优先级队列。</li>
<li>最短剩余时间优先：    每次选择剩余执⾏时间最短的进程来执⾏。</li>
<li>最⼤吞吐量调度：    旨在最⼤化单位时间内完成的进程数量</li>
</ol>
</li>
<li><p>进程间通信<br>  进程间通信（IPC）可以通过多种方式实现，包括管道、消息队列、信号量、共享内存等。这些机制允许不同进程之间交换数据和同步操作。</p>
<ol>
<li>管道：是⼀种半双⼯的通信⽅式，数据只能单向流动⽽且只能在具有⽗⼦进程关系的进程间使⽤。</li>
<li>命名管道： 也是半双⼯的通信⽅式，但是它允许⽆亲缘关系进程间的通信。</li>
<li>信号量：是⼀个计数器，可以⽤来控制多个进程对共享资源的访问，常作为⼀种锁机制，防⽌某进程正在访问共享资源时，其他进程也访问该资源。因此主要作为进程间以及同⼀进程内不同线程之间的同步⼿段。</li>
<li>消息队列：消息队列是消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载⽆格式字节流以及缓冲区⼤⼩受限等缺点。</li>
<li>信号：⽤于通知接收进程某个事件已经发⽣，从⽽迫使进程执⾏信号处理程序。</li>
<li>共享内存：就是映射⼀段能被其他进程所访问的内存，这段共享内存由⼀个进程创建，但多个进程都可以访问。共享内存是最快的进程通信⽅式，它是针对其他进程间通信⽅式运⾏效率低⽽专⻔设计的。它往往与其他通信机制，⽐如信号量配合使⽤，来实现进程间的同步和通信。</li>
<li>Socket 套接字：是⽀持TCP&#x2F;IP 的⽹络通信的基本操作单元，主要⽤于在客户端和服务器之间通过⽹络进⾏通信</li>
</ol>
</li>
<li><p>什么是死锁？如何避免死锁？<br>死锁是指两个或多个进程在争夺系统资源时，由于互相等待对⽅释放资源⽽⽆法继续执⾏的状态。死锁只有同时满⾜以下四个条件才会发⽣：<br>1、互斥条件：⼀个进程占⽤了某个资源时，其他进程⽆法同时占⽤该资源。<br>2、请求保持条件：⼀个线程因为请求资源⽽阻塞的时候，不会释放⾃⼰的资源。<br>3、不可剥夺条件：资源不能被强制性地从⼀个进程中剥夺，只能由持有者⾃愿释放。<br>4、环路等待条件：多个进程之间形成⼀个循环等待资源的链，每个进程都在等待下⼀个进程所占有的资源。<br>只需要破坏上⾯⼀个条件就可以破坏死锁。<br>破坏请求与保持条件：⼀次性申请所有的资源。<br>破坏不可剥夺条件：占⽤部分资源的线程进⼀步申请其他资源时，如果申请不到，可以主动释放它占有的资源。<br>破坏循环等待条件：靠按序申请资源来预防。让所有进程按照相同的顺序请求资源，释放资源则反序释放。</p>
</li>
<li><p>多进程与多线程区别：</p>
<ul>
<li>多进程是在不同的地址空间中执行，相互独立，通信相对复杂，但更稳定。</li>
<li>多线程共享相同的地址空间，通信更方便，但需要考虑同步和竞态条件，可能导致不稳定性。</li>
</ul>
</li>
<li><p>解释⼀下⽤户态和核⼼态<br>⽤户态 User Mode 和核⼼态 Kernel Mode ，是操作系统中两种不同的执⾏模式，⽤于控制进程或程序对计算机硬件资源的访问权限和操作范围。<br>⽤户态：进程或程序只能访问受限的资源和执⾏受限的指令集，不能直接访问操作系统的核⼼部分，也不能直接访问硬件资源，⽤户态下的 CPU 不允许独占，也就是说 CPU 能够被其他程序获取。<br>核⼼态：核⼼态是操作系统的特权级别，允许进程或程序执⾏特权指令和访问操作系统的核⼼部分。在核⼼态下，进程可以直接访问硬件资源，执⾏系统调⽤，管理内存、⽂件系统等操作。处于内核态的 CPU 可以从⼀个程序切换到另外⼀个程序，并且占⽤ CPU 不会发⽣抢占情况，⼀般处于特权级 0 的状态我们称之为内核态</p>
</li>
<li><p>用户态切换到内核态。<br>是通过系统调用（System Call）实现的。下面是大致的步骤：<br>1、<strong>触发系统调用：</strong> 当用户程序需要执行一些特权操作（例如文件操作、网络访问、内存分配等），需要请求操作系统的帮助。用户程序通过系统调用指令触发这一请求。在 x86 架构中，通常使用 <code>int 0x80</code> 或 <code>syscall</code> 指令来触发系统调用。<br>2、<strong>切换到内核态：</strong> 当发生系统调用时，处理器会由用户态切换到内核态。这个切换的过程中，处理器的特权级别会提升，从而允许操作系统执行一些受保护的指令。<br>3、<strong>系统调用处理：</strong> 操作系统的内核接收到系统调用请求后，会根据请求的类型执行相应的系统调用服务例程。这些服务例程负责完成用户程序请求的操作，可能涉及到内核中的数据结构和硬件资源。<br>4、<strong>返回用户态：</strong> 完成系统调用服务例程后，操作系统将控制权返回给用户程序，同时降低处理器的特权级别，将其切换回用户态。这个过程中，操作系统可能会将系统调用的结果返回给用户程序。</p>
</li>
<li><p>解释⼀下进程同步和互斥，以及解决方法</p>
<ul>
<li>进程同步是指多个并发执⾏的进程之间协调和管理它们的执⾏顺序，以确保它们按照⼀定的顺序或时间间隔执⾏。⽐如说，你想要和你的队友⼀起完成⼀个副本，你们需要相互配合，有时候等待对⽅的信号或者消息，有时候按照对⽅的要求执⾏某些动作，这就是进程同步。</li>
<li>互斥指的是在某⼀时刻只允许⼀个进程访问某个共享资源。当⼀个进程正在使⽤共享资源时，其他进程不能同时访问该资源。⽐如说，你想要使⽤⼀个祭坛来祈愿，但是这个祭坛⼀次只能被⼀个⼈使⽤，如果有其他⼈也想要使⽤，他们就必须等待你使⽤完毕后再去使⽤，这就是进程互斥。</li>
<li>解决进程同步和互斥的问题有很多种⽅法，其中⼀种常⻅的⽅法是使⽤信号量和 PV 操作。信号量是⼀种特殊的变量，它表示系统中某种资源的数量或者状态。PV 操作是⼀种对信号量进⾏增加或者减少的操作，它们可以⽤来控制进程之间的同步或者互斥。</li>
<li>举个例⼦，假设有⼀个信号量 s 表示⼀个祭坛是否可⽤，初始值为 1。如果 s 的值为 1，表示祭坛空闲；如果 s 的值为 0，表示祭坛被占⽤；如果 s 的值为 -1，表示有⼀个⼈在等待使⽤祭坛。那么我们可以⽤ PV 操作来实现对祭坛的互斥访问：<br>  如果你想要使⽤祭坛，你就执⾏ P(s) 操作，将 s 的值减 1。如果结果为 0 或者正数，表示你可以使⽤祭坛；如果结果为负数，表示有⼈在使⽤祭坛，你就必须等待。<br>  如果你使⽤完了祭坛，你就执⾏ V(s) 操作，将 s 的值加 1。如果结果为正数或者 0 ，表示没有⼈在等待使⽤祭坛；结果为负数，表示有⼈在等待使⽤祭坛，你就需要唤醒他们中的⼀个。<br>  这样就可以保证每次只有⼀个⼈能够使⽤祭坛，实现了进程互斥。</li>
<li>除此之外，下⾯的⽅法也可以解决进程同步和互斥问题：<br>  临界区（Critical Section）： 将可能引发互斥问题的代码段称为临界区。为了实现互斥，每个进程在进⼊临界区前必须获取⼀个锁，退出临界区后释放该锁。这确保同⼀时间只有⼀个进程可以进⼊临界区。<br>  互斥锁（Mutex）： 互斥锁是⼀种同步机制，⽤于实现互斥。每个共享资源都关联⼀个互斥锁，进程在访问该资源前需要先获取互斥锁，使⽤完后释放锁。只有获得锁的进程才能访问共享资源。<br>  条件变量（Condition Variable）： 条件变量⽤于在进程之间传递信息，以便它们在特定条件下等待或唤醒。通常与互斥锁⼀起使⽤，以确保等待和唤醒的操作在正确的时机执⾏</li>
</ul>
</li>
<li><p>什么是中段和异常？它们有什么区别？</p>
<ul>
<li>中断和异常是两种不同的事件，它们都会导致CPU暂停当前的程序执⾏，转⽽去执⾏⼀个特定的处理程序。</li>
<li>中断和异常的区别主要有以下⼏点：<br>  中断是由外部设备或其他处理器产⽣的，它们通常是异步的，也就是说，它们可以在任何时候发⽣，与当前执⾏的指令⽆关。例如，键盘输⼊、⿏标移动、⽹络数据到达等都会产⽣中断信号，通知CPU去处理这些事件。<br>  异常是由CPU内部产⽣的，它们通常是同步的，也就是说，它们只会在执⾏某些指令时发⽣，与 当前执⾏的指令有关。例如，除法运算时除数为零、访问⾮法内存地址、执⾏⾮法指令等都会产⽣异常信号，通知CPU去处理这些错误或故障。<br>  中断可以被屏蔽或禁⽌，这意味着CPU可以通过设置某些标志位或寄存器来忽略或延迟响应某些中断信号。这样可以避免中断过于频繁或⼲扰重要的任务。<br>  异常不能被屏蔽或禁⽌，这意味着CPU必须⽴即响应异常信号，并进⾏相应的处理。这样可以保证程序的正确性和系统的稳定性。</li>
</ul>
</li>
<li><p>介绍⼀下⼏种典型的锁</p>
<ul>
<li>两个基础的锁：<br>  互斥锁：互斥锁是⼀种最常⻅的锁类型，⽤于实现互斥访问共享资源。在任何时刻，只有⼀个线程可以持有互斥锁，其他线程必须等待直到锁被释放。这确保了同⼀时间只有⼀个线程能够访问被保护的资源。<br>  ⾃旋锁：⾃旋锁是⼀种基于忙等待的锁，即线程在尝试获取锁时会不断轮询，直到锁被释放。</li>
<li>其他的锁都是基于这两个锁的<br>  读写锁：允许多个线程同时读共享资源，只允许⼀个线程进⾏写操作。分为读（共享）和写（排他）两种状态。<br>  悲观锁：认为多线程同时修改共享资源的概率⽐较⾼，所以访问共享资源时候要上锁<br>  乐观锁：先不管，修改了共享资源再说，如果出现同时修改的情况，再放弃本次操作。</li>
</ul>
</li>
<li><p>你知道的线程同步的⽅式有哪些？<br>  线程同步机制是指在多线程编程中，为了保证线程之间的互不⼲扰，⽽采⽤的⼀种机制。常⻅的线程同步机制有以下⼏种：</p>
<ol>
<li>互斥锁：互斥锁是最常⻅的线程同步机制。它允许只有⼀个线程同时访问被保护的临界区（共享资源）</li>
<li>条件变量：条件变量⽤于线程间通信，允许⼀个线程等待某个条件满⾜，⽽其他线程可以发出信号通知等待线程。通常与互斥锁⼀起使⽤。</li>
<li>读写锁： 读写锁允许多个线程同时读取共享资源，但只允许⼀个线程写⼊资源。</li>
<li>信号量：⽤于控制多个线程对共享资源进⾏访问的⼯具</li>
</ol>
</li>
<li><p>什么是内存分段和分⻚？作⽤是什么？</p>
<ul>
<li>内存分段是将⼀个程序的内存空间分为不同的逻辑段 segments ，每个段代表程序的⼀个功能模块或数据类型，如代码段、数据段、堆栈段等。每个段都有其⾃⼰的⼤⼩和权限。</li>
<li>内存分⻚是把整个虚拟和物理内存空间分成固定⼤⼩的⻚(如4KB)。这样⼀个连续并且尺⼨固定的内存空间，我们叫⻚ Page</li>
<li>作⽤：<ol>
<li>逻辑隔离： 内存分段和分⻚都实现了程序的逻辑隔离，使不同的功能模块或数据类型能够被单独管理和保护，提⾼了程序的可靠性和安全性。</li>
<li>内存保护： 通过将不同的段或⻚⾯设置为只读、可读写、不可执⾏等权限，操作系统可以确保程序不会越界访问或修改其他段的内容，从⽽提⾼了系统的稳定性。</li>
<li>虚拟内存： 分段和分⻚都有助于实现虚拟内存的概念，允许应⽤程序认为它们在使⽤的是⼀个⽐实际物理内存更⼤的内存空间。</li>
<li>内存共享： 通过分⻚，操作系统可以实现内存⻚⾯的共享，从⽽节省内存空间，多个进程可以共享相同的代码或数据⻚⾯。</li>
<li>内存管理： 分⻚更加灵活，允许操作系统将不同进程的⻚⾯分散存放在物理内存中，从⽽提⾼内存利⽤率。分段则更适⽤于管理不同的逻辑模块。</li>
</ol>
</li>
<li>分段与分⻚的区别<br>  分⻚对⽤户不可⻅，分段对⽤户可⻅<br>  分⻚的地址空间是⼀维的，分段的地址空间是⼆维的<br>  分⻚（单级⻚表）、分段访问⼀个逻辑地址都需要两次访存，分段存储中可以引⼊快表机制<br>  分段更容易实现信息的共享和保护（纯代码或可重⼊代码可以共享）</li>
<li>分段与分⻚优缺点：<br>  分⻚管理： 内存空间利⽤率⾼，不会产⽣外部碎⽚，只会有少量的⻚内碎⽚。但是不⽅便按照逻辑模块实现信息的共享和保护 。<br>  分段管理： 很⽅便按照逻辑模块实现信息的共享和保护。但是如果段⻓过⼤，为其分配很⼤的连续空间会很不⽅便，段式管理会产⽣外部碎⽚</li>
</ul>
</li>
<li><p>解释⼀下⻚⾯置换算法，例如LRU（最近最少使⽤）、FIFO（先进先出）等</p>
<ul>
<li>假设你的⼿机内存有限，只能同时运⾏四个原神的⻆⾊。当你想切换到⼀个新的⻆⾊时，你需要从内存中换出⼀个旧的⻆⾊，以便为新的⻆⾊腾出空间。不同的⻚⾯置换算法就相当于不同的切换策略，例如：<br>  LRU（最近最少使⽤）算法：每次选择最⻓时间没有被使⽤的⻆⾊进⾏切换。这种策略基于你对⻆⾊的喜好，认为最近被使⽤过的⻆⾊很可能还会被使⽤，⽽最久未被使⽤的⻆⾊很可能不会再 被使⽤。 LRU算法可以有效地减少切换次数，但是实现起来⽐较复杂，需要记录每个⻆⾊的使⽤时间或者维护⼀个使⽤顺序的列表。<br>  FIFO（先进先出）算法：每次选择最早进⼊内存的⻆⾊进⾏切换。这种策略很简单，只需要维护⼀个⻆⾊队列，每次淘汰队⾸的⻆⾊，然后把新的⻆⾊加⼊队尾。但是FIFO算法可能会淘汰⼀些经常被使⽤的⻆⾊，导致切换次数增加。⽽且FIFO算法有可能出现⻉拉迪异常（Belady anomaly），即当分配给内存的空间增加时，切换次数反⽽增加</li>
<li>常⻅⻚⾯置换算法有最佳置换算法（OPT）、先进先出（FIFO）、最近最久未使⽤算法（LRU）、时钟算法（Clock）<ol>
<li>最佳置换算法: 该算法根据未来的⻚⾯访问情况，选择最⻓时间内不会被访问到的⻚⾯进⾏置换。那么就有⼀个问题了，未来要访问什么⻚⾯，操作系统怎么知道的呢?操作系统当然不会知道，所以这种算法只是⼀种理想情况下的置换算法，通常是⽆法实现的。</li>
<li>先进先出算法：也就是最先进⼊内存的⻚⾯最先被置换出去。这个算法⽐较简单明了，就不过多        解释了。但是先进先出算法会存在⼀个问题，就是Belady问题，即随着分配给进程的空闲⻚⾯数        增加，缺⻚的情次反⽽也会增加。 这和我们常识是相悖的，因为我们通常认为如果⼀个进程经常        发⽣缺⻚，那么就应该应该为他多分配⼀点内存。然⽽使⽤FIFO算法时，反⽽可能导致更多缺⻚        情况出现。这就是Belady问题，Belady问题只会在使⽤FIFO算法时出现。</li>
<li>最近最久未使⽤算法：LRU算法基于⻚⾯的使⽤历史，通过选择最⻓时间未被使⽤的⻚⾯进⾏置        换。LRU算法的核⼼思想是，最近被访问的⻚⾯可能在未来被再次访问，⽽最⻓时间未被访问的        ⻚⾯可能是最不常⽤的，因此将其置换出去可以腾出空间给新的⻚⾯。LRU算法通常是使⽤⼀个        数据结构去维护⻚⾯的使⽤历史，维护使⽤历史就是通过访问字段实现的。访问字段的位数和操        作系统分配给该进程的⻚⾯数有关，⽐如分配4个⻚⾯，访问字段就是2位，16个⻚⾯，访问字段        就是4位，依次类推。如此，每⼀个⻚⾯的访问字段都可以不同，通过访问字段的不同，我们就        可以判断⻚⾯的使⽤历史。</li>
<li>时钟算法：Clock算法基于⼀个环形链表或者循环队列数据结构来管理⻚⾯的访问情况，⽤于选        择被置换的⻚⾯。Clock算法的核⼼思想是通过使⽤⼀个指针(称为时钟指针)在环形链表上遍历，        检查⻚⾯是否被访问过。这个访问过同样需要我们上⾯说到的访问字段来表示，此时访问字段只        有⼀位。每个⻚⾯都与⼀个访问位相关联，标记该⻚⾯是否被访问过。        当需要进⾏⻚⾯置换时，Clock算法从时钟指针的位置开始遍历环形链表。 如果当前⻚⾯的访问        位为0，表示该⻚⾯最久未被访问，可以选择进⾏置换。将访问位设置为1，继续遍历下⼀个⻚        ⾯。 如果当前⻚⾯的访问位为1，表示该⻚⾯最近被访问过，它仍然处于活跃状态。将访问位设        置为0，并继续遍历下⼀个⻚⾯如果遍历过程中找到⼀个访问位为0的⻚⾯，那么选择该⻚⾯进⾏        置换。</li>
</ol>
</li>
</ul>
</li>
<li><p>CPU 飙高系统反应慢怎么排查？<br>CPU 是整个电脑的核心计算资源，对于一个应用进程来说，CPU 的最小执行单元是线程。导致 CPU 飙高的原因有几个方面：<br>1、CPU 上下文切换过多，对于 CPU 来说，同一时刻下每个 CPU 核心只能运行一个线程，如果有多个线程要执行，CPU 只能通过上下文切换的方式来执行不同的线程。较多的上下文切换会占据大量 CPU 资源，从而使得 cpu 无法去执行用户进程中的指令，导致响应速度下降。在 Java 中，文件 IO、网络 IO、锁等待、线程阻塞等操作都会造成线程阻塞从而触发上下文切换<br>2、CPU 资源过度消耗，也就是在程序中创建了大量的线程，或者有线程一直占用CPU 资源无法被释放，比如死循环！CPU 利用率过高之后，导致应用中的线程无法获得 CPU 的调度，从而影响程序的执行效率<br>3、既然是这两个问题导致的 CPU 利用率较高，于是我们可以通过 top 命令，找到 CPU利用率较高的进程，再通过 Shift+H 找到进程中 CPU 消耗过高的线程，有两种情况：<br>CPU 利用率过高的线程一直是同一个，说明程序中存在线程长期占用 CPU 没有释放的情况，这种情况直接通过jstack 获得线程的 Dump 日志，定位到线程日志后就可以找到问题的代码。<br>CPU 利用率过高的线程 id 不断变化，说明线程创建过多，需要挑选几个线程id通过 jstack 去线程 dump 日志中排查。<br>4、最后有可能定位的结果是程序正常，只是在 CPU 飙高的那一刻，用户访问量较大，导致系统资源不够。</p>
</li>
</ul>
<hr>

<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><ul>
<li><p>分布式、SOA、微服务之间有什么关系和区别?<br>1，分布式架构是指将单体架构中的各个部分拆分，然后部署不同的机器或进程中去，SOA和微服务都是分布式架构的<br>2，SOA 是一种面向服务的架构，系统的所有服务都注册在总线上，当调用服务时，从总线上查找服务信息，然后调用<br>3，微服务是一种更彻底的面向服务的架构，将系统中各个功能个体抽成一个个小的应用程序，基本保持一个应用对应的一个服务的架构</p>
</li>
<li><p>微服务架构？<br>微服务是一种软件开发架构风格，用于构建复杂应用程序。它将大型应用程序拆分成一系列较小、独立的服务，每个服务专注于完成特定的业务功能。这些服务之间通过轻量级的通信机制（通常是基于 HTTP 或 RPC）进行交互，可以独立部署、扩展和管理。</p>
</li>
<li><p>微服务的主要特点包括：</p>
<ul>
<li>单一责任：每个微服务专注于执行一个明确定义的业务功能。这使得开发人员可以更容易地理解和维护服务。</li>
<li>松耦合：微服务之间是独立的，它们可以使用不同的编程语言、技术堆栈和数据存储。这种松耦合使得开发团队能够独立地开发、测试和部署各个服务。</li>
<li>独立部署：每个微服务都可以独立地部署，这意味着当对一个服务进行更改时，不需要重新部署整个应用程序。这提高了开发和发布的速度，并允许快速迭代和灵活性。</li>
<li>弹性扩展：由于每个微服务是独立的，可以根据需要对它们进行独立的扩展。这使得应用程序能够更好地处理高负载情况，并具有更好的可伸缩性。</li>
<li>有限上下文：每个微服务维护自己的数据存储，这意味着它们可以使用不同类型的数据库或存储技术。这种隔离有助于减少整个系统的复杂性，并提高可靠性。</li>
</ul>
</li>
<li><p>微服务架构也存在一些挑战和缺点：</p>
<ul>
<li>分布式系统复杂性：微服务架构中的服务是分布式的，需要处理服务间通信、数据一致性、错误处理等问题。这增加了系统的复杂性，需要更多的设计和管理工作。</li>
<li>服务间通信开销：由于微服务架构中的服务通过网络通信进行交互，会增加一定的延迟和开销。此外，需要实现适当的通信机制和协议来确保可靠性和数据一致性。</li>
<li>运维复杂性：微服务架构中涉及多个独立的服务，每个服务都需要独立进行监控、日志记录和故障排除。这增加了运维的复杂性，需要适当的工具和自动化来管理和监控服务。</li>
<li>数据一致性：由于每个微服务维护自己的数据存储，确保数据一致性变得更加困难。在跨多个服务的业务操作中，需要采取适当的策略和技术来保证数据的一致性和完整性。</li>
</ul>
</li>
<li><p>CAP？</p>
<ul>
<li>CAP 理论指出，在分布式系统中，无法同时满足三个核心属性：一致性（Consistency）、可用性（Availability）和分区容忍性（Partition Tolerance），只能选择其中的两个。<ul>
<li><strong>一致性</strong>：在分布式系统中的所有节点上，对于某个操作的结果应该是一致的。换句话说，当一个节点执行了更新操作后，其他节点应该能够读取到更新后的值。这意味着所有节点在同一时间看到的数据都是相同的。</li>
<li><strong>可用性</strong>：系统在面对用户请求时，应该保证能够进行响应，即系统保持可用状态。即使部分节点发生故障，系统仍然能够继续提供服务。</li>
<li><strong>分区容忍性</strong>：系统能够在面对网络分区或者节点之间通信失败的情况下，仍然能够继续运行。即使系统中的某些节点之间无法进行通信，整个系统仍然可以继续工作。</li>
</ul>
</li>
</ul>
</li>
<li><p>Dubbo的架构设计是怎样的?<br>Dubbo 中的架构设计是非常优秀的，分为了很多层次，并且每层都是可以扩展的，比如:<br>1.Proxy服务代理层，支持JDK动态代理、javassist等代理机制<br>2.Registry注册中心层，支持Zookeeper、Redis等作为注册中心<br>3.Protocol远程调用层，支持Dubbo、Http等调用协议<br>4.Transport网络传输层，支持netty、mina等网络传输框架<br>5，Serialize数据序列化层，支持JSON、Hessian等序列化机制</p>
</li>
<li><p>Dubbo 与 Spring Cloud 的区别。<br>Dubbo 是 SOA 时代的产物，它的关注点主要在于服务的调用，流量分发、流量监控和熔断。而 Spring Cloud 诞生于微服务架构时代，考虑的是微服务治理的方方面面，另外由于依托了 Spirng、Spirng Boot 的优势之上，两个框架在开始目标就不一致，Dubbo 定位服务治理、Spirng Cloud 是一个生态。<br>两者最大的区别是 Dubbo 底层是使用 Netty 这样的 NIO 框架，是基于 TCP 协议传输的，配合以 Hession 序列化完成 RPC 通信。而 SpringCloud 是基于 Http 协议+Rest 接口调用远程过程的通信，相对来说，Http 请求会有更大的报文，占的带宽也会更多。但是 REST 相比 RPC 更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖。</p>
</li>
<li><p>关于“你对 Spring Cloud 的理解”<br>Spring Cloud 是一套分布式微服务的技术解决方案，它提供了快速构建分布式系统的常用的一些组件比如说配置管理、服务的注册与发现、服务调用的负载均衡、资源隔离、熔断降级等等；不过 Spring Cloud 只是 Spring 官方提供的一套微服务标准定义，而真正的实现目前有两套体系用的比较多。<br>Spring Cloud Alibaba 是基于阿里巴巴开源组件集成的一套微服务解决方案，包括：1. Dubbo————消息通讯 2. Nacos————服务注册与发现 3.Seata————事务隔离 4. Sentinel————熔断降级<br>有了 Spring Cloud 这样的技术生态，使得我们在落地微服务架构时。不用去考虑第三方技术集成带来额外成本，只要通过配置组件来完成架构下的技术问题，从而可以让我们更加侧重性能方面</p>
</li>
<li><p>弄懂 RPC。<br>  常见的远程通信方式，有基于 REST 架构的 HTTP 协议、以及 RPC 框架。</p>
<ol>
<li>什么是远程调用<br>  远程调用是指跨进程的功能调用，跨进程可以理解成一个计算机节点的多个进程，或者多个计算机节点的多个进程</li>
<li>什么是 RPC<br>  全称为 Remote Procedure Call，翻译过来就是远程过程调用，它是一种通过网络从远程计算机程机程序上请求服务，而不需要了解底层网络技术的协议，凡是符合该协议的框架，我们都可以称它为 RPC 框架。关于 RPC 协议，通俗来讲就是，A 计算机提供一个服务，B 计算机可以像调用本地服务那样调用 A 计算机的服务。要实现 RPC，需要通过网络传输数据，并对调用的过程进行封装。现在比较流行的 RPC 框架，都会采用 TCP 作为底层传输协议。RPC 强调的是过程调用，调用的过程对用户而言是是透明的，用户不需要关心调用的细节，可以像调用本地服务一样调用远程服务。</li>
<li>RPC 的运用场景和优势<br>  分布式架构的核心，就是利用多个普通计算机节点，组成一个庞大而复杂的计算网络，提供高性能以及高并发的能力支撑。在分布式架构中，原本的单体应用被拆分成多个独立部署的服务分部在计算机网络上，这些服务必然需要通过网络进行数据交互。而 RPC 框架就是解决在分布式架构中的各个业务服务彼此的网络通信问题。<br>  一般来说，RPC 服务主要是针对大型的企业，也就说当我们业务复杂度以及用户量都比较高时，需要解耦服务，扩展性强、部署灵活一般市面上开源的 PRC 框架，除了提供基础的远程通信功能以外，还会在性能消耗、传输效率、服务治理等方面做很多的设计，比如阿里开源的 RPC 框架 Dubbo。</li>
</ol>
</li>
<li><p>负载均衡的实现算法</p>
<ul>
<li>负载均衡是指将网络流量或工作负载分配到多个服务器或计算资源上，以提高系统的性能、可靠性和可扩展性。在实现负载均衡时，通常会采用以下算法：<ul>
<li>轮询（Round Robin）：按照轮询的方式依次将请求分发给后端服务器。每个请求按照顺序依次分配给不同的服务器，循环往复。这种算法简单且均衡，适用于服务器性能相似且无状态的情况。</li>
<li>最少连接（Least Connection）：根据当前连接数选择连接数最少的服务器来处理新的请求。这种算法可以有效地将负载均衡到连接数较少的服务器上，以保持各服务器的负载相对均衡。</li>
<li>IP哈希（IP Hash）：根据客户端的 IP 地址进行哈希计算，将同一个 IP 地址的请求发送到同一个后端服务器。这样可以确保同一个客户端的请求都发送到同一台服务器上，适用于需要保持会话一致性的场景。<br>  加权轮询（Weighted Round Robin）：给每个服务器分配一个权重值，根据权重值的比例来分配请求。具有较高权重的服务器会接收到更多的请求，适用于服务器性能不均衡的情况。</li>
<li>加权最少连接（Weighted Least Connection）：根据服务器的当前连接数和权重值来选择服务器。连接数越少且权重值越高的服务器会被优先选择。</li>
<li>随机（Random）：随机选择一个后端服务器来处理请求。这种算法简单且均衡，但无法保证每个服务器的负载一致。</li>
<li>响应时间加权（Response Time Weighted）：根据服务器的平均响应时间或处理时间来分配请求。响应时间较短的服务器会得到更多的请求，以提高系统整体的响应速度。</li>
</ul>
</li>
</ul>
</li>
<li><p>分布式事务的原理<br>分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于分布式系统的不同节点之上。比如大型的电商系统中的下单场景，会涉及到扣库存、优惠促销计算、订单 ID 生成。通常情况下，库存、促销、主键生成策略都位于不同的服务器和数据库表中。下单接口的成功与否，不仅取决于本地节点的数据库操作，而且还依赖第三方系统的结果，这时候分候分布式事务就保证这些操作要么全部成功，要么全部失败。<br>因此，本质上来说，分布式事务就是为了保证不同数据库的数据一致性。基于 CAP 定理可以知道，对于上述情况产生的分布式事务问题，我们要么采用强一致性方案、要么采用弱一致性方案。<br>？？</p>
</li>
<li><p>实现分布式锁的解决方案中，你认为 Zookeeper和 Redis 哪种更好？<br>两种方案都有各自的优缺点：<br>对于 redis 的分布式锁而言，它有以下缺点： 它获取锁的方式简单粗暴，如果获取不到锁，会不断尝试获取锁，比较消耗性能。 Redis 是 AP 模型，在集群模式中由于数据的一致性会导致锁出现问题，即便使用Redlock 算法来实现，在某些复杂场景下，也无法保证其实现 100%的可靠性。不过在实际开发中使用 Redis 实现分布式锁还是比较常见，而且大部分场情况下不会遇到”极端复杂的场景“，更重要的是 Redis 性能很高，在高并发场景中比较合适。<br>对于 zk 分布式锁而言:  zookeeper 天生设计定位就是分布式协调，强一致性。锁的模型健壮、简单易用、适合做分布式锁。 如果获取不到锁，只需要添加一个监听器就可以了，不用一直轮询，性能消耗较小。如果要在两者之间做选择，就我个人而言的话，比较推崇 ZK 实现的锁，因为对于分布式锁而言，它应该符合 CP 模型，但是 Redis 是 AP 模型，所以在这个点上，Zookeeper会更加合适。</p>
</li>
<li><p>什么是Docker？有什么优势？<br>？</p>
</li>
<li><p>Docker 核心组件。</p>
</li>
<li><p>什么是 Kubernetes？<br>近些年，随着 Docker 与微服务的普及，K8s 也乘着这两股东风，迅速蹿红起来。作为最火的容器编排工具之一，它的很多思想设计都契合了微服务和云原生应用的设计法则。也正因如此，越来越多的公司开始使用起 k8s。K8s 全称 Kubernetes，8 是中间 8 个字母的简称。作为一种容器自动部署、扩容以及管理的技术，我们可以简单理解其是一种容器编排技术。前身是 Borg 系统，在谷歌内部已经有了十多年的使用经验。<br>，、、</p>
</li>
<li><p>负载均衡的诞生背景<br>在互联网发展早期，由于用户量较少、业务需求也比较简单。对于软件应用，我们只需要一台高配的服务器即可完成业务的支撑，这样的软件架构称为单体架构<br>随着用户量的增加，服务器的请流量也随之增加，在这个过程中单体架构会产生两个问题。<br>1.软件的性能逐步下降，访问延迟越来越高<br>2.容易出现单点故障<br>为了解决这个问题，我们引入了集群化部署的架构，也就是把一个软件应用同时部署在多个服务器上。引入了负载均衡的设计，简单来说，负载均衡机制的核心目的是让客户端的请求合理均匀的分发到多台目标服务器，由于请求被多个节点分发，使得服务端的性能得到有效的提升。</p>
</li>
<li><p>如何实现负载均衡呢？<br>1、基于 DNS 实现负载均衡：实现方式比较简单，只需要在 DNS服务器上针对某个域名做多个 IP 映射即可。<br>2、基于硬件实现负载均衡<br>3、基于软件实现负载均衡</p>
</li>
<li><p>负载均衡的常用算法<br>所谓负载均衡算法，就是决定当前客户端请求匹配到目标服务器集群中的具体哪个节点。常见的负载均衡算法有：<br>1、轮训，也就是多个服务器按照顺序轮训返回，这样每个服务器都能获得相同的请求次数<br>2、随机，根据随机算法获得一个目标服务地址，由于该算法具备随机性，因此每个服务器获得的请求数量不一定均等。<br>3、一致性 hash，也就是对于具有相同 hash 码的请求，永远发送到同一个节点上。<br>4、最小连接数，根据目标服务器的请求数量来决定请求分发的权重，也就是目标服务集群中，请求更少的节点将会获得更多的请求。这是负载均衡中比较好的策略，真正能够实现目标服务器的请求均衡。</p>
</li>
</ul>
<hr>

<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><ul>
<li><p>绝对路径用什么符号表示？当前目录、上层目录用什么表示？主目录用什么表示? 切换目录用什么命令？<br>绝对路径： 如&#x2F;etc&#x2F;init.d<br>当前目录和上层目录： .&#x2F; ..&#x2F;<br>主目录： ~&#x2F;<br>切换目录： cd</p>
</li>
<li><p>Linux 下命令有哪几种可使用的通配符？分别代表什么含义?</p>
<ul>
<li>“?” 可替代单个字符。例如，file?.txt 可以匹配 file1.txt、fileA.txt 等。</li>
<li>“*” 可替代任意多个字符。例如，<code>*.txt</code> 可以匹配所有以 .txt 结尾的文件。</li>
<li>方括号 “[charset]” 可替代 charset 集中 的任何单个字符，例如 file[123].txt 可以匹配 file1.txt、file2.txt、file3.txt。</li>
<li><code>[a-zA-Z]+:[ ]+[0-9]*</code> 代表：匹配一个或多个字母（大小写不敏感）、冒号、至少一个空格，然后是零个或多个数字。<br>  例子：<code>Example: 123</code>、<code>abc:   </code>。</li>
</ul>
</li>
<li><p>正则表达式<br>\s+ 表示一个或多个空格；<br>\w：表示匹配任意字母、数字或下划线字符（即单词字符），等价于 <code>[a-zA-Z0-9_]</code>；<br>&#x2F;a?&#x2F;：表示字符 <code>a</code> 可以出现 0 次或 1 次，匹配空字符串或者单个字母 <code>a</code>；<br>i.：匹配一个字符 <code>i</code> 后面紧跟着任意字符。</p>
</li>
<li><p>常用 linux 命令。<br>执行退出： exit<br>列出文件列表：ls[参数] -a 所有文件; -l 详细信息，包括大小字节数，可读可写可执行的权限等<br>用于显示文件后几行内容：tail，例如： tail -n 1000：显示最后1000行<br>打包：tar -xvf；打包并压缩：tar -zcvf<br>查找字符串：grep<br>显示当前所在目录：pwd<br>创建空文件：touch<br>编辑器：vim vi<br>查看用过的命令列表：history</p>
</li>
<li><p>目录命令。<br>创建目录：mkdir<br>移除目录：rmdir<br>创建父目录的示例：mkdir -p<br>创建带权限的目录：mkdir -m </p>
</li>
<li><p>目录、文件命令。<br>创建文件：典型的如 touch，vi 也可以创建文件，其实只要向一个不存在的文件输出，都会创建文件<br>复制文件： cp<br>移动文件，改名：mv<br>删除文件，空文件夹：rm rmdir<br>列出当前系统上已打开的文件（包括目录、文件、网络连接等）的相关信息：lsof 的名字是 “List Open Files” 的缩写。</p>
</li>
<li><p>搜索文件用什么命令? 格式是怎么样的?<br>find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定动作&gt;<br>whereis 加参数与文件名<br>locate 只加文件名<br>find 直接搜索磁盘，较慢。<br>find &#x2F; -name “string*”</p>
</li>
<li><p>查看文件的命令。</p>
<ul>
<li>vi 文件名 #编辑方式查看，可修改</li>
<li>cat 文件名 #显示全部文件内容</li>
<li>more 文件名 #分页显示文件内容</li>
<li>less 文件名 #与 more 相似，更好的是可以往前翻页  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">less log2013.log <span class="comment"># 查看文件</span></span><br><span class="line">ps -ef | less <span class="comment"># ps查看进程信息并通过less分页显示</span></span><br><span class="line"><span class="built_in">history</span> | less <span class="comment"># 查看命令历史使用记录并通过less分页显示</span></span><br><span class="line">less log2013.log log2014.log <span class="comment"># 浏览多个文件</span></span><br></pre></td></tr></table></figure></li>
<li>tail 文件名 #仅查看尾部，还可以指定行数  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -n 10 test.log <span class="comment"># 查询日志尾部最后10行的日志;</span></span><br><span class="line"><span class="built_in">tail</span> -n +10 test.log <span class="comment"># 查询10行之后的所有日志;</span></span><br><span class="line"><span class="built_in">tail</span> -fn 10 test.log <span class="comment"># 循环实时查看最后1000行记录(最常用的)</span></span><br><span class="line"><span class="comment"># 一般还会配合着grep搜索用，例如 : </span></span><br><span class="line"><span class="built_in">tail</span> -fn 1000 test.log | grep <span class="string">&#x27;关键字&#x27;</span></span><br><span class="line"><span class="comment"># 如果一次性查询的数据量太大,可以进行翻页查看，例如 ：</span></span><br><span class="line"><span class="built_in">tail</span> -n 4700 aa.log |more -1000 可以进行多屏显示 (ctrl + f 或者 空格键可以快捷键）</span><br></pre></td></tr></table></figure></li>
<li>head 文件名 #仅查看头部,还可以指定行数  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> -n 10 test.log 查询日志文件中的头10行日志;</span><br><span class="line"><span class="built_in">head</span> -n -10 test.log 查询日志文件除了最后10行的其他所有日志;</span><br></pre></td></tr></table></figure></li>
<li>sed 这个命令可以查找日志文件特定的一段 , 根据时间的一个范围查询，可以按照行号和时间范围查询按照行号  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">&#x27;5,10p&#x27;</span> filename <span class="comment"># 这样你就可以只查看文件的第5行到第10行。</span></span><br><span class="line">sed -n <span class="string">&#x27;/2014-12-17 16:17:20/,/2014-12-17 16:17:36/p&#x27;</span> test.log <span class="comment"># 按照时间段</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>查看日志的方法</p>
<ol>
<li>查看系统日志、登录日志、应用程序日志：使用 <code>cat</code> 或 <code>less</code> 命令  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /var/log/syslog</span><br></pre></td></tr></table></figure></li>
<li>使用 <code>dmesg</code> 查看内核日志</li>
<li>使用 <code>journalctl</code> 查看 Systemd 日志</li>
</ol>
</li>
<li><p>查看进程线程的方法</p>
<ul>
<li>windows<br>  任务管理器可以查看进程和线程数，也可以用来杀死进程<br>  tasklist 查看进程<br>  taskkill 杀死进程</li>
<li>linux<br>  ps -fe 查看所有进程<br>  ps -fT -p &lt; PID&gt; 查看某个进程（PID）的所有线程<br>  kill 杀死进程<br>  top 按大写 H 切换是否显示线程<br>  top -H -p &lt; PID&gt; 查看某个进程（PID）的所有线程</li>
<li>Java<br>  jps 命令查看所有  Java 进程<br>  jstack &lt; PID&gt; 查看某个  Java 进程（PID）的所有线程状态<br>  jconsole 来查看某个  Java 进程中线程的运行情况（图形界面）</li>
</ul>
</li>
<li><p>Linux 中进程有哪几种状态？在 ps 显示出来的信息中分别用什么符号表示的？<br>1、不可中断状态：进程处于睡眠状态，但是此刻进程是不可中断的。不可中断，指进程不响应异步信号。<br>2、暂停状态&#x2F;跟踪状态：向进程发送一个 SIGSTOP 信号，它就会因响应该信号 而进入 TATASK_STOPPED 状态;当进程正在被跟踪时，它处于 TATASK_TRACED 这个特殊的状态。正被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。<br>3、就绪状态：在 run_queue 队列里的状态<br>4、运行状态：在 run_queue 队列里的状态<br>5、可中断睡眠状态：处于这个状态的进程因为等待某某事件的发生（比如等待socket 连接、等待信号量），而被挂起<br>6、zombie 状态（僵尸）：父亲没有通过 wait 系列的系统调用会顺便将子进程的尸体（task_struct）也释放掉<br>7、退出状态<br>D 不可中断 Uninterruptible（usually IO）、R 正在运行，或在队列中的进程、S 处于休眠状态、T 停止或被追踪、Z 僵尸进程、W 进入内存交换（从内核 2.6 开始无效）、X 死掉的进程</p>
</li>
<li><p>使用什么命令查看网络是否连通?使用什么命令查看 ip 地址及接口信息？<br>natstat，ifconfig</p>
</li>
<li><p>文件的权限可以用一串字符表示，其中”-rwxrw-rw-“是一个典型的例子。<br>  每个权限字符串由10个字符组成，分为四个部分：<br>  1、<strong>文件类型：</strong> 第一个字符表示文件的类型。包括：<code>-</code>：普通文件。<code>d</code>：目录。<code>l</code>：符号链接（软链接）<br>  2、<strong>用户权限：</strong> 接下来的三个字符表示文件所有者的权限。 <code>r</code>：读权限（Read） <code>w</code>：写权限（Write） <code>x</code>：执行权限（eXecute）<br>  3、<strong>组权限：</strong> 再接下来的三个字符表示文件所属组的权限。<br>  4、<strong>其他用户权限：</strong> 最后的三个字符表示其他用户的权限。<br>  在给定的例子”-rwxrw-rw-“中：文件类型是普通文件，文件所有者有读、写和执行权限，文件所属组有读和写权限，其他用户有读和写权限。</p>
</li>
<li><p>文件唯一标识符（File Identifier）<br>通常是通过文件的<code>inode</code>来实现的，而不是文件目录。<br><code>inode</code>是文件系统中用于唯一标识文件或目录的数据结构。每个文件或目录都有一个唯一的<code>inode</code>号码，它是一个整数值。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/10/11/%E9%9D%A2%E8%AF%95_%E7%BB%84%E4%BB%B6/" data-id="clzzl7c2i000wu0v5g0pj7urw" data-title="面 逝 | 组件" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Docker" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/31/Docker/" class="article-date">
  <time class="dt-published" datetime="2023-07-31T02:25:07.000Z" itemprop="datePublished">2023-07-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/31/Docker/">Docker</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Docker 是一种开源平台，一种快速构建、运行和管理应用的工具。它使用容器化技术，使得应用程序及其依赖性可以打包到一个容器中，并在任何支持 Docker 的环境中运行。<br><a target="_blank" rel="noopener" href="https://leo710aka.github.io/2022/03/06/SSH/"><strong>MobarXterm 通过 SSH 连接 linux虚拟机，操作虚拟机上的 Docker。</strong></a><br><img src="https://github.com/leo710aka/bk/blob/main/docker.png?raw=true"></p>
<h3 id="容器（Container）"><a href="#容器（Container）" class="headerlink" title="容器（Container）"></a><strong>容器（Container）</strong></h3><ul>
<li>容器是一个轻量级的、可移植的、自包含的单元，包括应用程序和其所有依赖项。</li>
<li>Docker 利用容器技术，将应用程序及其依赖项打包成一个容器，确保在不同环境中的一致性运行。</li>
<li><strong>Docker 位于容器 和 服务器-操作系统&#x2F;硬件 之间，是运行容器的引擎。</strong></li>
<li>隔离网络、文件、进程等环境。一个容器是一个沙盒隔离环境。</li>
<li>相对于虚拟机技术，docker 启动更快、更清量。但容器共用宿主机的内存、CPU物理资源，多容器可能存在互相抢占资源的情况。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \                  <span class="comment"># 创建并运行一个容器，-d 是让容器在后台运行；同一个镜像可创建多个容器</span></span><br><span class="line">   --name mysgl \                <span class="comment"># 给容器起名字，必须唯一</span></span><br><span class="line">   -p 3306:3306 \                <span class="comment"># 设置 宿主机端口：容器端口 映射</span></span><br><span class="line">   -e TZ=Asia/Shanghai \         <span class="comment"># 设置环境变量</span></span><br><span class="line">   -e MYSQL_ROOT_PASSWORD=123 \  <span class="comment"># 指定运行的镜像名，一般为 [镜像名]:[镜像版本]</span></span><br><span class="line">   mysql</span><br><span class="line">docker ps                        <span class="comment"># 查看本地容器（运行中的）</span></span><br><span class="line">docker ps a                      <span class="comment"># 查看所有容器 (包括未运行)</span></span><br><span class="line">docker start &lt;容器ID&gt;          <span class="comment"># 启动容器</span></span><br><span class="line">docker stop  &lt;容器ID&gt;          <span class="comment"># 停止容器中的进程，容器未删除</span></span><br><span class="line">docker <span class="built_in">rm</span> &lt;容器ID&gt;             <span class="comment"># 删除容器</span></span><br><span class="line">docker inspect &lt;容器ID&gt;        <span class="comment"># 查看容器配置信息 </span></span><br><span class="line">docker <span class="built_in">log</span> &lt;容器ID&gt;            <span class="comment"># 查看容器日志 </span></span><br><span class="line">docker <span class="built_in">exec</span> -it &lt;容器ID&gt; bash  <span class="comment"># 进入容器内部，命令行模式（容器内部模拟出一个操作系统）</span></span><br><span class="line">容器打包成镜像: docker commit -a <span class="string">&quot;作者信息&quot;</span> -m <span class="string">&quot;log信息&quot;</span> &lt;容器ID&gt;&lt;目标镜像名称:tag版本&gt; </span><br><span class="line">拷贝文件到容器: docker <span class="built_in">cp</span> &lt;文件目录&gt; &lt;容器ID&gt;:&lt;目标目录&gt;</span><br><span class="line">拷贝容器文件到宿主机:docker <span class="built_in">cp</span> &lt;容器ID&gt;:&lt;文件目录&gt;&lt;宿主机目标目录&gt;</span><br><span class="line">更新容器设置:docker update &lt;容器ID&gt;&lt;相关设置&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="镜像（Image）"><a href="#镜像（Image）" class="headerlink" title="镜像（Image）"></a><strong>镜像（Image）</strong></h3><ul>
<li>镜像是一个只读的模板，包含运行应用程序所需的所有信息，包括代码、运行时、库、环境变量和配置文件。</li>
<li><strong>容器是通过运行镜像创建的（像光盘），本地容器是真正运行的实例。镜像是容器的模板，是从容器打包来的，可以在不同操作系统，不同服务器之间传播。</strong></li>
<li>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker images                                <span class="comment"># 查看本地镜像</span></span><br><span class="line">docker search &lt;名称关键字&gt;                     <span class="comment"># 搜索镜像仓库</span></span><br><span class="line">docker pull &lt;镜像名:tag版本&gt;                   <span class="comment"># 下载镜像</span></span><br><span class="line">docker push &lt;镜像名:tag版本&gt;                   <span class="comment"># 上传镜像</span></span><br><span class="line">docker rmi &lt;镜像名:tag版本&gt;                    <span class="comment"># 删除镜像</span></span><br><span class="line">docker save -o &lt;输出文件路径&gt;&lt;镜像名:tag版本&gt;    <span class="comment"># 打包本地镜像文件</span></span><br><span class="line">docker load -i &lt;加载文件路径                   <span class="comment"># 导入本地镜像文件</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="仓库（Registry）"><a href="#仓库（Registry）" class="headerlink" title="仓库（Registry）"></a><strong>仓库（Registry）</strong></h3><ul>
<li>仓库是存储和组织 Docker 镜像的地方。Docker Hub 是一个常见的公共仓库，你也可以搭建私有仓库。</li>
<li>Docker 镜像可以从仓库中拉取，也可以推送到仓库。</li>
</ul>
<h3 id="沙箱"><a href="#沙箱" class="headerlink" title="沙箱"></a><strong>沙箱</strong></h3><ul>
<li>沙箱是一种安全机制，用于隔离和限制程序或应用程序的运行环境，以防止其对系统或其他程序产生潜在的危害。沙箱技术旨在创建一个受控制的环境，使得运行在其中的代码无法直接影响到系统的其他部分。这种隔离有助于确保安全性、防止恶意软件传播，同时提供一定程度的控制和监控。</li>
<li>容器化平台（如 Docker）使用沙箱技术来隔离容器中的应用程序，确保它们互相独立运行。</li>
</ul>
<h2 id="容器创建"><a href="#容器创建" class="headerlink" title="容器创建"></a><strong>容器创建</strong></h2><p>镜像结构：入口，层，基础镜像。分层的好处是可复用，，</p>
<ul>
<li>通过命令直接创建，需要完整镜像，几个G常有，稳定。</li>
<li>通过<strong>dockerfile</strong>创建，不需要完整镜像，更灵活。<br>Dockerfile 是一个包含构建镜像步骤的文本文件，包含一个个的指令。通过编写 Dockerfile，你可以定义如何构建镜像，包括基础镜像、安装依赖、复制文件等步骤。</li>
<li>使用 Docker 的基本步骤<ol>
<li><strong>安装 Docker：</strong> 根据操作系统的不同，安装适合的 Docker 版本。</li>
<li><strong>创建 Dockerfile：</strong> 编写包含应用程序构建步骤的 Dockerfile。</li>
<li><strong>构建镜像：</strong> 在包含 Dockerfile 的目录中运行 <code>docker build</code> 命令构建镜像。（如java项目还需要jar包）</li>
<li><strong>运行容器：</strong> 使用 <code>docker run</code> 命令基于构建的镜像创建和运行容器。</li>
<li><strong>发布镜像：</strong> 将构建的镜像推送到 Docker 仓库，以便其他人可以拉取使用。</li>
</ol>
</li>
</ul>
<h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><ul>
<li>数据卷(volume)是一个虚拟目录，是容器内目录与宿主机目录之间映射的桥梁（两边文件同时修改）。<br>（容器一般只包括支持运行的最少文件，一般无vi或其他编辑器，所以无法进入容器直接对容器中的文件进行修改）</li>
<li>如何挂载数据卷？在创建容器时，利用-v 数据卷名:容器内目录完成挂载。创建时如果发现挂载的数据卷不存在，会自动创建。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker volumels        <span class="comment"># 查看数据卷</span></span><br><span class="line">docker volume <span class="built_in">rm</span>       <span class="comment"># 删除数据卷</span></span><br><span class="line">docker volume inspect  <span class="comment"># 查看数据卷详情</span></span><br><span class="line">docker volume prune    <span class="comment"># 删除未使用的数据卷</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="容器编排-Orchestration-：运维人员"><a href="#容器编排-Orchestration-：运维人员" class="headerlink" title="容器编排(Orchestration)：运维人员"></a>容器编排(Orchestration)：运维人员</h3><p>容器编排是指在生产环境中管理和协调多个容器的过程。Docker 提供了 Docker Compose 工具，用于定义和运行多容器的应用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/31/Docker/" data-id="clzzl7c280003u0v5b0dp2n5b" data-title="Docker" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Pytorch_Colab" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/10/Pytorch_Colab/" class="article-date">
  <time class="dt-published" datetime="2023-07-10T03:58:39.000Z" itemprop="datePublished">2023-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/10/Pytorch_Colab/">Pytorch / Colab</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>PyTorch是一个开源的Python机器学习库，基于Torch库，底层由C++实现，应用于人工智能领域，如计算机视觉和自然语言处理。它最初由Meta Platforms的人工智能研究团队开发，现在属于Linux基金会的一部分。它是在修改后的BSD许可证下发布的自由及开放源代码软件。</p>
<p>许多深度学习软件都是基于 PyTorch 构建的，包括特斯拉自动驾驶、Uber的Pyro、Hugging Face的Transformers、 PyTorch Lightning。</p>
<h3 id="TensorBoard"><a href="#TensorBoard" class="headerlink" title="TensorBoard"></a>TensorBoard</h3><p>打开localhost:6006，访问TensorBoard，查看TensorFlow模型的图形、损失函数、精度等信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorboardX <span class="keyword">import</span> SummaryWriter</span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;xxx&quot;</span>)               <span class="comment"># 在文件夹里新建一个abc文件夹</span></span><br><span class="line">writer.add_scalar(<span class="string">&quot;y=2i&quot;</span>, <span class="number">2</span>*i, i)           <span class="comment"># 加坐标</span></span><br><span class="line">writer.add_images(<span class="string">&quot;test_data&quot;</span>, imgs, step)  <span class="comment"># 加图</span></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Pycharm -&gt; Terminal</span></span><br><span class="line">PS C:\Users\cf\Documents\Visual Studio Code\Python\learn_pytorch&gt; tensorboard --logdir=<span class="string">&quot;xxx&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="nn-Module"><a href="#nn-Module" class="headerlink" title="nn.Module"></a>nn.Module</h3><p>基本神经网络</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">cf</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__int__</span>(<span class="params">self</span>):   <span class="built_in">super</span>().__init__()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):      <span class="comment"># 必须重写forword()</span></span><br><span class="line">        output = <span class="built_in">input</span> + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>

<p><strong>输入层（Input Layer）：</strong>接受原始图像或数据作为输入。<br><strong>卷积层（Convolutional Layer）：</strong>进行特征提取。通过卷积操作，利用卷积核（或过滤器）从输入图像中提取特定的特征，如边缘、纹理等。卷积核会在整个图像上滑动，产生特征图。<br>卷积核的输入通道数与输入数据的通道数对应，卷积核的输出通道数与卷积核的数量对应。<br>卷积操作在神经网络中扮演着关键的角色，它通过特征提取、参数共享、空间局部性和参数数量控制等方面，使得卷积神经网络成为图像处理和计算机视觉任务中非常有效的工具。<br><strong>池化层（Pooling Layer）</strong>【最大ceil, 最小floor】：降采样和减少参数，避免过拟合。池化操作对特征图进行降采样，减少特征图的尺寸，并保留重要的特征信息。常用的池化方式为最大池化（Max Pooling）和平均池化（Average Pooling）。<br><strong>非线性激活：</strong>线性变换（如全连接层）在神经网络中只能实现线性映射，而现实世界中的数据和任务通常都是非线性的。为了解决这个问题，需要在网络中引入非线性激活函数，以增加网络的表达能力和灵活性。 给网络中引入非线性特征，以训练出符合各种曲线的模型。<br>·ReLU（Rectified Linear Unit）：f(x) &#x3D; max(0, x)，它在x大于0时是线性的，小于等于0时为0，能够有效地解决梯度消失问题。<br>·Sigmoid：f(x) &#x3D; 1 &#x2F; (1 + exp(-x))，它将输入映射到[0, 1]区间，用于二分类问题。<br>·Tanh：f(x) &#x3D; (exp(x) - exp(-x)) &#x2F; (exp(x) + exp(-x))，它将输入映射到[-1, 1]区间，也用于解决梯度消失问题。<br><strong>正则化层（Regularization Layer）：</strong>正则化层用于防止过拟合。过拟合是指模型在训练数据上表现良好，但在未见过的测试数据上表现较差的现象。正则化层通过添加一些额外的约束或惩罚项来控制模型的复杂度，以避免过度拟合。<br>·L1正则化：将参数的绝对值加入到损失函数中，使得模型倾向于产生稀疏的权重矩阵。<br>·L2正则化：将参数的平方加入到损失函数中，限制权重的大小，防止权重过大造成过拟合。<br>·Dropout正则化：随机在训练过程中丢弃一部分神经元，减少神经元之间的共适应性，提高泛化能力。<br><strong>全连接层（Fully Connected Layer）：</strong>将特征矩阵集合向量化。与卷积层不同，全连接层的神经元排成一列，这些神经元与前一层神经元通过权值互连，呈全连接结构。全连接层的层数以及每层神经元数并不固定。通常层数越高，神经元数目越少。<br>功能：进行分类。在卷积和池化层之后，通过全连接层将得到的特征映射转换为一维向量，并通过一系列的全连接神经元进行分类操作，将输入映射到对应的类别概率。<br><strong>输出层（Output Layer）：</strong>经过多层特征提取后，最后一层输出层可视为分类器，预测输入样本的类别。通常使用Softmax函数将全连接层的输出转换为类别概率分布，确定输入图像最可能属于哪个类别。<br><img src="https://leo710aka.github.io/bk/nn.png"></p>
<p>Sequential</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">self.model1 = Sequential(</span><br><span class="line">            Conv2d(in_channels=<span class="number">3</span>, out_channels=<span class="number">32</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(kernel_size=<span class="number">2</span>, ceil_mode=<span class="literal">True</span>),</span><br><span class="line">            Conv2d(<span class="number">32</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),     <span class="comment"># 二维卷积层</span></span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Flatten(),</span><br><span class="line">            Linear(<span class="number">1024</span>, <span class="number">64</span>),</span><br><span class="line">            Linear(<span class="number">64</span>, <span class="number">10</span>)</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>

<p>一次训练+验证：准备数据 - 加载数据 - 准备模型 - 设置损失函数 - 设置优化器 - 开始训练 - 验证 - 聚合展示</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):  <span class="comment"># 共20轮训练</span></span><br><span class="line">    running_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> dataloader:  <span class="comment"># 对数据进行一轮学习</span></span><br><span class="line">        imgs, targets = data</span><br><span class="line">        output = fc(imgs)</span><br><span class="line">        result_loss = loss(output, targets)  <span class="comment"># 计算损失</span></span><br><span class="line">        optim.zero_grad()  <span class="comment"># 优化器中，梯度置0</span></span><br><span class="line">        result_loss.backward()  <span class="comment"># 损失函数求梯度，反向传播</span></span><br><span class="line">        optim.step()  <span class="comment"># 优化器，优化卷积核参数</span></span><br><span class="line">        running_loss = running_loss + result_loss</span><br><span class="line">    <span class="built_in">print</span>(running_loss)</span><br></pre></td></tr></table></figure>

<h1 id="Colab"><a href="#Colab" class="headerlink" title="Colab"></a>Colab</h1><p><strong>Google Colab</strong>是谷歌提供的免费<strong>Jupyter</strong>笔记本环境，不需要配置环境（本质是<strong>Linux虚拟机</strong>），可以加!运行bash命令。提供一定免费的GPU，可以跑 Tensorflow、Pytorch 等深度学习框架。Google Colab提供的资源量是受限制的，所有 Colab 运行时都会在一段时间后重置。Colab Pro 订阅者的使用量仍会受到限制，但相比非订阅者可享有的限额要多出大约一倍。Colab Pro+ 订阅者还可获享更高的稳定性。</p>
<p>使用Colab训练比较重要的是处理好路径的关系，找到哪个文件在哪里，文件夹的执行目录在哪里，就可以比较简单的运行起程序了，不过Colab确实存在断线问题，我们需要时刻保存好文件，因此我将权值直接保存在云盘上，这样也不会丢失。<br><strong>12h</strong>的限额比较难受，有时候没到时间就限额了。因此需要及时保存训练的模型，长时间不用gpu的情况下也会被限额（Pro版也一样），因此训练完建议及时改成gpu或停止。</p>
<h3 id="Google-Drive"><a href="#Google-Drive" class="headerlink" title="Google Drive"></a>Google Drive</h3><p>谷歌云盘，谷歌云端硬盘。免费用户可以获取15G的空间，付费用户根据套餐可以选择最大20TB的储存空间。<br><strong>虚拟机根目录为 &#x2F;content，谷歌云盘地址为 &#x2F;content&#x2F;Drive&#x2F;MyDrive</strong></p>
<h3 id="深度学习库的下载"><a href="#深度学习库的下载" class="headerlink" title="深度学习库的下载"></a>深度学习库的下载</h3><p>使用git clone指令进行下载，然后通过cd指令将根目录转移到了xx文件夹。<strong>此时根目录为 &#x2F;content&#x2F;xx</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!git <span class="built_in">clone</span> https://github.com/xx/xx.git</span><br><span class="line">%<span class="built_in">cd</span> xx/</span><br></pre></td></tr></table></figure>

<h3 id="数据集与预训练权重的上传"><a href="#数据集与预训练权重的上传" class="headerlink" title="数据集与预训练权重的上传"></a>数据集与预训练权重的上传</h3><p>数据集压缩，上传Google Drive，在colab中打开的jupyter文件（等于打开了一个Linux<strong>虚拟机本地</strong>）中挂载Google Drive；将数据集从Drive中复制到当前根目录，解压。<strong>直接将数据集布置在谷歌云盘会导致大量的云盘数据传输，且谷歌云盘和虚拟机之间存在通信带宽，速度远不及本地(虚拟机)文件，因此需要将数据集复制解压到本地(虚拟机)里进行处理。</strong> (<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44791964/article/details/123659637?spm=1001.2014.3001.5501">https://blog.csdn.net/weixin_44791964/article/details/123659637?spm=1001.2014.3001.5501</a>)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!<span class="built_in">cp</span> /content/Drive/MyDrive/xx.zip ./</span><br><span class="line">!unzip ./xx.zip -d ./</span><br></pre></td></tr></table></figure>
<p>预训练权重存放在 &#x2F;content&#x2F;Drive&#x2F;MyDrive&#x2F;Models&#x2F;xx，然后创建logs和model_data。model_data放置的是预训练文件,logs放置的是网络训练过程中产生的权值。</p>
<h3 id="保存路径设置"><a href="#保存路径设置" class="headerlink" title="保存路径设置"></a>保存路径设置</h3><p>如果将权值保存在当前根目录下的logs文件夹（&#x2F;content&#x2F;xx&#x2F;logs），发生断线网络就白训练了，浪费大量的时间。<br>可以将google云盘软连接到根目录下，那么即使断线，权值也保留在云盘中。<br>本文之前在云盘中创建了logs文件夹（&#x2F;content&#x2F;Drive&#x2F;MyDrive&#x2F;Models&#x2F;xx&#x2F;logs），将该文件夹链接到当前根目录下的logs文件夹中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!<span class="built_in">ln</span> -s /content/Drive/MyDrive/Models/xx/logs logs   <span class="comment"># 即/content/xx/logs</span></span><br></pre></td></tr></table></figure>
<h3 id="开始训练"><a href="#开始训练" class="headerlink" title="开始训练"></a>开始训练</h3><p>1、标注文件的处理<br>2、训练文件的处理<br>1）预训练文件的使用。<br>2）保存周期的设置，这个设置是因为云盘的存储空间有限，每代都保存会导致存储空间满出。<br>3、开始训练：!python train.py</p>
<h3 id="常用-colab-命令"><a href="#常用-colab-命令" class="headerlink" title="常用 colab 命令"></a>常用 colab 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import shutil</span><br><span class="line">shutil.copytree(<span class="string">&quot;复制的文件夹&quot;</span>,<span class="string">&quot;目标路径+目标路径下的文件夹&quot;</span>)  <span class="comment"># 复制路径下的文件夹</span></span><br><span class="line">shutil.copytree(<span class="string">&quot;/content/drive/My Drive/channel&quot;</span>,<span class="string">&quot;/content/drive/My Drive/channel10&quot;</span>) <span class="comment"># ex</span></span><br><span class="line">shutil.rmtree(<span class="string">&quot;移除路径下的文件夹&quot;</span>) <span class="comment"># 移除路径下的文件夹</span></span><br><span class="line">shutil.copy(<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>) <span class="comment"># 复制单个文件的命令  同上</span></span><br><span class="line"><span class="comment"># 删除单个文件可以右键删除</span></span><br><span class="line">!<span class="built_in">pwd</span> <span class="comment"># 显示当前目录, /content 为根目录</span></span><br><span class="line">import os </span><br><span class="line">os.chdir(<span class="string">&quot;/content/federated-learning&quot;</span>) <span class="comment"># 变更根目录操作</span></span><br><span class="line">!python <span class="string">&quot;/content/federated-learning/main_nn.py&quot;</span> <span class="comment"># 运行python 文件</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/10/Pytorch_Colab/" data-id="clzzl7c2b000cu0v5fece8cos" data-title="Pytorch / Colab" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Git" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/12/Git/" class="article-date">
  <time class="dt-published" datetime="2023-04-12T09:02:15.000Z" itemprop="datePublished">2023-04-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/12/Git/">Git</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>First Project：）being confused and embrassed… luckily no one is staring at you but willing to help，as long as you try to find and explain a bug，try debugging、、</p>
<h3 id="Git-Bash"><a href="#Git-Bash" class="headerlink" title="Git Bash"></a>Git Bash</h3><ul>
<li><strong>分布式版本控制工具 git</strong>：没有“中央服务器”，每个人的电脑上都是一个完整的版本库（区别于集中式版本库管理系统如 svn）。</li>
<li><strong>Git Bash</strong>：Git提供的命令行工具，可运行linux命令 cd、ls、touch…<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list                         <span class="comment"># 查看配置</span></span><br></pre></td></tr></table></figure></li>
<li>配置 Git 的全局用户信息，这些信息在你提交代码到 Git 仓库时会被记录下来，用于标识提交代码的作者信息。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;xx&quot;</span>        <span class="comment"># 配置 user.name_caifeng</span></span><br><span class="line">git config --global user.email <span class="string">&quot;xx&quot;</span>       <span class="comment"># user.email_1908454905@qq.com</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h3><ul>
<li>leo710aka <a href="mailto:&#49;&#120;&#x78;&#120;&#120;&#120;&#120;&#120;&#120;&#120;&#x40;&#x71;&#120;&#46;&#99;&#x6f;&#x6d;">&#49;&#120;&#x78;&#120;&#120;&#120;&#120;&#120;&#120;&#120;&#x40;&#x71;&#120;&#46;&#99;&#x6f;&#x6d;</a> cxxxxxx</li>
<li>使用 SSH 密钥连接 GitHub：如果没有的话，使用？？？以下命令在本地<strong>生成 SSH 密钥</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;your_email@example.com&quot;</span></span><br></pre></td></tr></table></figure>
生成 SSH 密钥后，将 <code>~/.ssh/id_rsa.pub</code>（公钥）的内容添加到 GitHub 账号的 SSH 密钥设置中。</li>
<li>使用 HTTPS 认证连接 GitHub：在 GitHub 上克隆仓库时，使用 HTTPS 链接，然后在推送更改时，会提示输入 GitHub 账号的用户名和密码，或者使用个人访问令牌（Personal Access Token）代替账号密码。</li>
<li>访问令牌（Access Token）是一种用于通过API进行身份验证的方式。<ul>
<li>创建访问令牌：1. 登录到你的GitHub帐户。    2. 点击右上角的头像，选择 “Settings”。    3. 在左侧导航栏中选择 “Developer settings”。    4. 点击 “Personal access tokens”。    5. 点击 “Generate token”。    6. 提供一个描述，选择需要的权限（scope），然后点击 “Generate token”。    7. 复制生成的访问令牌。请注意，生成后会显示一次，如果忘记了，需要重新生成。</li>
<li>使用访问令牌：可以通过多种方式使用，例如在命令行中、在脚本中或者在应用程序中。</li>
<li>Token和SSH密钥是两种不同的身份验证机制，用于在GitHub或其他版本控制系统中进行身份验证。存在一些区别。<br>  用途不同： 访问令牌用于API身份验证，而SSH密钥用于远程仓库的SSH访问。<br>  获取方式不同： 访问令牌通过GitHub设置生成，而SSH密钥需要用户生成并添加到GitHub帐户。<br>  身份验证方式不同： 访问令牌通过HTTP标头进行身份验证，而SSH密钥使用SSH协议进行本地身份验证。<br>  适用场景不同： 访问令牌适用于与GitHub API进行交互，而SSH密钥适用于直接使用Git与远程仓库进行交互。</li>
</ul>
</li>
</ul>
<h3 id="Git-指令"><a href="#Git-指令" class="headerlink" title="Git 指令"></a>Git 指令</h3><img src="https://github.com/leo710aka/bk/blob/main/git.png?raw=true" width="700" height="300" alt="">

<ol>
<li>clone (克隆):从远程仓库中克隆代码到本地仓库。会下载远程仓库的所有分支的引用，但只会检出[chekout]默认分支到本地。</li>
<li>checkout (检出) :从本地仓库中检出一个仓库分支然后进行修订</li>
<li>add (添加):在提交前先将代码提交到暂存区</li>
<li>commit (提交): 提交到本地仓库。本地仓库中保存修改的各个历史版本</li>
<li>fetch (抓取): 从远程库抓取到本地仓库。这会更新所有远程分支的引用信息，但不会自动合并这些更新到本地分支。</li>
<li>merge(合并): 将指定的分支合并到当前分支。</li>
<li>pull(拉取) : 相当于fetch+merge，获取最新的远程提交，但只合并当前检出的本地分支与其对应的远程分支，然后放到到工作区。</li>
<li>push (推送) :修改完成后，需要和团队成员共享代码时，将代码推送到远程仓库</li>
</ol>
<h2 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h2><ul>
<li>要使用Git对我们的代码进行版本控制，首先需要创建本地仓库<br>(1) 在电脑的任意位置创建一个空目录(文件夹) 作为我们的本地Git仓库<br>(2) 进入这个目录中，右键打开Git bash<br>(3) 执行命令<code>git init</code><br>(4) 如果创建成功后可在文件夹下看到隐藏的.git目录。</li>
<li>新建仓库中的文件，其状态都是未被跟踪的（未纳入版本管理）<br><code>git add &lt;name&gt; / git add .</code>：跟踪一个&#x2F;所有文件或目录的状态，将其纳入版本管理（即暂存？），记录其状态或内容变化<br><code>git rm &lt;name&gt;</code>：删除文件<br><code>git rm --cache &lt;name&gt;</code>：保留文件但不再跟踪</li>
<li>添加，提交，推送：在IDEA中，点击Git提交并推送，选择提交、添加信息、修改远程仓库的分支(默认<code>origin:main</code>)，推送。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status                                       <span class="comment"># 查看当前状态（红色的字体显示的是修改的文件</span></span><br><span class="line">$ git add 单个文件名|通配符(. 添加所有修改)          <span class="comment"># 添加工作区代码到本地git暂存区</span></span><br><span class="line">$ git commit -m <span class="string">&quot;提交的信息&quot;</span>                        <span class="comment"># 提交暂存区代码到本地git仓库（生成一个版本）</span></span><br><span class="line">$ git <span class="built_in">log</span>                                          <span class="comment"># 查看提交日志信息（head指向当前操作的分支）</span></span><br><span class="line">$ git push &lt;远程仓库名&gt; &lt;本地分支名&gt;                 <span class="comment"># 推送本地代码到远程仓库</span></span><br><span class="line">$ git push &lt;远程仓库名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;    <span class="comment"># 将指定的本地分支推送到远程仓库的指定分支</span></span><br></pre></td></tr></table></figure>
<img src="https://github.com/leo710aka/bk/blob/main/git2.png?raw=true" width="350" height="300" alt=""></li>
</ul>
<h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><ul>
<li>上传本地仓库项目到远程<br>本地git bash生成ssh公钥，添加到gitee中，本地验证，添加远程仓库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa                                       <span class="comment"># 生成ssh密钥</span></span><br><span class="line">$ <span class="built_in">cat</span> ~/.ssh/id_rsa.pub                                   <span class="comment"># 查看密钥</span></span><br><span class="line">$ ssh -T git@gitee.com                                    <span class="comment"># 验证</span></span><br><span class="line">$ git remote add origin git@gitee.com:leo710aka/test.git  <span class="comment"># 添加远程仓库名为origin(别名)，加ssh地址</span></span><br><span class="line">$ git remote -v                                           <span class="comment"># 检查远程仓库配置是否正确</span></span><br><span class="line">$ git push origin master  <span class="comment"># 完成添加、提交后，将本地master分支推送至远程origin仓库</span></span><br></pre></td></tr></table></figure>
或者直接在idea中，对一个项目文件添加、提交后，直接在idea中<code>git remote</code>，使用github账号密码进行远程仓库的连接，然后推送。（连接远程仓库，要么使用ssh密钥，要么用github账号密码。）</li>
<li>添加远程仓库项目到本地<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> &lt;远程仓库地址&gt;                 <span class="comment"># 克隆远程仓库到本地（默认分支master）</span></span><br><span class="line">$ git <span class="built_in">clone</span> -b &lt;分支名&gt; &lt;远程仓库地址&gt;      <span class="comment"># 克隆指定分支（如develop）</span></span><br></pre></td></tr></table></figure>
也可以先从远程仓库<code>git clone</code>下来一个项目，完成修改后对项目文件添加、提交，在推送到远程仓库时，再进行 <code>ssh密钥/github账号密码</code> 的验证。</li>
</ul>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><ul>
<li>实际开发新功能，是在develop分支上创建feature分支，完成后合并到<code>develop分支</code>(部门开发分支)上，经测试，最后合并到<code>master分支</code>(线上分支，主分支，项目正在上线的分支)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git branch                  <span class="comment"># 查看本地所有的分支，当前激活的分支会在列表中以星号（*）标识。</span></span><br><span class="line">$ git branch -r               <span class="comment"># 查看远程仓库的分支</span></span><br><span class="line">$ git branch -a               <span class="comment"># 查看所有分支，包括本地分支和远程分支。</span></span><br><span class="line">$ git branch caifeng          <span class="comment"># 从当前分支上新建分支</span></span><br><span class="line">$ git checkout caifeng        <span class="comment"># 切换分支</span></span><br><span class="line">$ git checkout -b caifeng     <span class="comment"># 创建（若不存在）并切换分支</span></span><br><span class="line">$ git checkout -d caifeng     <span class="comment"># 删除分支（-D 强制删除）</span></span><br><span class="line">$ git merge &lt;分支名&gt;           <span class="comment"># 先切换回如master分支上，将其他分支上的提交合并到master上</span></span><br></pre></td></tr></table></figure></li>
<li>分支合并<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git merge [remote name] [branch name]   </span><br><span class="line">$ git <span class="built_in">log</span> --merge                       <span class="comment"># 显示合并冲突的提交日志</span></span><br><span class="line">$ git <span class="built_in">log</span> --graph --oneline --all       <span class="comment"># 可视化分支和合并历史，以简化理解合并的情况</span></span><br></pre></td></tr></table></figure></li>
<li>更新项目<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch [remote name] [branch name]   <span class="comment"># 抓取仓库里的更新到本地，不会进行合并</span></span><br><span class="line">$ git pull [remote name] [branch name]    <span class="comment"># 拉取远端仓库的修改拉到本地并自动进行合并，等同于fetch+merge</span></span><br></pre></td></tr></table></figure>
在一段时间，A、B用户修改了同一个文件，且修改了同一行位置的代码，此时会发生合并冲突A用户在本地修改代码后优先推送到远程仓库，此时B用户在本地修订代码，提交到本地仓库后，也需要推送到玩程仓库，此时B用户晚于A用户，故需要<strong>先拉取远程仓库的提交，经过合并后才能推送到远端分支</strong>。<br>或直接在IDEA里面选择分支pull（Git拉取），克隆&#x2F;更新后记得修改配置文件为测试&#x2F;本地（如果有）。</li>
<li>冲突：当两个分支上对文件的修改可能会存在冲突，例如同时修改了同一个文件的同一行，这时就需要手动解决冲突，解决步骤、、<br>1.处理文件中冲突的地方<br>2.将解决完冲突的文件加入暂存区(add)<br>3,提交到仓库(commit)<img src="https://github.com/leo710aka/bk/blob/main/git1.png?raw=true" width="500" height="300" alt=""></li>
</ul>
<h4 id="经典Git流模型"><a href="#经典Git流模型" class="headerlink" title="经典Git流模型"></a>经典Git流模型</h4><img src="https://github.com/leo710aka/bk/blob/main/git4.png?raw=true" width="500" height="300" alt="">


<h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><ul>
<li>贮藏代码：当前代码没写完，要切换分支时，必须先提交当前代码或贮藏<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash    </span><br></pre></td></tr></table></figure></li>
<li>版本回退<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard &lt;提交<span class="built_in">id</span>&gt;    <span class="comment"># 通过提交id切换版本</span></span><br><span class="line">$ git reflog                   <span class="comment"># 查看历史操作（已清除提交日志、版本切换日志。。。</span></span><br></pre></td></tr></table></figure></li>
<li>分支变基：将一系列的提交从一个分支上 “移动” 到另一个分支的起点，并将它们重新应用（或重新播放）到目标分支上。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase   <span class="comment"># 可以让提交历史更线性、更简洁</span></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/12/Git/" data-id="clzzl7c280004u0v5f1529eo3" data-title="Git" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hexo-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/01/hexo-world/" class="article-date">
  <time class="dt-published" datetime="2023-04-01T09:02:15.000Z" itemprop="datePublished">2023-04-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/01/hexo-world/">hexo | Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p>Hexo 是一个基于 Node.js 的静态博客框架，提供简单的方式来创建和部署静态博客，使作者专注于写作而不必担心后端服务器的维护。<br>Hexo 使用 Markdown 作为主要的文章撰写语言，这是一种轻量级的标记语言，使得写作变得简单且易于阅读。<br>Hexo 生成的是静态页面，因此页面加载速度非常快。这对于提供更好的用户体验和搜索引擎优化（SEO）非常有利。<br>Hexo 使用版本控制系统（通常是 Git）来管理博客内容，因此用户可以轻松地追踪和管理博客文章的历史。<br>Hexo 可以将博客部署到各种平台，包括 GitHub Pages、Netlify、Vercel 等。这使得博客的部署变得非常简单。</p>
<h3 id="配置-hexo"><a href="#配置-hexo" class="headerlink" title="配置 hexo"></a>配置 hexo</h3><p>见 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Eg41157tL%EF%BC%8C%E5%85%B6%E4%B8%AD%EF%BC%9A">https://www.bilibili.com/video/BV1Eg41157tL，其中：</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;leo710aka&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;1908454905@qq.com&quot;</span></span><br></pre></td></tr></table></figure>
<p>_cnfig.yml不能直接复制粘贴过去。。</p>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><p>在C:\Users\cf\Documents\Visual Studio Code\blog下右键<strong>Git Bash Here</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;文件名&quot;</span></span><br></pre></td></tr></table></figure>

<p>或者直接在..\source\posts下编写md文件. More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>

<p>在本地服务器看看效果. <a target="_blank" rel="noopener" href="http://localhost:4000/">http://localhost:4000/</a> </p>
<h3 id="Clean、-Generate-static-files-、Deploy-to-remote-sites"><a href="#Clean、-Generate-static-files-、Deploy-to-remote-sites" class="headerlink" title="Clean、 Generate static files 、Deploy to remote sites"></a>Clean、 Generate static files 、Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean   <span class="comment"># 清理缓存、清理之前生成的静态文件</span></span><br><span class="line">$ hexo g       <span class="comment"># 构建网页文件（通过md文件生成html、css、js..）</span></span><br><span class="line">$ hexo d       <span class="comment"># 同步github，更新博客上的内容（这一步可能需要多试几次）</span></span><br></pre></td></tr></table></figure>
<p>没办法同步的话，直接把新构建的 <code>E:\Code\Blog\blog\.deploy_git</code> 中的文件手动上传github仓库；<br>成功后若博客内容未更新，ctrl+f5清下缓存。</p>
<h3 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h3><p>在 <code>_config.yml</code> 或 <code>_config.landscape</code> 中设置，修改配置后先 hexo clean 一下，再发布。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/01/hexo-world/" data-id="clzzl7c2e000mu0v5bl6y4jti" data-title="hexo | Hello World" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Python_Anaconda_Django" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/09/01/Python_Anaconda_Django/" class="article-date">
  <time class="dt-published" datetime="2022-09-01T03:11:00.000Z" itemprop="datePublished">2022-09-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/09/01/Python_Anaconda_Django/">Python / Anaconda / Django</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Python是一种高级、通用、解释型、面向对象的编程语言。<br>Python是一种<strong>解释型语言</strong>，其代码不是直接编译成机器码，而是由解释器逐行解释执行。常见的Python解释器有 CPython、Jython 等。<br>其中 CPython 是官方标准实现，是由Python的创始人Guido van Rossum领导开发的官方Python解释器。它是使用C语言编写的，是最广泛使用的Python解释器。</p>
<h2 id="Python-环境"><a href="#Python-环境" class="headerlink" title="Python 环境"></a>Python 环境</h2><ol>
<li>配置 Python 环境：<ul>
<li>官方Python（CPython）：通过官方网站下载并安装，使用官方的 pip 包管理器进行包的安装。不具备虚拟环境管理工具，但可使用 venv 或 virtualenv 创建虚拟环境。<br> 使用：添加解释器 -&gt; Virtualenv -&gt; 基础解释器 -&gt; C:\Users\caife\AppData\Local\Programs\Python\Python312\python.exe</li>
<li>Anaconda Python：通过 Anaconda 官方网站下载并安装。使用 conda 包管理器进行包的安装和环境的管理。具备强大的虚拟环境管理工具，可以轻松创建、导出、列出和删除环境。 <!-- 使用方法：添加解释器 -> Conda环境 -> ??? --></li>
<li>项目中自带的环境：在开发环境中配置项目中的 Python 解释器（xxproject\env\Scripts\python.exe），使项目中使用的 Python 环境与系统中的 Python 环境独立。</li>
</ul>
</li>
<li>Python环境通常包括了解释器、标准库、开发工具和其他一些组件:<ul>
<li><strong>虚拟环境（Virtual Environment）：</strong> 虚拟环境是一个独立的Python环境，允许您在同一台机器上同时运行多个项目，每个项目都有其独立的依赖项和库。<code>venv</code> 和 <code>virtualenv</code> 是用于创建虚拟环境的工具。</li>
<li>解释器：如 <em>C:\Python312\python.exe</em>，用于运行代码。</li>
<li>包管理器：如 <em>C:\Python312\Scripts\pip3.exe</em>，用于（为解释器&#x2F;环境）安装、升级和卸载软件包。<code>pip</code> 是Python的官方包管理器，用于从 PyPI 安装第三方库。</li>
<li>库：如 <em>C:\Python312\lib</em>，其中包含了该环境中安装的所有Python包。</li>
</ul>
</li>
<li>开发环境：<ul>
<li>IDE（集成开发环境）：提供了代码编辑、调试、版本控制等一体化功能的工具。常见的 Python IDE包括 PyCharm、Visual Studio Code、Jupyter Notebook 等。</li>
<li>Jupyter Notebook： 交互式计算环境，支持在浏览器中编写和运行 Python代码，并包含文本、图像和公式等。</li>
</ul>
</li>
<li>PyCharm 配置解释器：<ul>
<li>使用 Pycharm 开发项目时，<font color= "#0873BA"> <strong>点击添加解释器 —&gt; 添加本地解释器，选择将要运行该项目的虚拟环境下的 Python 解释器。</strong> </font><br> <strong>选择使用这个虚拟环境对应的编辑器，就是选择了使用这个环境运行项目，使用这个环境中配好的包，版本和依赖库等等。</strong> 可以在“外部库”查看当前环境中的类库。</li>
<li>一般来说，<font color= "#0072B1"> <strong>可以直接选择本地Python解释器（Python3.10）环境中已经配好了大部分的类库，项目中需要的软件包可以手动安装（指定地址 C:\Users\caife\AppData\Local\Programs\Python\Python312\Lib）。</strong> </font></li>
</ul>
</li>
<li><strong>PyCharm终端的Python环境不一定与当前加载的项目使用的解释器器环境一致！！</strong><ul>
<li>所以要注意终端使用的是哪个编辑器，是否与当前项目使用的编辑器匹配。否则在终端 pip install 把包装到 Pycharm 终端的环境下，而当前项目运行在另一个虚拟环境中，便无法 import 已从终端安装的包。</li>
<li>看pycharm提示符的地址，其实就等于是cmd中cd到该地址执行命令</li>
</ul>
</li>
</ol>
<h3 id="Pycharm-终端指令"><a href="#Pycharm-终端指令" class="headerlink" title="Pycharm 终端指令"></a>Pycharm 终端指令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install xx    <span class="comment"># pip安装包到终端的环境中</span></span><br><span class="line">pip install xx --target C:\Users\caife\AppData\Local\Programs\Python\Python312\Lib <span class="comment"># 指定安装位置</span></span><br><span class="line">python --version  <span class="comment"># 查看 Python 版本</span></span><br><span class="line">pip list          <span class="comment"># 列出已安装的包</span></span><br></pre></td></tr></table></figure>

<h3 id="数据结构与函数"><a href="#数据结构与函数" class="headerlink" title="数据结构与函数"></a>数据结构与函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;apple&quot;</span>]  <span class="comment"># 列表</span></span><br><span class="line">my_tuple = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment"># 元组</span></span><br><span class="line">my_dict = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">25</span>&#125;  <span class="comment"># 字典</span></span><br><span class="line">my_set = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;  <span class="comment"># 集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name</span><br><span class="line">message = greet(<span class="string">&quot;Alice&quot;</span>)  <span class="comment"># 调用函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 面向对象编程（OOP）</span></span><br><span class="line"><span class="comment"># 定义类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bark</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Woof!&quot;</span>)</span><br><span class="line">my_dog = Dog(<span class="string">&quot;Buddy&quot;</span>)  <span class="comment"># 创建对象</span></span><br><span class="line">my_dog.bark()  <span class="comment"># 调用对象方法</span></span><br></pre></td></tr></table></figure>


<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    result = <span class="number">10</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Cannot divide by zero&quot;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This will be executed no matter what&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写入文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(<span class="string">&quot;Hello, Python!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    content = file.read()</span><br><span class="line">    <span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure>

<h3 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h3><p>Pandas 是一个强大的数据分析库，主要用于数据处理和分析。它提供了两种主要的数据结构：<code>Series</code> 和 <code>DataFrame</code>。</p>
<ul>
<li><code>Series</code> 是一个一维标记数组，可以保存任何数据类型。它由两个主要部分组成：索引（index）和数据（data）。</li>
<li><code>DataFrame</code> 是一个二维表格，类似于 Excel 表格或 SQL 表。它由行索引、列索引和数据组成。<br>  <strong>数据组织</strong>：DataFrame 以表格的形式组织数据，包括多个列，每一列可以包含不同的数据类型（整数、浮点数、字符串等）。<br>  <strong>索引</strong>：每个行和列都有一个标签索引。行索引表示 DataFrame 中的每个数据行，列索引表示 DataFrame 中的每个数据列。<br>  <strong>列</strong>：DataFrame 的每一列是一个 Pandas Series 对象，这意味着它们可以包含相同类型的数据。你可以将每一列视为一个数据字段，类似于数据库表中的列。    下面是一个示例 DataFrame 的结构：  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">|</span>    <span class="operator">|</span> Name     <span class="operator">|</span> Age <span class="operator">|</span> City       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="comment">----|----------|-----|------------|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">0</span>  <span class="operator">|</span> Alice    <span class="operator">|</span> <span class="number">25</span>  <span class="operator">|</span> Niu York   <span class="operator">|</span>  <span class="comment">-- 行索引（0, 1, 2, 3）标识每一行的位置</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> Bob      <span class="operator">|</span> <span class="number">30</span>  <span class="operator">|</span> Los Angeles<span class="operator">|</span>  <span class="comment">-- 列索引（Name, Age, City）表示不同的数据字段</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>  <span class="operator">|</span> Carol    <span class="operator">|</span> <span class="number">28</span>  <span class="operator">|</span> Chicago    <span class="operator">|</span>  <span class="comment">-- 每一列（Name, Age, City）都包含相应的数据</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span>  <span class="operator">|</span> David    <span class="operator">|</span> <span class="number">22</span>  <span class="operator">|</span> Houston    <span class="operator">|</span>  <span class="comment">-- 每一列都是一个 Pandas Series，包含相同类型的数据</span></span><br></pre></td></tr></table></figure></li>
<li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">s = pd.Series([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, np.nan, <span class="number">6</span>, <span class="number">8</span>])  <span class="comment"># 创建一个 Series</span></span><br><span class="line">df = pd.DataFrame(&#123;                     <span class="comment"># 创建一个 DataFrame</span></span><br><span class="line">    <span class="string">&#x27;Name&#x27;</span>: [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Charlie&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;Age&#x27;</span>: [<span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>],</span><br><span class="line">    <span class="string">&#x27;City&#x27;</span>: [<span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;San Francisco&#x27;</span>, <span class="string">&#x27;Los Angeles&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line">df = pd.DataFrame(columns=, data=)      <span class="comment"># 指定创建 DataFrame 的列索引和其中的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, row <span class="keyword">in</span> df.iterrows():        <span class="comment"># 遍历DataFrame的每一行</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Index: <span class="subst">&#123;index&#125;</span>, Name: <span class="subst">&#123;row[<span class="string">&#x27;Name&#x27;</span>]&#125;</span>, Age: <span class="subst">&#123;row[<span class="string">&#x27;Age&#x27;</span>]&#125;</span>, City: <span class="subst">&#123;row[<span class="string">&#x27;City&#x27;</span>]&#125;</span>&quot;</span>)  </span><br><span class="line">    <span class="comment"># Index: 0, Name: Alice, Age: 25, City: New York...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 DataFrame 对象保存为 CSV 文件</span></span><br><span class="line"><span class="comment"># sep 表示数据字段之间的分隔符，header 表示是否将列名写入文件，index 表示是否写入行索引。</span></span><br><span class="line">df.to_csv(<span class="string">&#x27;data.txt&#x27;</span>, sep = <span class="string">&#x27; &#x27;</span>, index = <span class="literal">False</span>, header = <span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 从 CSV、Excel文件读取数据</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;data.csv&#x27;</span>)</span><br><span class="line">df = pd.read_excel(<span class="string">&#x27;data.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h3><p><code>numpy</code>（Numerical Python的缩写）是一个用于科学计算的强大Python库。以下是一些 <code>numpy</code> 的主要功能和用法：</p>
<ol>
<li><strong>多维数组：</strong> <code>numpy</code> 提供了<code>ndarray</code>对象，是一个多维数组，用于存储同类型的元素。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 创建一个numpy数组</span></span><br><span class="line">arr = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure></li>
<li><strong>数组操作：</strong> <code>numpy</code> 提供了许多对数组进行操作的函数，包括数学、逻辑、形状操作等。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数组的数学运算</span></span><br><span class="line">result = arr + <span class="number">2</span></span><br><span class="line"><span class="comment"># 数组形状操作</span></span><br><span class="line">reshaped_arr = arr.reshape(<span class="number">5</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li>
<li><strong>矩阵操作：</strong> <code>numpy</code> 具有广泛的矩阵操作，包括矩阵乘法、转置等。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">matrix_a = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">matrix_b = np.array([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line"><span class="comment"># 矩阵乘法</span></span><br><span class="line">result_matrix = np.dot(matrix_a, matrix_b)</span><br></pre></td></tr></table></figure></li>
<li><strong>数学函数：</strong> <code>numpy</code> 包括大量的数学函数，用于三角函数、对数、指数等。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="comment"># 求sin(x)</span></span><br><span class="line">sin_values = np.sin(x)</span><br></pre></td></tr></table></figure></li>
<li><strong>随机数生成：</strong> <code>numpy</code> 提供了生成随机数的函数。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">random_numbers = np.random.rand(<span class="number">5</span>)  <span class="comment"># 生成5个在[0, 1)范围内的随机数</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Python爬虫"><a href="#Python爬虫" class="headerlink" title="Python爬虫"></a>Python爬虫</h2><h3 id="反爬虫策略"><a href="#反爬虫策略" class="headerlink" title="反爬虫策略"></a><strong>反爬虫策略</strong></h3><ul>
<li>设置合理的请求头。   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;   <span class="comment"># 伪装浏览器请求头</span></span><br><span class="line">   <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;ispeed_lsm=2; baikeVisitId=b84d4a50-436c-4e0f-9e29-dc2393e9cdca; COOKIE_SESSION=6_1_8_5_10_9_1_0_7_5_0_3_33002_0_2_0_1650022038_1650022034_1650022036%7C8%230_1_1650022030%7C1; BD_UPN=1126314751; BD_HOME=1; BD_CK_SAM=1; H_PS_645EC=89b2Pt9WoxiJHIC80g9QL3FIo7tdoc9Z9Gm9Nd6gkOPipOmTDtckrFlLxEpchFYkItCM; BAIDUID=FD56AC9125756B81A0E4EB7A60F27700:FG=1; BIDUPSID=FD56AC9125756B81E8CE802CC99B8074; PSTM=1648004100; BDUSS=Jpc2d4NGIwdzRCNVFTR0xNeS1IYXBLNTQwfjhzRnl3Z0xRSlZJTDhZeU1ibnhpRVFBQUFBJCQAAAAAAAAAAAEAAAAnQDHOyfq77rXDd2luZHkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIzhVGKM4VRiT2; H_PS_PSSID=36426_31660_35912_36167_34584_35979_36055_36235_26350; BA_HECTOR=ak20800k8kag8h8le71h8646s0q; BDRCVFR[feWj1Vr5u3D]=I67x6TjHwwYf0; delPer=0; PSINO=6&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.64 Safari/537.36&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用代理IP。</li>
<li>限制请求频率，避免被封IP。   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sleep_time = random.uniform(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">time.sleep(sleep_time)</span><br></pre></td></tr></table></figure></li>
<li>处理验证码和登录等复杂场景。</li>
</ul>
<h3 id="网络请求库："><a href="#网络请求库：" class="headerlink" title="网络请求库："></a><strong>网络请求库：</strong></h3><ul>
<li><code>requests</code>库：用于发送HTTP请求，获取网页内容。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment"># url_base = &#x27;http://leo/index.phtml?reportdate=&#123;year&#125;&amp;quarter=&#123;quarter&#125;&amp;p=&#123;page&#125;&#x27;</span></span><br><span class="line"><span class="comment"># url = url_base.format(year=iyear, quarter=iquarter, page=page)  # 替换url模板中的占位符</span></span><br><span class="line">response = requests.get(url=url, headers=self.headers)</span><br><span class="line">res = response.content.decode()  <span class="comment"># 获取服务器响应的内容，将其解码成字符串</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="HTML解析库："><a href="#HTML解析库：" class="headerlink" title="HTML解析库："></a><strong>HTML解析库：</strong></h3><ul>
<li><code>BeautifulSoup</code>：用于解析HTML文档，提取所需信息。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(res, <span class="string">&#x27;html.parser&#x27;</span>)           <span class="comment"># 解析 HTML 内容</span></span><br><span class="line">first_paragraph = soup.find(<span class="string">&#x27;p&#x27;</span>)                   <span class="comment"># 查找第一个&lt;p&gt;标签</span></span><br><span class="line">script = soup.find(<span class="built_in">id</span>=tag_id)                      <span class="comment"># 找到具有指定 id 属性的标签</span></span><br><span class="line"><span class="comment"># script.string.replace_with(new_string)           # 替换标签内容</span></span><br><span class="line"><span class="comment"># script.append(new_tag)                           # 在标签内追加新标签</span></span><br><span class="line"><span class="comment"># script.extract()                                 # 从文档中删除标签</span></span><br><span class="line">text = script.text                                 <span class="comment"># 获取标签内容   </span></span><br><span class="line"><span class="comment"># json_str = re.findall(r&#x27;\[.+\]&#x27;, text)[0]        # 用正则表达式 re 从 text 中查找一个或多个包含 JSON 数据的字符串的第一个匹配项</span></span><br><span class="line"><span class="comment"># data = json.loads(json_str)                      # 把json格式的字符串转换为Python类型</span></span><br><span class="line">script1 = soup.find(<span class="string">&#x27;p&#x27;</span>, class_=<span class="string">&#x27;paragraph&#x27;</span>)       <span class="comment"># 查找带有指定class的&lt;p&gt;标签</span></span><br><span class="line">script2 = soup.find(<span class="string">&#x27;a&#x27;</span>, href=<span class="string">&#x27;https://...&#x27;</span>)       <span class="comment"># 查找带有指定属性的&lt;a&gt;标签</span></span><br><span class="line">labels = soup.find_all(<span class="string">&#x27;a&#x27;</span>, attrs=&#123;<span class="string">&#x27;href&#x27;</span>: <span class="literal">True</span>&#125;)  <span class="comment"># 模糊搜索HTML代码中所有含href属性的&lt;a&gt;标签</span></span><br></pre></td></tr></table></figure></li>
<li><code>lxml</code>：使用类似 XPath 的功能解析HTML文档。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> html</span><br><span class="line">tree = html.fromstring(html_doc)</span><br><span class="line">paragraphs = tree.xpath(<span class="string">&#x27;//p&#x27;</span>)                                 <span class="comment"># 使用 XPath 表达式查找&lt;p&gt;标签</span></span><br><span class="line">paragraphs_with_class = tree.xpath(<span class="string">&#x27;//p[@class=&quot;paragraph&quot;]&#x27;</span>)  <span class="comment"># 使用 XPath 表达式查找具有指定class属性值的&lt;p&gt;标签</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="数据存储："><a href="#数据存储：" class="headerlink" title="数据存储："></a><strong>数据存储：</strong></h3><ul>
<li>文件存储：将爬取的数据保存为文本文件、CSV文件等。</li>
<li>数据库：使用SQLite、MySQL、MongoDB等数据库存储数据。   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load</span>(<span class="params">self, path</span>):</span><br><span class="line">   <span class="keyword">with</span> <span class="built_in">open</span>(path, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:   <span class="comment"># 加载存储在JSON文件中的数据, 指定文件为UTF-8编码</span></span><br><span class="line">       data = json.load(fp)</span><br><span class="line">   <span class="keyword">return</span> data</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save</span>(<span class="params">self, data, path</span>):</span><br><span class="line">   <span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:   <span class="comment"># 以json格式保存, 最近一日各国疫情数据</span></span><br><span class="line">       json.dump(data, fp, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">baidu_search</span>(<span class="params">v_result_file</span>):   <span class="comment"># 保存csv数据</span></span><br><span class="line">   df = pd.DataFrame(</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="string">&#x27;关键字&#x27;</span>: kw_list, <span class="string">&#x27;页码&#x27;</span>: page_list, <span class="string">&#x27;标题&#x27;</span>: title_list,  <span class="string">&#x27;百度链接&#x27;</span>: href_list, </span><br><span class="line">         <span class="string">&#x27;真实链接&#x27;</span>: real_url_list, <span class="string">&#x27;更新时间&#x27;</span>: time_list, <span class="string">&#x27;简介&#x27;</span>: desc_list,</span><br><span class="line">         <span class="string">&#x27;网站名称&#x27;</span>: site_list,</span><br><span class="line">      &#125;</span><br><span class="line">   )</span><br><span class="line">   <span class="keyword">if</span> os.path.exists(v_result_file):</span><br><span class="line">         header = <span class="literal">None</span>   <span class="comment"># 已存在的csv文件保存时不用加标头</span></span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">         <span class="comment"># 创建新文件时，设置csv文件标头</span></span><br><span class="line">         header = [<span class="string">&#x27;关键词&#x27;</span>, <span class="string">&#x27;页码&#x27;</span>, <span class="string">&#x27;标题&#x27;</span>, <span class="string">&#x27;百度链接&#x27;</span>, <span class="string">&#x27;真实链接&#x27;</span>, <span class="string">&#x27;更新时间&#x27;</span>, <span class="string">&#x27;简介&#x27;</span>, <span class="string">&#x27;网站名称&#x27;</span>] </span><br><span class="line">   df.to_csv(v_result_file, mode=<span class="string">&#x27;a+&#x27;</span>, index=<span class="literal">False</span>, header=header, encoding=<span class="string">&#x27;utf_8_sig&#x27;</span>)</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;结果保存成功:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(v_result_file))</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="爬虫框架"><a href="#爬虫框架" class="headerlink" title="爬虫框架"></a><strong>爬虫框架</strong></h3><ul>
<li>Scrapy：一个强大的Python爬虫框架，提供了高级功能如异步处理、中间件等。   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy startproject myproject</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="动态网页爬取"><a href="#动态网页爬取" class="headerlink" title="动态网页爬取"></a><strong>动态网页爬取</strong></h3><ul>
<li>使用Selenium或Headless浏览器模拟浏览器行为。</li>
<li>处理JavaScript渲染的页面。</li>
</ul>
<hr>

<h1 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h1><ol>
<li>利用 Anaconda，创建不同版本的虚拟环境，配置不同的包（如不同版本的 Pytorch），以管理不同的项目。</li>
<li>用 Pycharm 打开项目时，点击添加解释器 —&gt; 添加本地解释器，选择该项目对应的 conda 虚拟环境下，该虚拟环境的 python 解释器。选择使用这个虚拟环境对应的编辑器，就是选择了使用这个环境运行项目，使用这个环境中配好的包等等。</li>
<li>所以要注意终端使用的是哪个编辑器，是否与当前项目使用的编辑器匹配。否则 pip install 把包装到一个虚拟环境，而当前项目运行在另一个虚拟环境中，便无法 import 已安装的包。</li>
</ol>
<h3 id="新建虚拟环境"><a href="#新建虚拟环境" class="headerlink" title="新建虚拟环境"></a>新建虚拟环境</h3><p>打开Anaconda Prompt，创建一个名字为py36的python版本为3.6的虚拟环境（默认地址已改成D:\anaconda3\envs），并查看已有环境：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(base) C:\Users\cf&gt;conda create -n py36 python=3.6</span><br><span class="line">Proceed ([y]/n)? y</span><br><span class="line">(base) C:\Users\cf&gt;conda <span class="built_in">env</span> list</span><br><span class="line"><span class="comment"># conda environments:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">  base                  *  D:\anaconda3</span><br><span class="line">  py36                     D:\anaconda3\envs\py36</span><br></pre></td></tr></table></figure>

<p>激活（切换）环境，并查看该环境下已有包：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(base) C:\Users\cf&gt;conda activate py36</span><br><span class="line">(py36) C:\Users\cf&gt;pip list</span><br></pre></td></tr></table></figure>
<h3 id="装包"><a href="#装包" class="headerlink" title="装包"></a>装包</h3><p>方法1：在 Anaconda Prompt 中进入该环境后，执行 conda install … 或 pip install …(需要关闭代理)<br>方法2：在 Pycharm的terminal（终端），执行安装指令（此时所处的是 Pycharm终端 的环境（不一定是此时加载的项目的环境））</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其他pip指令</span></span><br><span class="line">pip list                                     <span class="comment"># 列出所有已安装的pip包</span></span><br><span class="line">pip install package_name==desired_version    <span class="comment"># 安装指定版本的Python包</span></span><br><span class="line">pip install --target=... package_name        <span class="comment"># 指定pip install包的路径</span></span><br><span class="line">pip show package_name                        <span class="comment"># 查看安装好的包的信息</span></span><br></pre></td></tr></table></figure>

<h3 id="Jupyter-Notebook"><a href="#Jupyter-Notebook" class="headerlink" title="Jupyter Notebook"></a>Jupyter Notebook</h3><p><font color= "#87CEFA  "><strong>以任意行为块，便于代码阅读和测试修改。</strong></font> 在一个环境中安装 jupyter notebook 后，运行:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(py36) C:\Users\cf&gt;jupyter notebook        </span><br></pre></td></tr></table></figure>
<p>在浏览器打开8888端口使用 <a target="_blank" rel="noopener" href="http://localhost:8888/?token=7e39781c1e364fa7a5ee95ef290ffa92eb0caef0c19aaad8">http://localhost:8888/?token=7e39781c1e364fa7a5ee95ef290ffa92eb0caef0c19aaad8</a></p>
<hr>

<h1 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h1><p>Django是一个基于Python的开源Web应用框架，它遵循 MTV 框架，与传统的 MVC 有一些区别，但是其基本思想和流程是类似的，旨在简化Web开发过程，提高开发效率，同时保持代码的可读性和可维护性。</p>
<h3 id="MTV-架构"><a href="#MTV-架构" class="headerlink" title="MTV 架构"></a>MTV 架构</h3><ol>
<li>Model（模型）：负责处理数据逻辑，定义数据库模型（ORM），进行数据的增删改查操作。</li>
<li>Template（模板）：负责呈现用户界面，包含 HTML、CSS、JavaScript 等前端代码，展示数据给用户。</li>
<li>View（视图）： 处理用户请求，根据请求调用适当的模型和模板，返回响应给用户。<img src="https://github.com/leo710aka/bk/blob/main/djg1.png?raw=true" width="400" height="300" alt=""></li>
</ol>
<h3 id="MTV-流程"><a href="#MTV-流程" class="headerlink" title="MTV 流程"></a>MTV 流程</h3><ol>
<li>用户发起请求Request到 Django 服务器。</li>
<li>Django 的 URL 配置根据请求的 URL 路径找到对应的视图（View）函数。</li>
<li>视图函数处理请求，可能需要进行数据库操作，调用模型（Model）获取数据。</li>
<li>视图函数将获取的数据传递给模板（Template），并渲染生成最终的 HTML 页面。</li>
<li>服务器将生成的 HTML 页面作为响应Response返回给用户。<img src="https://github.com/leo710aka/bk/blob/main/djg2.png?raw=true" width="700" height="300" alt=""></li>
</ol>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><ol>
<li>项目目录：包含整个 Django 项目的配置和管理文件，settings.py、urls.py、wsgi.py（WSGI 入口）、asgi.py（ASGI 入口）等。</li>
<li>应用目录：包含具体的应用程序代码和文件，models.py（模型）、views.py（视图）、urls.py（应用URL配置）、templates&#x2F; 等。</li>
<li>静态文件目录： 存放静态资源文件，如 CSS、JavaScript、图片等。默认路径是项目目录下的 static&#x2F; 文件夹。</li>
<li>模板目录： 存放 HTML 模板文件。 默认路径是应用目录下的 templates&#x2F; 文件夹。</li>
<li>数据库文件：默认情况下，Django 使用 SQLite 作为默认数据库，并将数据库文件存放在项目目录下的 db.sqlite3 文件中。<br><strong>一个Django项目（project）就是一个基于Django的Web应用，一个Django项目包含一组配置和若干个Django应用</strong><br><strong>一个Django应用（blog）就是一个可重用的Python软件包，每个应用可以自己管理模型、视图、模板、路由和静态文件等</strong><img src="https://github.com/leo710aka/bk/blob/main/djg3.png?raw=true" width="700" height="300" alt=""></li>
</ol>
<h3 id="几个入门命令"><a href="#几个入门命令" class="headerlink" title="几个入门命令"></a>几个入门命令</h3><ul>
<li>文件路径cmd  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd E:/.../mainproject                  <span class="comment"># 一定要把终端路径切换成项目根目录！！！</span></span><br><span class="line">django-admin startproject mainproject  <span class="comment"># 创建项目，生成工程目录</span></span><br><span class="line">python manage.py startapp firstWEB     <span class="comment"># 创建APP(进入工程目录/IDE console)</span></span><br><span class="line">python manage.py makemigrations        <span class="comment"># 创建库表(进入工程目录/IDE console)</span></span><br><span class="line">python manage.py migrate               <span class="comment"># 执行库表建立(进入工程目录/IDE console)</span></span><br><span class="line">python manage.py runserver             <span class="comment"># 启动项目(进入IDE console)</span></span><br></pre></td></tr></table></figure></li>
<li>几个入门设置（settings.py）：Django 框架时间设置，Django APP添加，Templates目录设置(在APP日录下，需要独立建立)</li>
</ul>
<h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><ul>
<li>实现一个请求view，访问 <strong>主项目project</strong> 中的 <strong>blog应用</strong> 的hello_world接口 <ol>
<li>编写应用请求 project&#x2F;blog&#x2F;views.py  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&quot;2323&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li>配置应用路由 project&#x2F;blog&#x2F;urls.py  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;hello_world&#x27;</span>, blog.views.hello_world)</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li>配置项目路由 project&#x2F;project&#x2F;urls.py  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    <span class="comment"># 如果url中含有 &#x27;blog&#x27;，就转发到应用层面的路由处理</span></span><br><span class="line">    path(<span class="string">&#x27;blog/&#x27;</span>, include(<span class="string">&#x27;blog.urls&#x27;</span>))</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li>添加blog应用到项目配置中 project&#x2F;project&#x2F;settings.py  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="string">&#x27;blog.apps.BlogConfig&#x27;</span>, <span class="comment"># 创建APP时自动创建</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>请求转发流程 <a target="_blank" rel="noopener" href="http://127.0.0.1:8000/blog/">http://127.0.0.1:8000/blog/</a><br>浏览器 –(项目路由)–&gt; Blog App –&gt; view.py –(应用路由)–&gt; hello_world函数 –&gt; 浏览器</li>
</ul>
<h2 id="模型层"><a href="#模型层" class="headerlink" title="模型层"></a>模型层</h2><ul>
<li>模型层是什么？<ul>
<li>模型层：位于Django视图层和数据库之间, Python对象和数据库表之间转换</li>
<li>模型层作用：屏蔽不同数据库之间的差异, 开发者更加专注于业务逻辑的开发, 提供很多便捷工具有助开发</li>
<li>模型层配置 project&#x2F;project&#x2F;settings.py  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.sqlite3&#x27;</span>,  <span class="comment"># 自带的数据库</span></span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>: BASE_DIR / <span class="string">&#x27;db.sqlite3&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>模型 Model：Model是数据库表的抽象表示。<ul>
<li>每个模型都继承自django.db.models.Model类，并定义了一组字段（Field），这些字段对应于数据库表中的列。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Author</span>(models.Model):  <span class="comment"># Author模型有两个字段：name和email</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">100</span>)  </span><br><span class="line">    email = models.EmailField()  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span>(models.Model):    <span class="comment"># Book模型有一个title字段和一个指向Author模型的外键</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">200</span>)  </span><br><span class="line">    author = models.ForeignKey(Author, on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure></li>
<li>一旦你定义了模型，Django就会自动为你生成一个数据库表（除非你明确告诉它不要这样做）。然后，你可以使用Django的ORM（对象关系映射）API来查询、创建、更新和删除数据库中的记录。以下是一些基本示例：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取所有作者  </span></span><br><span class="line">authors = Author.objects.<span class="built_in">all</span>()  </span><br><span class="line"><span class="comment"># 获取标题为&quot;Django教程&quot;的书  </span></span><br><span class="line">book = Book.objects.get(title=<span class="string">&quot;Django教程&quot;</span>)</span><br><span class="line"><span class="comment"># 创建一个新作者  </span></span><br><span class="line">new_author = Author.objects.create(name=<span class="string">&quot;John Doe&quot;</span>, email=<span class="string">&quot;john@example.com&quot;</span>)  </span><br><span class="line"><span class="comment"># 创建一个新书，并将其与作者关联  </span></span><br><span class="line">new_book = Book.objects.create(title=<span class="string">&quot;Django入门&quot;</span>, author=new_author)</span><br><span class="line"><span class="comment"># 获取并更新一本书的标题  </span></span><br><span class="line">book = Book.objects.get(title=<span class="string">&quot;Django教程&quot;</span>)  </span><br><span class="line">book.title = <span class="string">&quot;Django进阶&quot;</span>  </span><br><span class="line">book.save()</span><br><span class="line"><span class="comment"># 删除一本书  </span></span><br><span class="line">book = Book.objects.get(title=<span class="string">&quot;Django进阶&quot;</span>)  </span><br><span class="line">book.delete()</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>迁移 Migrations：Django框架中用于管理数据库模式更改的一种强大工具。<ul>
<li>当你更改Django模型（Model）时（例如添加、删除或修改字段），Django能够自动计算出需要应用到数据库中的更改，并将这些更改保存为迁移文件。然后，你可以使用Django的迁移命令将这些更改应用到数据库中。</li>
<li>创建迁移文件  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations  <span class="comment"># IDE console</span></span><br></pre></td></tr></table></figure></li>
<li>运行迁移文件 同步sqlite3数据库  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py migrate  <span class="comment"># IDE console</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Django shell操作<ul>
<li>Django shell：继承Django项目环境，用于交互的Python编程，方便快捷</li>
<li>新建文章：IDE console操作  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py shell  <span class="comment"># 进入 Djungo shell</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from blog.models import Article  <span class="comment"># 导入模型</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; a = Article()                    <span class="comment"># 创建文章</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; a.title = <span class="string">&#x27;Test Django Shell&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; a.brief = <span class="string">&#x27;...&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; a.save()                         <span class="comment"># 保存文章</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; articles = Article.objects.all() <span class="comment"># 获取文章</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(articles[0].title)</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Django Admin模块<ul>
<li>Django的后台管理工具，简化Djungo shell的使用；直接读取定义的模型元数据，提供强大的管理使用页面</li>
<li>Django的使用  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py createsuperuser  <span class="comment"># 创建管理员用户：caif / cxxxxxxx</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Article</span><br><span class="line"></span><br><span class="line">admin.site.register(Article)  <span class="comment"># 将模型注册到admin模块 project/blog/admin.py</span></span><br></pre></td></tr></table></figure>
  登录页面进行管理：<a target="_blank" rel="noopener" href="http://127.0.0.1:8000/admin/login/?next=/admin/%EF%BC%8C">http://127.0.0.1:8000/admin/login/?next=/admin/，</a> 选择模型，进行创建、修改、删除对象操作</li>
</ul>
</li>
<li>Model数据返回页面<ol>
<li>编写应用请求 project&#x2F;blog&#x2F;views.py  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> blog.models <span class="keyword">import</span> Article</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">article_content</span>(<span class="params">request</span>):  <span class="comment"># 就是返回处理过的model数据</span></span><br><span class="line">    article = Article.<span class="built_in">object</span>.<span class="built_in">all</span>()[<span class="number">0</span>]  <span class="comment"># 从sqlite3中获取对应模型的数据</span></span><br><span class="line">    ans_str = article.title + ...</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(ans_str)</span><br></pre></td></tr></table></figure></li>
<li>配置应用路由 project&#x2F;blog&#x2F;urls.py</li>
<li>配置项目路由 project&#x2F;project&#x2F;urls.py</li>
<li>添加blog应用到项目配置中 project&#x2F;project&#x2F;settings.py</li>
</ol>
</li>
</ul>
<h2 id="连接本地MySQL"><a href="#连接本地MySQL" class="headerlink" title="连接本地MySQL"></a>连接本地MySQL</h2><ul>
<li>默认情况下，Django连接的是自己带的sqlite数据库。好处是方便，不需要远程连接，打包项目挪到其他电脑上安装一下依赖一会就跑起来了，但是缺点就是，可能会出现各种莫名其面的问题，所以，尽可能在开始的时候，就配置上连接Mysql。</li>
<li>Django 连接 MySQL：<ul>
<li>安装 Python 访问 MySQL的 客户端模块  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install mysqlclient  <span class="comment"># Django官方已不建议使用pymysql库，而是改用mysqlclient</span></span><br></pre></td></tr></table></figure></li>
<li>修改 Django项目文件夹下的settings.py文件：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.mysql&#x27;</span>,   <span class="comment"># 使用MySQL引擎</span></span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>: <span class="string">&#x27;HKStock&#x27;</span>,                      <span class="comment"># 数据库名称</span></span><br><span class="line">        <span class="string">&#x27;USER&#x27;</span>: <span class="string">&#x27;root&#x27;</span>,                         <span class="comment"># 数据库用户名</span></span><br><span class="line">        <span class="string">&#x27;PASSWORD&#x27;</span>: <span class="string">&#x27;123456&#x27;</span>,                   <span class="comment"># 数据库密码</span></span><br><span class="line">        <span class="string">&#x27;HOST&#x27;</span>: <span class="string">&#x27;localhost&#x27;</span>,                    <span class="comment"># 数据库主机（如果在本地）</span></span><br><span class="line">        <span class="string">&#x27;PORT&#x27;</span>: <span class="string">&#x27;3306&#x27;</span>,                         <span class="comment"># 数据库端口（默认为3306）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Pycharm 连接 MySQL：点击 Pycharm右上角 database -&gt; “+” -&gt; source -&gt; MySQL，输入数据库名称、用户、密码连接成功</li>
<li>修改项目文件夹下的__init.py文件：要替换默认的数据库引擎，在项目文件夹下的__init__.py 添加以下内容。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">pymysql.install_as_MySQLdb()</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>定义模型 Model：将数据库 SQL 映射到面向对象的 Python 中来，使得你可以在 Django 中像操作普通对象一样操作数据库。</li>
<li>迁移 Migrations：定义好了Model，数据库中的表并不会神奇的出现，你还需要把模型转化为对数据库的操作，这就是迁移。<br>当你更改Django模型（Model）时（例如添加、删除或修改字段）Django能够自动计算出需要应用到数据库中的更改，并将这些更改保存为迁移文件。然后，你可以使用Django的迁移命令将这些更改应用到数据库中。</li>
<li>新model迁移：<ol>
<li>定义模型（mainapp&#x2F;models.py）  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">pen</span>(models.Model):</span><br><span class="line">    price = models.IntegerField()</span><br><span class="line">    color = models.CharField(default=<span class="string">&#x27;black&#x27;</span>, max_length=<span class="number">20</span>)</span><br></pre></td></tr></table></figure></li>
<li>创建迁移文件：指令执行完毕后会生成 mainapp&#x2F;migrations&#x2F;0001_initial.py 文件。Django 不会检查你的数据库，而是根据目前的模型的状态，创建一个操作列表，使项目状态与模型定义保持最新。  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations</span><br></pre></td></tr></table></figure></li>
<li>运行迁移文件：打开数据库可以看到多了 <code>mainapp_pen</code> 表，并且里面的字段和模型是完全匹配的。插入一些数据。  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py migrate </span><br></pre></td></tr></table></figure></li>
<li>功能demo  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编写url：在项目文件夹 datasite/urls.py</span></span><br><span class="line"><span class="keyword">from</span> mainapp <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;pen&#x27;</span>, views.pen) <span class="comment"># 配置项目url即可，无需配置应用url</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编写视图(views)：在应用文件夹web/views.py，操作model从MySQL中获取数据</span></span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Pen</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pen</span>(<span class="params">request</span>):</span><br><span class="line">    pen = Pen.objects.<span class="built_in">all</span>()</span><br><span class="line">    <span class="comment"># 结合html(templates/pen.html)展示数据</span></span><br><span class="line">    <span class="keyword">return</span> render(request，<span class="string">&quot;pen.html&quot;</span>，&#123;<span class="string">&quot;pen_queryset&quot;</span>:pen_queryset&#125;)</span><br></pre></td></tr></table></figure></li>
<li>启动web：<code>python manage.py runserver</code></li>
<li>发送请求：<code>http://127.0.0.1:8000/pen</code></li>
</ol>
</li>
<li><strong>操作MySQL中已有的表：</strong><ol>
<li>配置Django的数据库设置（项目级settings.py），确保已安装MySQL客户端并且设置好__init__.py文件。</li>
<li>创建Django模型：尽管数据库表已经存在，但仍需为这些表创建Django模型。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(models.Model):</span><br><span class="line">    name = models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    code = models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        db_table = <span class="string">&#x27;mainapp_student&#x27;</span>  <span class="comment"># 数据库中的实际表名，注意这里应该与你的数据库表名一致</span></span><br><span class="line">        managed = <span class="literal">False</span>   <span class="comment"># 指示Django该模型对应于现有的数据库表，不由Django迁移管理</span></span><br></pre></td></tr></table></figure></li>
<li>同步Django模型与数据库：只需<code>python manage.py makemigrations</code>，无需<code>python manage.py migrate</code> ？？</li>
<li>在Django中操作数据库表：使用Django的ORM API来查询、创建、更新和删除数据库中的记录了。</li>
</ol>
</li>
</ul>
<h2 id="视图与模版"><a href="#视图与模版" class="headerlink" title="视图与模版"></a>视图与模版</h2><ul>
<li>使用Bootstrap实现静态博客页面<ul>
<li>在 project&#x2F;blog&#x2F;template 下创建 index.html  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在 header 引入 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css&quot;</span> <span class="attr">integrity</span>=<span class="string">&quot;sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js&quot;</span> <span class="attr">integrity</span>=<span class="string">&quot;sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 静态代码块 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container page-header&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;text-center mb-4&quot;</span>&gt;</span>博客标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container page-body&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-9&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 博客详情1, 2, ... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-3&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 博客链接1, 2, ... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Django模板系统<ul>
<li>一个类似html的文本文件，结合view，实现动态页面。模板语法：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Blog Post&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123; post.title &#125;&#125;&lt;/h1&gt;</span><br><span class="line">   </span><br><span class="line">    &#123;% <span class="keyword">if</span> user.is_authenticated %&#125;</span><br><span class="line">        &lt;a href=<span class="string">&quot;&#123;% url &#x27;logout&#x27; %&#125;&quot;</span>&gt;Logout&lt;/a&gt;</span><br><span class="line">    &#123;% <span class="keyword">else</span> %&#125;</span><br><span class="line">        &lt;a href=<span class="string">&quot;&#123;% url &#x27;login&#x27; %&#125;&quot;</span>&gt;Login&lt;/a&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">    &#123;% <span class="keyword">for</span> comment in post.comments.all %&#125;</span><br><span class="line">        &lt;li&gt;&#123;&#123; comment.content &#125;&#125; - &#123;&#123; comment.author.username &#125;&#125;&lt;/li&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
<li>使用模板系统渲染博客页面<br>  在 Django 中，模板文件通常存储在每个应用的 <code>/templates</code>目录下。在应用view中渲染这个模板文件，并传递上下文数据：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment"># home_view 视图函数渲染了 home.html 模板，并向模板传递了两个变量：name 和 date</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">home_view</span>(<span class="params">request</span>):</span><br><span class="line">    context = &#123;</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;My Django Website&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;date&#x27;</span>: datetime.now(),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;home.html&#x27;</span>, context)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>: (</p>
<hr>

<h2 id="ECharts"><a href="#ECharts" class="headerlink" title="ECharts"></a>ECharts</h2><p>ECharts，一个使用 JavaScript 实现的开源可视化库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE9&#x2F;10&#x2F;11，Chrome，Firefox，Safari等），底层依赖矢量图形库 ZRender，提供直观，交互丰富，可高度个性化定制的数据可视化图表。<br><a target="_blank" rel="noopener" href="https://echarts.apache.org/">https://echarts.apache.org</a></p>
<ul>
<li>在项目中引入echarts<ul>
<li>在 <strong>mainapp&#x2F;static&#x2F;assets&#x2F;js&#x2F; 目录</strong>中保存 echarts.js</li>
<li>在 <strong>mainapp&#x2F;templates&#x2F;xx.html 文件</strong>中引入 echarts.js</li>
<li>示例：一个简单柱状图  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>ECharts<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入刚刚下载的 ECharts 文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;echarts.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 为 ECharts 准备一个定义了宽高的 DOM --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 600px;height:400px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 基于准备好的dom，初始化echarts实例</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> myChart = echarts.<span class="title function_">init</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;main&#x27;</span>));</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 指定图表的配置项和数据</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> option = &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">xAxis</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">data</span>: [<span class="string">&#x27;Mon&#x27;</span>, <span class="string">&#x27;Tue&#x27;</span>, <span class="string">&#x27;Wed&#x27;</span>, <span class="string">&#x27;Thu&#x27;</span>, <span class="string">&#x27;Fri&#x27;</span>, <span class="string">&#x27;Sat&#x27;</span>, <span class="string">&#x27;Sun&#x27;</span>]</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">yAxis</span>: &#123;&#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">series</span>: [</span></span><br><span class="line"><span class="language-javascript">            &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">type</span>: <span class="string">&#x27;bar&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">data</span>: [<span class="number">23</span>, <span class="number">24</span>, <span class="number">18</span>, <span class="number">25</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">25</span>]</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        ]</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 使用刚指定的配置项和数据显示图表。</span></span></span><br><span class="line"><span class="language-javascript">    myChart.<span class="title function_">setOption</span>(option);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>传入数据渲染echarts模版：<ol>
<li>在view函数中准备数据，比如一个Python列表或字典；通过渲染函数（render()）将数据传递到模板中；  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render  </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chart_view</span>(<span class="params">request</span>):  </span><br><span class="line">    <span class="comment"># 准备数据</span></span><br><span class="line">    x_axis_data = [<span class="string">&#x27;Mon&#x27;</span>, <span class="string">&#x27;Tue&#x27;</span>, <span class="string">&#x27;Wed&#x27;</span>, <span class="string">&#x27;Thu&#x27;</span>, <span class="string">&#x27;Fri&#x27;</span>, <span class="string">&#x27;Sat&#x27;</span>, <span class="string">&#x27;Sun&#x27;</span>]</span><br><span class="line">    y_axis_data = [<span class="number">23</span>, <span class="number">24</span>, <span class="number">18</span>, <span class="number">25</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">55</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将数据传递给模板</span></span><br><span class="line">    context = &#123;</span><br><span class="line">        <span class="string">&#x27;x_axis_data_json&#x27;</span>: json.dumps(x_axis_data),  <span class="comment"># JSON 字符串形式的数据</span></span><br><span class="line">        <span class="string">&#x27;y_axis_data_json&#x27;</span>: json.dumps(y_axis_data),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;2.html&#x27;</span>, context)</span><br></pre></td></tr></table></figure></li>
<li>复制示例模版from <a target="_blank" rel="noopener" href="https://echarts.apache.org/examples/zh/index.html%EF%BC%8C">https://echarts.apache.org/examples/zh/index.html，</a> 使用 Django模板标签将数据嵌入到 js代码中  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>ECharts<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 引入ECharts文件，确保路径正确 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;echarts.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 600px;height:400px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 基于准备好的dom，初始化echarts实例</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> myChart = echarts.<span class="title function_">init</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;main&#x27;</span>));</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 从 Django 模板上下文中取出数据，并转换为 JavaScript 数组</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> x_axis_data = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="string">&#x27;&#123;&#123; x_axis_data_json|escapejs &#125;&#125;&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> y_axis_data = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="string">&#x27;&#123;&#123; y_axis_data_json|escapejs &#125;&#125;&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 指定图表的配置项和数据</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> option = &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">xAxis</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">type</span>: <span class="string">&#x27;category&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">data</span>: x_axis_data  <span class="comment">// 使用从 Django 传递的数据</span></span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">yAxis</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">type</span>: <span class="string">&#x27;value&#x27;</span></span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">series</span>: [</span></span><br><span class="line"><span class="language-javascript">                &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">data</span>: y_axis_data,  <span class="comment">// 使用从 Django 传递的数据</span></span></span><br><span class="line"><span class="language-javascript">                <span class="attr">type</span>: <span class="string">&#x27;bar&#x27;</span></span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            ]</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 使用刚指定的配置项和数据显示图表。</span></span></span><br><span class="line"><span class="language-javascript">        myChart.<span class="title function_">setOption</span>(option);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/09/01/Python_Anaconda_Django/" data-id="clzzl7c2c000eu0v5clucdqna" data-title="Python / Anaconda / Django" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Redis" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/10/Redis/" class="article-date">
  <time class="dt-published" datetime="2022-06-10T03:49:42.000Z" itemprop="datePublished">2022-06-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/10/Redis/">Redis</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Redis是一种支持 key-value 等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。 默认端口：<strong>6379</strong></p>
<h2 id="启动-Redis"><a href="#启动-Redis" class="headerlink" title="启动 Redis"></a>启动 Redis</h2><p>下载 Windows版 msi文件：<a target="_blank" rel="noopener" href="https://github.com/microsoftarchive/redis/releases">https://github.com/microsoftarchive/redis/releases</a><br>在环境变量中配好 Redis 的安装目录后，直接打开 cmd，启动 Redis 客户端<br>启动客户端后, 在客户端cmd窗口中测试 Redis 是否正常工作，设置密码（<strong>命令行设置的密码在服务重启后失效</strong>）<br>注意：<strong>在 Windows 环境下，Redis 不支持后台运行模式，因此在启动 Redis 服务器时必须保持 cmd 窗口一直打开</strong>。（如果想要在后台运行 Redis，可以考虑使用虚拟机或者 Linux 环境下的 Redis）</p>
<ul>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\蔡枫&gt;redis-cli   <span class="comment"># 启动 Redis 客户端（默认Redis服务端未关闭）</span></span><br><span class="line">127.0.0.1:6379&gt; ping                                <span class="comment"># 在 Redis 客户端中输入 ping 命令</span></span><br><span class="line">PONG                                                <span class="comment"># 返回 PONG 表示 正常工作</span></span><br><span class="line">127.0.0.1:6379&gt; config <span class="built_in">set</span> requirepass chskj.2020   <span class="comment"># 修改密码</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; auth chskj.2020                     <span class="comment"># 验证密码</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass              <span class="comment"># 查看密码</span></span><br><span class="line">1)<span class="string">&quot;requirepass&quot;</span></span><br><span class="line">2)<span class="string">&quot;chskj.2020&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="启动-重启-Redis-服务器，客户端"><a href="#启动-重启-Redis-服务器，客户端" class="headerlink" title="启动(重启) Redis 服务器，客户端"></a>启动(重启) Redis 服务器，客户端</h3><p>进入 Redis 的安装目录(D:\Redis)，打开 cmd 窗口(地址栏cmd回车)，执行 redis-server.exe redis.windows.conf，即可<strong>启动 Redis 服务器</strong>。<br>启动Redis服务器后，在 Redis 安装目录打开另一个 cmd 窗口，执行 redis-cli.exe，(或直接双击文件夹中的redis-cli.exe)即可<strong>启动（重启）Redis 客户端</strong>。</p>
<h3 id="库"><a href="#库" class="headerlink" title="库"></a>库</h3><p>Redis中有16个数据库（Database），每个数据库都是一个独立的命名空间，用于存储键值对数据。这些数据库被编号为0到15，默认情况下客户端连接到数据库0。可以通过<code>SELECT</code>命令选择数据库来切换不同的数据库空间，每个数据库都是相互隔离的，数据不会互相干扰。<br>每个数据库都可以包含键值对数据，命令和配置，但请注意，Redis的每个数据库是相对较小的，因此可以将不同类型的数据存储在不同的数据库中，以便更好地组织和管理数据。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 1   <span class="comment"># 切换到数据库1</span></span><br></pre></td></tr></table></figure>


<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Redis所有的key（键）都是字符串。我们在<strong>谈基础数据结构时，讨论的是存储值的数据类型</strong>，主要包括常见的5种数据类型，分别是：String、List、Set、Zset、Hash。 三种特殊的数据类型，分别是 HyperLogLogs（基数统计），Bitmaps (位图) 和 geospatial（地理位置）。 Redis5.0 中还增加了一个数据结构Stream，它借鉴了Kafka的设计，是一个新的强大的支持多播的可持久化的消息队列。</p>
<!-- ![](https://pdai.tech/images/db/redis/db-redis-object-2-2.png) -->
<table>
<thead>
<tr>
<th>结构类型</th>
<th>结构存储的值</th>
<th>结构的读写能力</th>
</tr>
</thead>
<tbody><tr>
<td><strong>String字符串</strong></td>
<td>可以是字符串、整数或浮点数</td>
<td>对整个字符串或字符串的一部分进行操作；对整数或浮点数进行自增或自减操作；</td>
</tr>
<tr>
<td><strong>List列表</strong></td>
<td>一个链表，链表上的每个节点都包含一个字符串</td>
<td>对链表的两端进行push和pop操作，读取单个或多个元素；根据值查找或删除元素；</td>
</tr>
<tr>
<td><strong>Set集合包</strong></td>
<td>含字符串的无序集合</td>
<td>字符串的集合，包含基础的方法有看是否存在添加、获取、删除；还包含计算交集、并集、差集等</td>
</tr>
<tr>
<td><strong>Hash散列</strong></td>
<td>包含键值对的无序散列表</td>
<td>包含方法有添加、获取、删除单个元素</td>
</tr>
<tr>
<td><strong>Zset有序集合</strong></td>
<td>和散列一样，用于存储键值对字符串成员与浮点数分数之间的有序映射；元素的排列顺序由分数的大小决定；</td>
<td>包含方法有添加、获取、删除单个元素以及根据分值范围或成员来获取元素</td>
</tr>
</tbody></table>
<h3 id="String字符串"><a href="#String字符串" class="headerlink" title="String字符串"></a>String字符串</h3><ul>
<li>String是redis中最基本的数据类型，一个key对应一个value。</li>
<li>String类型是二进制安全的，意思是 redis 的 string 可以包含任何数据。如数字，字符串，jpg图片或者序列化的对象。</li>
<li>实战场景<ul>
<li>缓存： 经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力。</li>
<li>计数器：redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。session：常见方案spring session + redis实现session共享，</li>
</ul>
</li>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> hello world    <span class="comment"># 设置存储在给定键中的值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get hello          <span class="comment"># 获取存储在给定键中的值</span></span><br><span class="line"><span class="string">&quot;world&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; del hello          <span class="comment"># 删除存储在给定键中的值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> counter 2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get counter       </span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; incr counter       <span class="comment"># 将键存储的值加1</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; get counter</span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; incrby counter 100 <span class="comment"># 将键存储的值加上整数</span></span><br><span class="line">(<span class="built_in">integer</span>) 103</span><br><span class="line">127.0.0.1:6379&gt; get counter</span><br><span class="line"><span class="string">&quot;103&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; decr counter       <span class="comment"># 将键存储的值减1</span></span><br><span class="line">(<span class="built_in">integer</span>) 102</span><br><span class="line">127.0.0.1:6379&gt; get counter</span><br><span class="line"><span class="string">&quot;102&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="List列表"><a href="#List列表" class="headerlink" title="List列表"></a>List列表</h3><ul>
<li>Redis中的List其实就是链表（Redis用双端链表实现List）。</li>
<li>使用List结构，我们可以轻松地实现最新消息排队功能（比如新浪微博的TimeLine）。List的另一个应用就是消息队列，可以利用List的 PUSH 操作，将任务存放在List中，然后工作线程再用 POP 操作将任务取出进行执行。</li>
<li>使用列表的技巧：lpush+lpop&#x3D;Stack(栈)，lpush+rpop&#x3D;Queue（队列），lpush+ltrim&#x3D;Capped Collection（有限集合），lpush+brpop&#x3D;Message Queue（消息队列）</li>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush mylist 1 2 ll <span class="built_in">ls</span> mem   <span class="comment"># 将给定值推入到列表左端，RPUSH 将给定值推入到列表右端</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1           <span class="comment"># 获取列表在给定范围上的所有值</span></span><br><span class="line">1) <span class="string">&quot;mem&quot;</span></span><br><span class="line">2) <span class="string">&quot;ls&quot;</span></span><br><span class="line">3) <span class="string">&quot;ll&quot;</span></span><br><span class="line">4) <span class="string">&quot;2&quot;</span></span><br><span class="line">5) <span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lindex mylist -1             <span class="comment"># 可以使用负数下标，以 -n 表示列表的倒数第n个元素</span></span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; rpop mylist                  <span class="comment"># 从列表的右端弹出一个值，并返回被弹出的值；lpop 从左弹</span></span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lindex mylist 10             <span class="comment"># index不在 mylist 的区间范围内</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><ul>
<li>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</li>
<li>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</li>
<li>实战场景<ul>
<li>标签（tag）,给用户添加标签，或用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人。</li>
<li>点赞，或点踩，收藏等，可以放到set中实现</li>
</ul>
</li>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myset hao hao1 xiaohao hao  <span class="comment"># 向集合添加一个或多个成员	</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; scard myset                      <span class="comment"># 获取集合的成员数	</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; smembers myset                   <span class="comment"># 返回集合中的所有成员	</span></span><br><span class="line">1) <span class="string">&quot;xiaohao&quot;</span></span><br><span class="line">2) <span class="string">&quot;hao1&quot;</span></span><br><span class="line">3) <span class="string">&quot;hao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; sismember myset hao              <span class="comment"># 判断 member 元素是否是集合 key 的成员</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Hash散列"><a href="#Hash散列" class="headerlink" title="Hash散列"></a>Hash散列</h3><ul>
<li>Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</li>
<li>实战场景 - 缓存： 能直观，相比string更节省空间，的维护缓存信息，如用户信息，视频信息等。</li>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset user name1 hao               <span class="comment"># 添加键值对	</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hset user email1 hao@163.com</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall user                      <span class="comment"># 获取散列中包含的所有键值对	</span></span><br><span class="line">1) <span class="string">&quot;name1&quot;</span></span><br><span class="line">2) <span class="string">&quot;hao&quot;</span></span><br><span class="line">3) <span class="string">&quot;email1&quot;</span></span><br><span class="line">4) <span class="string">&quot;hao@163.com&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hget user user                    <span class="comment"># 获取指定散列键的值</span></span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; hget user name1</span><br><span class="line"><span class="string">&quot;hao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hset user name2 xiaohao</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hdel user name1                   <span class="comment"># 如果给定键存在于散列中，那么就移除这个键</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall user</span><br><span class="line">1) <span class="string">&quot;email1&quot;</span></span><br><span class="line">2) <span class="string">&quot;hao@163.com&quot;</span></span><br><span class="line">3) <span class="string">&quot;name2&quot;</span></span><br><span class="line">4) <span class="string">&quot;xiaohao&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Zset有序集合"><a href="#Zset有序集合" class="headerlink" title="Zset有序集合"></a>Zset有序集合</h3><ul>
<li>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。</li>
<li>有序集合的成员是唯一的, 但分数(score)却可以重复。有序集合是通过两种数据结构实现：<ol>
<li>压缩列表(ziplist): ziplist是为了提高存储效率而设计的一种特殊编码的双向链表。它可以存储字符串或者整数，存储整数时是采用整数的二进制而不是字符串形式存储。它能在O(1)的时间复杂度下完成list两端的push和pop操作。但是因为每次操作都需要重新分配ziplist的内存，所以实际复杂度和ziplist的内存使用量相关</li>
<li>跳跃表(zSkiplist): 跳跃表的性能可以保证在查找，删除，添加等操作的时候在对数期望时间内完成，这个性能是可以和平衡树来相比较的，而且在实现方面比平衡树要优雅，这是采用跳跃表的主要原因。跳跃表的复杂度是O(log(n))。</li>
</ol>
</li>
<li>实战场景 - 排行榜：有序集合经典使用场景。例如小说视频等网站需要对用户上传的小说视频做排行榜，榜单可以按照用户关注数，更新时间，字数等打分，做排行。</li>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd myscoreset 100 hao 90 xiaohao  <span class="comment"># 将一个带有给定分值的成员添加到有序集合里面</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myscoreset 0 -1            <span class="comment"># 根据元素在有序集合中所处位置，从有序集合中获取多个元素</span></span><br><span class="line">1) <span class="string">&quot;xiaohao&quot;</span></span><br><span class="line">2) <span class="string">&quot;hao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZSCORE myscoreset hao</span><br><span class="line"><span class="string">&quot;100&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrem myscoreset hao               <span class="comment"># 如果给定元素成员存在于有序集合中，那么就移除这个元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>采用一种基数算法，用于完成独立总数的统计。（同一个人多次访问，只记一访问量）（独立访客）<br>占据空间小，无论统计多少个数据，只占12K的内存空间<br>不精确的统计算法，标准误差为 0.81%。</p>
<h3 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h3><p>不是一种独立的数据结构，实际上就是字符串<br>支持按位存取数据，可以将其看成是byte数组<br>适合存储索大量的连续的数据的布尔值。（记录一个人连续一年每天的签到情况 0&#x2F;1）（日活跃用户）</p>
<hr>


<h2 id="RedisTemplate"><a href="#RedisTemplate" class="headerlink" title="RedisTemplate"></a>RedisTemplate</h2><ul>
<li>Spring Boot提供了<code>RedisTemplate</code>作为与Redis交互的强大工具。通过<code>RedisTemplate</code>，您可以在java项目中执行各种Redis命令来操作数据，包括字符串、列表、集合、散列、有序集合等。以下是一些常见的Redis操作示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储数据：</span></span><br><span class="line">redisTemplate.opsForValue().set(<span class="string">&quot;myKey&quot;</span>, <span class="string">&quot;myValue&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (String) redisTemplate.opsForValue().get(<span class="string">&quot;myKey&quot;</span>);</span><br><span class="line"><span class="comment">// 列表操作：</span></span><br><span class="line">redisTemplate.opsForList().leftPush(<span class="string">&quot;myList&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">List&lt;String&gt; myList = redisTemplate.opsForList().range(<span class="string">&quot;myList&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 集合操作：</span></span><br><span class="line">redisTemplate.opsForSet().add(<span class="string">&quot;mySet&quot;</span>, <span class="string">&quot;member1&quot;</span>, <span class="string">&quot;member2&quot;</span>);</span><br><span class="line">Set&lt;String&gt; mySet = redisTemplate.opsForSet().members(<span class="string">&quot;mySet&quot;</span>);</span><br><span class="line"><span class="comment">// 散列操作：</span></span><br><span class="line">Map&lt;String, String&gt; myHash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">myHash.put(<span class="string">&quot;field1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">myHash.put(<span class="string">&quot;field2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">redisTemplate.opsForHash().putAll(<span class="string">&quot;myHash&quot;</span>, myHash);</span><br><span class="line"><span class="type">String</span> <span class="variable">fieldValue</span> <span class="operator">=</span> (String) redisTemplate.opsForHash().get(<span class="string">&quot;myHash&quot;</span>, <span class="string">&quot;field1&quot;</span>);</span><br><span class="line"><span class="comment">// 有序集合操作：</span></span><br><span class="line">redisTemplate.opsForZSet().add(<span class="string">&quot;myZSet&quot;</span>, <span class="string">&quot;member1&quot;</span>, <span class="number">1.0</span>);</span><br><span class="line">Set&lt;String&gt; myZSet = redisTemplate.opsForZSet().range(<span class="string">&quot;myZSet&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li>
<li>公共命令<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redisTemplate.delete(key);  <span class="comment">// 删除一个数据结构</span></span><br><span class="line">redisTemplate.hasKey(key);  <span class="comment">// 是否存在一个数据结构</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Redis-事务管理"><a href="#Redis-事务管理" class="headerlink" title="Redis 事务管理"></a>Redis 事务管理</h3><ul>
<li>要使用编程式事务<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTransaction</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">SessionCallback</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">execute</span><span class="params">(RedisOperations redisOperations)</span> <span class="keyword">throws</span> DataAccessException &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> <span class="string">&quot;text:tx&quot;</span>;           </span><br><span class="line">            redisOperations.multi();         <span class="comment">// 启用事务</span></span><br><span class="line">            redisOperations.opsForSet().add(redisKey, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">            redisOperations.opsForSet().add(redisKey, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">            redisOperations.opsForSet().add(redisKey, <span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">            <span class="comment">// redis事务内做查询，无效</span></span><br><span class="line">            <span class="comment">// redis事务中的所有代码在事务提交后一起执行</span></span><br><span class="line">            System.out.println(redisOperations.opsForSet().members(redisKey));            </span><br><span class="line">            <span class="keyword">return</span> redisOperations.exec();   <span class="comment">// 提交事务</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>


<h2 id="Redis缓存问题"><a href="#Redis缓存问题" class="headerlink" title="Redis缓存问题"></a>Redis缓存问题</h2><p>在高并发的业务场景下，数据库大多数情况都是用户并发访问最薄弱的环节。所以，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问Mysql等数据库。这样可以大大缓解数据库的压力。<strong>当缓存库出现时，必须要考虑如下问题：</strong></p>
<ol>
<li><strong>缓存穿透</strong><ul>
<li>问题来源<br> 缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求。由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义，<br> 在流量大时，可能DB就挂掉了，要是有人利用不存在的kev频繁攻击我们的应用，这就是漏洞.<br> 如发起为id为”-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</li>
<li>1、接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;&#x3D;0的直接拦截<br> 2、从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒 (设置太长会导致正常情况也没法使用)。这样可以防止攻击用户反复用同一个id暴力攻击<br> 3、布隆过滤器。bloomfilter就类似于一个hash set，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断个key是否存在于某容器，不存在就直接返回。布隆过滤器的关键就在于hash算法和容器大小，</li>
</ul>
</li>
<li><strong>缓存击穿</strong><ul>
<li>问题来源：    缓存击穿是指缓存中没有但数据库中有的数据(一般是缓存时间到期)，这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力.</li>
<li>1、设置热点数据永远不过期<br> 2、接口限流与熔断，降级。重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些 &#x2F;3务不可用时候，进行熔断，失败快速返回机制。<br> 3、加互斥锁</li>
</ul>
</li>
<li><strong>缓存雪崩</strong><ul>
<li>问题来源： 缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</li>
<li>1、缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生<br> 2、如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中<br> 3、设置热点数据永远不过期.</li>
</ul>
</li>
<li><strong>缓存污染(或满了)</strong><ul>
<li>缓存污染问题说的是缓存中一些只会被访问一次或者几次的的数据，被访问完后，再也不会被访问到，但这部分数据依然留存在缓存中，消耗缓存空间.</li>
<li>缓存污染会随着数据的持续增加而逐渐显露，随着服务的不新运行，缓存中会存在大量的永远不会再次被访问的数据。缓存空间是有限的，如果缓存空间满了，再往缓存里写数据时就会有额外开销，影响Redis性能。这部分额外开销主要是指写的时候判断淘汰策略，根据淘汰策略去选择要淘汰的数据，然后进行删除操作。</li>
</ul>
</li>
</ol>
<h3 id="缓存淘汰策略"><a href="#缓存淘汰策略" class="headerlink" title="缓存淘汰策略"></a>缓存淘汰策略</h3><p>Redis共支持八种淘汰策略，分别是noeviction, volatile-random、 volatile-ttl， volatile-ru、 volatile-lfuallkeys-lru、allkeys-Iandom 和 allkevs-lfu 策略。主要看分三类看:</p>
<ul>
<li>不淘汰<br>noeviction (v4.0后默认的)：一旦缓存被写满了，再有写请求来时，Redis 不再提供服务，而是直接返回错误。这种策略不会淘汰数据，所以无法解决缓存污染问题。一般生产环境不建议使用。</li>
<li>对设置了过期时间的数据中进行淘汰<br>随机 volatile-random：在设置了过期时间的键值对中，进行随机删除。因为是随机删除，无法把不再访问的数据筛选出来，所以可能依然会存在缓存污染现象，无法解决<strong>缓存污染</strong>问题。<br>tvolatile-ttl：Redis在筛选需删除的数据时，越早过期的数据越优先被选择。随机删除就无法解决缓存污染问题。<br>volatile-lru：LRU 算法的全称是 Least Recently Used，按照最近最少使用的原则来筛选数据<br>volatile-lfu：LFU 缓存策略是在 LRU 策略基础上，为每个数据增加了一个计数器，来统计这个数据的访问次数。当使用 LFU 策略筛选淘汰数据时，首先会根据数据的访问次数进行筛选，把访问次数最低的数据淘汰出缓存。如果两个数据的访问次数相同，LFU 策略再比较这两个数据的访问时效性，把距离上一次访问时间更久的数据淘汰出缓存。</li>
<li>全部数据进行淘汰<br>随机 allkeys-random：从所有键值对中随机选择并删除数据。<br>allkeys-lru：使用 LRU 算法在所有数据中进行筛选。<br>allkeys-lfu：使用 LFU 算法在所有数据中进行筛选。</li>
</ul>
<h2 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h2><p>Redis 提供了两种主要的持久化方式，用于在系统重启时保持数据的持久性：RDB 持久化和 AOF 持久化。<br>用户可以根据实际需求选择 RDB 持久化、AOF 持久化或两者结合使用。通常情况下，AOF 持久化是更安全的选择，因为它可以提供更好的持久性保障，但也需要更多的磁盘空间。</p>
<ol>
<li><strong>RDB 持久化：</strong><ul>
<li>RDB 持久化是通过在指定的时间间隔内将内存中的数据集快照写入磁盘的方式来实现的。</li>
<li>快照是一个二进制文件，它记录了某个时间点上 Redis 数据集的所有键值对。</li>
<li>RDB 持久化是一个“点对点”操作，它在指定的时间点创建了一个数据快照。</li>
<li>RDB 持久化适用于备份、灾难恢复等场景。<br>RDB 持久化的配置选项可以在 Redis 配置文件中进行设置，例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1      # 表示在 900 秒（15分钟）内，如果至少有 1 个 key 发生了变化，则执行快照操作</span><br><span class="line">save 300 10     # 表示在 300 秒（5分钟）内，如果至少有 10 个 key 发生了变化，则执行快照操作</span><br><span class="line">save 60 10000   # 表示在 60 秒内，如果至少有 10000 个 key 发生了变化，则执行快照操作</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>AOF 持久化：</strong><ul>
<li>AOF（Append Only File）持久化记录了服务器执行的所有写操作指令，以追加的方式将这些指令记录到一个文件中。</li>
<li>AOF 持久化是一个“追加”操作，每个写操作都被追加到文件末尾。</li>
<li>AOF 持久化适用于对数据的实时持久化需求。<br>AOF 持久化的配置选项可以在 Redis 配置文件中进行设置，例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes            # 启用 AOF 持久化</span><br><span class="line">appendfsync everysec      # 每秒钟执行一次 fsync 操作</span><br></pre></td></tr></table></figure></li>
<li><code>appendfsync</code> 选项可以设置 <code>always</code>、<code>everysec</code> 或 <code>no</code>。<code>always</code> 表示每个写命令都会立即被写入磁盘，<code>everysec</code> 表示每秒执行一次 fsync 操作，<code>no</code> 表示由操作系统自行决定何时进行写入磁盘操作。</li>
<li>Redis 还提供了 AOF 重写机制，可以通过 <code>auto-aof-rewrite-percentage</code> 和 <code>auto-aof-rewrite-min-size</code> 选项配置。这允许 Redis 在不停机的情况下优化 AOF 文件的大小。</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/10/Redis/" data-id="clzzl7c2c000fu0v54i6w1srs" data-title="Redis" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Mybatis" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/12/Mybatis/" class="article-date">
  <time class="dt-published" datetime="2022-03-12T03:49:42.000Z" itemprop="datePublished">2022-03-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/12/Mybatis/">Mybatis / Mybatis-Plus</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-Mybatis"><a href="#1-Mybatis" class="headerlink" title="1. Mybatis"></a>1. Mybatis</h1><p>MyBatis 是一个开源的<strong>Java持久层框架</strong>，用于将对象与关系数据库的表之间进行映射。MyBatis 通过 XML或注解配置文件描述 <strong>Java 对象与数据库之间的映射关系</strong>，并提供了一些方便的查询语言（类似于SQL）来进行数据库操作。<br>使用 MyBatis 来操作 MySQL 数据库，将数据存储在 MySQL 中，或从 MySQL 中检索数据，同时使用 MyBatis 进行数据映射和数据库操作的管理。它们通常一起使用，以构建 Java 应用程序的持久层。</p>
<h3 id="数据映射："><a href="#数据映射：" class="headerlink" title="数据映射："></a><strong>数据映射：</strong></h3><p>MyBatis 的核心功能之一是提供简单且强大的数据映射。使用 XML或注解来定义 SQL查询和映射结果，将数据库表记录映射到 Java对象。</p>
<ul>
<li>1.1 XML 映射文件：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义查询 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM users WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 映射结果到对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>1.2 注解方式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;SELECT * FROM users WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">User <span class="title function_">selectUser</span><span class="params">(<span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="核心功能："><a href="#核心功能：" class="headerlink" title="核心功能："></a>核心功能：</h3><ul>
<li><strong>动态 SQL</strong>：MyBatis 允许你在 XML 中编写动态 SQL 语句，可以根据条件动态构建 SQL 查询。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM users</span><br><span class="line">  WHERE 1=1</span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span></span><br><span class="line">    AND username = #&#123;username&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;password != null&quot;</span>&gt;</span></span><br><span class="line">    AND password = #&#123;password&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>参数传递</strong>：MyBatis 支持多种参数传递方式，包括单个参数、多个参数、Map 和注解等。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;SELECT * FROM users WHERE id = #&#123;id&#125; AND username = #&#123;username&#125;&quot;)</span></span><br><span class="line">User <span class="title function_">selectUserByIdAndUsername</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="type">int</span> id, <span class="meta">@Param(&quot;username&quot;)</span> String username)</span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>批处理</strong>：MyBatis 允许执行批处理操作，可以有效地执行一组 SQL 语句。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(ExecutorType.BATCH);</span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"><span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">    userMapper.insertUser(user);</span><br><span class="line">&#125;</span><br><span class="line">sqlSession.flushStatements();</span><br><span class="line">sqlSession.commit();</span><br><span class="line">sqlSession.close();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="事务管理："><a href="#事务管理：" class="headerlink" title="事务管理："></a><strong>事务管理：</strong></h3><ul>
<li>MyBatis 也提供了事务管理的支持。可以通过配置数据源和事务管理器来实现事务的控制。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 数据源配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mydatabase&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 事务管理器配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>MyBatis 可以很容易地与 Spring 框架集成，通过 Spring 的事务管理来控制数据库事务。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring 配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mapper/*.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="SpringBoot实体类-——-VO-DTO-PO"><a href="#SpringBoot实体类-——-VO-DTO-PO" class="headerlink" title="SpringBoot实体类 —— VO&#x2F;DTO&#x2F;PO"></a>SpringBoot实体类 —— VO&#x2F;DTO&#x2F;PO</h3><ul>
<li><p><strong>VO</strong>：View Object，主要用于展示层。它的作用是把某个指定前端页面的所有数据封装起来。他的作用主要是减少传输数据量大小和保护数据库隐私数据（如用户密码、用户邮箱等相关信息）不外泄，同时保护数据库的结构不外泄。</p>
</li>
<li><p><strong>DTO</strong>：Data Transfer Object，数据传输对象，用于展示层与服务层之间的数据传输对象。（注：实际开发中还存在BO，其作用和DTO类似，当业务逻辑不复杂时一般会被合并。）</p>
</li>
<li><p><strong>PO</strong>：Persistant Object，持久化对象，和数据库形成映射关系。简单说PO就是每一个数据库中的数据表，一个字段对应PO中的一个变量。（也就是我们常用的Entities）</p>
<img src="https://github.com/leo710aka/bk/blob/main/mp1.jpeg?raw=true" width="800" height="300" alt=""> 
1、从前端页面中收到JSON格式数据，后端接口中将其封装为一个VO对象；接口接收到VO对象后将其转换为DTO对象，并调用业务类方法对其进行处理；然后处理为PO对象，调用Dao接口连接数据库进行数据访问（查询、插入、更新等）2、后端从数据库得到结果后，根据Dao接口将结果映射为PO对象，然后调用业务类方法将其转换为需要的DTO对象，再根据前端页面实际需求，转换为VO对象进行返回。</li>
<li><p><strong>类型转换</strong>：上述过程中，VO&#x2F;DTO&#x2F;PO等实体类中字段常常会存在多数相同，根据业务需求少数不同。为避免频繁的set和get操作对其进行转换，spring为我们提供了多种方法。（1）使用BeanUtils:（springframework包下）（2）使用BeanUtils:（Apache包下）（3）使用modelMapper？？</p>
</li>
<li><p><strong>DO（Data Object）：</strong>通常表示数据库中的数据实体，对应数据库表的结构。它主要用于数据存储和数据库操作，包含与数据库表字段一一对应的属性。类中通常包含与数据库表字段对应的成员变量、getter 和 setter 方法。它不应包含业务逻辑，主要负责数据的持久化和映射。<br>尽管 PO 和 DO 在一些情况下用法相似，但它们的侧重点有所不同。PO 更侧重于与数据库的交互，强调持久化和数据表映射；而 DO 侧重于在不同层之间传递数据，强调业务逻辑层面的数据封装。</p>
</li>
<li><p><strong>BO（Business Object）：</strong>通常表示业务层的业务实体，主要用于封装业务逻辑。BO 类一般包含与业务逻辑相关的属性和方法，与具体的数据存储形式无关。包含了一些业务逻辑的操作，比如计算、验证等。它不应直接与数据库进行交互，而是通过调用 Service 层或 DAO 层的方法实现数据的获取和存储。</p>
</li>
</ul>
<hr>

<h1 id="2-Mybatis-Plus"><a href="#2-Mybatis-Plus" class="headerlink" title="2. Mybatis-Plus"></a>2. Mybatis-Plus</h1><ul>
<li><strong>基于MyBatis</strong>：MyBatis-Plus是MyBatis的增强工具包，是在MyBatis基础上的扩展。只做增强不做改变，为简化开发、提高效率而生。它提供了更多的便捷、高效的开发功能，简化了开发人员的编码工作，大幅度提高了开发效率。</li>
<li><strong>功能</strong>：MyBatis-Plus 集成了MyBatis的核心功能，同时提供了更多针对CRUD操作、条件构造器、分页、代码生成器等功能的封装。</li>
<li><strong>简化操作</strong>：可以减少重复的CRUD代码，提供了一些便捷的API接口和工具，使得开发人员能够更方便地进行数据库操作。</li>
<li>引入 MybatisPlus依赖，可以直接代替 Mybatis依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>MyBatisPlus 的配置项继承了 MyBatis原生配置和一些自己特有的配置。例如:<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.itheima.mp.domain.po</span>  <span class="comment"># 别名扫描包</span></span><br><span class="line">  <span class="string">mapper-locations：&quot;classpath*:/mapper/**/*.xml&quot;</span>  <span class="comment"># Mapper.xml文件地址，默认值</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span>  <span class="comment"># 是否开户下划线和驼峰的映射</span></span><br><span class="line">    <span class="attr">cache-enabled:</span> <span class="literal">false</span>  <span class="comment"># 是否开户二级缓存</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">assign_id</span>  <span class="comment"># id为雪花算法生成</span></span><br><span class="line">      <span class="attr">update-strategy:</span> <span class="string">not_null</span>  <span class="comment"># 更新笑略:只更新非空字段</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="BaseMapper"><a href="#BaseMapper" class="headerlink" title="BaseMapper"></a>BaseMapper</h3><ul>
<li>定义 Mapper接口并继承 <code>BaseMapper</code>类，泛型指定要与数据库映射的 Java实体类（pojo类）；<br>MyBatisPlus通过扫描实体类，并基于<strong>反射</strong>获取实体类信息作为数据库表信息，自动实现 CRUD的逻辑<ul>
<li>默认以类名驼峰转下划线作为表名（User类 -&gt; user表）</li>
<li>默认把名为id的字段作为主键</li>
<li>默认把变量名驼峰转下划线作为表的字段名（createTime类属性 -&gt; create_time表字段）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt;&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>如果实体类和表的对应关系不符合 mp的约定，就要自行配置。可以使用注解:<ul>
<li><code>@TableName</code>：指定表名称及全局配置</li>
<li><code>@Tableld</code>：指定id字段及相关配置；<ul>
<li>IdType的常见类型有：AUTO、ASSIGN ID（默认使用，雪花算法）、INPUT</li>
</ul>
</li>
<li><code>@TableField</code>：指定普通字段及相关配置。使用 @TableField的常见场景是：<ul>
<li>1、成员变量名与数据库字段名不一致    2、成员变量名以is开头，且是布尔值<br>3、成员变量名与数据库关键字冲突        4、成员变量不是数据库字段<img src="https://github.com/leo710aka/bk/blob/main/mp.png?raw=true" width="800" height="300" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h3><p>MyBatisPlus支持 使用 Wrapper构造各种复杂的where条件，而不需要在 xml中写sql语句。可以满足日常开发的所有需求。<br><img src="https://github.com/leo710aka/bk/blob/main/mp2.png?raw=true" width="700" height="200" alt=""> </p>
<ul>
<li>QueryWrapper 和LambdaQueryWrapper通常用来构建 select、delete、update的 where条件部分</li>
<li>UpdateWrapper 和LambdaUpdateWrapper通常只有在 set语句比较特殊才使用</li>
<li>尽量使用 LambdaQueryWrapper和 LambdaUpdateWrapper避免硬编码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原sql：SELECT id,username,info,balance FROM user WHERE username LIKE ? AND balance &gt;= ?</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testQuerywrapper</span><span class="params">()</span> &#123;</span><br><span class="line">  QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;()  <span class="comment">// 1.构建查询条件</span></span><br><span class="line">    .select(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;info&quot;</span>, <span class="string">&quot;balance&quot;</span>)</span><br><span class="line">    .like(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;o&quot;</span>)</span><br><span class="line">    .ge(<span class="string">&quot;balance&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">  List&lt;User&gt; users = userMapper.selectList(wrapper);  <span class="comment">// 2.查询</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 Lambda替代上方法中的硬编码</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testLambdaQuerywrapper</span><span class="params">()</span> &#123;</span><br><span class="line">  LambdaQuerywrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQuerywrapper</span>&lt;User&gt;()</span><br><span class="line">    .select(User::getid, User::getUsername, User::getInfo, User::getBalance)</span><br><span class="line">    .like(User::getUsername, <span class="string">&quot;o&quot;</span>)</span><br><span class="line">    .ge(User::getBalance, <span class="number">1000</span>)</span><br><span class="line">  List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原sql：UPDATE user SET balance = 2000 WHERE (username = &quot;jack&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdateByQuerywrapper</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>()<span class="comment">// 1.要更新的数据</span></span><br><span class="line">  user.setBalance(<span class="number">2000</span>);</span><br><span class="line">  QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;().eq(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;jack&quot;</span>);<span class="comment">// 2.更新的条件</span></span><br><span class="line">  userMapper.update(user, wrapper);<span class="comment">// 3.执行更新</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原sql：UPDATE user SET balance = balance - 200 WHERE id in (1，2，4)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdatewrapper</span><span class="params">()</span> &#123;</span><br><span class="line">  List&lt;Long&gt; ids = List.of(<span class="number">1L</span>，<span class="number">2L</span>，<span class="number">4L</span>);</span><br><span class="line">  Updatewrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">Updatewrapper</span>&lt;User&gt;()</span><br><span class="line">    .setSql(<span class="string">&quot;balance = balance - 200&quot;</span>)</span><br><span class="line">    .in(<span class="string">&quot;id&quot;</span>, ids) ;</span><br><span class="line">  userMapper.update(<span class="literal">null</span>, wrapper) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="自定义SQL"><a href="#自定义SQL" class="headerlink" title="自定义SQL"></a>自定义SQL</h3><p>我们可以利用 MyBatisPlus的 Wrapper来构建复杂的 Where条件，然后自己定义SQL语句中剩下的部分。<br>在业务层编写wrapper包含sql中的where部分，在mapper方法声明wrapper变量名称“ew”，最后在mapper对应的xml中自定义sql编写where以外的部分（解决了 不能在业务层编写sql 和 使用mp简化查询语句编写 的矛盾？？<br><img src="https://github.com/leo710aka/bk/blob/main/mp3.png?raw=true" width="700" height="200" alt=""> </p>
<h3 id="IService接口"><a href="#IService接口" class="headerlink" title="IService接口"></a>IService接口</h3><ul>
<li>简单业务方法，直接在controller中调用对应的IService中的方法；<br>对于复杂业务，需要在自定义Servicelmpl中编写逻辑，调用对应的BaseMapper中的方法；<br>当BaseMapper不足以满足需求时，需要在mapper中编写自定义sql（处理where之外的sql，如update…）；<br>对于mapper中自定义sql，简单的使用注解编写，复杂的在xml中编写。。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、自定义Service接口继承IService接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2、自定义Service实现类，实现自定义接口并继承Servicelmpl类（否则要自己一个个实现IService接口的方法）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> </span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt;  <span class="comment">// 泛型中指定mapper和实体类类型</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">IUserService</span> &#123;              </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IUserServiceTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IUserService userService;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">      user.setUsername(uLiLeiu);</span><br><span class="line">      user.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">      userService.save(user);  <span class="comment">// 如果方法与BaseMapper中的重复，就不需要BaseMapper了？？</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>IService的 <strong>Lambda方法</strong>：在 自定义的 Servicelmpl类中进行 <strong>复杂操作</strong>；<ol>
<li>需求：复杂查询，查询条件如下（name: 用户名关键字，可以为空；status:用户状态，可以为空；minBalance:最小余额，可以为空；maxBalance:最大余额，可以为空）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">queryUsers</span><span class="params">(String name, Integer status, Integer minBalance Integer maxBalance)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> lambdaQuery()</span><br><span class="line">    .like(name != <span class="literal">null</span>, User::getUsername, name)</span><br><span class="line">    .eg(status != <span class="literal">null</span>, User::getStatus, status)</span><br><span class="line">    .ge(minBalance != <span class="literal">null</span>, User::getBalance, minBalance)</span><br><span class="line">    .le(maxBalance != <span class="literal">null</span>，User::getBalance, maxBalance)</span><br><span class="line">    .list();  <span class="comment">// 如果查询一个记录就是.one</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>需求：复杂更新，要求如下（按id更新，更新为扣后余额，如果扣减后余额为0，则将用户status修改为冻结状态(2)）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transaction</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">deductBalance</span><span class="params">(Long id，Integer money)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 4.扣城余额 update tb_user set balance = balance - ?</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">remainBalance</span> <span class="operator">=</span> user.getBalance() - money;</span><br><span class="line">  lambdaUpdate()</span><br><span class="line">    .set(User::getBalance, remainBalance)</span><br><span class="line">    .set(remainBalance == <span class="number">0</span>, User::getStatus, <span class="number">2</span>) <span class="comment">// 如果余额0，修改状态</span></span><br><span class="line">    .eq(User::getId, id) <span class="comment">// 相当于 where</span></span><br><span class="line">    .eq(User::getBalance，user.getBalance()) <span class="comment">// 乐观锁</span></span><br><span class="line">    .update();  <span class="comment">// 更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>IService批量新增（批处理）：开启 rewriteBatchedStatements&#x3D;true参数</li>
</ul>
<h3 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h3><p>首先，要在配置类中注册MyBatisplus的核心插件，同时添加分页插件<br>接着，就可以使用分页的API了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> &#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123; <span class="comment">// 拦截器的形式实现插件</span></span><br><span class="line">    <span class="comment">// 1. 初始化核心插件</span></span><br><span class="line">    <span class="type">MybatisplusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisplusInterceptor</span>();</span><br><span class="line">    <span class="comment">// 2. 添加分页插件</span></span><br><span class="line">    <span class="type">PaginationInnerInterceptor</span> <span class="variable">pageInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSOL);</span><br><span class="line">    pageInterceptor.setMaxLimit(<span class="number">100L</span>); <span class="comment">// 设置分页上限</span></span><br><span class="line">    interceptor.addInnerInterceptor(pageInterceptor); <span class="comment">// 添加到核心拦截器</span></span><br><span class="line">    <span class="keyword">return</span> interceptor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">testPageQuery</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">pageNo</span> <span class="operator">=</span> <span class="number">1</span>, pageSize = <span class="number">5</span>;  <span class="comment">// 分页参数</span></span><br><span class="line">  Page&lt;User&gt; page = Page.of(pageNo，pageSize);</span><br><span class="line">  page.addOrder(<span class="keyword">new</span> <span class="title class_">OrderItem</span>(<span class="string">&quot;balance&quot;</span>，<span class="literal">false</span>));  <span class="comment">// 排序参数，通过OrderItem来指定</span></span><br><span class="line">  <span class="comment">// 分页查询</span></span><br><span class="line">  Page&lt;User&gt; p = userService.page(page);</span><br><span class="line">  <span class="comment">// 总条数 p.getTotal(); 总页数 p.getPages(); 分页数据 List&lt;User&gt; records = p.getRecords();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/12/Mybatis/" data-id="clzzl7c2b000bu0v56rzr8znc" data-title="Mybatis / Mybatis-Plus" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Mysql" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/11/Mysql/" class="article-date">
  <time class="dt-published" datetime="2022-03-11T03:49:42.000Z" itemprop="datePublished">2022-03-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/11/Mysql/">MySQL</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>MySQL是一个开源的关系型数据库管理系统（RDBMS），广泛用于Web应用程序和中小型企业数据库。默认端口是 <strong>3306</strong>。</p>
<h2 id="启动并连接-MySQL"><a href="#启动并连接-MySQL" class="headerlink" title="启动并连接 MySQL"></a>启动并连接 MySQL</h2><ul>
<li>启动 MySQL 服务器（然后尝试连接到 MySQL 服务器；一般情况下 服务器不会自动关闭）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net start MySQL  <span class="comment"># 打开命令提示符（以管理员身份运行），运行以下命令来启动 MySQL 服务</span></span><br><span class="line">net stop MySQL   <span class="comment"># 停止 MySQL 服务</span></span><br></pre></td></tr></table></figure></li>
<li>另外，通过 <strong>Navicat</strong> 创建与本地(或远程) 的 MySQL(或其他)数据库的连接，以对数据库可视化管理<br>本机  <strong>username: root，password: “0xx1xx”</strong></li>
</ul>
<h2 id="SQL-术语"><a href="#SQL-术语" class="headerlink" title="SQL 术语"></a>SQL 术语</h2><p><img src="https://pdai.tech/images/db/db-sql-x-1.png"><br><strong>关系</strong>(Relation)：通常是指数据库表(table)。每个关系对应数据库中的一个表格，由多个行和列组成，其中每一行通常代表表格中的一个数据记录，而每一列代表记录中的一个属性（字段）。<br><strong>属性</strong>(attribute)：列的名字，上图有学号、姓名、班级、兴趣爱好、班主任、课程、授课主任、分数.<br><strong>依赖</strong> (relation)：列属性间存在的某种联系<br><strong>元组</strong>(tuple)：每一个行，如第二行 (1301，小明，13班，篮球，王老师，英语，赵英，70) 就是一个元组<br><strong>模式</strong>(schema)：这里指逻辑结构，如 学生信息(学号，姓名，班级，兴趣爱好，班主任，课程，授课主任，分数)的笼统表述。（数据库模式是数据库的结构描述，包括表格、字段、关系、视图、索引等元素的组织方式。描述了数据库中不同关系表格之间的关联和数据的组织方式。通常包含了数据库中表格的定义，包括表格的名称、字段的名称、字段的数据类型、主键等信息。）<br><strong>域</strong> (domain)：数据类型，如string、integer等，上图中每一个属性都有它的数据类型 (即域)<br><strong>键</strong>(key)：由关系的一个或多个属性组成，任意两个键相同的元组，所有属性都相同。需要保证表示键的属性最少。一个关系可以存在好几种键，工程中一般从这些候选键中选出一个作为主键 (primary key)<br><strong>主键</strong>（Primary Key）：主键是一个表格中的一列或一组列，它的值用来唯一标识表格中的每一行记录。主键的值<strong>不能重复，且不能为空</strong>。这意味着每一行记录在主键列上必须有唯一的值，用于区分记录。主键用于建立表格之间的关系和确保数据的完整性。通常，每个表格都有一个主键，但也可以由多个列组成复合主键<br>候选键(candidate key)：由关系的一个或多个属性组成，候选键都具备键的特征，都有资格成为主键<br>超键(super key)：包含键的属性集合，无需保证属性集的最小化。每个键也是超键。可以认为是键的超集。<br><strong>外键</strong>(foreign key)：如果某一个关系A中的一个(组)属性是另一个关系B的键，则该(组)属性在A中称为外键。<br>主属性 (prime attribute)：所有候选键所包含的属性都是<strong>主属性</strong><br>投影 (proiection)：选取特定的列，如将关系学生信息投影为学号、姓名即得到上表中仅包含学号、姓名的列<br>选择 (selection)：按照一定条件选取特定元组，如选择上表中分数&gt;80的元组<br>笛卡儿积 (交叉连接Cross join)：第一个关系每一行分别与第二个关系的每一行组合<br>自然连接(natural join)：第一个关系中每一行与第二个关系的每一行进行匹配，如果得到有交叉部分则合并，若无交叉部分则舍弃。<br>连接(theta join)：即加上约束条件的笛卡儿积，先得到笛卡儿积，然后根据约束条件删除不满足的元组.<br>外连接 (outer join)：执行自然连接后，将舍弃的部分也加入，并且匹配失败处的属性用NULL代替。<br>除法运算(division)：关系R除以关系S的结果为T，则T包含所有在R但不在S中的属性，且T的元组与S的元组的所有组合在R中。</p>
<hr>

<h2 id="SQL-语法"><a href="#SQL-语法" class="headerlink" title="SQL 语法"></a>SQL 语法</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE mydatabase;  <span class="comment">/* 创建数据库 */</span></span><br><span class="line">USE mydatabase;              <span class="comment">/* 选择数据库 */</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users (                   <span class="comment">-- 创建表</span></span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    username <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> users;                      <span class="comment">-- 删除表</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> users <span class="keyword">ADD</span> col <span class="type">CHAR</span>(<span class="number">20</span>);    <span class="comment">-- 添加列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> col;   <span class="comment">-- 删除列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable CHANGE col col1 <span class="type">CHAR</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;123&#x27;</span>;   <span class="comment">-- 修改列和属性</span></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users (username, email) <span class="keyword">VALUES</span> (<span class="string">&#x27;user1&#x27;</span>, <span class="string">&#x27;user1@example.com&#x27;</span>);  </span><br><span class="line"><span class="comment">-- 插入检索出来的数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mytable1(col1, col2)</span><br><span class="line"><span class="comment">-- 更新数据</span></span><br><span class="line"><span class="keyword">UPDATE</span> users <span class="keyword">SET</span> email<span class="operator">=</span><span class="string">&#x27;newemail@example.com&#x27;</span> <span class="keyword">WHERE</span> username<span class="operator">=</span><span class="string">&#x27;user1&#x27;</span>;  </span><br><span class="line"><span class="comment">-- 删除数据</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username<span class="operator">=</span><span class="string">&#x27;user1&#x27;</span>;  </span><br></pre></td></tr></table></figure>


<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">distinct</span> id </span><br><span class="line"><span class="keyword">FROM</span> users;  </span><br><span class="line">LIMIT <span class="number">2</span>, <span class="number">3</span>;                     </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> col1 <span class="keyword">DESC</span>, col2 <span class="keyword">ASC</span>;   </span><br><span class="line"><span class="keyword">WHERE</span> col <span class="keyword">is</span> <span class="keyword">NULL</span>;          </span><br><span class="line"><span class="comment">-- 子查询：只能返回一个字段的数据，可以将子查询的结果作为 WHRER 语句的过滤条件，配合 (not )in</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mytable1    </span><br><span class="line"><span class="keyword">WHERE</span> col1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> col2</span><br><span class="line">               <span class="keyword">FROM</span> mytable2);</span><br><span class="line"><span class="comment">-- 分组：将数据按照一个或多个列的值分成不同的组，常与聚合函数（如 SUM、COUNT、AVG 等）一起以对每个组聚合操作</span></span><br><span class="line"><span class="comment">-- GROUP BY 子句： 用于指定按哪些列进行分组； HAVING 子句： 用于对分组后的数据进行筛选。</span></span><br><span class="line"><span class="comment">-- WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。</span></span><br><span class="line"><span class="keyword">SELECT</span> col, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num   </span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> col <span class="operator">&gt;</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> col</span><br><span class="line"><span class="keyword">HAVING</span> num <span class="operator">&gt;=</span> <span class="number">2</span>       </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">SUM</span>(column2) <span class="keyword">DESC</span>;  </span><br></pre></td></tr></table></figure>
<ol>
<li>SELECT：查询出属性，用 AS 给列名、计算字段和表名取别名，以简化 SQL 语句以及连接相同表；<br>select 中 sql 函数计算出的值作为查询出的属性（select round(count(<em>)&#x2F;3, 2) from ..）<br>select 中可以加一个select 用于属性计算（select id, count(</em>)&#x2F;(select count(*) from Users) per from ..）<br>若有重复列，使用 DISTINCT 去除重复值</li>
<li>LIMIT：LIMIT 2, 3 返回第 3 ~ 5 行。配合排序实现获取最大&#x2F;最小值。。</li>
<li>WHERE：过滤行，AND 和 OR 用于连接多个过滤条件。优先处理 AND，使用 () 决定优先级；<br>is 搭配 null，IN 操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。</li>
<li>ORDER：可以按多个列进行排序，并指定不同的排序方式，默认升序ASC, 降序DESC</li>
<li>GROUP BY 可以放在 WHERE 前、后，想清楚在分组前、后过滤</li>
<li>子查询的结果需要指定别名。</li>
</ol>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 连接(内连接)：返回多个表中匹配条件满足的行，不匹配的行不会被包括在结果集中。</span></span><br><span class="line"><span class="comment">-- 使用 (INNER )JOIN 关键字，条件语句使用 ON 而不是 WHERE，连接可以替换子查询且效率一般会更快。</span></span><br><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A <span class="keyword">JOIN</span> tableb <span class="keyword">AS</span> B</span><br><span class="line"><span class="keyword">ON</span> A.key <span class="operator">=</span> B.key;</span><br><span class="line"><span class="comment">-- 自连接：可以看成内连接的一种，只是连接的表是自身而已。</span></span><br><span class="line"><span class="keyword">SELECT</span> e1.name</span><br><span class="line"><span class="keyword">FROM</span> employee <span class="keyword">AS</span> e1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> employee <span class="keyword">AS</span> e2</span><br><span class="line"><span class="keyword">ON</span> e1.department <span class="operator">=</span> e2.department <span class="keyword">AND</span> e2.name <span class="operator">=</span> &quot;Jim&quot;;</span><br><span class="line"><span class="comment">-- 自然连接：自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。</span></span><br><span class="line"><span class="comment">-- 内连接和自然连接的区别: 内连接提供连接的列，而自然连接自动连接所有同名列。</span></span><br><span class="line"><span class="keyword">SELECT</span> A.value, B.value <span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> tableb <span class="keyword">AS</span> B;</span><br><span class="line"><span class="comment">-- 外连接：保留了没有关联的那些行。分为左，右外连接以及全外连接。</span></span><br><span class="line"><span class="comment">-- 左连接返回左表的所有行以及与右表匹配的行。如果右表中没有匹配的行，将会返回 NULL 值。</span></span><br><span class="line"><span class="comment">-- on 后等于新连接出了一张表，where 在新表上进行查询</span></span><br><span class="line"><span class="keyword">select</span> Employee.name, Bonus.bonus</span><br><span class="line"><span class="keyword">from</span> Employee <span class="keyword">left</span> <span class="keyword">join</span> Bonus</span><br><span class="line"><span class="keyword">on</span> Employee.empId <span class="operator">=</span> Bonus.empId</span><br><span class="line"><span class="keyword">where</span> Bonus.bonus <span class="operator">&lt;</span> <span class="number">1000</span> <span class="keyword">or</span> Bonus.bonus <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure>


<h2 id="SQL-函数"><a href="#SQL-函数" class="headerlink" title="SQL 函数"></a>SQL 函数</h2><ol>
<li><strong>数学函数：</strong><code>SUM()</code>：计算指定列的总和。 <code>AVG()</code>：计算指定列的平均值。 <code>MAX()</code>：找出指定列的最大值。 <code>MIN()</code>：找出指定列的最小值。 <code>COUNT()</code>：计算指定列的行数。 <code>ROUND(x,y)</code>：把 x 四舍五入到 y 位小数。 <code>ABS()</code>：返回绝对值。</li>
<li><strong>字符串函数：</strong><code>CONCAT()</code>：连接两个或多个字符串。 <code>SUBSTRING()</code> 或 <code>SUBSTR()</code>：从字符串中提取子字符串。  <code>LENGTH()</code>：返回字符串的长度。  <code>UPPER()</code>：将字符串转换为大写。 <code>LOWER()</code>：将字符串转换为小写。  <code>TRIM()</code>：去除字符串首尾的空格或其他指定字符。  <code>REPLACE()</code>：替换字符串中的子串。</li>
<li><strong>日期和时间函数：</strong><code>NOW()</code> 或 <code>CURRENT_TIMESTAMP()</code>：返回当前日期和时间。 <code>DATE()</code>：从日期时间值中提取日期部分。 <code>TIME()</code>：从日期时间值中提取时间部分。 <code>YEAR()</code>：从日期中提取年份。 <code>MONTH()</code>：从日期中提取月份。  <code>DAY()</code>：从日期中提取天。<code>HOUR()</code>：从时间中提取小时。  <code>MINUTE()</code>：从时间中提取分钟。 <code>SECOND()</code>：从时间中提取秒。</li>
<li><strong>逻辑函数：</strong> <code>IF()</code> 或 <code>CASE</code>：根据条件返回不同的值，if(rating&lt;3, 1, 0)；<code>COALESCE()</code>：返回第一个非空值。</li>
<li><strong>聚合函数：</strong>  <code>GROUP_CONCAT()</code>：将组内的值连接成一个字符串。 <code>GROUP_BY</code>：分组聚合查询结果。</li>
<li><strong>窗口函数：</strong><code>ROW_NUMBER()</code>：为结果集的每行分配一个唯一的行号。  <code>RANK()</code>：为结果集中的行分配排名。 <code>DENSE_RANK()</code>：为结果集中的行分配密集排名。 <code>OVER()</code>：定义窗口以进行窗口函数计算。</li>
</ol>
<h2 id="MySQL-数据类型"><a href="#MySQL-数据类型" class="headerlink" title="MySQL 数据类型"></a>MySQL 数据类型</h2><ol>
<li><strong>整数类型：</strong> 用于存储整数值，包括 <code>TINYINT</code>, <code>SMALLINT</code>, <code>MEDIUMINT</code>, <code>INT</code>, 和 <code>BIGINT</code>。</li>
<li><strong>浮点数类型：</strong> 用于存储浮点数，包括 <code>FLOAT</code> 和 <code>DOUBLE</code>。 <code>DECIMAL</code> 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。<br>FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽。如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分</li>
<li><strong>定点数类型：</strong> 用于存储定点数，包括 <code>DECIMAL</code> 或 <code>NUMERIC</code>。</li>
<li><strong>字符串类型：</strong> 用于存储文本数据，主要有 <code>CHAR</code>, <code>VARCHAR</code> 两种类型，一种是定长的，一种是变长的。<br>VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。VARCHAR 会保留字符串末尾的空格，而 CHAR 会删除。</li>
<li><strong>二进制数据类型：</strong> 用于存储二进制数据，包括 <code>BINARY</code>, <code>VARBINARY</code>, <code>TINYBLOB</code>, <code>BLOB</code>, <code>MEDIUMBLOB</code>, 和 <code>LONGBLOB</code>.</li>
<li><strong>日期和时间类型（Date and Time Types）：</strong> <strong><code>DATE</code>：</strong> 用于存储日期。日期格式为’YYYY-MM-DD’，如’2023-10-12’。 <strong><code>TIME</code>：</strong> 用于存储时间。时间格式为’HH:MM:SS’，如 ‘14:30:45’。 <strong><code>YEAR</code>：</strong> 用于存储年份，可以使用两位或四位格式（’YY’或’YYYY’）<br><strong><code>DATETIME</code>：</strong> 用于存储日期和时间。能够保存从 1001 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。它与时区无关，格式为’YYYY-MM-DD HH:MM:SS’，如’2023-10-12 14:30:45’。<br><strong><code>TIMESTAMP</code>：</strong> 用于存储日期和时间，在插入或更新时自动记录当前时间。使用 4 个字节，只能表示从 1970 年到 2038 年。时区有关，即一个时间戳在不同的时区所代表的具体时间是不同的。应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。</li>
<li><strong>布尔类型：</strong> 用于存储布尔值，包括 <code>BOOLEAN</code>, <code>BOOL</code>, <code>TINYINT(1)</code>。</li>
<li><strong>枚举类型：</strong> 用于存储枚举值，其中一个预定义的枚举值，如 <code>ENUM(&#39;value1&#39;, &#39;value2&#39;, ...)</code></li>
<li><strong>集合类型：</strong> 用于存储一个或多个预定义的集合值，如 <code>SET(&#39;value1&#39;, &#39;value2&#39;, ...)</code></li>
<li><strong>自动增长类型：</strong> 用于自动生成唯一标识符，如 <code>AUTO_INCREMENT</code>。</li>
</ol>
<h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。<br>如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。<br>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。<br>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。<br>有依赖：学号 -&gt; 姓名、学院，  学院 -&gt; 院长，  学号、课程-&gt; 成绩<br>则 成绩Grade 完全函数依赖于键码（学号，课程），它没有任何冗余数据，每个学生的每门课都有特定的成绩。姓名, 学院 和 院长 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。</p>
<h3 id="MySQL-范式"><a href="#MySQL-范式" class="headerlink" title="MySQL 范式"></a>MySQL 范式</h3><p>范式理论是为了解决四种异常。不符合范式的关系，会产生很多异常：1、冗余数据。2、修改异常: 修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。3、删除异常: 删除一个信息，那么也会丢失其它信息。4、插入异常: 例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。<br>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。</p>
<ol>
<li>第一范式 (1NF)：属性不可分。</li>
<li>第二范式 (2NF)：每个非主属性完全函数依赖于键码。可以通过分解来满足。（一张表分解成多张表）</li>
<li>第三范式 (3NF)：非主属性不传递函数依赖于键码。可以进行分解。<br>for more：<a target="_blank" rel="noopener" href="https://blog.csdn.net/calcular/article/details/79332453">https://blog.csdn.net/calcular/article/details/79332453</a></li>
</ol>
<hr>


<h1 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h1><ul>
<li><strong>事务</strong>：指的是满足 <strong>ACID</strong> 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。<ul>
<li>原子性(Atomicity)事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</li>
<li>一致性(Consistency)数据库在事务执行前后都保持一致性状态。一致性状态下，所有事务对一个数据的读取结果都是相同的。</li>
<li>隔离性(Isolation)一个事务所做的修改在最终提交以前，对其它事务是不可见的。</li>
<li>持久性(Durability)一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。可以通过数据库备份和恢复来实现，在系统发生崩溃时，使用备份的数据库进行数据恢复。</li>
</ul>
</li>
<li><strong>并发一致性</strong>：产生不一致的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。<ul>
<li>丢失修改：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。</li>
<li>读脏数据：T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</li>
<li>不可重复读：T2 读取一个数据，T1 对该数据做了修改。 T2 再次读取这个数据时读取的结果和第一次读取的结果不同。</li>
<li>幻影读：T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据 结果和第一次不同。<br>并发控制可以通过 <strong>封锁</strong> 来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的 <strong>隔离级别</strong>，让用户以一种更轻松的方式处理并发一致性问题。</li>
</ul>
</li>
<li><strong>封锁</strong><ul>
<li>封锁粒度：MySQL 中提供了两种封锁粒度，行级锁以及表级锁。</li>
<li>读写锁：1、排它锁(Exclusive)，简写为 X 锁，又称写锁。 2、共享锁(Shared)，简写为 S 锁，又称读锁。</li>
<li>意向锁：使用意向锁(Intention Locks)可以更容易地支持多粒度封锁。</li>
<li>封锁协议：1. 三级封锁协议 2. 两段锁协议</li>
</ul>
</li>
<li><strong>隔离等级</strong>：MySQL支持 <strong>四种</strong> 标准的事务隔离级别，这些隔离级别定义了事务之间的可见性和并发控制。<table>
<thead>
<tr>
<th>READ UNCOMMITTED &#x2F; READ COMMITTED &#x2F; REPEATABLE READ &#x2F; SERIALIZABLE</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻影读</th>
</tr>
</thead>
<tbody><tr>
<td>未提交读（允许一个事务读取另一个事务未提交的数据）</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>提交读（一个事务只能读取到另一个事务已经提交的数据）</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>可重复读（事务执行期间，一个事务多次读取同一行数据时，会得到相同的结果）</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>可串行化（最高的隔离级别，确保事务串行执行）</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
</li>
<li>数据库默认隔离级别<br>oracle数据库默认的隔离级别是：读已提交。<br>mysql数据库默认的隔离级别是：可重复读。</li>
<li>InnoDB 中如何防止幻读 or MVCC 实现<ul>
<li>1、执行普通 select，此时会以 MVCC 快照读的方式读取<br>（1）一致性非锁定读（快照读），普通的SELECT，通过多版本并发控制（MVCC）实现。<br>（2）在快照读下，RR 隔离级别只会在事务开启后的第一次查询生成 Read View ，并使用至事务提交。所以在生成 Read View 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”。<br>（3）只有在事务隔离级别 RC(读取已提交) 和 RR（可重读）下，InnoDB 才会使用一致性非锁定读。</li>
<li>2、执行 select…for update&#x2F;lock in share mode、insert、update、delete 等当前读<br>（1）一致性锁定读（当前读），SELECT … FOR UPDATE&#x2F;SELECT … LOCK IN SHARE MODE&#x2F;INSERT&#x2F;UPDATE&#x2F;DELETE，通过锁实现。<br>（2）在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！InnoDB 使用 Next-key Lock 来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;  <span class="comment">-- 启动事务，用于标志事务的开始。在这之后的 SQL 语句都将在一个事务中执行 </span></span><br><span class="line"><span class="keyword">COMMIT</span>;             <span class="comment">-- 提交事务，当所有的 SQL 语句都执行成功时，使用 `COMMIT` 命令来提交事务，将更改永久保存到数据库。提交后，事务结束。</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;           <span class="comment">-- 回滚事务，如果在事务执行的过程中发生了错误或者不符合条件，可以使用 `ROLLBACK` 命令来回滚事务，撤销所有的更改，使数据库回到事务开始前的状态。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SAVEPOINT</span> savepoint_name;    <span class="comment">-- 保存点，用于创建一个保存点，以便在事务中的某一时刻回滚到这个保存点。可以在事务中设置多个保存点。</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> savepoint_name;  <span class="comment">-- 回滚到保存点，如果在事务中的某一步出现问题，可以回滚到之前设置的某个保存点，而不必回滚整个事务。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置事务隔离级别，包括 `READ UNCOMMITTED`、`READ COMMITTED`、`REPEATABLE READ` 和 `SERIALIZABLE`。</span></span><br><span class="line"><span class="keyword">SET</span> TRANSACTION ISOLATION LEVEL level;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- MySQL 默认是自动提交模式，即每个 SQL 语句都会自动成为一个事务并提交。命令关闭自动提交，再通过 `COMMIT` 手动提交，或者通过 `ROLLBACK` 回滚。</span></span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">--示例 1</span></span><br><span class="line">  <span class="keyword">START</span> TRANSACTION;</span><br><span class="line">  <span class="comment">-- 执行一系列 SQL 语句</span></span><br><span class="line">  <span class="comment">-- 提交事务</span></span><br><span class="line">  <span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--示例 2</span></span><br><span class="line">  <span class="keyword">START</span> TRANSACTION;</span><br><span class="line">  <span class="comment">-- 执行一系列 SQL 语句</span></span><br><span class="line">  <span class="comment">-- 如果发生错误，回滚事务</span></span><br><span class="line">  <span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="MySQL-存储引擎"><a href="#MySQL-存储引擎" class="headerlink" title="MySQL 存储引擎"></a>MySQL 存储引擎</h1><ul>
<li>InnoDB<ul>
<li>是 MySQL 默认的事务型存储引擎。  实现了四个标准的隔离级别，默认级别是可重复读。在可重复读隔离级别下，通过多版本并发控制(MVCC)+ 间隙锁(Next-Key Locking)防止幻影读</li>
<li>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。 内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等</li>
<li>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</li>
</ul>
</li>
<li>MyISAM<ul>
<li>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它</li>
<li>提供了大量的特性，包括压缩表、空间数据索引等。</li>
<li><strong>不支持事务</strong></li>
<li>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入(CONCURRENT INSERT)。</li>
<li>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作非常慢</li>
<li>如果指定了 DELAY KEY WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作</li>
</ul>
</li>
</ul>
<h1 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h1><p>在MySQL中，索引是一种用于提高数据库查询效率的数据结构。它类似于书的目录，通过在数据库表上创建索引，可以快速定位并访问表中的特定数据行，而无需全表扫描。索引在数据库的性能优化中扮演着关键的角色，特别是在大型数据集上。<br>索引是在<strong>存储引擎层</strong>实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p>
<ul>
<li>索引类型<ol>
<li><strong>B+Tree 索引</strong>：是大多数 MySQL 存储引擎的默认索引类型。因为不再需要进行全表扫描，只需要对树进行搜索即可，因此查找速度快很多。除了用于查找，还可以用于排序和分组。<br>InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</li>
<li><strong>哈希索引</strong>：能以 O(1) 时间进行查找，但是失去了有序性。存在限制：无法用于排序与分组；只支持精确查找，无法用于部分查找和范围查找。<br>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</li>
<li>全文索引：MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。全文索引一般使用倒排索引实现，它记录着关键词到其所在文档的映射。InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</li>
<li>空间数据索引：MyISAM 存储引擎支持空间数据索引(R-Tree)，可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。必须使用 GIS 相关的函数来维护数据</li>
</ol>
</li>
<li>索引的优点：大大减少了服务器需要扫描的数据行数。帮助服务器避免进行排序和分组，也就不需要创建临时表(B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，因为不需要排序和分组，也就不需要创建临时表)。将随机 I&#x2F;O 变为顺序 I&#x2F;O(B+Tree 索引是有序的，也就将相邻的数据都存储在一起)。</li>
<li>索引的使用场景<ul>
<li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效。</li>
<li>对于中到大型的表，索引就非常有效。</li>
<li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li>
</ul>
</li>
</ul>
<h3 id="B-Tree-索引"><a href="#B-Tree-索引" class="headerlink" title="B+Tree 索引"></a>B+Tree 索引</h3><p>是大多数 MySQL 存储引擎的默认索引类型因为不再需要进行全表扫描，只需要对树进行搜索即可，因此查找速度快很多。除了用于查找，还可以用于排序和分组可以指定多个列作为索引列，多个索引列共同组成键.<br>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。<br>InnoDB 的 B+Tree 索引分为主索引和辅助索引.<br>主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>
<h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><p>1.独立的列<br>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。例如下面的查询不能使用 actor id 列的索引:<br>2.多列索引<br>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor id和 film id 设置为多列索引。<br>3.索引列的顺序<br>4.前缀索引对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。对于前缀长度的选取需要根据索引选择性来确定。<br>5.覆盖索引</p>
<hr>


<h2 id="MySQL-一条-SQL-的执行过程详解"><a href="#MySQL-一条-SQL-的执行过程详解" class="headerlink" title="MySQL - 一条 SQL 的执行过程详解"></a>MySQL - 一条 SQL 的执行过程详解</h2><p><a target="_blank" rel="noopener" href="https://pdai.tech/md/db/sql-mysql/sql-mysql-execute.html">https://pdai.tech/md/db/sql-mysql/sql-mysql-execute.html</a></p>
<p>在系统和 MySQL 进行交互之前，MySQL 驱动会帮我们建立好连接，然后我们只需要发送 SQL 语句就可以执行 CRUD 了。<br>java 系统在通过 MySQL 驱动和 MySQL 数据库连接的时候是基于 TCP&#x2F;IP 协议的，多线程请求的时候频繁的创建和销毁连接显然是不合理的。在访问 MySQL 数据库的时候，建立的连接并不是每次请求都会去创建的，而是从数据库连接池中去获取，这样就解决了因为反复的创建和销毁连接而带来的性能损耗问题了。MySQL 的架构体系中也已经提供了这样的一个池子，也是数据库连池。双方都是通过数据库连接池来管理各个连接的，这样一方面线程之前不需要是争抢连接，更重要的是不需要反复的创建的销毁连接。<br><img src="https://pdai.tech/images/db/mysql/db-mysql-sql-4.png"></p>
<h4 id="网络连接必须由线程来处理"><a href="#网络连接必须由线程来处理" class="headerlink" title="网络连接必须由线程来处理"></a>网络连接必须由线程来处理</h4><p>网络中的连接都是由线程来处理的，所谓网络连接说白了就是一次请求，每次请求都会有相应的线程去处理的。也就是说对于 SQL 语句的请求在 MySQL 中是由一个个的线程去处理的。<br><img src="https://pdai.tech/images/db/mysql/db-mysql-sql-5.png"><br>SQL 接口：MySQL 中处理请求的线程在获取到请求以后获取 SQL 语句去交给 SQL 接口去处理。<br>查询解析器：会将 SQL 接口传递过来的 SQL 语句进行解析，翻译成 MySQL 自己能认识的语言<br>MySQL 查询优化器：查询优化器内部具体怎么实现的我们不需要是关心，我需要知道的是 MySQL 会帮我去使用他自己认为的最好的方式去优化这条 SQL 语句，并生成一条条的执行计划，比如你创建了多个索引，MySQL 会依据成本最小原则来选择使用对应的索引，这里的成本主要包括两个方面, IO 成本和 CPU 成本。MySQL 优化器 会计算 「IO 成本 + CPU」 成本最小的那个索引来执行<br>存储引擎：查询优化器会调用存储引擎的接口，去执行 SQL，也就是说真正执行 SQL 的动作是在存储引擎中完成的。数据是被存放在内存或者是磁盘中的（存储引擎是一个非常重要的组件，后面会详细介绍）<br>执行器：执行器是一个非常重要的组件，因为前面那些组件的操作最终必须通过执行器去调用存储引擎接口才能被执行。执行器最终最根据一系列的执行计划去调用存储引擎的接口去完成 SQL 的执行<br><img src="https://pdai.tech/images/db/mysql/db-mysql-sql-8.png"></p>
<h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>当我们系统发出这样的查询去交给 MySQL 的时候，MySQL 会按照我们上面介绍的一系列的流程最终通过执行器调用存储引擎去执行，流程图就是上面那个。<br>在执行这个 SQL 的时候 SQL 语句对应的数据要么是在内存中，要么是在磁盘中，如果直接在磁盘中操作，那这样的随机IO读写的速度肯定让人无法接受的，所以每次在执行 SQL 的时候都会将其数据加载到内存中，这块内存就是 InnoDB 中一个非常重要的组件：缓冲池 Buffer Pool</p>
<p>关于Buffer Pool、Redo Log Buffer 和undo log、redo log、bin log 概念以及关系：<br>Buffer Pool 是 MySQL 的一个非常重要的组件，因为针对数据库的增删改操作都是在 Buffer Pool 中完成的<br>Undo log 记录的是数据操作前的样子<br>redo log 记录的是数据被操作后的样子（redo log 是 Innodb 存储引擎特有）<br>bin log 记录的是整个操作记录（这个对于主从复制具有非常重要的意义）<br>、、，，<br>，。</p>
<h4 id="从准备更新一条数据到事务的提交的流程描述"><a href="#从准备更新一条数据到事务的提交的流程描述" class="headerlink" title="从准备更新一条数据到事务的提交的流程描述"></a>从准备更新一条数据到事务的提交的流程描述</h4><ul>
<li>首先执行器根据 MySQL 的执行计划来查询数据，先是从缓存池中查询数据，如果没有就会去数据库中查询，如果查询到了就将其放到缓存池中</li>
<li>在数据被缓存到缓存池的同时，会写入 undo log 日志文件更</li>
<li>新的动作是在 BufferPool 中完成的，同时会将更新后的数据添加到 redo log buffer 中</li>
<li>完成以后就可以提交事务，在提交的同时会做以下三件事 <ul>
<li>将redo log buffer中的数据刷入到 redo log 文件中</li>
<li>将本次操作记录写入到 bin log文件中</li>
<li>将 bin log 文件名字和更新内容在 bin log 中的位置记录到redo log中，同时在 redo log 最后添加 commit 标记</li>
</ul>
</li>
<li>至此表示整个更新事务已经完成</li>
</ul>
<hr>

<h1 id="关系型数据库是如何工作的"><a href="#关系型数据库是如何工作的" class="headerlink" title="关系型数据库是如何工作的"></a>关系型数据库是如何工作的</h1><h1 id="SQL-DB-组成"><a href="#SQL-DB-组成" class="headerlink" title="SQL DB 组成"></a>SQL DB 组成</h1><h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><p>进程管理器(process manager): 很多数据库具备一个需要妥善管理的进程&#x2F;线程池。再者，为了实现纳秒级操作，一些现代数据库使用自己的线程而不是操作系统线程<br>网络管理器(network manager): 网路 I&#x2F;O 是个大问题，尤其是对于分布式数据库。所以一些数据库具备自己的网络管理器<br>文件系统管理器(File system manager): 磁盘 I&#x2F;O 是数据库的首要瓶颈。具备一个文件系统管理器来完美地处理OS文件系统甚至取代OS文件系统，是非常重要的。<br>内存管理器(memory manager): 为了避免磁盘 I&#x2F;O 带来的性能损失，需要大量的内存。但是如果你要处理大容量内存你需要高效的内存管理器，尤其是你有很多查询同时使用内存的时候。<br>安全管理器 (Security Manager) : 用于对用户的验证和授权<br>客户端管理器 (Client manager) : 用于管理客户端连接。</p>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>备份管理器 (Backup manager) : 用于保存和恢复数据<br>恢复管理器 (Recovery manager) : 用于崩溃后重启数据库到一个一致状态。<br>监控管理器 (Monitor manager) : 用于记录数据库活动信息和提供监控数据库的工具。<br>管理员管理器(Administration manager) : 用于保存元数据(比如表的名称和结构)，提供管理数据库、模式、表空的工具</p>
<h3 id="查询管理器"><a href="#查询管理器" class="headerlink" title="查询管理器"></a>查询管理器</h3><p>查询解析器 (Query parser) : 用于检查查询是否合法<br>查询重写器 (Query rewriter) : 用于预优化查询<br>查询优化器 (Query optimizer) : 用于优化查询<br>查询执行器 (Query executor) : 用于编译和执行查询</p>
<h3 id="数据管理器"><a href="#数据管理器" class="headerlink" title="数据管理器"></a>数据管理器</h3><p>事务管理器 (Transaction manager) : 用于处理事务<br>缓存管理器 (Cache manager): 数据被使用之前置于内存，或者数据写入磁盘之前置于内存<br>数据访问管理器 (Data access manager) : 访问磁盘中的数据</p>
<h2 id="数据查询的流程"><a href="#数据查询的流程" class="headerlink" title="数据查询的流程"></a>数据查询的流程</h2><ul>
<li><strong>客户端管理器</strong>： 客户端管理器是处理客户端通信的。客户端可以是一个（网站）服务器或者一个最终用户或最终应用。客户端管理器通过一系列知名的API（JDBC, ODBC, OLE-DB …）提供不同的方式来访问数据库。客户端管理器也提供专有的数据库访问API。<br>（<code>JDBC</code> 是 Java 编程语言中用于连接和操作数据库的标准<strong>API</strong>。可以理解为 JDBC 是 Java 与数据库之间的桥梁，允许 Java 应用程序与 MySQL 数据库进行通信和交互。<code>MyBatis</code> 是一个开源的<strong>Java持久层框架</strong>，用于将对象与关系数据库的表之间进行映射,使用 MyBatis 来操作 MySQL 数据库。）</li>
<li><strong>查询管理器</strong>：查询首先被解析并判断是否合法、然后被重写，去除了无用的操作并且加入预优化部分、接着被优化以便提升性能，并被转换为可执行代码和数据访问计划、然后计划被编译、最后，被执行</li>
<li><strong>数据管理器</strong>：在这一步，查询管理器执行了查询，需要从表和索引获取数据，于是向数据管理器提出请求。</li>
<li><strong>客户端管理器</strong></li>
</ul>
<h3 id="管理用户权限"><a href="#管理用户权限" class="headerlink" title="管理用户权限"></a>管理用户权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建用户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;newuser&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span>;</span><br><span class="line"><span class="comment">-- 授予用户权限</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> mydatabase.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;newuser&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"><span class="comment">-- 刷新权限</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<h3 id="备份和恢复"><a href="#备份和恢复" class="headerlink" title="备份和恢复"></a>备份和恢复</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 备份数据库</span></span><br><span class="line">mysqldump -u username -p mydatabase &gt; backup.sql</span><br><span class="line"><span class="comment"># 恢复数据库</span></span><br><span class="line">mysql -u username -p mydatabase &lt; backup.sql</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/11/Mysql/" data-id="clzzl7c2b000au0v5eicua4sy" data-title="MySQL" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-VMware_SSH" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/05/VMware_SSH/" class="article-date">
  <time class="dt-published" datetime="2022-03-05T09:02:15.000Z" itemprop="datePublished">2022-03-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/05/VMware_SSH/">VMware / SSH</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="虚拟机-VM"><a href="#虚拟机-VM" class="headerlink" title="虚拟机 (VM)"></a><strong>虚拟机 (VM)</strong></h2><ul>
<li>虚拟机（Virtual Machine）是一种利用软件模拟硬件的技术，使得一台物理计算机可以同时运行多个虚拟的操作系统或应用程序实例。虚拟机技术提供了更好的资源利用率、隔离性和灵活性，常见的虚拟机有硬件虚拟机和软件虚拟机两种。</li>
<li>它包括虚拟的 CPU、内存、硬盘、网络接口等组件。</li>
<li>可以在虚拟机上安装操作系统和应用程序，就像在物理计算机上一样。</li>
<li>虚拟机和容器的区别：虚拟机模拟整个操作系统，资源占用相对较多；容器共享主机的操作系统内核，更轻量级，启动速度快。</li>
</ul>
<h2 id="VMware-Workstation"><a href="#VMware-Workstation" class="headerlink" title="VMware Workstation"></a>VMware Workstation</h2><ul>
<li>VMware Workstation 是一款用于虚拟化的桌面软件，它允许用户在单个物理计算机上运行多个虚拟操作系统。</li>
<li>创建虚拟机：启动 VMware Workstation，<br>1、创建新虚拟机，选择ISO文件，填写虚拟机的名称以及将来保存的位置；<br>2、虚拟机配置：按照向导的指示配置虚拟机，包括选择操作系统、分配内存、创建虚拟硬盘等；安装操作系统：<br>3、启动虚拟机，按照正常流程安装选定的操作系统。</li>
<li>虚拟机克隆： VMware Workstation 允许你克隆虚拟机，以便快速创建相似的虚拟机。</li>
<li>虚拟机导入：(除了创建虚拟机外) 你可以导入其他虚拟化平台的虚拟机。导入虚拟机时，通常使用的是虚拟机的配置文件和虚拟硬盘文件。（存放于 <code>C:\Users\蔡枫\Documents\Virtual Machines</code> 或 <code>D:\Virtual Machines</code>）<ul>
<li>虚拟机配置文件： 这个文件包含了虚拟机的设置、硬件配置、网络配置等信息。在 VMware 中，这个文件通常有一个扩展名为 <code>.vmx</code>。当你导入虚拟机时，你需要选择这个配置文件。</li>
<li>虚拟硬盘文件： 这个文件包含了虚拟机的硬盘数据，即操作系统和应用程序的安装等信息。在 VMware 中，虚拟硬盘文件的格式通常是 <code>.vmdk</code>。你也需要选择这个文件来导入虚拟机。</li>
</ul>
</li>
<li>在VMware界面中操作虚拟机非常不友好，一般推荐使用专门的<a target="_blank" rel="noopener" href="https://leo710aka.github.io/2022/03/06/SSH/"><strong>SSH客户端</strong></a>。市面上常见有：Xshell，Finshell，<a target="_blank" rel="noopener" href="https://leo710aka.github.io/2022/03/06/SSH/">MobarXterm</a></li>
</ul>
<h2 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h2><p>一个基于Red Hat Enterprise Linux（RHEL）源代码构建的开源操作系统。默认账号：root，，账号2：<strong>leo</strong>，密码：<strong>cx078xxx</strong>。</p>
<ul>
<li>虚拟机目录：D:\VMCentOS-7，(网络适配器)名称：ens33；默认路由(网关)：192.168.111.2，DNS：192.168.111.2<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[leo@localhost ~]$ ifconfig</span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">      inet 192.168.111.128  netmask 255.255.255.0  broadcast 192.168.111.255 <span class="comment"># IPv4 子网掩码 广播地址</span></span><br><span class="line">      inet6 fe80::2304:6b2e:1716:b51  prefixlen 64  scopeid 0x20&lt;<span class="built_in">link</span>&gt;       <span class="comment"># IPv6地址</span></span><br><span class="line">      ether 00:0c:29:1a:cb:1a  txqueuelen 1000  (Ethernet)                   <span class="comment"># MAC 地址</span></span><br><span class="line">      RX packets 1704  bytes 1628741 (1.5 MiB)</span><br><span class="line">      RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">      TX packets 850  bytes 71942 (70.2 KiB)</span><br><span class="line">      TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>
设置 ipv4 method为手动（网卡地址改为静态IP，这样可以避免每次启动虚拟机IP都变化）</li>
</ul>
<h2 id="Kali-Linux"><a href="#Kali-Linux" class="headerlink" title="Kali Linux"></a>Kali Linux</h2><p>Kali Linux（简称Kali）是一个基于Debian Linux的专业渗透测试和网络安全评估发行版。它提供了大量的安全工具，方便安全专业人员进行渗透测试、网络扫描、恢复密码等操作。默认账号：<strong>kali</strong>，默认密码：<strong>kali</strong><br>专业工具集：预装了大量的渗透测试和安全评估工具，包括 Metasploit、Wireshark、Nmap、Aircrack-ng 等。</p>
<hr>

<h1 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h1><ol>
<li>SSH（Secure Shell）是一种用于在网络上进行加密通信的协议。它通常用于通过不安全的网络（例如互联网）安全地访问远程计算机上的终端。SSH 协议的主要目的是提供加密和身份验证，确保在客户端和服务器之间传输的数据是安全的。</li>
<li>SSH 协议有两个主要组件：<strong>SSH客户端</strong>：用于发起远程连接的计算机上的程序。通过 SSH 客户端，用户可以连接到远程计算机并执行命令； <strong>SSH服务器</strong>：运行在远程计算机上的程序，接受来自客户端的连接并提供终端访问或执行其他操作。</li>
<li>SSH 还可以用于文件传输和端口转发等用途，使其成为管理和维护远程服务器的强大工具。在日常工作中，开发人员、系统管理员和网络管理员经常使用 SSH 来远程管理和维护服务器。</li>
</ol>
<h3 id="SSH命令行工具"><a href="#SSH命令行工具" class="headerlink" title="SSH命令行工具"></a>SSH命令行工具</h3><p>Windows命令提示符和PowerShell都支持SSH命令。你可以使用ssh命令来连接到远程服务器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh username@hostname  <span class="comment"># 用户名 @ 公网IP</span></span><br><span class="line">ssh -i 密钥文件 username@hostname  <span class="comment"># 密钥登录</span></span><br></pre></td></tr></table></figure>

<h2 id="SSH客户端：MobarXterm"><a href="#SSH客户端：MobarXterm" class="headerlink" title="SSH客户端：MobarXterm"></a>SSH客户端：MobarXterm</h2><p>如果远程服务器上的操作系统的界面使用起来不方便，可以使用ssh客户端连接并操控远程服务器，<strong>包括本机上的虚拟机；</strong><br>在VMware界面中操作虚拟机非常不友好，一般推荐使用专门的SSH客户端，常见有 Xshell，Finshell，MobarXterm</p>
<h3 id="连接虚拟机"><a href="#连接虚拟机" class="headerlink" title="连接虚拟机"></a><strong>连接虚拟机</strong></h3><p>1、打开MobarXterm，点击session按钮，进入会话管理：<br>2、在弹出的session管理页面中，填写信息：Remote Host(虚拟机的ipv4地址)，Specify name(root)<br>3、输入密码：(与虚拟机的一样？)cx0xx1xx，连接本机上 VMware中的 CentOS7系统的虚拟机<br>4、连接(虚拟机)成功后，进入操作界面了，通过 MobarXterm界面 对 VMware中的虚拟机 进行操作。</p>
<h3 id="使用-MobarXterm-操作-Docker"><a href="#使用-MobarXterm-操作-Docker" class="headerlink" title="使用 MobarXterm 操作 Docker"></a>使用 MobarXterm 操作 Docker</h3><ol>
<li><strong>启动虚拟机</strong>，使用 MobarXterm 连接虚拟机成功后，进入操作界面。<strong>在 MobarXterm界面上 对 VMware中的虚拟机 进行操作。</strong></li>
<li>安装配置 Docker<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先要安装一个yum工具，并配置Docker的yum源</span></span><br><span class="line">yum install -y yum-utils</span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"><span class="comment"># 安装Docker</span></span><br><span class="line">yum install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br><span class="line">systemctl start docker    <span class="comment"># 启动Docker</span></span><br><span class="line">systemctl stop docker     <span class="comment"># 停止Docker</span></span><br><span class="line">systemctl restart docker  <span class="comment"># 重启</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker   <span class="comment"># 设置开机自启</span></span><br><span class="line">docker ps                 <span class="comment"># 执行docker ps命令，如果不报错，说明安装启动成功</span></span><br></pre></td></tr></table></figure></li>
<li>配置阿里云镜像加速，重启docker</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/05/VMware_SSH/" data-id="clzzl7c2d000ku0v5cc8hfa69" data-title="VMware / SSH" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2046/12/">December 2046</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2046/12/30/nice-photo/">Nice Photo</a>
          </li>
        
          <li>
            <a href="/2024/08/18/%E4%BF%9D%E9%99%A9/">保 险</a>
          </li>
        
          <li>
            <a href="/2024/07/07/%E7%BE%8E%E7%9A%84Midea/">美 的 Midea</a>
          </li>
        
          <li>
            <a href="/2024/05/01/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/">毕 业 设 计</a>
          </li>
        
          <li>
            <a href="/2024/01/11/RabbitMQ/">RabbitMQ</a>
          </li>
        
          <li>
            <a href="/2024/01/07/SpringCloud/">SpringCloud</a>
          </li>
        
          <li>
            <a href="/2024/01/04/%E9%AA%8F%E4%BC%AFJunbo/">骏 伯 Junbo</a>
          </li>
        
          <li>
            <a href="/2023/10/20/%E6%98%A5%E6%8B%9B2024/">春 招 2024</a>
          </li>
        
          <li>
            <a href="/2023/10/13/%E9%9D%A2%E8%AF%95_%E4%B8%AA%E4%BA%BA/">面 逝 | 个人</a>
          </li>
        
          <li>
            <a href="/2023/10/12/%E9%9D%A2%E8%AF%95_Java/">面 逝 | Java</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 fengcai<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>