<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Qué miras Bobo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Qué miras Bobo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Qué miras Bobo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="fengcai">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Qué miras Bobo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="https://github.com/leo710aka/bk/blob/main/DT1.jpg?raw=true">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Qué miras Bobo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Colab" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/31/Colab/" class="article-date">
  <time class="dt-published" datetime="2023-07-31T02:25:07.000Z" itemprop="datePublished">2023-07-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/31/Colab/">Colab</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>Google Colab</strong>是谷歌提供的免费<strong>Jupyter</strong>笔记本环境，不需要配置环境（本质是<strong>Linux虚拟机</strong>），可以加!运行bash命令。提供一定免费的GPU，可以跑 Tensorflow、Pytorch 等深度学习框架。Google Colab提供的资源量是受限制的，所有 Colab 运行时都会在一段时间后重置。Colab Pro 订阅者的使用量仍会受到限制，但相比非订阅者可享有的限额要多出大约一倍。Colab Pro+ 订阅者还可获享更高的稳定性。</p>
<p>使用Colab训练比较重要的是处理好路径的关系，找到哪个文件在哪里，文件夹的执行目录在哪里，就可以比较简单的运行起程序了，不过Colab确实存在断线问题，我们需要时刻保存好文件，因此我将权值直接保存在云盘上，这样也不会丢失。<br><strong>12h</strong>的限额比较难受，有时候没到时间就限额了。因此需要及时保存训练的模型，长时间不用gpu的情况下也会被限额（Pro版也一样），因此训练完建议及时改成gpu或停止。</p>
<h3 id="Google-Drive"><a href="#Google-Drive" class="headerlink" title="Google Drive"></a>Google Drive</h3><p>谷歌云盘，谷歌云端硬盘。免费用户可以获取15G的空间，付费用户根据套餐可以选择最大20TB的储存空间。<br><strong>虚拟机根目录为 &#x2F;content，谷歌云盘地址为 &#x2F;content&#x2F;Drive&#x2F;MyDrive</strong></p>
<h3 id="深度学习库的下载"><a href="#深度学习库的下载" class="headerlink" title="深度学习库的下载"></a>深度学习库的下载</h3><p>使用git clone指令进行下载，然后通过cd指令将根目录转移到了xx文件夹。<strong>此时根目录为 &#x2F;content&#x2F;xx</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!git <span class="built_in">clone</span> https://github.com/xx/xx.git</span><br><span class="line">%<span class="built_in">cd</span> xx/</span><br></pre></td></tr></table></figure>

<h3 id="数据集与预训练权重的上传"><a href="#数据集与预训练权重的上传" class="headerlink" title="数据集与预训练权重的上传"></a>数据集与预训练权重的上传</h3><p>数据集压缩，上传Google Drive，在colab中打开的jupyter文件（等于打开了一个Linux<strong>虚拟机本地</strong>）中挂载Google Drive；将数据集从Drive中复制到当前根目录，解压。<strong>直接将数据集布置在谷歌云盘会导致大量的云盘数据传输，且谷歌云盘和虚拟机之间存在通信带宽，速度远不及本地(虚拟机)文件，因此需要将数据集复制解压到本地(虚拟机)里进行处理。</strong> (<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44791964/article/details/123659637?spm=1001.2014.3001.5501">https://blog.csdn.net/weixin_44791964/article/details/123659637?spm=1001.2014.3001.5501</a>)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!<span class="built_in">cp</span> /content/Drive/MyDrive/xx.zip ./</span><br><span class="line">!unzip ./xx.zip -d ./</span><br></pre></td></tr></table></figure>
<p>预训练权重存放在 &#x2F;content&#x2F;Drive&#x2F;MyDrive&#x2F;Models&#x2F;xx，然后创建logs和model_data。model_data放置的是预训练文件,logs放置的是网络训练过程中产生的权值。</p>
<h3 id="保存路径设置"><a href="#保存路径设置" class="headerlink" title="保存路径设置"></a>保存路径设置</h3><p>如果将权值保存在当前根目录下的logs文件夹（&#x2F;content&#x2F;xx&#x2F;logs），发生断线网络就白训练了，浪费大量的时间。<br>可以将google云盘软连接到根目录下，那么即使断线，权值也保留在云盘中。<br>本文之前在云盘中创建了logs文件夹（&#x2F;content&#x2F;Drive&#x2F;MyDrive&#x2F;Models&#x2F;xx&#x2F;logs），将该文件夹链接到当前根目录下的logs文件夹中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!<span class="built_in">ln</span> -s /content/Drive/MyDrive/Models/xx/logs logs   <span class="comment"># 即/content/xx/logs</span></span><br></pre></td></tr></table></figure>
<h3 id="开始训练"><a href="#开始训练" class="headerlink" title="开始训练"></a>开始训练</h3><p>1、标注文件的处理<br>2、训练文件的处理<br>1）预训练文件的使用。<br>2）保存周期的设置，这个设置是因为云盘的存储空间有限，每代都保存会导致存储空间满出。<br>3、开始训练：!python train.py</p>
<h3 id="常用-colab-命令"><a href="#常用-colab-命令" class="headerlink" title="常用 colab 命令"></a>常用 colab 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import shutil</span><br><span class="line">shutil.copytree(<span class="string">&quot;复制的文件夹&quot;</span>,<span class="string">&quot;目标路径+目标路径下的文件夹&quot;</span>)  <span class="comment"># 复制路径下的文件夹</span></span><br><span class="line">shutil.copytree(<span class="string">&quot;/content/drive/My Drive/channel&quot;</span>,<span class="string">&quot;/content/drive/My Drive/channel10&quot;</span>) <span class="comment"># ex</span></span><br><span class="line">shutil.rmtree(<span class="string">&quot;移除路径下的文件夹&quot;</span>) <span class="comment"># 移除路径下的文件夹</span></span><br><span class="line">shutil.copy(<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>) <span class="comment"># 复制单个文件的命令  同上</span></span><br><span class="line"><span class="comment"># 删除单个文件可以右键删除</span></span><br><span class="line">!<span class="built_in">pwd</span> <span class="comment"># 显示当前目录, /content 为根目录</span></span><br><span class="line">import os </span><br><span class="line">os.chdir(<span class="string">&quot;/content/federated-learning&quot;</span>) <span class="comment"># 变更根目录操作</span></span><br><span class="line">!python <span class="string">&quot;/content/federated-learning/main_nn.py&quot;</span> <span class="comment"># 运行python 文件</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/31/Colab/" data-id="cls3bhyxl0005sgv57dn31tja" data-title="Colab" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Pytorch" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/14/Pytorch/" class="article-date">
  <time class="dt-published" datetime="2023-07-14T03:58:39.000Z" itemprop="datePublished">2023-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/14/Pytorch/">Pytorch</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="TensorBoard"><a href="#TensorBoard" class="headerlink" title="TensorBoard"></a>TensorBoard</h3><p>打开localhost:6006，访问TensorBoard，查看TensorFlow模型的图形、损失函数、精度等信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorboardX <span class="keyword">import</span> SummaryWriter</span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;xxx&quot;</span>)               <span class="comment"># 在文件夹里新建一个abc文件夹</span></span><br><span class="line">writer.add_scalar(<span class="string">&quot;y=2i&quot;</span>, <span class="number">2</span>*i, i)           <span class="comment"># 加坐标</span></span><br><span class="line">writer.add_images(<span class="string">&quot;test_data&quot;</span>, imgs, step)  <span class="comment"># 加图</span></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Pycharm -&gt; Terminal</span></span><br><span class="line">PS C:\Users\cf\Documents\Visual Studio Code\Python\learn_pytorch&gt; tensorboard --logdir=<span class="string">&quot;xxx&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="nn-Module"><a href="#nn-Module" class="headerlink" title="nn.Module"></a>nn.Module</h3><p>基本神经网络</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">cf</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__int__</span>(<span class="params">self</span>):   <span class="built_in">super</span>().__init__()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):      <span class="comment"># 必须重写forword()</span></span><br><span class="line">        output = <span class="built_in">input</span> + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>

<p><strong>输入层（Input Layer）：</strong>接受原始图像或数据作为输入。<br><strong>卷积层（Convolutional Layer）：</strong>进行特征提取。通过卷积操作，利用卷积核（或过滤器）从输入图像中提取特定的特征，如边缘、纹理等。卷积核会在整个图像上滑动，产生特征图。<br>卷积核的输入通道数与输入数据的通道数对应，卷积核的输出通道数与卷积核的数量对应。<br>卷积操作在神经网络中扮演着关键的角色，它通过特征提取、参数共享、空间局部性和参数数量控制等方面，使得卷积神经网络成为图像处理和计算机视觉任务中非常有效的工具。<br><strong>池化层（Pooling Layer）</strong>【最大ceil, 最小floor】：降采样和减少参数，避免过拟合。池化操作对特征图进行降采样，减少特征图的尺寸，并保留重要的特征信息。常用的池化方式为最大池化（Max Pooling）和平均池化（Average Pooling）。<br><strong>非线性激活：</strong>线性变换（如全连接层）在神经网络中只能实现线性映射，而现实世界中的数据和任务通常都是非线性的。为了解决这个问题，需要在网络中引入非线性激活函数，以增加网络的表达能力和灵活性。 给网络中引入非线性特征，以训练出符合各种曲线的模型。<br>·ReLU（Rectified Linear Unit）：f(x) &#x3D; max(0, x)，它在x大于0时是线性的，小于等于0时为0，能够有效地解决梯度消失问题。<br>·Sigmoid：f(x) &#x3D; 1 &#x2F; (1 + exp(-x))，它将输入映射到[0, 1]区间，用于二分类问题。<br>·Tanh：f(x) &#x3D; (exp(x) - exp(-x)) &#x2F; (exp(x) + exp(-x))，它将输入映射到[-1, 1]区间，也用于解决梯度消失问题。<br><strong>正则化层（Regularization Layer）：</strong>正则化层用于防止过拟合。过拟合是指模型在训练数据上表现良好，但在未见过的测试数据上表现较差的现象。正则化层通过添加一些额外的约束或惩罚项来控制模型的复杂度，以避免过度拟合。<br>·L1正则化：将参数的绝对值加入到损失函数中，使得模型倾向于产生稀疏的权重矩阵。<br>·L2正则化：将参数的平方加入到损失函数中，限制权重的大小，防止权重过大造成过拟合。<br>·Dropout正则化：随机在训练过程中丢弃一部分神经元，减少神经元之间的共适应性，提高泛化能力。<br><strong>全连接层（Fully Connected Layer）：</strong>将特征矩阵集合向量化。与卷积层不同，全连接层的神经元排成一列，这些神经元与前一层神经元通过权值互连，呈全连接结构。全连接层的层数以及每层神经元数并不固定。通常层数越高，神经元数目越少。<br>功能：进行分类。在卷积和池化层之后，通过全连接层将得到的特征映射转换为一维向量，并通过一系列的全连接神经元进行分类操作，将输入映射到对应的类别概率。<br><strong>输出层（Output Layer）：</strong>经过多层特征提取后，最后一层输出层可视为分类器，预测输入样本的类别。通常使用Softmax函数将全连接层的输出转换为类别概率分布，确定输入图像最可能属于哪个类别。<br><img src="https://leo710aka.github.io/bk/nn.png"></p>
<p>Sequential</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">self.model1 = Sequential(</span><br><span class="line">            Conv2d(in_channels=<span class="number">3</span>, out_channels=<span class="number">32</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(kernel_size=<span class="number">2</span>, ceil_mode=<span class="literal">True</span>),</span><br><span class="line">            Conv2d(<span class="number">32</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),     <span class="comment"># 二维卷积层</span></span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Flatten(),</span><br><span class="line">            Linear(<span class="number">1024</span>, <span class="number">64</span>),</span><br><span class="line">            Linear(<span class="number">64</span>, <span class="number">10</span>)</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>

<p>一次训练+验证：准备数据 - 加载数据 - 准备模型 - 设置损失函数 - 设置优化器 - 开始训练 - 验证 - 聚合展示</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):  <span class="comment"># 共20轮训练</span></span><br><span class="line">    running_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> dataloader:  <span class="comment"># 对数据进行一轮学习</span></span><br><span class="line">        imgs, targets = data</span><br><span class="line">        output = fc(imgs)</span><br><span class="line">        result_loss = loss(output, targets)  <span class="comment"># 计算损失</span></span><br><span class="line">        optim.zero_grad()  <span class="comment"># 优化器中，梯度置0</span></span><br><span class="line">        result_loss.backward()  <span class="comment"># 损失函数求梯度，反向传播</span></span><br><span class="line">        optim.step()  <span class="comment"># 优化器，优化卷积核参数</span></span><br><span class="line">        running_loss = running_loss + result_loss</span><br><span class="line">    <span class="built_in">print</span>(running_loss)</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/14/Pytorch/" data-id="cls3bhyxw000ksgv5hv1pgat7" data-title="Pytorch" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Anaconda" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/10/Anaconda/" class="article-date">
  <time class="dt-published" datetime="2023-07-10T06:15:42.000Z" itemprop="datePublished">2023-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/10/Anaconda/">Anaconda</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol>
<li>利用 Anaconda，创建不同版本的虚拟环境，配置不同的包（如不同版本的 Pytorch），以管理不同的项目。</li>
<li>用 Pycharm 打开项目时，点击添加解释器 —&gt; 添加本地解释器，选择该项目对应的 conda 虚拟环境下，该虚拟环境的 python 解释器。选择使用这个虚拟环境对应的编辑器，就是选择了使用这个环境运行项目，使用这个环境中配好的包等等。</li>
<li>所以要注意终端使用的是哪个编辑器，是否与当前项目使用的编辑器匹配。否则 pip install 把包装到一个虚拟环境，而当前项目运行在另一个虚拟环境中，便无法 import 已安装的包。</li>
</ol>
<h3 id="新建虚拟环境"><a href="#新建虚拟环境" class="headerlink" title="新建虚拟环境"></a>新建虚拟环境</h3><p>打开Anaconda Prompt，创建一个名字为py36的python版本为3.6的虚拟环境（默认地址已改成D:\anaconda3\envs），并查看已有环境：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(base) C:\Users\cf&gt;conda create -n py36 python=3.6</span><br><span class="line">Proceed ([y]/n)? y</span><br><span class="line">(base) C:\Users\cf&gt;conda <span class="built_in">env</span> list</span><br><span class="line"><span class="comment"># conda environments:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">  base                  *  D:\anaconda3</span><br><span class="line">  py36                     D:\anaconda3\envs\py36</span><br></pre></td></tr></table></figure>

<p>激活（切换）环境，并查看该环境下已有包：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(base) C:\Users\cf&gt;conda activate py36</span><br><span class="line">(py36) C:\Users\cf&gt;pip list</span><br></pre></td></tr></table></figure>
<h3 id="装包"><a href="#装包" class="headerlink" title="装包"></a>装包</h3><p>方法1：在 Anaconda Prompt 中进入该环境后，执行 conda install … 或 pip install …(需要关闭代理)<br>方法2：在 Pycharm的terminal（终端），执行安装指令（此时所处的是 Pycharm终端 的环境（不一定是此时加载的项目的环境））</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其他pip指令</span></span><br><span class="line">pip list                                     <span class="comment"># 列出所有已安装的pip包</span></span><br><span class="line">pip install package_name==desired_version    <span class="comment"># 安装指定版本的Python包</span></span><br><span class="line">pip install --target=... package_name        <span class="comment"># 指定pip install包的路径</span></span><br><span class="line">pip show package_name                        <span class="comment"># 查看安装好的包的信息</span></span><br></pre></td></tr></table></figure>

<h3 id="Jupyter-Notebook"><a href="#Jupyter-Notebook" class="headerlink" title="Jupyter Notebook"></a>Jupyter Notebook</h3><p><font color= "#87CEFA  "><strong>以任意行为块，便于代码阅读和测试修改。</strong></font> 在一个环境中安装 jupyter notebook 后，运行:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(py36) C:\Users\cf&gt;jupyter notebook        </span><br></pre></td></tr></table></figure>
<p>在浏览器打开8888端口使用 <a target="_blank" rel="noopener" href="http://localhost:8888/?token=7e39781c1e364fa7a5ee95ef290ffa92eb0caef0c19aaad8">http://localhost:8888/?token=7e39781c1e364fa7a5ee95ef290ffa92eb0caef0c19aaad8</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/10/Anaconda/" data-id="cls3bhyxm0006sgv53687b0pw" data-title="Anaconda" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Docker" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/14/Docker/" class="article-date">
  <time class="dt-published" datetime="2023-04-14T03:49:42.000Z" itemprop="datePublished">2023-04-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/14/Docker/">Docker</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Docker 是一种开源平台，一种快速构建、运行和管理应用的工具。它使用容器化技术，使得应用程序及其依赖性可以打包到一个容器中，并在任何支持 Docker 的环境中运行。<br><a target="_blank" rel="noopener" href="https://leo710aka.github.io/2022/03/06/SSH/"><strong>MobarXterm 通过 SSH 连接 linux虚拟机，操作虚拟机上的 Docker。</strong></a><br><img src="https://github.com/leo710aka/bk/blob/main/docker.png?raw=true"></p>
<h3 id="容器（Container）"><a href="#容器（Container）" class="headerlink" title="容器（Container）"></a><strong>容器（Container）</strong></h3><ul>
<li>容器是一个轻量级的、可移植的、自包含的单元，包括应用程序和其所有依赖项。</li>
<li>Docker 利用容器技术，将应用程序及其依赖项打包成一个容器，确保在不同环境中的一致性运行。</li>
<li><strong>Docker 位于容器 和 服务器-操作系统&#x2F;硬件 之间，是运行容器的引擎。</strong></li>
<li>隔离网络、文件、进程等环境。一个容器是一个沙盒隔离环境。</li>
<li>相对于虚拟机技术，docker 启动更快、更清量。但容器共用宿主机的内存、CPU物理资源，多容器可能存在互相抢占资源的情况。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \                  <span class="comment"># 创建并运行一个容器，-d 是让容器在后台运行；同一个镜像可创建多个容器</span></span><br><span class="line">   --name mysgl \                <span class="comment"># 给容器起名字，必须唯一</span></span><br><span class="line">   -p 3306:3306 \                <span class="comment"># 设置 宿主机端口：容器端口 映射</span></span><br><span class="line">   -e TZ=Asia/Shanghai \         <span class="comment"># 设置环境变量</span></span><br><span class="line">   -e MYSQL_ROOT_PASSWORD=123 \  <span class="comment"># 指定运行的镜像名，一般为 [镜像名]:[镜像版本]</span></span><br><span class="line">   mysql</span><br><span class="line">docker ps                        <span class="comment"># 查看本地容器（运行中的）</span></span><br><span class="line">docker ps a                      <span class="comment"># 查看所有容器 (包括未运行)</span></span><br><span class="line">docker start &lt;容器ID&gt;          <span class="comment"># 启动容器</span></span><br><span class="line">docker stop  &lt;容器ID&gt;          <span class="comment"># 停止容器中的进程，容器未删除</span></span><br><span class="line">docker <span class="built_in">rm</span> &lt;容器ID&gt;             <span class="comment"># 删除容器</span></span><br><span class="line">docker inspect &lt;容器ID&gt;        <span class="comment"># 查看容器配置信息 </span></span><br><span class="line">docker <span class="built_in">log</span> &lt;容器ID&gt;            <span class="comment"># 查看容器日志 </span></span><br><span class="line">docker <span class="built_in">exec</span> -it &lt;容器ID&gt; bash  <span class="comment"># 进入容器内部，命令行模式（容器内部模拟出一个操作系统）</span></span><br><span class="line">容器打包成镜像: docker commit -a <span class="string">&quot;作者信息&quot;</span> -m <span class="string">&quot;log信息&quot;</span> &lt;容器ID&gt;&lt;目标镜像名称:tag版本&gt; </span><br><span class="line">拷贝文件到容器: docker <span class="built_in">cp</span> &lt;文件目录&gt; &lt;容器ID&gt;:&lt;目标目录&gt;</span><br><span class="line">拷贝容器文件到宿主机:docker <span class="built_in">cp</span> &lt;容器ID&gt;:&lt;文件目录&gt;&lt;宿主机目标目录&gt;</span><br><span class="line">更新容器设置:docker update &lt;容器ID&gt;&lt;相关设置&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="镜像（Image）"><a href="#镜像（Image）" class="headerlink" title="镜像（Image）"></a><strong>镜像（Image）</strong></h3><ul>
<li>镜像是一个只读的模板，包含运行应用程序所需的所有信息，包括代码、运行时、库、环境变量和配置文件。</li>
<li><strong>容器是通过运行镜像创建的（像光盘），本地容器是真正运行的实例。镜像是容器的模板，是从容器打包来的，可以在不同操作系统，不同服务器之间传播。</strong></li>
<li>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker images                                <span class="comment"># 查看本地镜像</span></span><br><span class="line">docker search &lt;名称关键字&gt;                     <span class="comment"># 搜索镜像仓库</span></span><br><span class="line">docker pull &lt;镜像名:tag版本&gt;                   <span class="comment"># 下载镜像</span></span><br><span class="line">docker push &lt;镜像名:tag版本&gt;                   <span class="comment"># 上传镜像</span></span><br><span class="line">docker rmi &lt;镜像名:tag版本&gt;                    <span class="comment"># 删除镜像</span></span><br><span class="line">docker save -o &lt;输出文件路径&gt;&lt;镜像名:tag版本&gt;    <span class="comment"># 打包本地镜像文件</span></span><br><span class="line">docker load -i &lt;加载文件路径                   <span class="comment"># 导入本地镜像文件</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="仓库（Registry）"><a href="#仓库（Registry）" class="headerlink" title="仓库（Registry）"></a><strong>仓库（Registry）</strong></h3><ul>
<li>仓库是存储和组织 Docker 镜像的地方。Docker Hub 是一个常见的公共仓库，你也可以搭建私有仓库。</li>
<li>Docker 镜像可以从仓库中拉取，也可以推送到仓库。</li>
</ul>
<h3 id="沙箱"><a href="#沙箱" class="headerlink" title="沙箱"></a><strong>沙箱</strong></h3><ul>
<li>沙箱是一种安全机制，用于隔离和限制程序或应用程序的运行环境，以防止其对系统或其他程序产生潜在的危害。沙箱技术旨在创建一个受控制的环境，使得运行在其中的代码无法直接影响到系统的其他部分。这种隔离有助于确保安全性、防止恶意软件传播，同时提供一定程度的控制和监控。</li>
<li>容器化平台（如 Docker）使用沙箱技术来隔离容器中的应用程序，确保它们互相独立运行。</li>
</ul>
<h2 id="容器创建"><a href="#容器创建" class="headerlink" title="容器创建"></a><strong>容器创建</strong></h2><p>镜像结构：入口，层，基础镜像。分层的好处是可复用，，</p>
<ul>
<li>通过命令直接创建，需要完整镜像，几个G常有，稳定。</li>
<li>通过<strong>dockerfile</strong>创建，不需要完整镜像，更灵活。<br>Dockerfile 是一个包含构建镜像步骤的文本文件，包含一个个的指令。通过编写 Dockerfile，你可以定义如何构建镜像，包括基础镜像、安装依赖、复制文件等步骤。</li>
<li>使用 Docker 的基本步骤<ol>
<li><strong>安装 Docker：</strong> 根据操作系统的不同，安装适合的 Docker 版本。</li>
<li><strong>创建 Dockerfile：</strong> 编写包含应用程序构建步骤的 Dockerfile。</li>
<li><strong>构建镜像：</strong> 在包含 Dockerfile 的目录中运行 <code>docker build</code> 命令构建镜像。（如java项目还需要jar包）</li>
<li><strong>运行容器：</strong> 使用 <code>docker run</code> 命令基于构建的镜像创建和运行容器。</li>
<li><strong>发布镜像：</strong> 将构建的镜像推送到 Docker 仓库，以便其他人可以拉取使用。</li>
</ol>
</li>
</ul>
<h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><ul>
<li>数据卷(volume)是一个虚拟目录，是容器内目录与宿主机目录之间映射的桥梁（两边文件同时修改）。<br>（容器一般只包括支持运行的最少文件，一般无vi或其他编辑器，所以无法进入容器直接对容器中的文件进行修改）</li>
<li>如何挂载数据卷？在创建容器时，利用-v 数据卷名:容器内目录完成挂载。创建时如果发现挂载的数据卷不存在，会自动创建。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker volumels        <span class="comment"># 查看数据卷</span></span><br><span class="line">docker volume <span class="built_in">rm</span>       <span class="comment"># 删除数据卷</span></span><br><span class="line">docker volume inspect  <span class="comment"># 查看数据卷详情</span></span><br><span class="line">docker volume prune    <span class="comment"># 删除未使用的数据卷</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="容器编排-Orchestration-：运维人员"><a href="#容器编排-Orchestration-：运维人员" class="headerlink" title="容器编排(Orchestration)：运维人员"></a>容器编排(Orchestration)：运维人员</h3><p>容器编排是指在生产环境中管理和协调多个容器的过程。Docker 提供了 Docker Compose 工具，用于定义和运行多容器的应用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/14/Docker/" data-id="cls3bhyxn0008sgv5500s8nyf" data-title="Docker" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Git" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/12/Git/" class="article-date">
  <time class="dt-published" datetime="2023-04-12T09:02:15.000Z" itemprop="datePublished">2023-04-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/12/Git/">Git</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>First Project：）being confused and embrassed… luckily no one is staring at you but willing to help，as long as you try to find and explain a bug，try debugging、、<br><img src="https://github.com/leo710aka/bk/blob/main/git.png?raw=true" width="700" height="300" alt=""></p>
<p><strong>分布式版本控制工具 git</strong>：没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样工作的时候，无需要联网了因为版本库就在你自己的电脑上，多人协作只需要各自的修改推送给对方，就能互相看到对方的修改了（实际上一般还是用共享版本库控制）。</p>
<ol>
<li>clone (克隆):从远程仓库中克隆代码到本地仓库</li>
<li>checkout (检出) :从本地仓库中检出一个仓库分支然后进行修订</li>
<li>add (添加):在提交前先将代码提交到暂存区</li>
<li>commit (提交): 提交到本地仓库。本地仓库中保存修改的各个历史版本</li>
<li>fetch (抓取): 从远程库，抓取到本地仓库，不进行任何的合并动作，一般操作比较少。</li>
<li>pull(拉取) : 从远程库拉到本地库，自动进行合并(merge)，然后放到到工作区，相当于fetch+merge</li>
<li>push (推送) :修改完成后，需要和团队成员共享代码时，将代码推送到远程仓库</li>
</ol>
<h3 id="Git-Bash"><a href="#Git-Bash" class="headerlink" title="Git Bash"></a>Git Bash</h3><p>Git提供的命令行工具，(内置小Linux)可运行linux命令 cd、ls、touch…</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --list                         <span class="comment"># 查看配置</span></span><br><span class="line">git config --global user.name <span class="string">&quot;xx&quot;</span>        <span class="comment"># 配置 user.name_caifeng</span></span><br><span class="line">git config --global user.email <span class="string">&quot;xx&quot;</span>       <span class="comment"># user.email_1908454905@qq.com</span></span><br></pre></td></tr></table></figure>
<p>配置 Git 的全局用户信息，这些信息在你提交代码到 Git 仓库时会被记录下来，用于标识提交代码的作者信息。</p>
<h3 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h3><ul>
<li>leo710aka <a href="mailto:&#49;&#x39;&#x30;&#x38;&#120;&#120;&#x78;&#x78;&#120;&#120;&#x40;&#x71;&#113;&#x2e;&#99;&#x6f;&#109;">&#49;&#x39;&#x30;&#x38;&#120;&#120;&#x78;&#x78;&#120;&#120;&#x40;&#x71;&#113;&#x2e;&#99;&#x6f;&#109;</a> cxxxxxx</li>
<li>使用 SSH 密钥连接 GitHub：如果没有的话，使用？？？以下命令在本地<strong>生成 SSH 密钥</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;your_email@example.com&quot;</span></span><br></pre></td></tr></table></figure>
生成 SSH 密钥后，将 <code>~/.ssh/id_rsa.pub</code>（公钥）的内容添加到 GitHub 账号的 SSH 密钥设置中。</li>
<li>使用 HTTPS 认证连接 GitHub：<br>在 GitHub 上克隆仓库时，使用 HTTPS 链接，然后在推送更改时，会提示输入 GitHub 账号的用户名和密码，或者使用个人访问令牌（Personal Access Token）代替账号密码。</li>
</ul>
<h3 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h3><p>要使用Git对我们的代码进行版本控制，首先需要获得本地仓库<br>(1)在电脑的任意位置创建一个空目录(文件夹) 作为我们的本地Git仓库<br>(2)进入这个目录中，右键打开Git bash<br>(3)执行命令<code>git init</code><br>(4)如果创建成功后可在文件夹下看到隐藏的.git目录。</p>
<h3 id="添加-提交-推送"><a href="#添加-提交-推送" class="headerlink" title="添加 提交 推送"></a>添加 提交 推送</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status                                      <span class="comment"># 查看当前状态（红色的字体显示的是修改的文件</span></span><br><span class="line">$ git add 单个文件名|通配符(. 添加所有修改)            <span class="comment"># 添加工作区代码到本地git暂存区</span></span><br><span class="line">$ git commit -m <span class="string">&quot;提交的信息&quot;</span>                        <span class="comment"># 提交暂存区代码到本地git仓库（生成一个版本）</span></span><br><span class="line">$ git <span class="built_in">log</span>                                         <span class="comment"># 查看提交日志信息（head指向当前操作的分支）</span></span><br><span class="line">$ git push &lt;远程仓库名&gt; &lt;本地分支名&gt;                  <span class="comment"># 推送本地代码到远程仓库</span></span><br><span class="line">$ git push &lt;远程仓库名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;      <span class="comment"># 将指定的本地分支推送到远程仓库的指定分支</span></span><br></pre></td></tr></table></figure>
<p>或者在IDEA中：点击Git提交并推送，选择提交、添加信息、修改远程仓库的分支(默认<code>origin:main</code>)，推送。</p>
<h3 id="克隆远程项目"><a href="#克隆远程项目" class="headerlink" title="克隆远程项目"></a>克隆远程项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> &lt;远程仓库地址&gt;                 <span class="comment"># 克隆远程仓库到本地（默认分支master）</span></span><br><span class="line">$ git <span class="built_in">clone</span> -b &lt;分支名&gt; &lt;远程仓库地址&gt;      <span class="comment"># 克隆指定分支（如develop）</span></span><br></pre></td></tr></table></figure>


<h2 id="连接本地与远程仓库"><a href="#连接本地与远程仓库" class="headerlink" title="连接本地与远程仓库"></a>连接本地与远程仓库</h2><ol>
<li>上传本地仓库项目到远程<br>本地git bash生成ssh公钥，添加到gitee中，本地验证，添加远程仓库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa                                       <span class="comment"># 生成ssh密钥</span></span><br><span class="line">$ <span class="built_in">cat</span> ~/.ssh/id_rsa.pub                                   <span class="comment"># 查看密钥</span></span><br><span class="line">$ ssh -T git@gitee.com                                    <span class="comment"># 验证</span></span><br><span class="line">$ git remote add origin git@gitee.com:leo710aka/test.git  <span class="comment"># 添加远程仓库名为origin(别名)，加ssh地址</span></span><br><span class="line">$ git remote -v                                           <span class="comment"># 检查远程仓库配置是否正确</span></span><br><span class="line">$ git push origin master  <span class="comment"># 完成添加、提交后，将本地master分支推送至远程origin仓库</span></span><br></pre></td></tr></table></figure>
或者直接在idea中，对一个项目文件添加、提交后，直接在idea中<code>git remote</code>，使用github账号密码进行远程仓库的连接，然后推送。（连接远程仓库，要么使用ssh密钥，要么用github账号密码。）</li>
<li>添加远程仓库项目到本地<br>也可以先从远程仓库<code>git clone</code>下来一个项目，完成修改后对项目文件添加、提交，在推送到远程仓库时，再进行 <code>ssh密钥/github账号密码</code> 的验证。</li>
</ol>
<h3 id="更新项目"><a href="#更新项目" class="headerlink" title="更新项目"></a>更新项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch [remote name] [branch name]   <span class="comment"># 抓取指令就是将仓库里的更新都抓取到本地，不会进行合并。如果不指定远端名称和分支名，则抓取所有分支</span></span><br><span class="line">$ git pull [remote name] [branch name]    <span class="comment"># 拉取指令就是将远端仓库的修改拉到本地并自动进行合并，等同于fetch+merge。如果不指定远端名称和分支名，则抓取所有并更新当前分支。</span></span><br></pre></td></tr></table></figure>
<p>在一段时间，A、B用户修改了同一个文件，且修改了同一行位置的代码，此时会发生合并冲突A用户在本地修改代码后优先推送到远程仓库，此时B用户在本地修订代码，提交到本地仓库后，也需要推送到玩程仓库，此时B用户晚于A用户，故需要<strong>先拉取远程仓库的提交，经过合并后才能推送到远端分支</strong>。<br>或直接在IDEA里面选择分支pull（Git拉取），克隆&#x2F;更新后记得修改配置文件为测试&#x2F;本地（如果有）。</p>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><ul>
<li><strong><code>master分支</code>：</strong>线上分支，主分支，项目正在上线的分支</li>
<li><strong><code>develop分支</code>：</strong>部门开发分支，完成后合并到master</li>
<li>实际开发新功能，是在develop分支上创建feature分支，完成后合并到develop上（合并后就没用了，删掉）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git branch                  <span class="comment"># 查看本地所有的分支，当前激活的分支会在列表中以星号（*）标识。（一个不同的分支就是一个不同的本地仓库）</span></span><br><span class="line">$ git branch -r               <span class="comment"># 查看远程仓库的分支</span></span><br><span class="line">$ git branch -a               <span class="comment"># 查看所有分支，包括本地分支和远程分支。</span></span><br><span class="line">$ git branch caifeng          <span class="comment"># 从当前分支上新建分支</span></span><br><span class="line">$ git checkout caifeng        <span class="comment"># 切换分支</span></span><br><span class="line">$ git checkout -b caifeng     <span class="comment"># 创建（若不存在）并切换分支</span></span><br><span class="line">$ git checkout -d caifeng     <span class="comment"># 删除分支（-D 强制删除）</span></span><br><span class="line">$ git merge &lt;分支名&gt;           <span class="comment"># 先切换回如master分支上，将其他分支上的提交合并到master上</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><p>当两个分支上对文件的修改可能会存在冲突，例如同时修改了同一个文件的同一行，这时就需要手动解决冲突，解决冲突步骤:<br>1.处理文件中冲突的地方<br>2.将解决完冲突的文件加入暂存区(add)<br>3,提交到仓库(commit)<br><img src="https://github.com/leo710aka/bk/blob/main/git1.png?raw=true"></p>
<h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard &lt;提交<span class="built_in">id</span>&gt;    <span class="comment"># 通过提交id切换版本</span></span><br><span class="line">$ git reflog                  <span class="comment"># 查看历史操作（已清除提交日志、版本切换日志。。。</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/12/Git/" data-id="cls3bhyxs0009sgv59eft4vfs" data-title="Git" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hexo-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/01/hexo-world/" class="article-date">
  <time class="dt-published" datetime="2023-04-01T09:02:15.000Z" itemprop="datePublished">2023-04-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/01/hexo-world/">hexo | Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p>Hexo 是一个基于 Node.js 的静态博客框架，提供简单的方式来创建和部署静态博客，使作者专注于写作而不必担心后端服务器的维护。<br>Hexo 使用 Markdown 作为主要的文章撰写语言，这是一种轻量级的标记语言，使得写作变得简单且易于阅读。<br>Hexo 生成的是静态页面，因此页面加载速度非常快。这对于提供更好的用户体验和搜索引擎优化（SEO）非常有利。<br>Hexo 使用版本控制系统（通常是 Git）来管理博客内容，因此用户可以轻松地追踪和管理博客文章的历史。<br>Hexo 可以将博客部署到各种平台，包括 GitHub Pages、Netlify、Vercel 等。这使得博客的部署变得非常简单。</p>
<h3 id="配置-hexo"><a href="#配置-hexo" class="headerlink" title="配置 hexo"></a>配置 hexo</h3><p>见 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Eg41157tL%EF%BC%8C%E5%85%B6%E4%B8%AD%EF%BC%9A">https://www.bilibili.com/video/BV1Eg41157tL，其中：</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;leo710aka&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;1908454905@qq.com&quot;</span></span><br></pre></td></tr></table></figure>
<p>_cnfig.yml不能直接复制粘贴过去。。</p>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><p>在C:\Users\cf\Documents\Visual Studio Code\blog下右键<strong>Git Bash Here</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;文件名&quot;</span></span><br></pre></td></tr></table></figure>

<p>或者直接在..\source\posts下编写md文件. More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>

<p>在本地服务器看看效果. <a target="_blank" rel="noopener" href="http://localhost:4000/">http://localhost:4000/</a> </p>
<h3 id="Clean、-Generate-static-files-、Deploy-to-remote-sites"><a href="#Clean、-Generate-static-files-、Deploy-to-remote-sites" class="headerlink" title="Clean、 Generate static files 、Deploy to remote sites"></a>Clean、 Generate static files 、Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean   <span class="comment"># 清理缓存、清理之前生成的静态文件</span></span><br><span class="line">$ hexo g       <span class="comment"># 构建网页文件（通过md文件生成html、css、js..）</span></span><br><span class="line">$ hexo d       <span class="comment"># 同步github，更新博客上的内容（这一步可能需要多试几次）</span></span><br></pre></td></tr></table></figure>
<p>没办法同步的话，直接把新构建的 <code>E:\Code\Blog\blog\.deploy_git</code> 中的文件手动上传github仓库；<br>成功后若博客内容未更新，ctrl+f5清下缓存。</p>
<h3 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h3><p>在 <code>_config.yml</code> 或 <code>_config.landscape</code> 中设置，修改配置后先 hexo clean 一下，再发布。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/01/hexo-world/" data-id="cls3bhyxy000tsgv56plegecd" data-title="hexo | Hello World" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Python爬虫" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/09/02/Python%E7%88%AC%E8%99%AB/" class="article-date">
  <time class="dt-published" datetime="2022-09-02T03:11:00.000Z" itemprop="datePublished">2022-09-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/09/02/Python%E7%88%AC%E8%99%AB/">Python spider</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="反爬虫策略"><a href="#反爬虫策略" class="headerlink" title="反爬虫策略"></a><strong>反爬虫策略</strong></h3><ul>
<li>设置合理的请求头。   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;   <span class="comment"># 伪装浏览器请求头</span></span><br><span class="line">   <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;ispeed_lsm=2; baikeVisitId=b84d4a50-436c-4e0f-9e29-dc2393e9cdca; COOKIE_SESSION=6_1_8_5_10_9_1_0_7_5_0_3_33002_0_2_0_1650022038_1650022034_1650022036%7C8%230_1_1650022030%7C1; BD_UPN=1126314751; BD_HOME=1; BD_CK_SAM=1; H_PS_645EC=89b2Pt9WoxiJHIC80g9QL3FIo7tdoc9Z9Gm9Nd6gkOPipOmTDtckrFlLxEpchFYkItCM; BAIDUID=FD56AC9125756B81A0E4EB7A60F27700:FG=1; BIDUPSID=FD56AC9125756B81E8CE802CC99B8074; PSTM=1648004100; BDUSS=Jpc2d4NGIwdzRCNVFTR0xNeS1IYXBLNTQwfjhzRnl3Z0xRSlZJTDhZeU1ibnhpRVFBQUFBJCQAAAAAAAAAAAEAAAAnQDHOyfq77rXDd2luZHkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIzhVGKM4VRiT2; H_PS_PSSID=36426_31660_35912_36167_34584_35979_36055_36235_26350; BA_HECTOR=ak20800k8kag8h8le71h8646s0q; BDRCVFR[feWj1Vr5u3D]=I67x6TjHwwYf0; delPer=0; PSINO=6&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.64 Safari/537.36&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用代理IP。</li>
<li>限制请求频率，避免被封IP。   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sleep_time = random.uniform(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">time.sleep(sleep_time)</span><br></pre></td></tr></table></figure></li>
<li>处理验证码和登录等复杂场景。</li>
</ul>
<h3 id="网络请求库："><a href="#网络请求库：" class="headerlink" title="网络请求库："></a><strong>网络请求库：</strong></h3><ul>
<li><code>requests</code>库：用于发送HTTP请求，获取网页内容。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment"># url_base = &#x27;http://leo/index.phtml?reportdate=&#123;year&#125;&amp;quarter=&#123;quarter&#125;&amp;p=&#123;page&#125;&#x27;</span></span><br><span class="line"><span class="comment"># url = url_base.format(year=iyear, quarter=iquarter, page=page)  # 替换url模板中的占位符</span></span><br><span class="line">response = requests.get(url=url, headers=self.headers)</span><br><span class="line">res = response.content.decode()  <span class="comment"># 获取服务器响应的内容，将其解码成字符串</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="HTML解析库："><a href="#HTML解析库：" class="headerlink" title="HTML解析库："></a><strong>HTML解析库：</strong></h3><ul>
<li><p><code>BeautifulSoup</code>：用于解析HTML文档，提取所需信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(res, <span class="string">&#x27;html.parser&#x27;</span>)           <span class="comment"># 解析 HTML 内容</span></span><br><span class="line">first_paragraph = soup.find(<span class="string">&#x27;p&#x27;</span>)                   <span class="comment"># 查找第一个&lt;p&gt;标签</span></span><br><span class="line">script = soup.find(<span class="built_in">id</span>=tag_id)                      <span class="comment"># 找到具有指定 id 属性的标签</span></span><br><span class="line"><span class="comment"># script.string.replace_with(new_string)           # 替换标签内容</span></span><br><span class="line"><span class="comment"># script.append(new_tag)                           # 在标签内追加新标签</span></span><br><span class="line"><span class="comment"># script.extract()                                 # 从文档中删除标签</span></span><br><span class="line">text = script.text                                 <span class="comment"># 获取标签内容   </span></span><br><span class="line"><span class="comment"># json_str = re.findall(r&#x27;\[.+\]&#x27;, text)[0]        # 用正则表达式 re 从 text 中查找一个或多个包含 JSON 数据的字符串的第一个匹配项</span></span><br><span class="line"><span class="comment"># data = json.loads(json_str)                      # 把json格式的字符串转换为Python类型</span></span><br><span class="line">script1 = soup.find(<span class="string">&#x27;p&#x27;</span>, class_=<span class="string">&#x27;paragraph&#x27;</span>)       <span class="comment"># 查找带有指定class的&lt;p&gt;标签</span></span><br><span class="line">script2 = soup.find(<span class="string">&#x27;a&#x27;</span>, href=<span class="string">&#x27;https://...&#x27;</span>)       <span class="comment"># 查找带有指定属性的&lt;a&gt;标签</span></span><br><span class="line">labels = soup.find_all(<span class="string">&#x27;a&#x27;</span>, attrs=&#123;<span class="string">&#x27;href&#x27;</span>: <span class="literal">True</span>&#125;)  <span class="comment"># 模糊搜索HTML代码中所有含href属性的&lt;a&gt;标签</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>lxml</code>：使用类似 XPath 的功能解析HTML文档。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> html</span><br><span class="line">tree = html.fromstring(html_doc)</span><br><span class="line">paragraphs = tree.xpath(<span class="string">&#x27;//p&#x27;</span>)                                 <span class="comment"># 使用 XPath 表达式查找&lt;p&gt;标签</span></span><br><span class="line">paragraphs_with_class = tree.xpath(<span class="string">&#x27;//p[@class=&quot;paragraph&quot;]&#x27;</span>)  <span class="comment"># 使用 XPath 表达式查找具有指定class属性值的&lt;p&gt;标签</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="数据存储："><a href="#数据存储：" class="headerlink" title="数据存储："></a><strong>数据存储：</strong></h3><ul>
<li>文件存储：将爬取的数据保存为文本文件、CSV文件等。</li>
<li>数据库：使用SQLite、MySQL、MongoDB等数据库存储数据。   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load</span>(<span class="params">self, path</span>):</span><br><span class="line">   <span class="keyword">with</span> <span class="built_in">open</span>(path, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:   <span class="comment"># 加载存储在JSON文件中的数据, 指定文件为UTF-8编码</span></span><br><span class="line">       data = json.load(fp)</span><br><span class="line">   <span class="keyword">return</span> data</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save</span>(<span class="params">self, data, path</span>):</span><br><span class="line">   <span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:   <span class="comment"># 以json格式保存, 最近一日各国疫情数据</span></span><br><span class="line">       json.dump(data, fp, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">baidu_search</span>(<span class="params">v_result_file</span>):   <span class="comment"># 保存csv数据</span></span><br><span class="line">   df = pd.DataFrame(</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="string">&#x27;关键字&#x27;</span>: kw_list, <span class="string">&#x27;页码&#x27;</span>: page_list, <span class="string">&#x27;标题&#x27;</span>: title_list,  <span class="string">&#x27;百度链接&#x27;</span>: href_list, </span><br><span class="line">         <span class="string">&#x27;真实链接&#x27;</span>: real_url_list, <span class="string">&#x27;更新时间&#x27;</span>: time_list, <span class="string">&#x27;简介&#x27;</span>: desc_list,</span><br><span class="line">         <span class="string">&#x27;网站名称&#x27;</span>: site_list,</span><br><span class="line">      &#125;</span><br><span class="line">   )</span><br><span class="line">   <span class="keyword">if</span> os.path.exists(v_result_file):</span><br><span class="line">         header = <span class="literal">None</span>   <span class="comment"># 已存在的csv文件保存时不用加标头</span></span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">         <span class="comment"># 创建新文件时，设置csv文件标头</span></span><br><span class="line">         header = [<span class="string">&#x27;关键词&#x27;</span>, <span class="string">&#x27;页码&#x27;</span>, <span class="string">&#x27;标题&#x27;</span>, <span class="string">&#x27;百度链接&#x27;</span>, <span class="string">&#x27;真实链接&#x27;</span>, <span class="string">&#x27;更新时间&#x27;</span>, <span class="string">&#x27;简介&#x27;</span>, <span class="string">&#x27;网站名称&#x27;</span>] </span><br><span class="line">   df.to_csv(v_result_file, mode=<span class="string">&#x27;a+&#x27;</span>, index=<span class="literal">False</span>, header=header, encoding=<span class="string">&#x27;utf_8_sig&#x27;</span>)</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;结果保存成功:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(v_result_file))</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="爬虫框架"><a href="#爬虫框架" class="headerlink" title="爬虫框架"></a><strong>爬虫框架</strong></h3><ul>
<li>Scrapy：一个强大的Python爬虫框架，提供了高级功能如异步处理、中间件等。   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy startproject myproject</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="动态网页爬取"><a href="#动态网页爬取" class="headerlink" title="动态网页爬取"></a><strong>动态网页爬取</strong></h3><ul>
<li>使用Selenium或Headless浏览器模拟浏览器行为。</li>
<li>处理JavaScript渲染的页面。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/09/02/Python%E7%88%AC%E8%99%AB/" data-id="cls3bhyxw000jsgv5a9xnd9ae" data-title="Python spider" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Python基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/09/01/Python%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2022-09-01T03:11:00.000Z" itemprop="datePublished">2022-09-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/09/01/Python%E5%9F%BA%E7%A1%80/">Python 基础</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Python是一种高级、通用、解释型、面向对象的编程语言。<br>Python是一种<strong>解释型语言</strong>，其代码不是直接编译成机器码，而是由解释器逐行解释执行。常见的Python解释器有 CPython、Jython 等。<br>其中 CPython 是官方标准实现，是由Python的创始人Guido van Rossum领导开发的官方Python解释器。它是使用C语言编写的，是最广泛使用的Python解释器。</p>
<h2 id="Python-环境"><a href="#Python-环境" class="headerlink" title="Python 环境"></a>Python 环境</h2><ol>
<li>Python环境通常包括了解释器、标准库、开发工具和其他一些组件。以下是一些常见的Python环境相关的工具和概念：<ul>
<li><strong>虚拟环境（Virtual Environment）：</strong> 虚拟环境是一个独立的Python环境，允许您在同一台机器上同时运行多个项目，每个项目都有其独立的依赖项和库。<code>venv</code> 和 <code>virtualenv</code> 是用于创建虚拟环境的工具。</li>
<li><strong>包管理器：</strong> Python的包管理器用于安装、升级和卸载软件包。<code>pip</code> 是Python的官方包管理器，用于从 PyPI 安装第三方库。</li>
<li><strong>IDE（集成开发环境）：</strong> 提供了代码编辑、调试、版本控制等一体化功能的工具。一些常见的Python IDE包括 PyCharm、Visual Studio Code、Jupyter Notebook 等。</li>
<li>Jupyter Notebook： 交互式计算环境，支持在浏览器中编写和运行Python代码，并包含文本、图像和公式等。</li>
</ul>
</li>
<li><strong>PyCharm 终端的 Python 环境不一定与当前加载的项目使用的编辑器环境一致！！</strong><br>用  Pycharm 打开 Python 项目时，<font color= "#87CEFA"> <strong>点击添加解释器 —&gt; 添加本地解释器，选择将要运行该项目的虚拟环境下的 Python 解释器。</strong> </font>  <strong>选择使用这个虚拟环境对应的编辑器，就是选择了使用这个环境运行项目，使用这个环境中配好的包等等。</strong><br>所以要注意终端使用的是哪个编辑器，是否与当前项目使用的编辑器匹配。否则在终端pip install把包装到一个虚拟环境下，而当前项目运行在另一个虚拟环境中，便无法 import 已从终端安装的包。</li>
</ol>
<h3 id="模块和包"><a href="#模块和包" class="headerlink" title="模块和包"></a>模块和包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install xx          <span class="comment"># 打开终端，在终端的 Python 环境中安装 xx 包；可指定安装位置</span></span><br><span class="line">pip install efinance --target C:\Users\蔡枫\AppData\Local\Programs\Python\Python310\Lib</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math <span class="keyword">as</span> mat      <span class="comment"># 导入模块</span></span><br><span class="line">result = math.sqrt(<span class="number">16</span>)  <span class="comment"># 使用模块中的函数</span></span><br></pre></td></tr></table></figure>

<h3 id="数据结构与函数"><a href="#数据结构与函数" class="headerlink" title="数据结构与函数"></a>数据结构与函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;apple&quot;</span>]  <span class="comment"># 列表</span></span><br><span class="line">my_tuple = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment"># 元组</span></span><br><span class="line">my_dict = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">25</span>&#125;  <span class="comment"># 字典</span></span><br><span class="line">my_set = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;  <span class="comment"># 集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name</span><br><span class="line">message = greet(<span class="string">&quot;Alice&quot;</span>)  <span class="comment"># 调用函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 面向对象编程（OOP）</span></span><br><span class="line"><span class="comment"># 定义类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bark</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Woof!&quot;</span>)</span><br><span class="line">my_dog = Dog(<span class="string">&quot;Buddy&quot;</span>)  <span class="comment"># 创建对象</span></span><br><span class="line">my_dog.bark()  <span class="comment"># 调用对象方法</span></span><br></pre></td></tr></table></figure>


<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    result = <span class="number">10</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Cannot divide by zero&quot;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This will be executed no matter what&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写入文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(<span class="string">&quot;Hello, Python!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    content = file.read()</span><br><span class="line">    <span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure>

<h3 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h3><p>Pandas 是一个强大的数据分析库，主要用于数据处理和分析。它提供了两种主要的数据结构：<code>Series</code> 和 <code>DataFrame</code>。</p>
<ul>
<li><code>Series</code> 是一个一维标记数组，可以保存任何数据类型。它由两个主要部分组成：索引（index）和数据（data）。</li>
<li><code>DataFrame</code> 是一个二维表格，类似于 Excel 表格或 SQL 表。它由行索引、列索引和数据组成。<br>  <strong>数据组织</strong>：DataFrame 以表格的形式组织数据，包括多个列，每一列可以包含不同的数据类型（整数、浮点数、字符串等）。<br>  <strong>索引</strong>：每个行和列都有一个标签索引。行索引表示 DataFrame 中的每个数据行，列索引表示 DataFrame 中的每个数据列。<br>  <strong>列</strong>：DataFrame 的每一列是一个 Pandas Series 对象，这意味着它们可以包含相同类型的数据。你可以将每一列视为一个数据字段，类似于数据库表中的列。    下面是一个示例 DataFrame 的结构：  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">|</span>    <span class="operator">|</span> Name     <span class="operator">|</span> Age <span class="operator">|</span> City       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="comment">----|----------|-----|------------|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">0</span>  <span class="operator">|</span> Alice    <span class="operator">|</span> <span class="number">25</span>  <span class="operator">|</span> Niu York   <span class="operator">|</span>  <span class="comment">-- 行索引（0, 1, 2, 3）标识每一行的位置</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> Bob      <span class="operator">|</span> <span class="number">30</span>  <span class="operator">|</span> Los Angeles<span class="operator">|</span>  <span class="comment">-- 列索引（Name, Age, City）表示不同的数据字段</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>  <span class="operator">|</span> Carol    <span class="operator">|</span> <span class="number">28</span>  <span class="operator">|</span> Chicago    <span class="operator">|</span>  <span class="comment">-- 每一列（Name, Age, City）都包含相应的数据</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span>  <span class="operator">|</span> David    <span class="operator">|</span> <span class="number">22</span>  <span class="operator">|</span> Houston    <span class="operator">|</span>  <span class="comment">-- 每一列都是一个 Pandas Series，包含相同类型的数据</span></span><br></pre></td></tr></table></figure></li>
<li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">s = pd.Series([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, np.nan, <span class="number">6</span>, <span class="number">8</span>])  <span class="comment"># 创建一个 Series</span></span><br><span class="line">df = pd.DataFrame(&#123;                     <span class="comment"># 创建一个 DataFrame</span></span><br><span class="line">    <span class="string">&#x27;Name&#x27;</span>: [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Charlie&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;Age&#x27;</span>: [<span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>],</span><br><span class="line">    <span class="string">&#x27;City&#x27;</span>: [<span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;San Francisco&#x27;</span>, <span class="string">&#x27;Los Angeles&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line">df = pd.DataFrame(columns=, data=)      <span class="comment"># 指定创建 DataFrame 的列索引和其中的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, row <span class="keyword">in</span> df.iterrows():        <span class="comment"># 遍历DataFrame的每一行</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Index: <span class="subst">&#123;index&#125;</span>, Name: <span class="subst">&#123;row[<span class="string">&#x27;Name&#x27;</span>]&#125;</span>, Age: <span class="subst">&#123;row[<span class="string">&#x27;Age&#x27;</span>]&#125;</span>, City: <span class="subst">&#123;row[<span class="string">&#x27;City&#x27;</span>]&#125;</span>&quot;</span>)  </span><br><span class="line">    <span class="comment"># Index: 0, Name: Alice, Age: 25, City: New York...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 DataFrame 对象保存为 CSV 文件</span></span><br><span class="line"><span class="comment"># sep 表示数据字段之间的分隔符，header 表示是否将列名写入文件，index 表示是否写入行索引。</span></span><br><span class="line">df.to_csv(<span class="string">&#x27;data.txt&#x27;</span>, sep = <span class="string">&#x27; &#x27;</span>, index = <span class="literal">False</span>, header = <span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 从 CSV、Excel文件读取数据</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;data.csv&#x27;</span>)</span><br><span class="line">df = pd.read_excel(<span class="string">&#x27;data.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h3><p><code>numpy</code>（Numerical Python的缩写）是一个用于科学计算的强大Python库。以下是一些 <code>numpy</code> 的主要功能和用法：</p>
<ol>
<li><strong>多维数组：</strong> <code>numpy</code> 提供了<code>ndarray</code>对象，是一个多维数组，用于存储同类型的元素。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 创建一个numpy数组</span></span><br><span class="line">arr = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure></li>
<li><strong>数组操作：</strong> <code>numpy</code> 提供了许多对数组进行操作的函数，包括数学、逻辑、形状操作等。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数组的数学运算</span></span><br><span class="line">result = arr + <span class="number">2</span></span><br><span class="line"><span class="comment"># 数组形状操作</span></span><br><span class="line">reshaped_arr = arr.reshape(<span class="number">5</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li>
<li><strong>矩阵操作：</strong> <code>numpy</code> 具有广泛的矩阵操作，包括矩阵乘法、转置等。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">matrix_a = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">matrix_b = np.array([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line"><span class="comment"># 矩阵乘法</span></span><br><span class="line">result_matrix = np.dot(matrix_a, matrix_b)</span><br></pre></td></tr></table></figure></li>
<li><strong>数学函数：</strong> <code>numpy</code> 包括大量的数学函数，用于三角函数、对数、指数等。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="comment"># 求sin(x)</span></span><br><span class="line">sin_values = np.sin(x)</span><br></pre></td></tr></table></figure></li>
<li><strong>随机数生成：</strong> <code>numpy</code> 提供了生成随机数的函数。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">random_numbers = np.random.rand(<span class="number">5</span>)  <span class="comment"># 生成5个在[0, 1)范围内的随机数</span></span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/09/01/Python%E5%9F%BA%E7%A1%80/" data-id="cls3bhyxw000isgv530u3cx86" data-title="Python 基础" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Mybatis" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/12/Mybatis/" class="article-date">
  <time class="dt-published" datetime="2022-03-12T03:49:42.000Z" itemprop="datePublished">2022-03-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/12/Mybatis/">Mybatis | Mybatis-Plus</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-Mybatis"><a href="#1-Mybatis" class="headerlink" title="1. Mybatis"></a>1. Mybatis</h1><p>MyBatis 是一个开源的<strong>Java持久层框架</strong>，用于将对象与关系数据库的表之间进行映射。MyBatis 通过 XML或注解配置文件描述 <strong>Java 对象与数据库之间的映射关系</strong>，并提供了一些方便的查询语言（类似于SQL）来进行数据库操作。<br>使用 MyBatis 来操作 MySQL 数据库，将数据存储在 MySQL 中，或从 MySQL 中检索数据，同时使用 MyBatis 进行数据映射和数据库操作的管理。它们通常一起使用，以构建 Java 应用程序的持久层。</p>
<h3 id="数据映射："><a href="#数据映射：" class="headerlink" title="数据映射："></a><strong>数据映射：</strong></h3><p>MyBatis 的核心功能之一是提供简单且强大的数据映射。使用 XML或注解来定义 SQL查询和映射结果，将数据库表记录映射到 Java对象。</p>
<ul>
<li>1.1 XML 映射文件：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义查询 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM users WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 映射结果到对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>1.2 注解方式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;SELECT * FROM users WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">User <span class="title function_">selectUser</span><span class="params">(<span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="核心功能："><a href="#核心功能：" class="headerlink" title="核心功能："></a>核心功能：</h3><ul>
<li><strong>动态 SQL</strong>：MyBatis 允许你在 XML 中编写动态 SQL 语句，可以根据条件动态构建 SQL 查询。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM users</span><br><span class="line">  WHERE 1=1</span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span></span><br><span class="line">    AND username = #&#123;username&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;password != null&quot;</span>&gt;</span></span><br><span class="line">    AND password = #&#123;password&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>参数传递</strong>：MyBatis 支持多种参数传递方式，包括单个参数、多个参数、Map 和注解等。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;SELECT * FROM users WHERE id = #&#123;id&#125; AND username = #&#123;username&#125;&quot;)</span></span><br><span class="line">User <span class="title function_">selectUserByIdAndUsername</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="type">int</span> id, <span class="meta">@Param(&quot;username&quot;)</span> String username)</span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>批处理</strong>：MyBatis 允许执行批处理操作，可以有效地执行一组 SQL 语句。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(ExecutorType.BATCH);</span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"><span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">    userMapper.insertUser(user);</span><br><span class="line">&#125;</span><br><span class="line">sqlSession.flushStatements();</span><br><span class="line">sqlSession.commit();</span><br><span class="line">sqlSession.close();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="事务管理："><a href="#事务管理：" class="headerlink" title="事务管理："></a><strong>事务管理：</strong></h3><ul>
<li>MyBatis 也提供了事务管理的支持。可以通过配置数据源和事务管理器来实现事务的控制。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 数据源配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mydatabase&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 事务管理器配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>MyBatis 可以很容易地与 Spring 框架集成，通过 Spring 的事务管理来控制数据库事务。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring 配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mapper/*.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="SpringBoot实体类-——-VO-DTO-PO"><a href="#SpringBoot实体类-——-VO-DTO-PO" class="headerlink" title="SpringBoot实体类 —— VO&#x2F;DTO&#x2F;PO"></a>SpringBoot实体类 —— VO&#x2F;DTO&#x2F;PO</h3><ul>
<li><p><strong>VO</strong>：View Object，主要用于展示层。它的作用是把某个指定前端页面的所有数据封装起来。他的作用主要是减少传输数据量大小和保护数据库隐私数据（如用户密码、用户邮箱等相关信息）不外泄，同时保护数据库的结构不外泄。</p>
</li>
<li><p><strong>DTO</strong>：Data Transfer Object，数据传输对象，用于展示层与服务层之间的数据传输对象。（注：实际开发中还存在BO，其作用和DTO类似，当业务逻辑不复杂时一般会被合并。）</p>
</li>
<li><p><strong>PO</strong>：Persistant Object，持久化对象，和数据库形成映射关系。简单说PO就是每一个数据库中的数据表，一个字段对应PO中的一个变量。（也就是我们常用的Entities）</p>
<img src="https://github.com/leo710aka/bk/blob/main/mp1.jpeg?raw=true" width="800" height="300" alt=""> 
1、从前端页面中收到JSON格式数据，后端接口中将其封装为一个VO对象；接口接收到VO对象后将其转换为DTO对象，并调用业务类方法对其进行处理；然后处理为PO对象，调用Dao接口连接数据库进行数据访问（查询、插入、更新等）2、后端从数据库得到结果后，根据Dao接口将结果映射为PO对象，然后调用业务类方法将其转换为需要的DTO对象，再根据前端页面实际需求，转换为VO对象进行返回。</li>
<li><p><strong>类型转换</strong>：上述过程中，VO&#x2F;DTO&#x2F;PO等实体类中字段常常会存在多数相同，根据业务需求少数不同。为避免频繁的set和get操作对其进行转换，spring为我们提供了多种方法。（1）使用BeanUtils:（springframework包下）（2）使用BeanUtils:（Apache包下）（3）使用modelMapper？？</p>
</li>
<li><p><strong>DO（Data Object）：</strong>通常表示数据库中的数据实体，对应数据库表的结构。它主要用于数据存储和数据库操作，包含与数据库表字段一一对应的属性。类中通常包含与数据库表字段对应的成员变量、getter 和 setter 方法。它不应包含业务逻辑，主要负责数据的持久化和映射。<br>尽管 PO 和 DO 在一些情况下用法相似，但它们的侧重点有所不同。PO 更侧重于与数据库的交互，强调持久化和数据表映射；而 DO 侧重于在不同层之间传递数据，强调业务逻辑层面的数据封装。</p>
</li>
<li><p><strong>BO（Business Object）：</strong>通常表示业务层的业务实体，主要用于封装业务逻辑。BO 类一般包含与业务逻辑相关的属性和方法，与具体的数据存储形式无关。包含了一些业务逻辑的操作，比如计算、验证等。它不应直接与数据库进行交互，而是通过调用 Service 层或 DAO 层的方法实现数据的获取和存储。</p>
</li>
</ul>
<hr>

<h1 id="2-Mybatis-Plus"><a href="#2-Mybatis-Plus" class="headerlink" title="2. Mybatis-Plus"></a>2. Mybatis-Plus</h1><ul>
<li><strong>基于MyBatis</strong>：MyBatis-Plus是MyBatis的增强工具包，是在MyBatis基础上的扩展。只做增强不做改变，为简化开发、提高效率而生。它提供了更多的便捷、高效的开发功能，简化了开发人员的编码工作，大幅度提高了开发效率。</li>
<li><strong>功能</strong>：MyBatis-Plus 集成了MyBatis的核心功能，同时提供了更多针对CRUD操作、条件构造器、分页、代码生成器等功能的封装。</li>
<li><strong>简化操作</strong>：可以减少重复的CRUD代码，提供了一些便捷的API接口和工具，使得开发人员能够更方便地进行数据库操作。</li>
<li>引入 MybatisPlus依赖，可以直接代替 Mybatis依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>MyBatisPlus 的配置项继承了 MyBatis原生配置和一些自己特有的配置。例如:<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.itheima.mp.domain.po</span>  <span class="comment"># 别名扫描包</span></span><br><span class="line">  <span class="string">mapper-locations：&quot;classpath*:/mapper/**/*.xml&quot;</span>  <span class="comment"># Mapper.xml文件地址，默认值</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span>  <span class="comment"># 是否开户下划线和驼峰的映射</span></span><br><span class="line">    <span class="attr">cache-enabled:</span> <span class="literal">false</span>  <span class="comment"># 是否开户二级缓存</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">assign_id</span>  <span class="comment"># id为雪花算法生成</span></span><br><span class="line">      <span class="attr">update-strategy:</span> <span class="string">not_null</span>  <span class="comment"># 更新笑略:只更新非空字段</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="BaseMapper"><a href="#BaseMapper" class="headerlink" title="BaseMapper"></a>BaseMapper</h3><ul>
<li>定义 Mapper接口并继承 <code>BaseMapper</code>类，泛型指定要与数据库映射的 Java实体类（pojo类）；<br>MyBatisPlus通过扫描实体类，并基于<strong>反射</strong>获取实体类信息作为数据库表信息，自动实现 CRUD的逻辑<ul>
<li>默认以类名驼峰转下划线作为表名（User类 -&gt; user表）</li>
<li>默认把名为id的字段作为主键</li>
<li>默认把变量名驼峰转下划线作为表的字段名（createTime类属性 -&gt; create_time表字段）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt;&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>如果实体类和表的对应关系不符合 mp的约定，就要自行配置。可以使用注解:<ul>
<li><code>@TableName</code>：指定表名称及全局配置</li>
<li><code>@Tableld</code>：指定id字段及相关配置；<ul>
<li>IdType的常见类型有：AUTO、ASSIGN ID（默认使用，雪花算法）、INPUT</li>
</ul>
</li>
<li><code>@TableField</code>：指定普通字段及相关配置。使用 @TableField的常见场景是：<ul>
<li>1、成员变量名与数据库字段名不一致    2、成员变量名以is开头，且是布尔值<br>3、成员变量名与数据库关键字冲突        4、成员变量不是数据库字段<img src="https://github.com/leo710aka/bk/blob/main/mp.png?raw=true" width="800" height="300" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h3><p>MyBatisPlus支持 使用 Wrapper构造各种复杂的where条件，而不需要在 xml中写sql语句。可以满足日常开发的所有需求。<br><img src="https://github.com/leo710aka/bk/blob/main/mp2.png?raw=true" width="700" height="200" alt=""> </p>
<ul>
<li>QueryWrapper 和LambdaQueryWrapper通常用来构建 select、delete、update的 where条件部分</li>
<li>UpdateWrapper 和LambdaUpdateWrapper通常只有在 set语句比较特殊才使用</li>
<li>尽量使用 LambdaQueryWrapper和 LambdaUpdateWrapper避免硬编码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原sql：SELECT id,username,info,balance FROM user WHERE username LIKE ? AND balance &gt;= ?</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testQuerywrapper</span><span class="params">()</span> &#123;</span><br><span class="line">  QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;()  <span class="comment">// 1.构建查询条件</span></span><br><span class="line">    .select(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;info&quot;</span>, <span class="string">&quot;balance&quot;</span>)</span><br><span class="line">    .like(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;o&quot;</span>)</span><br><span class="line">    .ge(<span class="string">&quot;balance&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">  List&lt;User&gt; users = userMapper.selectList(wrapper);  <span class="comment">// 2.查询</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 Lambda替代上方法中的硬编码</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testLambdaQuerywrapper</span><span class="params">()</span> &#123;</span><br><span class="line">  LambdaQuerywrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQuerywrapper</span>&lt;User&gt;()</span><br><span class="line">    .select(User::getid, User::getUsername, User::getInfo, User::getBalance)</span><br><span class="line">    .like(User::getUsername, <span class="string">&quot;o&quot;</span>)</span><br><span class="line">    .ge(User::getBalance, <span class="number">1000</span>)</span><br><span class="line">  List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原sql：UPDATE user SET balance = 2000 WHERE (username = &quot;jack&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdateByQuerywrapper</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>()<span class="comment">// 1.要更新的数据</span></span><br><span class="line">  user.setBalance(<span class="number">2000</span>);</span><br><span class="line">  QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;().eq(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;jack&quot;</span>);<span class="comment">// 2.更新的条件</span></span><br><span class="line">  userMapper.update(user, wrapper);<span class="comment">// 3.执行更新</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原sql：UPDATE user SET balance = balance - 200 WHERE id in (1，2，4)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdatewrapper</span><span class="params">()</span> &#123;</span><br><span class="line">  List&lt;Long&gt; ids = List.of(<span class="number">1L</span>，<span class="number">2L</span>，<span class="number">4L</span>);</span><br><span class="line">  Updatewrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">Updatewrapper</span>&lt;User&gt;()</span><br><span class="line">    .setSql(<span class="string">&quot;balance = balance - 200&quot;</span>)</span><br><span class="line">    .in(<span class="string">&quot;id&quot;</span>, ids) ;</span><br><span class="line">  userMapper.update(<span class="literal">null</span>, wrapper) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="自定义SQL"><a href="#自定义SQL" class="headerlink" title="自定义SQL"></a>自定义SQL</h3><p>我们可以利用 MyBatisPlus的 Wrapper来构建复杂的 Where条件，然后自己定义SQL语句中剩下的部分。<br>在业务层编写wrapper包含sql中的where部分，在mapper方法声明wrapper变量名称“ew”，最后在mapper对应的xml中自定义sql编写where以外的部分（解决了 不能在业务层编写sql 和 使用mp简化查询语句编写 的矛盾？？<br><img src="https://github.com/leo710aka/bk/blob/main/mp3.png?raw=true" width="700" height="200" alt=""> </p>
<h3 id="IService接口"><a href="#IService接口" class="headerlink" title="IService接口"></a>IService接口</h3><ul>
<li>简单业务方法，直接在controller中调用对应的IService中的方法；<br>对于复杂业务，需要在自定义Servicelmpl中编写逻辑，调用对应的BaseMapper中的方法；<br>当BaseMapper不足以满足需求时，需要在mapper中编写自定义sql（处理where之外的sql，如update…）；<br>对于mapper中自定义sql，简单的使用注解编写，复杂的在xml中编写。。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、自定义Service接口继承IService接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2、自定义Service实现类，实现自定义接口并继承Servicelmpl类（否则要自己一个个实现IService接口的方法）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> </span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt;  <span class="comment">// 泛型中指定mapper和实体类类型</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">IUserService</span> &#123;              </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IUserServiceTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IUserService userService;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">      user.setUsername(uLiLeiu);</span><br><span class="line">      user.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">      userService.save(user);  <span class="comment">// 如果方法与BaseMapper中的重复，就不需要BaseMapper了？？</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>IService的 <strong>Lambda方法</strong>：在 自定义的 Servicelmpl类中进行 <strong>复杂操作</strong>；<ol>
<li>需求：复杂查询，查询条件如下（name: 用户名关键字，可以为空；status:用户状态，可以为空；minBalance:最小余额，可以为空；maxBalance:最大余额，可以为空）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">queryUsers</span><span class="params">(String name, Integer status, Integer minBalance Integer maxBalance)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> lambdaQuery()</span><br><span class="line">    .like(name != <span class="literal">null</span>, User::getUsername, name)</span><br><span class="line">    .eg(status != <span class="literal">null</span>, User::getStatus, status)</span><br><span class="line">    .ge(minBalance != <span class="literal">null</span>, User::getBalance, minBalance)</span><br><span class="line">    .le(maxBalance != <span class="literal">null</span>，User::getBalance, maxBalance)</span><br><span class="line">    .list();  <span class="comment">// 如果查询一个记录就是.one</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>需求：复杂更新，要求如下（按id更新，更新为扣后余额，如果扣减后余额为0，则将用户status修改为冻结状态(2)）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transaction</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">deductBalance</span><span class="params">(Long id，Integer money)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 4.扣城余额 update tb_user set balance = balance - ?</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">remainBalance</span> <span class="operator">=</span> user.getBalance() - money;</span><br><span class="line">  lambdaUpdate()</span><br><span class="line">    .set(User::getBalance, remainBalance)</span><br><span class="line">    .set(remainBalance == <span class="number">0</span>, User::getStatus, <span class="number">2</span>) <span class="comment">// 如果余额0，修改状态</span></span><br><span class="line">    .eq(User::getId, id) <span class="comment">// 相当于 where</span></span><br><span class="line">    .eq(User::getBalance，user.getBalance()) <span class="comment">// 乐观锁</span></span><br><span class="line">    .update();  <span class="comment">// 更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>IService批量新增（批处理）：开启 rewriteBatchedStatements&#x3D;true参数</li>
</ul>
<h3 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h3><p>首先，要在配置类中注册MyBatisplus的核心插件，同时添加分页插件<br>接着，就可以使用分页的API了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> &#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123; <span class="comment">// 拦截器的形式实现插件</span></span><br><span class="line">    <span class="comment">// 1. 初始化核心插件</span></span><br><span class="line">    <span class="type">MybatisplusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisplusInterceptor</span>();</span><br><span class="line">    <span class="comment">// 2. 添加分页插件</span></span><br><span class="line">    <span class="type">PaginationInnerInterceptor</span> <span class="variable">pageInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSOL);</span><br><span class="line">    pageInterceptor.setMaxLimit(<span class="number">100L</span>); <span class="comment">// 设置分页上限</span></span><br><span class="line">    interceptor.addInnerInterceptor(pageInterceptor); <span class="comment">// 添加到核心拦截器</span></span><br><span class="line">    <span class="keyword">return</span> interceptor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">testPageQuery</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">pageNo</span> <span class="operator">=</span> <span class="number">1</span>, pageSize = <span class="number">5</span>;  <span class="comment">// 分页参数</span></span><br><span class="line">  Page&lt;User&gt; page = Page.of(pageNo，pageSize);</span><br><span class="line">  page.addOrder(<span class="keyword">new</span> <span class="title class_">OrderItem</span>(<span class="string">&quot;balance&quot;</span>，<span class="literal">false</span>));  <span class="comment">// 排序参数，通过OrderItem来指定</span></span><br><span class="line">  <span class="comment">// 分页查询</span></span><br><span class="line">  Page&lt;User&gt; p = userService.page(page);</span><br><span class="line">  <span class="comment">// 总条数 p.getTotal(); 总页数 p.getPages(); 分页数据 List&lt;User&gt; records = p.getRecords();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/12/Mybatis/" data-id="cls3bhyxv000gsgv5c4e70yyu" data-title="Mybatis | Mybatis-Plus" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Mysql" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/11/Mysql/" class="article-date">
  <time class="dt-published" datetime="2022-03-11T03:49:42.000Z" itemprop="datePublished">2022-03-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/11/Mysql/">MySQL</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>MySQL是一个开源的关系型数据库管理系统（RDBMS），广泛用于Web应用程序和中小型企业数据库。默认端口是 <strong>3306</strong>。</p>
<h2 id="启动并连接-MySQL"><a href="#启动并连接-MySQL" class="headerlink" title="启动并连接 MySQL"></a>启动并连接 MySQL</h2><ul>
<li>启动 MySQL 服务器（然后尝试连接到 MySQL 服务器；一般情况下 服务器不会自动关闭）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net start MySQL  <span class="comment"># 打开命令提示符（以管理员身份运行），运行以下命令来启动 MySQL 服务</span></span><br><span class="line">net stop MySQL   <span class="comment"># 停止 MySQL 服务</span></span><br></pre></td></tr></table></figure></li>
<li>另外，通过 <strong>Navicat</strong> 创建与本地(或远程) 的 MySQL(或其他)数据库的连接，以对数据库可视化管理<br>本机  <strong>username: root，password: “0xx1xx”</strong></li>
</ul>
<h2 id="SQL-术语"><a href="#SQL-术语" class="headerlink" title="SQL 术语"></a>SQL 术语</h2><p><img src="https://pdai.tech/images/db/db-sql-x-1.png"><br><strong>关系</strong>(Relation)：通常是指数据库表(table)。每个关系对应数据库中的一个表格，由多个行和列组成，其中每一行通常代表表格中的一个数据记录，而每一列代表记录中的一个属性（字段）。<br><strong>属性</strong>(attribute)：列的名字，上图有学号、姓名、班级、兴趣爱好、班主任、课程、授课主任、分数.<br><strong>依赖</strong> (relation)：列属性间存在的某种联系<br><strong>元组</strong>(tuple)：每一个行，如第二行 (1301，小明，13班，篮球，王老师，英语，赵英，70) 就是一个元组<br><strong>模式</strong>(schema)：这里指逻辑结构，如 学生信息(学号，姓名，班级，兴趣爱好，班主任，课程，授课主任，分数)的笼统表述。（数据库模式是数据库的结构描述，包括表格、字段、关系、视图、索引等元素的组织方式。描述了数据库中不同关系表格之间的关联和数据的组织方式。通常包含了数据库中表格的定义，包括表格的名称、字段的名称、字段的数据类型、主键等信息。）<br><strong>域</strong> (domain)：数据类型，如string、integer等，上图中每一个属性都有它的数据类型 (即域)<br><strong>键</strong>(key)：由关系的一个或多个属性组成，任意两个键相同的元组，所有属性都相同。需要保证表示键的属性最少。一个关系可以存在好几种键，工程中一般从这些候选键中选出一个作为主键 (primary key)<br><strong>主键</strong>（Primary Key）：主键是一个表格中的一列或一组列，它的值用来唯一标识表格中的每一行记录。主键的值<strong>不能重复，且不能为空</strong>。这意味着每一行记录在主键列上必须有唯一的值，用于区分记录。主键用于建立表格之间的关系和确保数据的完整性。通常，每个表格都有一个主键，但也可以由多个列组成复合主键<br>候选键(candidate key)：由关系的一个或多个属性组成，候选键都具备键的特征，都有资格成为主键<br>超键(super key)：包含键的属性集合，无需保证属性集的最小化。每个键也是超键。可以认为是键的超集。<br><strong>外键</strong>(foreign key)：如果某一个关系A中的一个(组)属性是另一个关系B的键，则该(组)属性在A中称为外键。<br>主属性 (prime attribute)：所有候选键所包含的属性都是<strong>主属性</strong><br>投影 (proiection)：选取特定的列，如将关系学生信息投影为学号、姓名即得到上表中仅包含学号、姓名的列<br>选择 (selection)：按照一定条件选取特定元组，如选择上表中分数&gt;80的元组<br>笛卡儿积 (交叉连接Cross join)：第一个关系每一行分别与第二个关系的每一行组合<br>自然连接(natural join)：第一个关系中每一行与第二个关系的每一行进行匹配，如果得到有交叉部分则合并，若无交叉部分则舍弃。<br>连接(theta join)：即加上约束条件的笛卡儿积，先得到笛卡儿积，然后根据约束条件删除不满足的元组.<br>外连接 (outer join)：执行自然连接后，将舍弃的部分也加入，并且匹配失败处的属性用NULL代替。<br>除法运算(division)：关系R除以关系S的结果为T，则T包含所有在R但不在S中的属性，且T的元组与S的元组的所有组合在R中。</p>
<hr>

<h2 id="SQL-语法"><a href="#SQL-语法" class="headerlink" title="SQL 语法"></a>SQL 语法</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE mydatabase;  <span class="comment">/* 创建数据库 */</span></span><br><span class="line">USE mydatabase;              <span class="comment">/* 选择数据库 */</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users (                   <span class="comment">-- 创建表</span></span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    username <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> users;                      <span class="comment">-- 删除表</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> users <span class="keyword">ADD</span> col <span class="type">CHAR</span>(<span class="number">20</span>);    <span class="comment">-- 添加列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> col;   <span class="comment">-- 删除列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable CHANGE col col1 <span class="type">CHAR</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;123&#x27;</span>;   <span class="comment">-- 修改列和属性</span></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users (username, email) <span class="keyword">VALUES</span> (<span class="string">&#x27;user1&#x27;</span>, <span class="string">&#x27;user1@example.com&#x27;</span>);  </span><br><span class="line"><span class="comment">-- 插入检索出来的数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mytable1(col1, col2)</span><br><span class="line"><span class="comment">-- 更新数据</span></span><br><span class="line"><span class="keyword">UPDATE</span> users <span class="keyword">SET</span> email<span class="operator">=</span><span class="string">&#x27;newemail@example.com&#x27;</span> <span class="keyword">WHERE</span> username<span class="operator">=</span><span class="string">&#x27;user1&#x27;</span>;  </span><br><span class="line"><span class="comment">-- 删除数据</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username<span class="operator">=</span><span class="string">&#x27;user1&#x27;</span>;  </span><br></pre></td></tr></table></figure>


<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">distinct</span> id </span><br><span class="line"><span class="keyword">FROM</span> users;  </span><br><span class="line">LIMIT <span class="number">2</span>, <span class="number">3</span>;                     </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> col1 <span class="keyword">DESC</span>, col2 <span class="keyword">ASC</span>;   </span><br><span class="line"><span class="keyword">WHERE</span> col <span class="keyword">is</span> <span class="keyword">NULL</span>;          </span><br><span class="line"><span class="comment">-- 子查询：只能返回一个字段的数据，可以将子查询的结果作为 WHRER 语句的过滤条件，配合 (not )in</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mytable1    </span><br><span class="line"><span class="keyword">WHERE</span> col1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> col2</span><br><span class="line">               <span class="keyword">FROM</span> mytable2);</span><br><span class="line"><span class="comment">-- 分组：将数据按照一个或多个列的值分成不同的组，常与聚合函数（如 SUM、COUNT、AVG 等）一起以对每个组聚合操作</span></span><br><span class="line"><span class="comment">-- GROUP BY 子句： 用于指定按哪些列进行分组； HAVING 子句： 用于对分组后的数据进行筛选。</span></span><br><span class="line"><span class="comment">-- WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。</span></span><br><span class="line"><span class="keyword">SELECT</span> col, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num   </span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> col <span class="operator">&gt;</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> col</span><br><span class="line"><span class="keyword">HAVING</span> num <span class="operator">&gt;=</span> <span class="number">2</span>       </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">SUM</span>(column2) <span class="keyword">DESC</span>;  </span><br></pre></td></tr></table></figure>
<ol>
<li>SELECT：查询出属性，用 AS 给列名、计算字段和表名取别名，以简化 SQL 语句以及连接相同表；<br>select 中 sql 函数计算出的值作为查询出的属性（select round(count(<em>)&#x2F;3, 2) from ..）<br>select 中可以加一个select 用于属性计算（select id, count(</em>)&#x2F;(select count(*) from Users) per from ..）<br>若有重复列，使用 DISTINCT 去除重复值</li>
<li>LIMIT：LIMIT 2, 3 返回第 3 ~ 5 行。配合排序实现获取最大&#x2F;最小值。。</li>
<li>WHERE：过滤行，AND 和 OR 用于连接多个过滤条件。优先处理 AND，使用 () 决定优先级；<br>is 搭配 null，IN 操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。</li>
<li>ORDER：可以按多个列进行排序，并指定不同的排序方式，默认升序ASC, 降序DESC</li>
<li>GROUP BY 可以放在 WHERE 前、后，想清楚在分组前、后过滤</li>
<li>子查询的结果需要指定别名。</li>
</ol>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 连接(内连接)：返回多个表中匹配条件满足的行，不匹配的行不会被包括在结果集中。</span></span><br><span class="line"><span class="comment">-- 使用 (INNER )JOIN 关键字，条件语句使用 ON 而不是 WHERE，连接可以替换子查询且效率一般会更快。</span></span><br><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A <span class="keyword">JOIN</span> tableb <span class="keyword">AS</span> B</span><br><span class="line"><span class="keyword">ON</span> A.key <span class="operator">=</span> B.key;</span><br><span class="line"><span class="comment">-- 自连接：可以看成内连接的一种，只是连接的表是自身而已。</span></span><br><span class="line"><span class="keyword">SELECT</span> e1.name</span><br><span class="line"><span class="keyword">FROM</span> employee <span class="keyword">AS</span> e1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> employee <span class="keyword">AS</span> e2</span><br><span class="line"><span class="keyword">ON</span> e1.department <span class="operator">=</span> e2.department <span class="keyword">AND</span> e2.name <span class="operator">=</span> &quot;Jim&quot;;</span><br><span class="line"><span class="comment">-- 自然连接：自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。</span></span><br><span class="line"><span class="comment">-- 内连接和自然连接的区别: 内连接提供连接的列，而自然连接自动连接所有同名列。</span></span><br><span class="line"><span class="keyword">SELECT</span> A.value, B.value <span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> tableb <span class="keyword">AS</span> B;</span><br><span class="line"><span class="comment">-- 外连接：保留了没有关联的那些行。分为左，右外连接以及全外连接。</span></span><br><span class="line"><span class="comment">-- 左连接返回左表的所有行以及与右表匹配的行。如果右表中没有匹配的行，将会返回 NULL 值。</span></span><br><span class="line"><span class="comment">-- on 后等于新连接出了一张表，where 在新表上进行查询</span></span><br><span class="line"><span class="keyword">select</span> Employee.name, Bonus.bonus</span><br><span class="line"><span class="keyword">from</span> Employee <span class="keyword">left</span> <span class="keyword">join</span> Bonus</span><br><span class="line"><span class="keyword">on</span> Employee.empId <span class="operator">=</span> Bonus.empId</span><br><span class="line"><span class="keyword">where</span> Bonus.bonus <span class="operator">&lt;</span> <span class="number">1000</span> <span class="keyword">or</span> Bonus.bonus <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure>


<h2 id="SQL-函数"><a href="#SQL-函数" class="headerlink" title="SQL 函数"></a>SQL 函数</h2><ol>
<li><strong>数学函数：</strong><code>SUM()</code>：计算指定列的总和。 <code>AVG()</code>：计算指定列的平均值。 <code>MAX()</code>：找出指定列的最大值。 <code>MIN()</code>：找出指定列的最小值。 <code>COUNT()</code>：计算指定列的行数。 <code>ROUND(x,y)</code>：把 x 四舍五入到 y 位小数。 <code>ABS()</code>：返回绝对值。</li>
<li><strong>字符串函数：</strong><code>CONCAT()</code>：连接两个或多个字符串。 <code>SUBSTRING()</code> 或 <code>SUBSTR()</code>：从字符串中提取子字符串。  <code>LENGTH()</code>：返回字符串的长度。  <code>UPPER()</code>：将字符串转换为大写。 <code>LOWER()</code>：将字符串转换为小写。  <code>TRIM()</code>：去除字符串首尾的空格或其他指定字符。  <code>REPLACE()</code>：替换字符串中的子串。</li>
<li><strong>日期和时间函数：</strong><code>NOW()</code> 或 <code>CURRENT_TIMESTAMP()</code>：返回当前日期和时间。 <code>DATE()</code>：从日期时间值中提取日期部分。 <code>TIME()</code>：从日期时间值中提取时间部分。 <code>YEAR()</code>：从日期中提取年份。 <code>MONTH()</code>：从日期中提取月份。  <code>DAY()</code>：从日期中提取天。<code>HOUR()</code>：从时间中提取小时。  <code>MINUTE()</code>：从时间中提取分钟。 <code>SECOND()</code>：从时间中提取秒。</li>
<li><strong>逻辑函数：</strong> <code>IF()</code> 或 <code>CASE</code>：根据条件返回不同的值，if(rating&lt;3, 1, 0)；<code>COALESCE()</code>：返回第一个非空值。</li>
<li><strong>聚合函数：</strong>  <code>GROUP_CONCAT()</code>：将组内的值连接成一个字符串。 <code>GROUP_BY</code>：分组聚合查询结果。</li>
<li><strong>窗口函数：</strong><code>ROW_NUMBER()</code>：为结果集的每行分配一个唯一的行号。  <code>RANK()</code>：为结果集中的行分配排名。 <code>DENSE_RANK()</code>：为结果集中的行分配密集排名。 <code>OVER()</code>：定义窗口以进行窗口函数计算。</li>
</ol>
<h2 id="MySQL-数据类型"><a href="#MySQL-数据类型" class="headerlink" title="MySQL 数据类型"></a>MySQL 数据类型</h2><ol>
<li><strong>整数类型：</strong> 用于存储整数值，包括 <code>TINYINT</code>, <code>SMALLINT</code>, <code>MEDIUMINT</code>, <code>INT</code>, 和 <code>BIGINT</code>。</li>
<li><strong>浮点数类型：</strong> 用于存储浮点数，包括 <code>FLOAT</code> 和 <code>DOUBLE</code>。 <code>DECIMAL</code> 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。<br>FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽。如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分</li>
<li><strong>定点数类型：</strong> 用于存储定点数，包括 <code>DECIMAL</code> 或 <code>NUMERIC</code>。</li>
<li><strong>字符串类型：</strong> 用于存储文本数据，主要有 <code>CHAR</code>, <code>VARCHAR</code> 两种类型，一种是定长的，一种是变长的。<br>VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。VARCHAR 会保留字符串末尾的空格，而 CHAR 会删除。</li>
<li><strong>二进制数据类型：</strong> 用于存储二进制数据，包括 <code>BINARY</code>, <code>VARBINARY</code>, <code>TINYBLOB</code>, <code>BLOB</code>, <code>MEDIUMBLOB</code>, 和 <code>LONGBLOB</code>.</li>
<li><strong>日期和时间类型（Date and Time Types）：</strong> <strong><code>DATE</code>：</strong> 用于存储日期。日期格式为’YYYY-MM-DD’，如’2023-10-12’。 <strong><code>TIME</code>：</strong> 用于存储时间。时间格式为’HH:MM:SS’，如 ‘14:30:45’。 <strong><code>YEAR</code>：</strong> 用于存储年份，可以使用两位或四位格式（’YY’或’YYYY’）<br><strong><code>DATETIME</code>：</strong> 用于存储日期和时间。能够保存从 1001 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。它与时区无关，格式为’YYYY-MM-DD HH:MM:SS’，如’2023-10-12 14:30:45’。<br><strong><code>TIMESTAMP</code>：</strong> 用于存储日期和时间，在插入或更新时自动记录当前时间。使用 4 个字节，只能表示从 1970 年到 2038 年。时区有关，即一个时间戳在不同的时区所代表的具体时间是不同的。应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。</li>
<li><strong>布尔类型：</strong> 用于存储布尔值，包括 <code>BOOLEAN</code>, <code>BOOL</code>, <code>TINYINT(1)</code>。</li>
<li><strong>枚举类型：</strong> 用于存储枚举值，其中一个预定义的枚举值，如 <code>ENUM(&#39;value1&#39;, &#39;value2&#39;, ...)</code></li>
<li><strong>集合类型：</strong> 用于存储一个或多个预定义的集合值，如 <code>SET(&#39;value1&#39;, &#39;value2&#39;, ...)</code></li>
<li><strong>自动增长类型：</strong> 用于自动生成唯一标识符，如 <code>AUTO_INCREMENT</code>。</li>
</ol>
<hr>

<h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。<br>如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。<br>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。<br>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。<br>有依赖：学号 -&gt; 姓名、学院，  学院 -&gt; 院长，  学号、课程-&gt; 成绩<br>则 成绩Grade 完全函数依赖于键码（学号，课程），它没有任何冗余数据，每个学生的每门课都有特定的成绩。姓名, 学院 和 院长 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。</p>
<h3 id="MySQL-范式"><a href="#MySQL-范式" class="headerlink" title="MySQL 范式"></a>MySQL 范式</h3><p>范式理论是为了解决四种异常。不符合范式的关系，会产生很多异常：1、冗余数据。2、修改异常: 修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。3、删除异常: 删除一个信息，那么也会丢失其它信息。4、插入异常: 例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。<br>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。</p>
<ol>
<li>第一范式 (1NF)：属性不可分。</li>
<li>第二范式 (2NF)：每个非主属性完全函数依赖于键码。可以通过分解来满足。（一张表分解成多张表）</li>
<li>第三范式 (3NF)：非主属性不传递函数依赖于键码。可以进行分解。<br>for more：<a target="_blank" rel="noopener" href="https://blog.csdn.net/calcular/article/details/79332453">https://blog.csdn.net/calcular/article/details/79332453</a></li>
</ol>
<h2 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h2><ul>
<li><strong>事务</strong>：指的是满足 <strong>ACID</strong> 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。<ul>
<li>原子性(Atomicity)事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</li>
<li>一致性(Consistency)数据库在事务执行前后都保持一致性状态。一致性状态下，所有事务对一个数据的读取结果都是相同的。</li>
<li>隔离性(Isolation)一个事务所做的修改在最终提交以前，对其它事务是不可见的。</li>
<li>持久性(Durability)一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。可以通过数据库备份和恢复来实现，在系统发生崩溃时，使用备份的数据库进行数据恢复。</li>
</ul>
</li>
<li><strong>并发一致性</strong>：产生不一致的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。<ul>
<li>丢失修改：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。</li>
<li>读脏数据：T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</li>
<li>不可重复读：T2 读取一个数据，T1 对该数据做了修改。 T2 再次读取这个数据时读取的结果和第一次读取的结果不同。</li>
<li>幻影读：T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据 结果和第一次不同。<br>并发控制可以通过 <strong>封锁</strong> 来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的 <strong>隔离级别</strong>，让用户以一种更轻松的方式处理并发一致性问题。</li>
</ul>
</li>
<li><strong>封锁</strong><ul>
<li>封锁粒度：MySQL 中提供了两种封锁粒度，行级锁以及表级锁。</li>
<li>读写锁：1、排它锁(Exclusive)，简写为 X 锁，又称写锁。 2、共享锁(Shared)，简写为 S 锁，又称读锁。</li>
<li>意向锁：使用意向锁(Intention Locks)可以更容易地支持多粒度封锁。</li>
<li>封锁协议：1. 三级封锁协议 2. 两段锁协议</li>
</ul>
</li>
<li><strong>隔离等级</strong>：MySQL支持 <strong>四种</strong> 标准的事务隔离级别，这些隔离级别定义了事务之间的可见性和并发控制。<table>
<thead>
<tr>
<th>READ UNCOMMITTED &#x2F; READ COMMITTED &#x2F; REPEATABLE READ &#x2F; SERIALIZABLE</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻影读</th>
</tr>
</thead>
<tbody><tr>
<td>未提交读（允许一个事务读取另一个事务未提交的数据）</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>提交读（一个事务只能读取到另一个事务已经提交的数据）</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>可重复读（事务执行期间，一个事务多次读取同一行数据时，会得到相同的结果）</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>可串行化（最高的隔离级别，确保事务串行执行）</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
</li>
<li>数据库默认隔离级别<br>oracle数据库默认的隔离级别是：读已提交。<br>mysql数据库默认的隔离级别是：可重复读。</li>
<li>InnoDB 中如何防止幻读 or MVCC 实现<ul>
<li>1、执行普通 select，此时会以 MVCC 快照读的方式读取<br>（1）一致性非锁定读（快照读），普通的SELECT，通过多版本并发控制（MVCC）实现。<br>（2）在快照读下，RR 隔离级别只会在事务开启后的第一次查询生成 Read View ，并使用至事务提交。所以在生成 Read View 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”。<br>（3）只有在事务隔离级别 RC(读取已提交) 和 RR（可重读）下，InnoDB 才会使用一致性非锁定读。</li>
<li>2、执行 select…for update&#x2F;lock in share mode、insert、update、delete 等当前读<br>（1）一致性锁定读（当前读），SELECT … FOR UPDATE&#x2F;SELECT … LOCK IN SHARE MODE&#x2F;INSERT&#x2F;UPDATE&#x2F;DELETE，通过锁实现。<br>（2）在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！InnoDB 使用 Next-key Lock 来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;  <span class="comment">-- 启动事务，用于标志事务的开始。在这之后的 SQL 语句都将在一个事务中执行 </span></span><br><span class="line"><span class="keyword">COMMIT</span>;             <span class="comment">-- 提交事务，当所有的 SQL 语句都执行成功时，使用 `COMMIT` 命令来提交事务，将更改永久保存到数据库。提交后，事务结束。</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;           <span class="comment">-- 回滚事务，如果在事务执行的过程中发生了错误或者不符合条件，可以使用 `ROLLBACK` 命令来回滚事务，撤销所有的更改，使数据库回到事务开始前的状态。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SAVEPOINT</span> savepoint_name;    <span class="comment">-- 保存点，用于创建一个保存点，以便在事务中的某一时刻回滚到这个保存点。可以在事务中设置多个保存点。</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> savepoint_name;  <span class="comment">-- 回滚到保存点，如果在事务中的某一步出现问题，可以回滚到之前设置的某个保存点，而不必回滚整个事务。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置事务隔离级别，包括 `READ UNCOMMITTED`、`READ COMMITTED`、`REPEATABLE READ` 和 `SERIALIZABLE`。</span></span><br><span class="line"><span class="keyword">SET</span> TRANSACTION ISOLATION LEVEL level;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- MySQL 默认是自动提交模式，即每个 SQL 语句都会自动成为一个事务并提交。命令关闭自动提交，再通过 `COMMIT` 手动提交，或者通过 `ROLLBACK` 回滚。</span></span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">--示例 1</span></span><br><span class="line">  <span class="keyword">START</span> TRANSACTION;</span><br><span class="line">  <span class="comment">-- 执行一系列 SQL 语句</span></span><br><span class="line">  <span class="comment">-- 提交事务</span></span><br><span class="line">  <span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--示例 2</span></span><br><span class="line">  <span class="keyword">START</span> TRANSACTION;</span><br><span class="line">  <span class="comment">-- 执行一系列 SQL 语句</span></span><br><span class="line">  <span class="comment">-- 如果发生错误，回滚事务</span></span><br><span class="line">  <span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="管理用户权限"><a href="#管理用户权限" class="headerlink" title="管理用户权限"></a>管理用户权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建用户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;newuser&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span>;</span><br><span class="line"><span class="comment">-- 授予用户权限</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> mydatabase.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;newuser&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"><span class="comment">-- 刷新权限</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<h3 id="备份和恢复"><a href="#备份和恢复" class="headerlink" title="备份和恢复"></a>备份和恢复</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 备份数据库</span></span><br><span class="line">mysqldump -u username -p mydatabase &gt; backup.sql</span><br><span class="line"><span class="comment"># 恢复数据库</span></span><br><span class="line">mysql -u username -p mydatabase &lt; backup.sql</span><br></pre></td></tr></table></figure>


<h2 id="MySQL-存储引擎"><a href="#MySQL-存储引擎" class="headerlink" title="MySQL 存储引擎"></a>MySQL 存储引擎</h2><ul>
<li>InnoDB<ul>
<li>是 MySQL 默认的事务型存储引擎。  实现了四个标准的隔离级别，默认级别是可重复读。在可重复读隔离级别下，通过多版本并发控制(MVCC)+ 间隙锁(Next-Key Locking)防止幻影读</li>
<li>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。 内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等</li>
<li>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</li>
</ul>
</li>
<li>MyISAM<ul>
<li>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它</li>
<li>提供了大量的特性，包括压缩表、空间数据索引等。</li>
<li><strong>不支持事务</strong></li>
<li>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入(CONCURRENT INSERT)。</li>
<li>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作非常慢</li>
<li>如果指定了 DELAY KEY WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作</li>
</ul>
</li>
</ul>
<hr>

<h1 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h1><p>在MySQL中，索引是一种用于提高数据库查询效率的数据结构。它类似于书的目录，通过在数据库表上创建索引，可以快速定位并访问表中的特定数据行，而无需全表扫描。索引在数据库的性能优化中扮演着关键的角色，特别是在大型数据集上。<br>索引是在<strong>存储引擎层</strong>实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p>
<ul>
<li>索引类型<ol>
<li><strong>B+Tree 索引</strong>：是大多数 MySQL 存储引擎的默认索引类型。因为不再需要进行全表扫描，只需要对树进行搜索即可，因此查找速度快很多。除了用于查找，还可以用于排序和分组。<br>InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</li>
<li><strong>哈希索引</strong>：能以 O(1) 时间进行查找，但是失去了有序性。存在限制：无法用于排序与分组；只支持精确查找，无法用于部分查找和范围查找。<br>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</li>
<li>全文索引：MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。全文索引一般使用倒排索引实现，它记录着关键词到其所在文档的映射。InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</li>
<li>空间数据索引：MyISAM 存储引擎支持空间数据索引(R-Tree)，可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。必须使用 GIS 相关的函数来维护数据</li>
</ol>
</li>
<li>索引的优点：大大减少了服务器需要扫描的数据行数。帮助服务器避免进行排序和分组，也就不需要创建临时表(B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，因为不需要排序和分组，也就不需要创建临时表)。将随机 I&#x2F;O 变为顺序 I&#x2F;O(B+Tree 索引是有序的，也就将相邻的数据都存储在一起)。</li>
<li>索引的使用场景<ul>
<li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效。</li>
<li>对于中到大型的表，索引就非常有效。</li>
<li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li>
</ul>
</li>
</ul>
<h3 id="B-Tree-索引"><a href="#B-Tree-索引" class="headerlink" title="B+Tree 索引"></a>B+Tree 索引</h3><p>是大多数 MySQL 存储引擎的默认索引类型因为不再需要进行全表扫描，只需要对树进行搜索即可，因此查找速度快很多。除了用于查找，还可以用于排序和分组可以指定多个列作为索引列，多个索引列共同组成键.<br>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。<br>InnoDB 的 B+Tree 索引分为主索引和辅助索引.<br>主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>
<h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><p>1.独立的列<br>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。例如下面的查询不能使用 actor id 列的索引:<br>2.多列索引<br>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor id和 film id 设置为多列索引。<br>3.索引列的顺序<br>4.前缀索引对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。对于前缀长度的选取需要根据索引选择性来确定。<br>5.覆盖索引</p>
<hr>


<h1 id="SQL-DB-组成"><a href="#SQL-DB-组成" class="headerlink" title="SQL DB 组成"></a>SQL DB 组成</h1><h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><p>进程管理器(process manager): 很多数据库具备一个需要妥善管理的进程&#x2F;线程池。再者，为了实现纳秒级操作，一些现代数据库使用自己的线程而不是操作系统线程<br>网络管理器(network manager): 网路 I&#x2F;O 是个大问题，尤其是对于分布式数据库。所以一些数据库具备自己的网络管理器<br>文件系统管理器(File system manager): 磁盘 I&#x2F;O 是数据库的首要瓶颈。具备一个文件系统管理器来完美地处理OS文件系统甚至取代OS文件系统，是非常重要的。<br>内存管理器(memory manager): 为了避免磁盘 I&#x2F;O 带来的性能损失，需要大量的内存。但是如果你要处理大容量内存你需要高效的内存管理器，尤其是你有很多查询同时使用内存的时候。<br>安全管理器 (Security Manager) : 用于对用户的验证和授权<br>客户端管理器 (Client manager) : 用于管理客户端连接。</p>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>备份管理器 (Backup manager) : 用于保存和恢复数据<br>恢复管理器 (Recovery manager) : 用于崩溃后重启数据库到一个一致状态。<br>监控管理器 (Monitor manager) : 用于记录数据库活动信息和提供监控数据库的工具。<br>管理员管理器(Administration manager) : 用于保存元数据(比如表的名称和结构)，提供管理数据库、模式、表空的工具</p>
<h3 id="查询管理器"><a href="#查询管理器" class="headerlink" title="查询管理器"></a>查询管理器</h3><p>查询解析器 (Query parser) : 用于检查查询是否合法<br>查询重写器 (Query rewriter) : 用于预优化查询<br>查询优化器 (Query optimizer) : 用于优化查询<br>查询执行器 (Query executor) : 用于编译和执行查询</p>
<h3 id="数据管理器"><a href="#数据管理器" class="headerlink" title="数据管理器"></a>数据管理器</h3><p>事务管理器 (Transaction manager) : 用于处理事务<br>缓存管理器 (Cache manager): 数据被使用之前置于内存，或者数据写入磁盘之前置于内存<br>数据访问管理器 (Data access manager) : 访问磁盘中的数据</p>
<h2 id="数据查询的流程"><a href="#数据查询的流程" class="headerlink" title="数据查询的流程"></a>数据查询的流程</h2><ul>
<li><strong>客户端管理器</strong>： 客户端管理器是处理客户端通信的。客户端可以是一个（网站）服务器或者一个最终用户或最终应用。客户端管理器通过一系列知名的API（JDBC, ODBC, OLE-DB …）提供不同的方式来访问数据库。客户端管理器也提供专有的数据库访问API。<br>（<code>JDBC</code> 是 Java 编程语言中用于连接和操作数据库的标准<strong>API</strong>。可以理解为 JDBC 是 Java 与数据库之间的桥梁，允许 Java 应用程序与 MySQL 数据库进行通信和交互。<code>MyBatis</code> 是一个开源的<strong>Java持久层框架</strong>，用于将对象与关系数据库的表之间进行映射,使用 MyBatis 来操作 MySQL 数据库。）</li>
<li><strong>查询管理器</strong>：查询首先被解析并判断是否合法、然后被重写，去除了无用的操作并且加入预优化部分、接着被优化以便提升性能，并被转换为可执行代码和数据访问计划、然后计划被编译、最后，被执行</li>
<li><strong>数据管理器</strong>：在这一步，查询管理器执行了查询，需要从表和索引获取数据，于是向数据管理器提出请求。</li>
<li><strong>客户端管理器</strong></li>
</ul>
<h2 id="MySQL-一条-SQL-的执行过程详解"><a href="#MySQL-一条-SQL-的执行过程详解" class="headerlink" title="MySQL - 一条 SQL 的执行过程详解"></a>MySQL - 一条 SQL 的执行过程详解</h2><p><a target="_blank" rel="noopener" href="https://pdai.tech/md/db/sql-mysql/sql-mysql-execute.html">https://pdai.tech/md/db/sql-mysql/sql-mysql-execute.html</a></p>
<p>在系统和 MySQL 进行交互之前，MySQL 驱动会帮我们建立好连接，然后我们只需要发送 SQL 语句就可以执行 CRUD 了。<br>java 系统在通过 MySQL 驱动和 MySQL 数据库连接的时候是基于 TCP&#x2F;IP 协议的，多线程请求的时候频繁的创建和销毁连接显然是不合理的。在访问 MySQL 数据库的时候，建立的连接并不是每次请求都会去创建的，而是从数据库连接池中去获取，这样就解决了因为反复的创建和销毁连接而带来的性能损耗问题了。MySQL 的架构体系中也已经提供了这样的一个池子，也是数据库连池。双方都是通过数据库连接池来管理各个连接的，这样一方面线程之前不需要是争抢连接，更重要的是不需要反复的创建的销毁连接。<br><img src="https://pdai.tech/images/db/mysql/db-mysql-sql-4.png"></p>
<h4 id="网络连接必须由线程来处理"><a href="#网络连接必须由线程来处理" class="headerlink" title="网络连接必须由线程来处理"></a>网络连接必须由线程来处理</h4><p>网络中的连接都是由线程来处理的，所谓网络连接说白了就是一次请求，每次请求都会有相应的线程去处理的。也就是说对于 SQL 语句的请求在 MySQL 中是由一个个的线程去处理的。<br><img src="https://pdai.tech/images/db/mysql/db-mysql-sql-5.png"><br>SQL 接口：MySQL 中处理请求的线程在获取到请求以后获取 SQL 语句去交给 SQL 接口去处理。<br>查询解析器：会将 SQL 接口传递过来的 SQL 语句进行解析，翻译成 MySQL 自己能认识的语言<br>MySQL 查询优化器：查询优化器内部具体怎么实现的我们不需要是关心，我需要知道的是 MySQL 会帮我去使用他自己认为的最好的方式去优化这条 SQL 语句，并生成一条条的执行计划，比如你创建了多个索引，MySQL 会依据成本最小原则来选择使用对应的索引，这里的成本主要包括两个方面, IO 成本和 CPU 成本。MySQL 优化器 会计算 「IO 成本 + CPU」 成本最小的那个索引来执行<br>存储引擎：查询优化器会调用存储引擎的接口，去执行 SQL，也就是说真正执行 SQL 的动作是在存储引擎中完成的。数据是被存放在内存或者是磁盘中的（存储引擎是一个非常重要的组件，后面会详细介绍）<br>执行器：执行器是一个非常重要的组件，因为前面那些组件的操作最终必须通过执行器去调用存储引擎接口才能被执行。执行器最终最根据一系列的执行计划去调用存储引擎的接口去完成 SQL 的执行<br><img src="https://pdai.tech/images/db/mysql/db-mysql-sql-8.png"></p>
<h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>当我们系统发出这样的查询去交给 MySQL 的时候，MySQL 会按照我们上面介绍的一系列的流程最终通过执行器调用存储引擎去执行，流程图就是上面那个。<br>在执行这个 SQL 的时候 SQL 语句对应的数据要么是在内存中，要么是在磁盘中，如果直接在磁盘中操作，那这样的随机IO读写的速度肯定让人无法接受的，所以每次在执行 SQL 的时候都会将其数据加载到内存中，这块内存就是 InnoDB 中一个非常重要的组件：缓冲池 Buffer Pool</p>
<p>关于Buffer Pool、Redo Log Buffer 和undo log、redo log、bin log 概念以及关系：<br>Buffer Pool 是 MySQL 的一个非常重要的组件，因为针对数据库的增删改操作都是在 Buffer Pool 中完成的<br>Undo log 记录的是数据操作前的样子<br>redo log 记录的是数据被操作后的样子（redo log 是 Innodb 存储引擎特有）<br>bin log 记录的是整个操作记录（这个对于主从复制具有非常重要的意义）<br>、、，，<br>，。</p>
<h4 id="从准备更新一条数据到事务的提交的流程描述"><a href="#从准备更新一条数据到事务的提交的流程描述" class="headerlink" title="从准备更新一条数据到事务的提交的流程描述"></a>从准备更新一条数据到事务的提交的流程描述</h4><ul>
<li>首先执行器根据 MySQL 的执行计划来查询数据，先是从缓存池中查询数据，如果没有就会去数据库中查询，如果查询到了就将其放到缓存池中</li>
<li>在数据被缓存到缓存池的同时，会写入 undo log 日志文件更</li>
<li>新的动作是在 BufferPool 中完成的，同时会将更新后的数据添加到 redo log buffer 中</li>
<li>完成以后就可以提交事务，在提交的同时会做以下三件事 <ul>
<li>将redo log buffer中的数据刷入到 redo log 文件中</li>
<li>将本次操作记录写入到 bin log文件中</li>
<li>将 bin log 文件名字和更新内容在 bin log 中的位置记录到redo log中，同时在 redo log 最后添加 commit 标记</li>
</ul>
</li>
<li>至此表示整个更新事务已经完成</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/11/Mysql/" data-id="cls3bhyxv000hsgv5gz9ya627" data-title="MySQL" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2046/12/">December 2046</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2046/12/30/nice-photo/">Nice Photo</a>
          </li>
        
          <li>
            <a href="/2024/01/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
          </li>
        
          <li>
            <a href="/2024/01/11/RabbitMQ/">RabbitMQ</a>
          </li>
        
          <li>
            <a href="/2024/01/10/Redis/">Redis</a>
          </li>
        
          <li>
            <a href="/2024/01/07/SpringCloud/">SpringCloud</a>
          </li>
        
          <li>
            <a href="/2024/01/04/%E9%AA%8F%E4%BC%AF/">骏 伯</a>
          </li>
        
          <li>
            <a href="/2023/10/13/%E9%9D%A2%E8%AF%95_%E4%B8%AA%E4%BA%BA/">面 逝 | 个人</a>
          </li>
        
          <li>
            <a href="/2023/10/12/%E9%9D%A2%E8%AF%95_Java/">面 逝 | Java</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 fengcai<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>