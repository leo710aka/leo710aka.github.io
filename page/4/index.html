<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Qué miras Bobo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Qué miras Bobo">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="Qué miras Bobo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="fengcai">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Qué miras Bobo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="https://github.com/leo710aka/bk/blob/main/DT1.jpg?raw=true">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Qué miras Bobo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Java数据结构" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/02/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date">
  <time class="dt-published" datetime="2021-09-02T03:49:42.000Z" itemprop="datePublished">2021-09-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/02/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">Java 数据结构</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><strong>数组</strong>是一种连续存储线性结构，数组尺寸不能改变。元素类型相同，大小相等，通过使用整型索引值来访问他们的元素。数组是多维的。数组能够容纳基本数据类型（int、char等）或者对象引用（如类对象）。<br><strong>数组的优点</strong>：存取速度快<br><strong>数组的缺点</strong>：事先必须知道数组的长度、插入删除元素很慢、空间通常有限制、需要大块连续内存块、插入删除元素的效率很低<br>Java没有指针，同时也不对程序员暴露其元素的地址，寻址操作完全交给虚拟机。所以看不到每个元素的地址情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers;                               <span class="comment">// 声明一个 int 数组</span></span><br><span class="line">numbers = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];                        <span class="comment">// 初始化一个长度为 5 的 int 数组</span></span><br><span class="line"><span class="type">int</span>[] values = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;              <span class="comment">// 声明并初始化一个 int 数组</span></span><br><span class="line">... <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, j&#125;;                  <span class="comment">// 在方法中返回数组[i, j]</span></span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> arr.length;                     <span class="comment">// 获取数组的长度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> arr[<span class="number">1</span>];                          <span class="comment">// 获取索引为 1 的元素</span></span><br><span class="line"><span class="type">int</span>[][] twoDimArray = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">4</span>];         <span class="comment">// 创建一个 3x4 的二维数组</span></span><br><span class="line"><span class="type">int</span>[][] twodimArray = &#123;&#123;<span class="number">1</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">5</span>&#125;&#125;;   <span class="comment">// 声明并初始化一个 二维 int 数组</span></span><br><span class="line"><span class="type">int</span>[][][] threeDimArray = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">4</span>][<span class="number">2</span>];  <span class="comment">// 创建一个 3x4x2 的三维数组</span></span><br><span class="line">System.out.println(twoDimArray[<span class="number">0</span>]);          <span class="comment">// [I@7852e922：16进制数值，不是真正的地址，是处理后的</span></span><br></pre></td></tr></table></figure>
<p><code>int[] numbers;</code> 只是声明了一个名为 numbers 的整数数组的引用，它并没有创建数组对象，并没有分配内存或存储数据。<br><code>int[] numbers = new int[5];</code> 在这里，new int[5] 表示创建一个能够存储 5 个整数的整型数组，并将该数组的引用赋给 numbers 变量。这是一个基本的数组类型，而不是 Arrays、ArrayList 或 Vector 对象。<br>数组是基本的数据结构，而 Arrays 和 ArrayList 是 Java 中的类，提供了用于操作和管理数组的方法。</p>
<h4 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h4><p><code>Arrays 类</code>是 Java API 中的一个工具类，它提供了一系列静态方法来操作数组，比如排序、搜索、比较等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">Arrays.fill(arr, <span class="number">10</span>);                           <span class="comment">//  fill()：将数组的所有元素设置为指定值。</span></span><br><span class="line">String[] array = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(array);       <span class="comment">//  asList()：将数组转换为 `List`。</span></span><br><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">Arrays.sort(numbers);                           <span class="comment">//  sort()：对数组进行排序。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(numbers, <span class="number">3</span>);    <span class="comment">//  binarySearch()：在排序数组中执行二分查找。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Arrays.toString(numbers);          <span class="comment">//  toString()：将数组转换为字符串表示形式。</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEqual</span> <span class="operator">=</span> Arrays.equals(arr, numbers);  <span class="comment">//  equals()：比较两个数组是否相等。</span></span><br><span class="line"><span class="type">int</span>[] copy1 = Arrays.copyOf(arr, sou.length);   <span class="comment">//  copyOf：复制数组或复制数组的指定范围。</span></span><br><span class="line"><span class="type">int</span>[] copy2 = Arrays.copyOfRange(arr, <span class="number">2</span>, <span class="number">4</span>);    <span class="comment">//  copyOfRange()：复制数组或复制数组的指定范围。</span></span><br></pre></td></tr></table></figure>

<h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p><code>Vector</code> 是一个同步的动态数组类，类似于 <code>ArrayList</code>，可以自动增长和缩小以容纳对象。<br><strong>ArrayList 和 Vector 都是动态数组实现的集合</strong>，而 <code>Arrays</code> 类主要用于数组的各种操作。<br><code>Vector</code> 是线程安全的（是同步的），而 <code>Arrays</code> 不是（没有提供同步）。<code>Vector</code> 在对集合进行操作时会进行同步，适用于多线程环境。单线程环境下，推荐使用 <code>ArrayList</code> 而不是 <code>Vector</code>，因为 <code>ArrayList</code> 不是同步的，性能更高。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt;String&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();            <span class="comment">// 创建 Vector</span></span><br><span class="line">vector.add(<span class="string">&quot;Element 1&quot;</span>);                           <span class="comment">// 添加元素</span></span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> vector.size();                          <span class="comment">// 获取 Vector 的大小</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> vector.isEmpty();                <span class="comment">// 检查 Vector 是否为空</span></span><br><span class="line"><span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> vector.get(<span class="number">0</span>);                    <span class="comment">// 访问 Vector 中的元素：获取索引为0的元素</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> vector.indexOf(<span class="string">&quot;Element 2&quot;</span>);           <span class="comment">// 查找元素在 Vector 中的位置</span></span><br><span class="line">vector.remove(<span class="number">1</span>);                                  <span class="comment">// 删除 Vector 中的元素：删除索引为1的元素</span></span><br><span class="line"><span class="keyword">for</span> (String element : vector) &#123; ...&#125;               <span class="comment">// 遍历 Vector 中的元素</span></span><br></pre></td></tr></table></figure>

<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>ArrayList是基于<strong>动态数组</strong>实现的，可以自动扩容。（动态数组是一种数据结构，而非类，是一种具有自动扩容能力的数组）<br>它支持快速随机访问元素，但在插入和删除元素时可能会比较耗时。适用于需要随机访问元素、按索引查找和遍历集合的场景。<br>1、<code>add(E e)</code>：在尾部添加元素。<br>2、<code>get(int index)</code>：获取指定位置的元素。<br>3、<code>set(int index, E element)</code>：用于替换指定索引处的元素。<br>4、<code>remove(int index)</code>：移除指定位置的元素。<br>5、<code>size()</code>：返回集合大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; cur = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();                        <span class="comment">// 一维动态数组</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();    <span class="comment">// 二维动态数组</span></span><br><span class="line">ans.get(i).set(j, ans.get(i).get(j) + ans.get(i-<span class="number">1</span>).get(j));  <span class="comment">// 二维数组读写</span></span><br></pre></td></tr></table></figure>

<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList是基于<strong>双向链表</strong>实现的，每个节点都存储了对前一个和后一个元素的引用。它在插入和删除元素时效率较高，但在随机访问元素时效率较低。LinkedList适用于需要频繁的插入、删除操作的场景。<br>1、<code>add(E e)</code>：在尾部添加元素。<br>2、<code>addFirst(E e)</code>：在头部添加元素。<br>3、<code>get(int index)</code>：获取指定位置的元素。<br>4、<code>remove(int index)</code>：移除指定位置的元素。<br>5、<code>size()</code>：返回集合大小。</p>
<hr>


<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><strong>链表</strong>由一个节点序列组成，每个节点包含数据和指向下一个节点的引用。n个节点离散分配，每个节点只有一个前驱节点和一个后续节点，首节点没有前驱节点，尾节点没有后续节点。当你创建一个链表时，你持有的引用实际上指向链表中第一个节点的地址，也就是头节点。头节点存储了链表的起始地址，通过这个地址可以访问整个链表。<br><strong>链表优点</strong>：空间没有限制、插入删除元素很快。<strong>链表缺点</strong>：存取速度很慢</p>
<h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p>单链表的每个节点包含两个部分：数据和指向下一个节点的引用。第一个节点称为头节点，最后一个节点的下一个节点为空<code>null</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;   <span class="comment">// Java中单链表的节点（Node）通常会被定义为一个内部类。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> data;  <span class="comment">// 数据域</span></span><br><span class="line">    <span class="keyword">public</span> Node next; <span class="comment">// 指针域，指向下一个节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123;    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;        <span class="built_in">this</span>.data = data;    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data, Node next)</span> &#123;        <span class="built_in">this</span>.data = data;        <span class="built_in">this</span>.next = next;    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="comment">// 添加新节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(data);</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            head = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">while</span> (current.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current.next = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他操作（删除节点、查找节点等）可以根据需要实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>双向链表</strong> 中的每个节点都有两个指针：一个指向前一个节点，一个指向后一个节点。双向链表允许在节点之间双向遍历。<br>将两种(双向&#x2F;单向)链表的最后一个结点指向第一个结点从而实现 <strong>循环链表</strong>，能通过任何一个节点找到其他所有的节点。</p>
<hr>


<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。哈希表使用 <strong>O(N)</strong> 空间复杂度存储数据，并且以 <strong>O(1)</strong> 时间复杂度求解问题。</p>
<ul>
<li>构造散列函数的方法有：<ol>
<li>直接定址法： 取关键字或关键字的某个线性函数值为散列地址。即：h(key) &#x3D; key 或 h(key) &#x3D; a * key + b，其中 a，b 为常数</li>
<li>数字分析法</li>
<li>平方取值法： 取关键字平方后的中间几位为散列地址。</li>
<li>折叠法： 将关键字分割成位数相同的几部分，然后取这几部分的叠加和作为散列地址。</li>
<li>除留余数法： 取关键字被某个不大于散列表表长 m 的数 p 除后所得的余数为散列地址，即： h(key) &#x3D; key MOD p p ≤ m</li>
<li>随机数法： 选择一个随机函数，取关键字的随机函数值为它的散列地址，即： h(key) &#x3D; random(key)</li>
</ol>
</li>
</ul>
<p>使用了散列表的集合有map和set；</p>
<ul>
<li><strong>HashSet</strong> 用于存储一个集合，可以查找元素是否在集合中。<br>但是，如果元素有穷，并且范围不大，那么可以用一个布尔数组来存储一个元素是否存在，就足够了。</li>
<li><strong>HashMap</strong> 主要用于映射关系，从而把两个元素联系起来。HashMap 也可以用来对元素进行计数统计，此时键为元素，值为计数。和 HashSet 类似，如果元素有穷并且范围不大，可以用整型数组来进行统计。</li>
</ul>
<h4 id="HashMap-常用方法"><a href="#HashMap-常用方法" class="headerlink" title="HashMap 常用方法"></a>HashMap 常用方法</h4><p><code>put(key, value)</code>：将指定的键值对添加到哈希表中；如果该键已存在于 HashMap 中，则其旧值会被新值替换。<br><code>get(key)</code>：根据键获取对应的值。<br><code>containsKey(key)</code>：检查哈希表中是否包含指定的键。<code>containsValue(value)</code>：检查哈希表中是否包含指定的值。<br><code>remove(key)</code>：根据键移除键值对。<br><code>size()</code>：返回哈希表中键值对的数量。<br><code>isEmpty()</code>：检查哈希表是否为空。<br><code>keySet()</code>：返回哈希表中所有键的集合。<code>values()</code>：返回哈希表中所有值的集合。<code>entrySet()</code>：返回键值对的集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line">Map&lt;String, Integer&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  <span class="comment">// 创建一个HashMap</span></span><br><span class="line">hashMap.put(<span class="string">&quot;Three&quot;</span>, <span class="number">3</span>);  hashMap.remove(<span class="string">&quot;Three&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!hashMap.containsKey(<span class="string">&quot;Three&quot;</span>))  hashMap.put(<span class="string">&quot;Three&quot;</span>, <span class="number">3</span>); </span><br><span class="line"><span class="comment">// 遍历kv：2种方法</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : hashMap.entrySet()) &#123;  </span><br><span class="line">    System.out.println(<span class="string">&quot;Key: &quot;</span> + entry.getKey() + <span class="string">&quot;, Value: &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(String s : hashMap.keySet()) System.out.println(<span class="string">&quot;Key: &quot;</span> + s + <span class="string">&quot;, Value: &quot;</span> + hashMap.get(s));</span><br></pre></td></tr></table></figure>

<h4 id="HashSet-常用方法"><a href="#HashSet-常用方法" class="headerlink" title="HashSet 常用方法"></a>HashSet 常用方法</h4><p><code>add(E e)</code>: 向集合中添加元素。<code>addAll(Collection&lt;? extends E&gt; c)</code>: 将另一个集合的所有元素添加到当前集合。<br><code>remove(Object o)</code>: 移除指定的元素。<code>removeAll(Collection&lt;?&gt; c)</code>: 移除当前集合中包含在指定集合中的所有元素。<br><code>contains(Object o)</code>: 判断集合中是否包含指定元素。containsAll(Collection&lt;?&gt; c): 判断集合是否包含指定集合中的所有元素。<br><code>size()</code>: 返回集合的大小（元素个数）。<br><code>isEmpty()</code>: 判断集合是否为空。<br><code>clear()</code>: 清空集合中的所有元素。<br><code>iterator()</code>: 返回用于遍历集合的迭代器。</p>
<hr>


<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><strong>String</strong> 内部使用 char 数组存储数据。该数组被声明为 final，因此它不可被继承，初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 <strong>不可变</strong>。String 是一个类，而不是基本数据类型或容器。表示的是一个字符序列。<br>字符串是一个<strong>引用类型</strong>，因此在创建 String 对象时，实际上是在内存中分配了一块存储空间来存储字符串的值。(字符串常量池，堆，栈，</p>
<ul>
<li><strong>获取字符串信息</strong>：<br><code>length()</code>：返回字符串的长度。<br><code>charAt(int index)</code>：返回指定索引处的字符。<br><code>substring(int beginIndex)</code>：返回从 beginIndex 开始到字符串末尾的子字符串。<br><code>substring(int beginIndex, int endIndex)</code>：返回从 beginIndex 到 endIndex（不含）之间的子字符串</li>
<li><strong>字符串拼接</strong>：直接使用 <code>+</code> 运算符，或 <code>concat(String str)</code>：将指定字符串 str 连接到原字符串的末尾。<br>String 不可变，+&#x3D; 操作符或 concat()实际上创建了一个新的字符串对象，该对象包含 字符串值修改后的内容，然后将其分配给了原 str变量，使 str 引用了新的字符串对象，而原始的空字符串对象仍然存在，没有被修改。</li>
<li><strong>字符串查找和比较</strong>：<br><code>indexOf(String str)</code>：返回指定子字符串 str 在主字符串中第一次出现的位置。<code>lastIndexOf()</code>：返回最后一次..<br><code>equals(Object another)</code>：比较两个字符串是否相等。<code>equalsIgnoreCase()</code>：忽略大小写比较..。</li>
<li><strong>字符串转换</strong>：<br><code>toLowerCase()</code>：将字符串转换为小写，<code>toUpperCase()</code>：转大写。对于字符，有 <code>Character.toLowerCase()</code> 方法；<br><code>trim()</code>：去除字符串首尾的空格。</li>
<li><strong>切割字符串：</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;Hello world! This is a Java example.&quot;</span>;</span><br><span class="line"><span class="comment">// split() 方法根据匹配给定的正则表达式来拆分字符串。(注意判断结果可能是空字符串)</span></span><br><span class="line"><span class="comment">// 注意：`.`、`$`、`|` 和 `*` 等转义字符，必须得加 \\。多个分隔符，可以用 | 作为连字符。</span></span><br><span class="line"><span class="comment">// 使用空格切割字符串: \\s+ 表示一个或多个空格</span></span><br><span class="line">String[] words = text.split(<span class="string">&quot;\\s+&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><strong>字符串替换</strong>：<br><code>replace(char oldChar, char newChar)</code>：将字符串中的 <code>oldChar</code> 替换为 <code>newChar</code>。<br><code>replaceAll(String regex, String replace)</code>：使用新字符串<code>replace</code>替换所有与 <code>regex</code>匹配的字符串。<br><code>replaceFirst(String regex, String replacement)</code>：替换第一个匹配的字符串。</li>
<li><strong>字符串翻转</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">original</span> <span class="operator">=</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">reversed</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(original).reverse();</span><br><span class="line"><span class="type">String</span> <span class="variable">reversedString</span> <span class="operator">=</span> reversed.toString();</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>

<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p>数组和链表都是线性存储结构的基础，栈和队列都是线性存储结构的应用</p>
<h3 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h3><p>栈是一种后进先出（LIFO，Last-In-First-Out）的数据结构。在Java中，可以使用 <code>java.util.Stack</code> 类实现栈的功能，也可以使用 <code>Deque</code> 接口（比如 <code>ArrayDeque</code> 或 <code>LinkedList</code>）来模拟栈的行为。<br>Java 中，Stack 类实际上继承自 Vector 类。Vector 类实现了一个动态数组，而 Stack 在 Vector 的基础上提供了栈的常见操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">stack.push(<span class="number">10</span>);                       <span class="comment">// push(E item)：将元素压入栈顶。</span></span><br><span class="line">stack.push(<span class="number">20</span>); </span><br><span class="line">System.out.println(stack.pop());      <span class="comment">// pop()：移除并返回栈顶元素。输出 30</span></span><br><span class="line">System.out.println(stack.peek());     <span class="comment">// peek()：返回但不移除栈顶元素。输出 20</span></span><br><span class="line">System.out.println(stack.isEmpty());  <span class="comment">// isEmpty()：检查队列是否为空。输出 false</span></span><br></pre></td></tr></table></figure>

<h3 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h3><p>队列是一种先进先出（FIFO，First-In-First-Out）的数据结构。在Java中，可以使用 <code>java.util.Queue</code> 接口和它的实现类来实现队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">queue.offer(<span class="number">10</span>);                        <span class="comment">// offer(E e)：将元素插入队列。</span></span><br><span class="line">queue.offer(<span class="number">20</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> que.size();                 <span class="comment">// 队列的大小</span></span><br><span class="line">System.out.println(queue.poll());       <span class="comment">// poll()：移除并返回队列头部的元素。输出 10</span></span><br><span class="line">System.out.println(queue.peek());       <span class="comment">// peek()：返回但不移除队列头部的元素。输出 20</span></span><br><span class="line">System.out.println(queue.isEmpty());    <span class="comment">// isEmpty()：检查队列是否为空。输出 false</span></span><br></pre></td></tr></table></figure>

<p>双向队列 (Deque, “double ended queue”)，它可以从队列的两端添加和删除元素。Java的java.util包提供了<code>ArrayDeque</code>和<code>LinkedList</code>两种实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;String&gt;();  </span><br><span class="line"><span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">    stack.pollFirst();      <span class="comment">// 前出</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    stack.offerLast(name);  <span class="comment">// 后入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优先级队列 (PriorityQueue), 是一个无界队列，它使用元素的自然顺序或者构造队列时提供的Comparator对元素进行排序。PriorityQueue不允许使用null元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个基于自然顺序的优先级队列  </span></span><br><span class="line">PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();  </span><br><span class="line"><span class="comment">// 添加元素  </span></span><br><span class="line">queue.add(<span class="number">3</span>);  </span><br><span class="line">queue.add(<span class="number">1</span>);  </span><br><span class="line">queue.add(<span class="number">4</span>);  </span><br><span class="line"><span class="type">int</span> <span class="variable">removed</span> <span class="operator">=</span> queue.poll();  <span class="comment">// 取出并删除队列中的最小元素 </span></span><br><span class="line">System.out.println(queue);   <span class="comment">// 输出队列：3, 4  </span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个基于自定义Comparator的优先级队列  </span></span><br><span class="line">PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.comparingInt(Math::abs));  </span><br><span class="line"><span class="comment">// 添加元素  </span></span><br><span class="line">queue.add(-<span class="number">3</span>);  </span><br><span class="line">queue.add(-<span class="number">1</span>);  </span><br><span class="line">queue.add(<span class="number">4</span>);  </span><br><span class="line">queue.add(-<span class="number">2</span>);  </span><br><span class="line">System.out.println(queue);  <span class="comment">// 输出队列：1, 2, 3, 4，因为它们的绝对值从小到大排列  </span></span><br></pre></td></tr></table></figure>
<br>

<hr>

<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>树：它是n(n&gt;&#x3D;0)个节点的有限集。n&#x3D;0时为空树。n&gt;0时，有限集的元素构成一个具有层次感的数据结构。<br>区别于线性表一对一的元素关系，树中的节点是一对多的关系。树具有以下特点:<br>1、n&gt;0时，根节点是唯一的，不可能存在多个根节点。<br>2、每个节点有零个至多个子节点；除了根节点外，每个节点有且仅有一个父节点。根节点没有父节点。</p>
<ol>
<li>基本概念：<ul>
<li>子树: 除了根节点外，每个子节点都可以分为多个不相交的子树。</li>
<li>孩子与双亲: 若一个结点有子树，那么该结点称为子树根的”双亲”，子树的根是该结点的”孩子”。</li>
<li>兄弟: 具有相同双亲的节点互为兄弟。</li>
<li>节点的度: 一个节点拥有子树的数目。</li>
<li>叶子: 没有子树，也即是度为0的节点。</li>
<li>分支节点: 除了叶子节点之外的节点，也即是度不为0的节点。</li>
<li>内部节点: 除了根节点之外的分支节点。</li>
<li>层次: 根节点为第一层，其余节点的层次等于其双亲节点的层次加1.</li>
<li>树的高度: 也称为树的深度，树中节点的最大层次。</li>
<li>有序树: 树中节点各子树之间的次序是重要的，不可以随意交换位置。</li>
<li>无序树: 树种节点各子树之间的次序是不重要的。可以随意交换位置。</li>
<li>森林: 0或多棵互不相交的树的集合。</li>
</ul>
</li>
<li>二叉树：最多有两棵子树的树被称为二叉树<ul>
<li>满二叉树: 二叉树中所有非叶子结点的度都是2，且叶子结点都在同一层次上</li>
<li>完全二叉树: 如果一个二叉树与满二叉树前m个节点的结构相同，这样的二叉树被称为完全二叉树</li>
<li>插入</li>
<li>删除</li>
<li>遍历：前序遍历、中序遍历、后序遍历</li>
<li>搜索</li>
</ul>
</li>
<li>动态查找树<ul>
<li><strong>二叉搜索树 BST</strong><ul>
<li>指一棵空树或者具有下列性质的二叉树：若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；任意节点的左、右子树也分别为二叉查找树；没有键值相等的节点。</li>
<li>二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低为 O(logn) 。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、多重集、关联数组等。</li>
</ul>
</li>
<li><strong>二叉平衡树 AVL</strong><ul>
<li>含有相同节点的二叉查找树可以有不同的形态，而二叉查找树的平均查找长度与树的深度有关，所以需要找出一个查找平均长度最小的一棵，那就是平衡二叉树</li>
<li>具有以下性质：要么是棵空树，要么其根节点左右子树的深度之差的绝对值不超过1；其左右子树也都是平衡二叉树；二叉树节点的平衡因子定义为该节点的左子树的深度减去右子树的深度。则AVL的所有节点的平衡因子只可能是-1,0,1。</li>
</ul>
</li>
<li><strong>红黑树</strong><ul>
<li>红黑树也是一种自平衡的二叉查找树，它在每个节点增加了一个存储位记录节点的颜色，可以是RED,也可以是BLACK;通过任意一条从根到叶子简单路径上颜色的约束，红黑树保证最长路径不超过最短路径的二倍，因而近似平衡。</li>
<li>特征：1、每个结点要么是红的要么是黑的。(红或黑)  2、根结点是黑的。(根黑)  3、每个叶结点(叶结点即指树尾端NIL指针或NULL结点)都是黑的。(叶黑)  4、如果一个结点是红的，那么它的两个儿子都是黑的。(红子黑) 5、对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。(路径下黑相同)</li>
<li>红黑树与AVL树的比较<br>  1.AVL树的时间复杂度虽然优于红黑树，但是对于现在的计算机，cpu太快，可以忽略性能差异<br>  2.红黑树的插入删除比AVL树更便于控制操作<br>  3.红黑树整体性能略优于AVL树(红黑树旋转情况少于AVL树)  <img src="https://pdai.tech/images/alg/alg-tree-14.png" width="400" height="300" alt=""></li>
<li>用法最广：Java ConcurrentHashMap &amp; TreeMap；C++ STL: map &amp; set；linux进程调度Completely Fair Scheduler,用红黑树管理进程控制块；epoll在内核中的实现，用红黑树管理事件块；nginx中，用红黑树管理timer等</li>
</ul>
</li>
<li>哈夫曼树：哈夫曼又称最优二叉树。是一种带权路径长度最短的二叉树，一般可以按下面步骤构建:        <img src="https://pdai.tech/images/alg/alg-tree-13.png" width="400" height="300" alt=""><ul>
<li>（1）将所有左，右子树都为空的作为根节点。（2）在森林中选出两棵根节点的权值最小的树作为一棵新树的左，右子树，置新树的附加根节点的权值为其左，右子树上根节点的权值之和。注意，左子树的权值应小于右子树的。（3）从森林中删除这两棵树，同时把新树加入到森林中。</li>
<li>（4）重复（2）（3）步骤，直到森林中只有一棵树为止，此树便是哈夫曼树。</li>
</ul>
</li>
</ul>
</li>
<li>多路查找树<ul>
<li><strong>B 树</strong>：是一种自平衡的树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一种自平衡的m阶树，与自平衡二叉查找树不同，B树适用于读写相对大的数据块的存储系统。<ul>
<li>根结点至少有两个子女。</li>
<li>每个中间节点都包含k-1个元素和k个孩子，其中 m&#x2F;2 &lt;&#x3D; k &lt;&#x3D; m</li>
<li>每一个叶子节点都包含k-1个元素，其中 m&#x2F;2 &lt;&#x3D; k &lt;&#x3D; m</li>
<li>所有的叶子结点都位于同一层。</li>
<li>每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。<br> B-Tree中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个3阶的B-Tree: <img src="https://pdai.tech/images/alg/alg-tree-15.png" width="600" height="300" alt=""></li>
</ul>
</li>
<li><strong>B+ 树</strong>：B+ 树是一种树数据结构，通常用于关系型数据库(如Mysql)和操作系统的文件系统中。<ul>
<li>B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。自底向上插入，与二叉树相反。</li>
<li>在B树基础上，为叶子结点增加链表指针(B树+叶子有序链表)，所有关键字都在叶子结点 中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中。</li>
<li>b+树的非叶子节点不保存数据，只保存子树的临界值(最大或者最小)，所以同样大小的节点，b+树相对于b树能够有更多的分支，使得这棵树更加矮胖，查询时做的IO操作次数也更少。<br>  将上一节中的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示:  <img src="https://pdai.tech/images/alg/alg-tree-16.png" width="600" height="300" alt=""></li>
</ul>
</li>
<li>B* 树</li>
<li>R 树：R树是用来做空间数据存储的树状数据结构。例如给地理位置，矩形和多边形这类多维数据建立索引。</li>
</ul>
</li>
</ol>
<h3 id="避免孤立的学习知识点，要关联学习。"><a href="#避免孤立的学习知识点，要关联学习。" class="headerlink" title="避免孤立的学习知识点，要关联学习。"></a>避免孤立的学习知识点，要关联学习。</h3><p>比如实际应用当中，我们经常使用的是查找和排序操作，这在我们的各种管理系统、数据库系统、操作系统等当中，十分常用，我们通过这个线索将知识点串联起来：<br><code>数组</code>的下标寻址十分迅速，但计算机的内存是有限的，故数组的长度也是有限的；而且无序数组的查找最坏情况需要遍历整个数组；后来人们提出了<code>二分查找</code>，要求数组的构造一定有序，二分法查找解决了普通数组查找复杂度过高的问题。任何一种数组无法解决的问题就是插入、删除操作比较复杂，因此，在一个增删查改比较频繁的数据结构中，数组不会被优先考虑<br><code>普通链表</code>由于它的结构特点被证明根本不适合进行查找<br><code>哈希表</code>是数组和链表的折中，同时它的设计依赖散列函数的设计，数组不能无限长、链表也不适合查找，所以也不适合大规模的查找 ??? ???<br><code>二叉查找树</code>因为可能退化成链表，同样不适合进行查找<br><code>AVL树</code>是为了解决可能退化成链表问题，但是AVL树的旋转过程非常麻烦，因此插入和删除很慢，也就是构建AVL树比较麻烦<br><code>红黑树</code>是平衡二叉树和AVL树的折中，是比较合适的。集合类中的Map、关联数组具有较高的查询效率，它们的底层实现就是红黑树。<br><code>多路查找树</code> 是大规模数据存储中，实现索引查询这样一个实际背景下，树节点存储的元素数量是有限的(如果元素数量非常多的话，查找就退化成节点内部的线性查找了)，这样导致二叉查找树结构由于树的深度过大而造成磁盘I&#x2F;O读写过于频繁，进而导致查询效率低下。<br><code>B树</code>与自平衡二叉查找树不同，B树适用于读写相对大的数据块的存储系统，例如磁盘。它的应用是文件系统及部分非关系型数据库索引。<br><code>B+树</code>在B树基础上，为叶子结点增加链表指针(B树+叶子有序链表)，所有关键字都在叶子结点 中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中。通常用于关系型数据库(如Mysql)和操作系统的文件系统中。<br><code>B* 树</code>是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针, 在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1&#x2F;2提高到2&#x2F;3。<br><code>R树</code>是用来做空间数据存储的树状数据结构。例如给地理位置，矩形和多边形这类多维数据建立索引。Trie树是自然语言处理中最常用的数据结构，很多字符串处理任务都会用到。<br><code>Trie树</code>本身是一种有限状态自动机，还有很多变体。什么模式匹配、正则表达式，都与这有关。与树类似，用于处理字符串相关的问题时非常高效,它可以实现快速检索，常用于字典中的单词查询，搜索引擎的自动补全甚至 IP 路由。下图展示了“top”, “thus”和“their”三个单词在前缀树中如何存储的：<br><strong>针对大量数据，如果在内存中作业优先考虑红黑树(map,set之类多为RB-tree实现)，如果在硬盘中作业优先考虑B系列树</strong></p>
<p>各树详解：<a target="_blank" rel="noopener" href="https://pdai.tech/md/algorithm/alg-basic-tree-search.html">https://pdai.tech/md/algorithm/alg-basic-tree-search.html</a></p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>在Java中，二叉树是一种常见的树形数据结构，每个节点最多有两个子节点，分别为左子节点和右子节点。二叉树的节点类似于一个结构体，包含了数据、左子节点和右子节点的引用。以下是一个简单的二叉树的实现示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123;   <span class="built_in">this</span>.val = val;    <span class="built_in">this</span>.left = <span class="literal">null</span>;    <span class="built_in">this</span>.right = <span class="literal">null</span>;   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode root;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BinaryTree</span><span class="params">()</span> &#123;    root = <span class="literal">null</span>;   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        root = insertRec(root, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">insertRec</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (val &lt; root.val) &#123;</span><br><span class="line">            root.left = insertRec(root.left, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root.val) &#123;</span><br><span class="line">            root.right = insertRec(root.right, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他操作（搜索节点、删除节点等）可以根据需要实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><ul>
<li>红黑树的特性<br>（1）每个节点或者是黑色，或者是红色。<br>（2）根节点是黑色。<br>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL 或NULL)的叶子节点！ ]<br>（4）如果一个节点是红色的，则它的子节点必须是黑色的。<br>（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</li>
<li>左旋<br>对 x 进行左旋，意味着，将“x 的右孩子”设为“x 的父亲节点”；即，将 x 变成了一个左节点(x成了为 z 的左孩子)！因此，左旋中的“左”，意味着“被旋转的节点将变成一个左节点”。 </li>
<li>右旋<br>对 x 进行右旋，意味着，将“x 的左孩子”设为“x 的父亲节点”；即，将 x 变成了一个右节点(x成了为 y 的右孩子)！因此，右旋中的“右”，意味着“被旋转的节点将变成一个右节点”。 </li>
<li>添加<br>第一步: 将红黑树当作一颗二叉查找树，将节点插入。<br>第二步：将插入的节点着色为”红色”。<br>根据被插入节点的父节点的情况，可以将”当节点 z 被着色为红色节点，并插入二叉树”划分为三种情况来处理。<br>① 情况说明：被插入的节点是根节点。处理方法：直接把此节点涂为黑色。<br>② 情况说明：被插入的节点的父节点是黑色。处理方法：什么也不需要做。节点被插入后，仍然是红黑树。<br>③ 情况说明：被插入的节点的父节点是红色。这种情况下，被插入节点是一定存在非空祖父节点的；进一步的讲，被插入节点也一定存在叔叔节点(即使叔叔节点为空，我们也视之为存在，空节点本身就是黑色节点)。理解这点之后，我们依据”叔叔节点的情况”，将这种情况进一步划分为 3种情况(Case)<br>，，，<br>第三步: 通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。 </li>
<li>删除<br>第一步：将红黑树当作一颗二叉查找树，将节点删除。这和”删除常规二叉查找树中删除节点的方法是一样的”。分 3 种情况：<br>① 被删除节点没有儿子，即为叶节点。那么，直接将该节点删除就 OK 了。<br>② 被删除节点只有一个儿子。那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置。<br>③ 被删除节点有两个儿子。那么，先找出它的后继节点；然后把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。<br>第二步：通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。 因为”第一步”中删除节点之后，可能会违背红黑树的特性。所以需要通过”旋转和重新着色”来修正该树，使之重新成为一棵红黑树。<br>选择重着色 3 种情况。<br>① 情况说明： x 是“红+黑”节点。处理方法：直接把 x 设为黑色，结束。此时红黑树性质全部恢复。<br>② 情况说明： x 是“黑+黑”节点，且 x 是根。处理方法：什么都不做，结束。此时红黑树性质全部恢复。<br>③ 情况说明： x 是“黑+黑”节点，且 x 不是根。处理方法：这种情况又可以划分为 4 种子情况。这 4 种子情况如下表所示：<br>，，，，</li>
</ul>
<h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>B-tree 又叫平衡多路查找树。一棵 m 阶的 B-tree (m 叉树)的特性如下（其中 ceil(x)是一个取上限的函数） ：</p>
<ol>
<li>树中每个结点至多有 m 个孩子；</li>
<li>除根结点和叶子结点外，其它每个结点至少有有 ceil(m &#x2F; 2)个孩子；</li>
<li>若根结点不是叶子结点，则至少有 2 个孩子（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）；</li>
<li>所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部结点或查询失败的结点，实际上这些结点不存在，指向这些结点的指针都为 null)；</li>
<li>每个非终端结点中包含有 n 个关键字信息： (n， P0， K1， P1， K2， P2， ……， Kn， Pn)。其中：<ul>
<li>Ki (i&#x3D;1…n)为关键字，且关键字按顺序排序 K(i-1)&lt; Ki。</li>
<li>Pi 为指向子树根的接点，且指针 P(i-1)指向子树种所有结点的关键字均小于 Ki，但都大于 K(i-1)。</li>
<li>关键字的个数 n 必须满足： ceil(m &#x2F; 2)-1 &lt;&#x3D; n &lt;&#x3D; m-1。<img src="https://leo710aka.github.io/bk/b-tree.png" width="650" height="300" alt=""></li>
</ul>
</li>
</ol>
<p>一棵 m 阶的 B+tree 和 m 阶的 B-tree 的差异在于：</p>
<ol>
<li>有 n 棵子树的结点中含有 n 个关键字； (B-tree 是 n 棵子树有 n-1 个关键字)</li>
<li>所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (B-tree 的叶子节点并没有包括全部需要查找的信息)</li>
<li>所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。(B-tree 的非终节点也包含需要查找的有效信息)<img src="https://leo710aka.github.io/bk/b+tree.png" width="650" height="300" alt=""></li>
</ol>
<h3 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h3><p>位图的原理就是用一个 bit 来标识一个数字是否存在，采用一个 bit 来存储一个数据，所以这样可以大大的节省空间。 bitmap 是很常用的数据结构， 比如用于 Bloom Filter 中；用于无重复整数的排序等等。 bitmap 通常基于数组来实现，数组中每个元素可以看成是一系列二进制数，所有元素组成更大的二进制集合。</p>
<hr>

<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>图(Graph)是由顶点和连接顶点的边构成的离散结构。图是最灵活的数据结构之一，很多问题都可以使用图模型进行建模求解。<br>理解：图基础，图的遍历，最小生成树(Prim &amp; Kruskal)，最短路径(Dijkstra &amp; Frolyd)，拓扑排序(Topological sort)，AOE &amp; 关键路径等。</p>
<ul>
<li>图的定义：图是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为: G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。和线性表，树的差异:<ul>
<li>线性表中我们把数据元素叫元素，树中将数据元素叫结点，在图中数据元素，我们则称之为顶点(Vertex)。</li>
<li>线性表可以没有元素，称为空表；树中可以没有节点，称为空树；但是，在图中不允许没有顶点(有穷非空性)。</li>
<li>线性表中的各元素是线性关系，树中的各元素是层次关系，而图中各顶点的关系是用边来表示(边集可以为空)</li>
</ul>
</li>
<li>相关术语<ul>
<li>顶点的度：顶点Vi的度(Degree)是指在图中与Vi相关联的边的条数。对于有向图来说，有入度(In-degree)和出度(Out-degree)之分，有向图顶点的度等于该顶点的入度和出度之和。</li>
<li>邻接：若无向图中的两个顶点V1和V2存在一条边(V1,V2)，则称顶点V1和V2邻接(Adjacent)；若有向图中存在一条边&lt;V3,V2&gt;，则称顶点V3与顶点V2邻接，且是V3邻接到V2或V2邻接直V3；</li>
<li>路径：在无向图中，若从顶点Vi出发有一组边可到达顶点Vj，则称该顶点序列为从顶点Vi到顶点Vj的路径(Path)。</li>
<li>连通：若从Vi到Vj有路径可通，则称顶点Vi和顶点Vj是连通(Connected)的。</li>
<li>权(Weight)：有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做权(Weight)。</li>
</ul>
</li>
<li>类型<ul>
<li>无向图：如果图中任意两个顶点之间的边都是无向边(没有方向的边)，则称该图为无向图。边使用小括号“()”表示;如 (V1,V2);</li>
<li>有向图：如果图中任意两个顶点之间的边都是有向边(有方向的边)，则称该图为有向图。边使用尖括号“&lt;&gt;”表示;如 &lt;V1,V2&gt;</li>
<li>无向完全图: 在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。(有(n*(n-1))&#x2F;2条边)</li>
<li>有向完全图: 在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。(含有n个顶点的有向完全图有n*(n-1)条边)</li>
</ul>
</li>
<li>图的存储结构<ul>
<li>邻接矩阵表示法：用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组(称为邻接矩阵)存储图中的边或弧的信息。  <img src="https://pdai.tech/images/alg/alg-graph-store-1.png" width="400" height="300" alt="">
  <img src="https://pdai.tech/images/alg/alg-graph-store-2.png" width="400" height="300" alt="">
  不足: 由于存在n个顶点的图需要n*n个数组元素进行存储，当图为稀疏图时，使用邻接矩阵存储方法将会出现大量0元素，这会造成极大的空间浪费。这时，可以考虑使用邻接表表示法来存储图中的数据</li>
<li>邻接表表示法：邻接表由表头节点和表节点两部分组成，图中每个顶点均对应一个存储在数组中的表头节点。如果这个表头节点所对应的顶点存在邻接节点，则把邻接节点依次存放于表头节点所指向的单向链表中。  <img src="https://pdai.tech/images/alg/alg-graph-store-3.jpg" width="400" height="300" alt="">
  <img src="https://pdai.tech/images/alg/alg-graph-store-4.jpg" width="400" height="300" alt=""></li>
</ul>
</li>
</ul>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>深度优先搜索: 假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。显然，深度优先搜索是一个递归的过程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vexnode *g[], <span class="type">int</span> v1)</span> </span>&#123;</span><br><span class="line">    stack&lt;vexnode*&gt; stk;</span><br><span class="line">    stk.<span class="built_in">push</span>(g[v1]);</span><br><span class="line">    g[v1]-&gt;visited = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        vexnode *cur = stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; cur-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (vexnode *neighbor : cur-&gt;neighbors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!neighbor-&gt;visited) &#123;</span><br><span class="line">                neighbor-&gt;visited = <span class="literal">true</span>;</span><br><span class="line">                stk.<span class="built_in">push</span>(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>广度优先搜索算法(Breadth First Search)，又称为”宽度优先搜索”或”横向优先搜索”。<br>它的思想是: 从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。<br>换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1,2…的顶点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vexnode *g[], <span class="type">int</span> v1)</span> </span>&#123;</span><br><span class="line">    queue&lt;vexnode*&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(g[v1]);</span><br><span class="line">    g[v1]-&gt;visited = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        vexnode *cur = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; cur-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (vexnode *neighbor : cur-&gt;neighbors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!neighbor-&gt;visited) &#123;</span><br><span class="line">                neighbor-&gt;visited = <span class="literal">true</span>;</span><br><span class="line">                que.<span class="built_in">push</span>(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DFS &amp; BFS 实现 <a target="_blank" rel="noopener" href="https://pdai.tech/md/algorithm/alg-basic-graph-bfs-dfs.html">https://pdai.tech/md/algorithm/alg-basic-graph-bfs-dfs.html</a></p>
<hr>

<h1 id="ACM模式Java输入"><a href="#ACM模式Java输入" class="headerlink" title="ACM模式Java输入"></a>ACM模式Java输入</h1><p>核心代码模式下不用考虑输入输出的问题，只需要根据所给函数框架写中间逻辑代码。但是在ACM模式下要，即函数的输入是从控制台键入的几行数据，而输出是直接将结果打印到控制台。<br>nextInt()：直至读取到空格或回车之后结束本次的int值；<br>next()：直至读取到空格或回车之后结束本次的String值，不可读取回车；<br>nextLine()：直至读取到换行符（回车）之后结束本次读取的String，可读取回车（空值）</p>
<h4 id="单个输入"><a href="#单个输入" class="headerlink" title="单个输入"></a>单个输入</h4><p>有的函数输入很简单，就是一个数，或者一个字符串，或者一行数中间用空格隔开，这种输入很简单，处理方法如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 读取输入的一个整型</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="comment">// 如果输入的是double类型</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> sc.nextDouble();</span><br><span class="line">        <span class="comment">// 如果输入的是一个字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sc.next(); </span><br><span class="line">        <span class="comment">// 读取的是一整行</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">l</span> <span class="operator">=</span> sc.nextLine(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="一行输入"><a href="#一行输入" class="headerlink" title="一行输入"></a>一行输入</h4><p>如果输入的是一行数据，中间用空格隔开，比如输入的是2 3 4</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> sc.nextInt();  <span class="comment">// 接收第1个数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> sc.nextInt();	<span class="comment">// 接收第2个数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> sc.nextInt();	<span class="comment">// 接收第3个数</span></span><br></pre></td></tr></table></figure>
<p>有时候输入不是空格分隔，而是逗号分割的，比如输入的是1,2,3,4,5，并假设我们需要用数组接收，可以这么操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="comment">//以字符串形式作为输入</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.next();</span><br><span class="line"><span class="comment">//通过分隔符将其转为字符串数组</span></span><br><span class="line">String[] arr = str.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"><span class="comment">//初始化一个整数数组</span></span><br><span class="line"><span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line"><span class="comment">//给整数数组赋值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">    nums[j] = Integer.parseInt(arr[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多行输入"><a href="#多行输入" class="headerlink" title="多行输入"></a>多行输入</h4><p>一共输入两行，第一行表示第二行有多少个数，比如第一行为4，第二行为0 2 3 4。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="comment">// 第一行的数表示第二行有多少个数，即数组的长度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    nums[i] = sc.nextInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="持续输入"><a href="#持续输入" class="headerlink" title="持续输入"></a>持续输入</h4><p>如果题目中没有明说一次给几个输入，为了保险可以直接无脑用 while(sc.hasNext()) {} 包括起来，一直等待输入，除非终止程序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">    <span class="comment">// 多个输入都需要经过相同的逻辑判断然后在输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Acm模式输出"><a href="#Acm模式输出" class="headerlink" title="Acm模式输出"></a>Acm模式输出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.print();   <span class="comment">// 用于打印不带换行符的内容到控制台</span></span><br><span class="line">System.out.println(); <span class="comment">// 用于打印带换行符的内容到控制台，打印完后会换行</span></span><br><span class="line">System.out.format();  <span class="comment">// 用于格式化输出，可以通过格式化字符串来指定输出的格式</span></span><br><span class="line">System.out.printf();  <span class="comment">// 也用于格式化输出，但是使用更简单，格式化字符串以及对应的参数放在一起即可</span></span><br><span class="line">System.out.println(<span class="string">&quot;Hello&quot;</span> + <span class="string">&quot;, &quot;</span> + <span class="string">&quot;world&quot;</span> + <span class="string">&quot;!&quot;</span>); <span class="comment">// 字符串连接可以直接用 + 号：&quot;Hello, world!&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 规格化的输出：</span></span><br><span class="line"><span class="comment">// `#` 表示如果该位置有数字则显示，否则不显示；`0` 表示该位置无论是否有数字都显示，如果没有数字则显示 `0`；</span></span><br><span class="line"><span class="type">DecimalFormat</span> <span class="variable">fd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;#.00#&quot;</span>);</span><br><span class="line"><span class="type">DecimalFormat</span> <span class="variable">gd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;0.000&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;x =&quot;</span> + fd.format(x)); <span class="comment">// `.00#` 表示保留两位小数并四舍五入；x = 12.3456， fd.format(x) 输出的结果是 12.35</span></span><br><span class="line">System.out.println(<span class="string">&quot;x =&quot;</span> + gd.format(x)); <span class="comment">// `0.000` 表示保留三位小数四舍五入； x = 12.3456， gd.format(x) 输出的结果是 12.346</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二进制字符串输出：</span></span><br><span class="line"><span class="type">String</span> <span class="variable">binaryString</span> <span class="operator">=</span> Integer.toBinaryString(<span class="number">42</span>); <span class="comment">// 将整数转换为二进制字符串</span></span><br><span class="line">System.out.println(<span class="string">&quot;Binary representation of &quot;</span> + number + <span class="string">&quot; is: &quot;</span> + binaryString);</span><br></pre></td></tr></table></figure>

<h3 id="日期处理"><a href="#日期处理" class="headerlink" title="日期处理"></a>日期处理</h3><p>SimpleDateFormat 用于日期格式化和解析，可以将日期对象格式化为指定的字符串，也可以将特定格式的字符串解析为日期对象。</p>
<ol>
<li>格式化日期为字符串：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">formattedDate</span> <span class="operator">=</span> sdf.format(now);</span><br></pre></td></tr></table></figure></li>
<li>解析字符串为日期：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">dateString</span> <span class="operator">=</span> <span class="string">&quot;2024-03-02 15:30:00&quot;</span>;</span><br><span class="line"><span class="type">Date</span> <span class="variable">parsedDate</span> <span class="operator">=</span> sdf.parse(dateString);</span><br><span class="line">System.out.println(<span class="string">&quot;Parsed Date: &quot;</span> + parsedDate);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><p>我们读取 <code>a.txt</code> 和 <code>b.txt</code> 中的内容，并将其写入到 <code>c.txt</code> 中。然后，我们统计总行数并在第一行写入总行数。<br>请注意，在写入总行数之前需要先将文件关闭并重新打开以实现在文件的开头插入内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileCopyWithLineCount</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">reader1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">reader2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;b.txt&quot;</span>));</span><br><span class="line">            <span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;c.txt&quot;</span>))</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 读取第一个文件并写入到输出文件</span></span><br><span class="line">            String line;</span><br><span class="line">            <span class="type">int</span> <span class="variable">totalCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((line = reader1.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                writer.write(line);</span><br><span class="line">                writer.newLine();</span><br><span class="line">                totalCount++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取第二个文件并写入到输出文件</span></span><br><span class="line">            <span class="keyword">while</span> ((line = reader2.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                writer.write(line);</span><br><span class="line">                writer.newLine();</span><br><span class="line">                totalCount++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在第一行写入总行数</span></span><br><span class="line">            writer.flush();</span><br><span class="line">            writer.close();</span><br><span class="line">            <span class="type">BufferedWriter</span> <span class="variable">writer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;c.txt&quot;</span>, <span class="literal">true</span>));</span><br><span class="line">            writer2.write(<span class="string">&quot;Total Lines: &quot;</span> + totalCount);</span><br><span class="line">            writer2.newLine();</span><br><span class="line">            writer2.flush();</span><br><span class="line">            writer2.close();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;内容已成功从 &quot;</span> + <span class="string">&quot;a.txt&quot;</span> + <span class="string">&quot; 和 &quot;</span> + <span class="string">&quot;b.txt&quot;</span> + <span class="string">&quot; 读取并写入 &quot;</span> + <span class="string">&quot;c.txt&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;发生IO异常: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<hr>

<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>Java 中的位运算是对二进制数据进行操作的一种方式，常用的位运算符有以下几种：</p>
<ol>
<li><p><strong>按位与（&amp;）</strong>：两个位都为 1 时，结果为 1；否则为 0。例如：<code>1010 &amp; 1100 = 1000</code>。</p>
</li>
<li><p><strong>按位或（|）</strong>：两个位中至少有一个为 1 时，结果为 1；否则为 0。例如：<code>1010 | 1100 = 1110</code>。</p>
</li>
<li><p><strong>按位异或（^）</strong>：两个位相同为 0，不同为 1。例如：<code>1010 ^ 1100 = 0110</code>。</p>
</li>
<li><p><strong>按位取反（~）</strong>：对一个二进制数的每个位取反，0 变为 1，1 变为 0。例如：<code>~1010 = 0101</code>。</p>
</li>
<li><p><strong>左移（&lt;&lt;）</strong>：将一个数的所有位向左移动指定的位数，右侧空出的位用 0 填充。例如：<code>1010 &lt;&lt; 2 = 101000</code>。</p>
</li>
<li><p><strong>右移（&gt;&gt;）</strong>：将一个数的所有位向右移动指定的位数，左侧空出的位用符号位填充（正数用 0，负数用 1）。例如：<code>1010 &gt;&gt; 2 = 10</code>。</p>
</li>
<li><p><strong>无符号右移（&gt;&gt;&gt;）</strong>：将一个数的所有位向右移动指定的位数，左侧空出的位用 0 填充。例如：<code>1010 &gt;&gt;&gt; 2 = 10</code>。</p>
</li>
</ol>
<hr>

<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><ul>
<li>时间复杂度是一种用来衡量算法运行时间与输入规模之间关系的概念。它不是用来精确测量程序运行时间的，而是描述在输入规模变化时，算法运行时间的增长趋势。</li>
<li>大O表示上界，当用它作为算法的最坏情况运行时间的上界，就是对任意数据输入的运行时间的上界。<br>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!)</li>
</ul>
<h2 id="♥常见排序算法知识体系详解♥"><a href="#♥常见排序算法知识体系详解♥" class="headerlink" title="♥常见排序算法知识体系详解♥"></a>♥常见排序算法知识体系详解♥</h2><p>A. 重点理解几个排序之间的对比，时间和空间复杂度，以及应用。PS：越简单越要提高认知效率，做到战略上藐视战术上重视。<br>B. 具体分析各种排序及其复杂度，查漏补缺；在综合复杂度及稳定性情况下，通常希尔, 快排和 归并需要重点掌握。<br>稳定性：指相等元素的相对顺序在排序前后是否保持不变。稳定性在某些应用场景中很重要，例如在对相同优先级的任务进行排序时，保持原始顺序可确保任务的处理顺序不被打乱。<br><img src="https://pdai.tech/images/alg/alg-sort-overview-1.png"><br><a target="_blank" rel="noopener" href="https://leo710aka.github.io/2020/09/09/5%20%E7%B4%A2%E5%BC%95_%E6%8E%92%E5%BA%8F_/">https://leo710aka.github.io/2020/09/09/5%20%E7%B4%A2%E5%BC%95_%E6%8E%92%E5%BA%8F_/</a></p>
<ul>
<li><p>冒泡排序(Bubble Sort)<br>它是一种较简单的排序算法。它会遍历若干次要排序的数列，每次遍历时，它都会从前往后依次的比较相邻两个数的大小；如果前者比后者大，则交换它们的位置。这样，一次遍历之后，最大的元素就在数列的末尾！采用相同的方法再次遍历时，第二大的元素就被排列在最大元素之前。重复此操作，直到整个数列都有序为止</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort1</span><span class="params">(<span class="type">int</span> [] a, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)&#123;<span class="comment">//表示 n 次排序过程。</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;n-i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j-<span class="number">1</span>] &gt; a[j])&#123;<span class="comment">//前面的数字大于后面的数字就交换</span></span><br><span class="line">                <span class="comment">//交换 a[j-1]和 a[j]</span></span><br><span class="line">                <span class="type">int</span> temp;</span><br><span class="line">                temp = a[j-<span class="number">1</span>];</span><br><span class="line">                a[j-<span class="number">1</span>] = a[j];</span><br><span class="line">                a[j]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入排序(Insertion Sort)<br>基本思想是: 把n个待排序的元素看成为一个有序表和一个无序表。开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次可完成排序过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> arr[])</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 插入的数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">insertVal</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        <span class="comment">// 被插入的位置(准备和前一个数比较)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果插入的数比被插入的数小</span></span><br><span class="line">        <span class="keyword">while</span>(index &gt;= <span class="number">0</span> &amp;&amp; insertVal &lt; arr[index]) &#123;</span><br><span class="line">            <span class="comment">// 将把 arr[index] 向后移动</span></span><br><span class="line">            arr[index+<span class="number">1</span>] = arr[index];</span><br><span class="line">            <span class="comment">// 让 index 向前移动</span></span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把插入的数放入合适位置</span></span><br><span class="line">        arr[index+<span class="number">1</span>] = insertVal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>选择排序(Selection sort)<br>基本思想是: 首先在未排序的数列中找到最小(or最大)元素，然后将其存放到数列的起始位置；接着，再从剩余未排序的元素中继续寻找最小(or最大)元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectionSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123; </span><br><span class="line">		<span class="type">int</span> minIndex = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;len; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(a[j] &lt; a[minIndex]) &#123;</span><br><span class="line">				minIndex = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">swap</span>(a[i], a[minIndex]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>快速排序(Quick Sort)<br>采用分治的思想，将一个数组分成两个子数组，然后递归地对子数组进行排序。它选择一个元素作为”pivot”（基准），并将数组中小于基准的元素放在基准的左边，大于基准的元素放在基准的右边，然后对左右子数组进行递归排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt;= high) <span class="keyword">return</span>; <span class="comment">// 边界条件判断</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> low;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> high;</span><br><span class="line">    <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> nums[low];</span><br><span class="line">    <span class="keyword">while</span> (end &gt; start) &#123;</span><br><span class="line">        <span class="keyword">while</span> (end &gt; start &amp;&amp; nums[end] &gt;= key) &#123;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end &gt; start) &#123;</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (end &gt; start &amp;&amp; nums[start] &lt;= key) &#123;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end &gt; start) &#123;</span><br><span class="line">            nums[end] = nums[start];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[start] = key; <span class="comment">// 基准值放回合适位置</span></span><br><span class="line">    quickSort(nums, low, start - <span class="number">1</span>); <span class="comment">// 左边序列递归排序</span></span><br><span class="line">    quickSort(nums, start + <span class="number">1</span>, high); <span class="comment">// 右边序列递归排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>希尔排序(Shell Sort)：实质上是一种分组插入方法。<br>它的基本思想是: 对于n个待排序的数列，取一个小于n的整数gap(gap被称为步长)将待排序元素分成若干个组子序列，所有距离为gap的倍数的记录放在同一个组中；然后，对各组内的元素进行直接插入排序。 这一趟排序完成之后，每一个组的元素都是有序的。然后减小gap的值，并重复执行上述的分组和排序。重复这样的操作，当gap&#x3D;1时，整个数列就是有序的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dk</span> <span class="operator">=</span> a.length/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>( dk &gt;= <span class="number">1</span> )&#123;</span><br><span class="line">        ShellInsertSort(a, dk);</span><br><span class="line">        dk = dk/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ShellInsertSort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> dk)</span> &#123;</span><br><span class="line">    <span class="comment">//类似插入排序，只是插入排序增量是 1，这里增量是 dk,把 1 换成 dk 就可以了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=dk;i&lt;a.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;a[i-dk])&#123;</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="type">int</span> x=a[i];<span class="comment">//x 为待插入元素</span></span><br><span class="line">            a[i]=a[i-dk];</span><br><span class="line">            <span class="keyword">for</span>(j=i-dk; j&gt;=<span class="number">0</span> &amp;&amp; x&lt;a[j];j=j-dk)&#123;</span><br><span class="line">                <span class="comment">//通过循环，逐个后移一位找到要插入的位置。</span></span><br><span class="line">                a[j+dk]=a[j];</span><br><span class="line">            &#125;</span><br><span class="line">            a[j+dk]=x;<span class="comment">//插入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="堆排序-Heap-Sort"><a href="#堆排序-Heap-Sort" class="headerlink" title="堆排序(Heap Sort)"></a>堆排序(Heap Sort)</h3><ul>
<li><p>堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。<br>它具有 O(n log n) 的时间复杂度，并且是原地排序算法（不需要额外的空间）。堆排序分为两个阶段：建堆和排序。</p>
<ol>
<li><strong>建堆（Heapify）</strong>：<ul>
<li>将待排序数组视为完全二叉树，从最后一个非叶子节点开始，依次向上进行调整，使得每个节点都满足堆的性质（最大堆或最小堆）。</li>
<li>对于最大堆，父节点的值大于或等于子节点的值；对于最小堆，父节点的值小于或等于子节点的值。</li>
<li>建堆过程可以通过自上而下的调整（向下调整）或自下而上的调整（向上调整）来实现。</li>
</ul>
</li>
<li><strong>排序</strong>：<ul>
<li>将堆顶元素（根节点）与最后一个元素交换，并将最后一个元素移出堆（视为已排序部分）。</li>
<li>对剩余的元素重新进行堆调整，使得剩余元素重新构成堆。</li>
<li>重复上述步骤，直到所有元素都被移出堆，完成排序。</li>
</ul>
</li>
</ol>
</li>
<li><p>下面是堆排序的详细步骤：</p>
<ol>
<li>将待排序数组构建成一个最大堆（或最小堆），即建堆过程。可以选择自上而下的调整（向下调整）或自下而上的调整（向上调整）来实现。</li>
<li>从最后一个非叶子节点开始，依次向前对每个节点进行堆调整，使得当前节点及其子树满足堆的性质。</li>
<li>交换堆顶元素（根节点）和最后一个元素，并将最后一个元素移出堆（视为已排序部分）。</li>
<li>对剩余的元素重新进行堆调整，使得剩余元素重新构成堆。</li>
<li>重复步骤3和步骤4，直到所有元素都被移出堆，完成排序。<img src="https://github.com/leo710aka/bk/blob/main/HeapSort.png?raw=true" width="500" height="200" alt=""></li>
</ol>
</li>
<li> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AdjustDwon</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> size, <span class="type">int</span> parent)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (child &lt; size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child + <span class="number">1</span> &lt; size &amp;&amp; a[child + <span class="number">1</span>] &gt; a[child]) &#123;</span><br><span class="line">            ++child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[child] &gt; a[parent]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[child], a[parent]);</span><br><span class="line">            parent = child;</span><br><span class="line">            child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = (n - <span class="number">1</span> - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">AdjustDwon</span>(a, n, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> end = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (end &gt; <span class="number">0</span>)	&#123;</span><br><span class="line">        <span class="built_in">swap</span>(a[<span class="number">0</span>], a[end]);</span><br><span class="line">        <span class="built_in">AdjustDwon</span>(a, end, <span class="number">0</span>);</span><br><span class="line">        --end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>桶排序：原理很简单，将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bucketSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">        min = Math.min(min, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建桶</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">bucketNum</span> <span class="operator">=</span> (max - min) / arr.length + <span class="number">1</span>;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(bucketNum);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bucketNum; i++)&#123;</span><br><span class="line">        bucketArr.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将每个元素放入桶</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (arr[i] - min) / (arr.length);</span><br><span class="line">        bucketArr.get(num).add(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对每个桶进行排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bucketArr.size(); i++)&#123;</span><br><span class="line">        Collections.sort(bucketArr.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>归并排序算法：采用分治的思想将一个大问题分割成多个小问题来解决。<br>具体来说，归并排序的过程包括分割、排序和合并三个步骤。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n1 = mid - left + <span class="number">1</span>, n2 = right - mid;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftArr</span><span class="params">(n1)</span>, <span class="title">rightArr</span><span class="params">(n2)</span></span>;                        <span class="comment">// 创建临时数组来存储左右两部分的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; i++)  leftArr[i] = arr[left + i];     <span class="comment">// 将数据复制到临时数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n2; i++)  rightArr[i] = arr[mid + <span class="number">1</span> + i];    </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = left;                                   <span class="comment">// 合并两个临时数组</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftArr[i] &lt;= rightArr[j]) arr[k++] = leftArr[i++];  </span><br><span class="line">        <span class="keyword">else</span> arr[k++] = rightArr[j++]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1)  arr[k++] = leftArr[i++];                      <span class="comment">// 处理剩余元素</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; n2)  arr[k++] = rightArr[j++];  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;           <span class="comment">// 归并排序主函数</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">mergeSort</span>(arr, left, mid);                                <span class="comment">// 分割左右两部分</span></span><br><span class="line">        <span class="built_in">mergeSort</span>(arr, mid + <span class="number">1</span>, right); </span><br><span class="line">        <span class="built_in">merge</span>(arr, left, mid, right);                             <span class="comment">// 合并已排序的两部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基数排序<br>基本思想是: 将整数按位数切割成不同的数字，然后按每个位数分别比较。具体做法是: 将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">radixSort</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[]=&#123;<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>,<span class="number">13</span>,<span class="number">27</span>,<span class="number">49</span>,<span class="number">78</span>,<span class="number">34</span>,<span class="number">12</span>,<span class="number">64</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">62</span>,<span class="number">99</span>,<span class="number">98</span>,<span class="number">54</span>,<span class="number">101</span>,<span class="number">56</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">15</span>,<span class="number">35</span>,<span class="number">2</span> <span class="number">5</span>,<span class="number">53</span>,<span class="number">51</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">radixSort</span><span class="params">()</span>&#123;</span><br><span class="line">        sort(a);</span><br><span class="line">        <span class="keyword">for</span>(inti=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            System.out.println(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] array)</span>&#123;</span><br><span class="line">        <span class="comment">//首先确定排序的趟数;</span></span><br><span class="line">        <span class="type">int</span> max=array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(inti=<span class="number">1</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]&gt;max)&#123;</span><br><span class="line">                max=array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> time=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//判断位数;</span></span><br><span class="line">        <span class="keyword">while</span>(max&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            max/=<span class="number">10</span>;</span><br><span class="line">            time++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//建立 10 个队列;</span></span><br><span class="line">        List&lt;ArrayList&gt; queue=newArrayList&lt;ArrayList&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt;queue1=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            queue.add(queue1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行 time 次分配和收集;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;time;i++)&#123;</span><br><span class="line">            <span class="comment">//分配数组元素;</span></span><br><span class="line">            <span class="keyword">for</span>(intj=<span class="number">0</span>;j&lt;array.length;j++)&#123;</span><br><span class="line">                <span class="comment">//得到数字的第 time+1 位数;</span></span><br><span class="line">                <span class="type">int</span> x=array[j]%(<span class="type">int</span>)Math.pow(<span class="number">10</span>,i+<span class="number">1</span>)/(<span class="type">int</span>)Math.pow(<span class="number">10</span>, i);</span><br><span class="line">                ArrayList&lt;Integer&gt;queue2=queue.get(x);</span><br><span class="line">                queue2.add(array[j]);</span><br><span class="line">                queue.set(x, queue2);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> count=<span class="number">0</span>;<span class="comment">//元素计数器;</span></span><br><span class="line">                <span class="comment">//收集队列元素;</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">10</span>;k++)&#123;</span><br><span class="line">                <span class="keyword">while</span>(queue.get(k).size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    ArrayList&lt;Integer&gt;queue3=queue.get(k);</span><br><span class="line">                    array[count]=queue3.get(<span class="number">0</span>);</span><br><span class="line">                    queue3.remove(<span class="number">0</span>);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/02/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" data-id="cm2rjvvgn000ab4v5gb2idx6q" data-title="Java 数据结构" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Java基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/01/Java%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2021-09-01T03:49:42.000Z" itemprop="datePublished">2021-09-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/01/Java%E5%9F%BA%E7%A1%80/">Java 基础</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol>
<li>Java 是一种高级编程语言和计算平台。它最初由Sun（后被Oracle收购）于1995年发布，旨在实现“一次编写，到处运行”的理念。</li>
<li><strong>Java SE（标准版）</strong>：是 Java 平台的基本版本，也是最基本的 Java 编程平台。提供了 Java 编程语言的核心功能，包括基本的语言结构、标准库、输入&#x2F;输出、多线程支持等。Java SE 适用于通用的桌面应用程序、命令行工具、小型服务、移动应用程序等各种领域。</li>
<li><strong>Java EE（企业版）</strong>：是在 Java SE 的基础上构建的，专门用于开发和运行企业级应用程序的平台。它提供了一组扩展和 API，用于构建大型、分布式、可伸缩、高性能的应用程序，如企业级 Web 应用、电子商务系统等。Java EE 包括了 Servlet、JSP、EJB、JPA等各种技术和规范，以支持不同类型的企业级应用。</li>
</ol>
<div style="display: flex; align-items: center;">
  <div style="flex: 0 0 30%;">
    <img src="https://www.runoob.com/wp-content/uploads/2013/12/java.jpg" alt="" style="max-width: 100%;">
  </div>
  <div style="flex: 1; padding-left: 10px;">
    <p><em>Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的高级程序设计语言。Java 可运行于多个平台，如 Windows, Mac OS 及其他多种 UNIX 版本的系统。<br>移动操作系统 Android 大部分的代码采用 Java 编程语言编程。</em></p>
  </div>
</div>

<h2 id="面向对象-三大特性"><a href="#面向对象-三大特性" class="headerlink" title="面向对象 三大特性"></a>面向对象 三大特性</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承实现了 IS-A 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 向上转型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向上继承是面向对象编程中的一个关键概念，它通过创建一个统一的接口和通用的父类，支持多态性，减少代码重复，提高</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();  <span class="comment">// 代码的可维护性和可扩展性。使代码更灵活、通用和易于理解，有助于构建更高质量的程序</span></span><br></pre></td></tr></table></figure>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>编译时多态主要指方法的重载（一个类中的多个同名方法）<br>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定（父,子类之间）；有三个条件:继承、覆盖(重写)、向上转型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;  System.out.println(<span class="string">&quot;aoaoao..&quot;</span>); &#125;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;  System.out.println(<span class="string">&quot;旺旺旺&quot;</span>);    &#125;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;  System.out.println(<span class="string">&quot;喵喵喵&quot;</span>);    &#125;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Music</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Animal&gt; animals = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        animals.add(<span class="keyword">new</span> <span class="title class_">Cat</span>());  </span><br><span class="line">        animals.add(<span class="keyword">new</span> <span class="title class_">Dog</span>());    <span class="comment">// animals.add(new ..()).....</span></span><br><span class="line">        <span class="keyword">for</span>(Animal animal : animals) &#123;            </span><br><span class="line">            animal.play();        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>数据类型定义了数据的种类和取值范围，以及对这些数据执行的操作。在Java中，数据类型主要分为两类：</p>
<h3 id="1-基本数据类型"><a href="#1-基本数据类型" class="headerlink" title="1. 基本数据类型"></a>1. 基本数据类型</h3><ul>
<li><strong>基本数据类型</strong>：这些数据类型是Java语言的一部分，用于表示基本的数据值。有以下几种：<br>整数类型：byte、short、int、long; 浮点数类型：float、double; 字符类型：char; 布尔类型：boolean<br><code>Integer.MAX_VALUE</code>常量表示int类型的最大值，值为2147483647。<table>
<thead>
<tr>
<th>类型</th>
<th>byte</th>
<th>short</th>
<th>int</th>
<th>long</th>
<th>float</th>
<th>double</th>
<th>char</th>
<th>boolean</th>
</tr>
</thead>
<tbody><tr>
<td>大小(Byte)</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>8</td>
<td>4</td>
<td>8</td>
<td>2</td>
<td>1</td>
</tr>
</tbody></table>
</li>
<li><strong>包装类型</strong>：包装是指将基本数据类型包装在对象中的过程。这是因为 Java 是面向对象的编程语言，需要将基本数据类型封装在对象中，从而在面向对象的上下文中使用它们，在处理集合、泛型、反射等Java编程中的许多场景中非常有用。例如，你可以将一个 int 存储在一个 List&lt;Integer&gt; 中，而不是 List&lt;int&gt;<br>类型对应：byte - Byte, short - Short, int - Integer, long - Long, float - Float, double - Double, char - Character, boolean - Boolean<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">2</span>;  <span class="comment">// 装箱，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x;      <span class="comment">// 拆箱</span></span><br></pre></td></tr></table></figure></li>
<li><strong>类型转换</strong>（char、String、int和double之间）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int 转 double: int i = 123;</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> (<span class="type">double</span>)i; <span class="comment">// 或者直接 d = i;</span></span><br><span class="line"><span class="comment">// double 转 int: double d = 123.45;</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>)d; <span class="comment">// 使用类型转换，但请注意这会截断小数部分。结果是 123</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int 转 char：int i = 97;</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>)i;    <span class="comment">// 通过 ASCII值转换。97 对应的字符是 &#x27;a&#x27;</span></span><br><span class="line">c = (<span class="type">char</span>)(c + <span class="number">32</span>);  <span class="comment">// 大小写字母差值32，与cpp中的一样</span></span><br><span class="line"><span class="comment">// char 转 int：char c = &#x27;a&#x27;;</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>)c; <span class="comment">// 通过ASCII值转换。&#x27;a&#x27; 的ASCII值是 97</span></span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="string">&#x27;9&#x27;</span> - <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int 转 String</span></span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">strNumber1</span> <span class="operator">=</span> String.valueOf(number);  </span><br><span class="line"><span class="type">String</span> <span class="variable">strNumber2</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> + number;            </span><br><span class="line"><span class="type">String</span> <span class="variable">strNumber3</span> <span class="operator">=</span> Integer.toString(number); </span><br><span class="line"><span class="comment">// String 转 int</span></span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> Integer.parseInt(str); <span class="comment">// 默认十进制</span></span><br><span class="line"><span class="type">int</span> <span class="variable">numBinary</span> <span class="operator">=</span> Integer.parseInt(binaryStr, <span class="number">2</span>); <span class="comment">// 二进制</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String 转 double: String doubleStr = &quot;123.45&quot;;</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> Double.parseDouble(doubleStr);</span><br><span class="line"><span class="comment">// double 转 String: double d = 123.45;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.valueOf(d); <span class="comment">// 或者 &quot;str = d +;&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// char 转 String：char c = &#x27;a&#x27;;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Character.toString(c);</span><br><span class="line">str += c; <span class="comment">// 将 `char` 直接与字符串连接（`char` 会自动被转换成 `String`）。</span></span><br><span class="line"><span class="comment">// String 转 char：String str = &quot;hello&quot;;</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> Character.charAt(str, <span class="number">0</span>); <span class="comment">// 获取字符串的第一个字符</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-引用数据类型"><a href="#2-引用数据类型" class="headerlink" title="2. 引用数据类型"></a>2. 引用数据类型</h3><p>引用数据类型用于引用对象，而不是直接存储数据值。引用数据类型包括类、接口、数组、枚举等。</p>
<ul>
<li>引用：引用是一个变量，用于存储对象的内存地址。它指向对象在堆内存中的位置，而不是对象本身。通过引用，可以访问和操作对象的数据和方法。</li>
<li>引用类型：引用类型是Java中的数据类型之一，用于声明引用变量。Java的引用类型包括类、接口、数组、枚举和注解。引用类型的变量可以用来引用相应类型的对象。</li>
<li><strong>堆内存：在Java中，所有的对象都存储在堆内存中。引用变量存储的是对象在堆内存中的地址。当创建一个新对象时，它被分配到堆内存中，然后引用变量被赋予该对象的地址。</strong></li>
<li><strong>栈内存：Java中的引用变量本身存储在栈内存中。栈内存用于存储局部变量，包括引用变量。引用变量在栈上分配内存，但它们指向的对象存储在堆内存中。</strong></li>
<li>强引用：强引用是最常见的引用类型。当一个对象被强引用变量引用时，它不会被垃圾回收器回收，直到引用变量不再引用该对象。如果没有任何强引用指向一个对象，该对象就会成为垃圾，可以被垃圾回收。</li>
<li>软引用：软引用用于描述一些还有用但并非必需的对象。当内存不足时，垃圾回收器可能会回收被软引用引用的对象，释放内存。这可以防止内存溢出，但不会保证垃圾回收器什么时候回收这些对象。</li>
<li>弱引用：弱引用用于描述非必需对象的引用。弱引用的对象会在垃圾回收器下次运行时被回收，不论内存是否足够。这使得弱引用适用于临时对象和缓存。</li>
<li>虚引用：虚引用是最弱的引用类型。虚引用的对象没有直接访问的权限，它主要用于跟踪对象是否被回收。虚引用必须和引用队列（ReferenceQueue）一起使用，以便在对象被回收时收到通知。</li>
</ul>
<h3 id="主要引用类型"><a href="#主要引用类型" class="headerlink" title="主要引用类型:"></a><strong>主要引用类型:</strong></h3><ul>
<li>类引用类型：类引用类型用于引用类的实例，即对象。这是Java中最常见的引用类型。例如，如果有一个类 <code>Person</code>，您可以创建 <code>Person</code> 类型的引用来引用不同的 <code>Person</code> 对象：<code>Person person = new Person();</code></li>
<li>接口引用类型：接口引用类型用于引用实现了特定接口的对象。例如，如果有一个接口 <code>Drawable</code>，您可以创建 <code>Drawable</code> 类型的引用来引用实现了 <code>Drawable</code> 接口的对象：<code>Drawable drawable = new Circle();</code></li>
<li>数组引用类型：数组引用类型用于引用数组对象。数组可以包含基本数据类型或引用类型的元素。例如，<code>int[] numbers</code> 是一个引用类型，用于引用整数数组。</li>
<li>枚举引用类型</li>
<li>泛型引用类型</li>
<li>父类引用类型：父类引用类型用于引用子类对象。这可以用于实现多态。例如，如果有一个父类 <code>Animal</code> 和一个子类 <code>Dog</code>，您可以创建 <code>Animal</code> 类型的引用来引用 <code>Dog</code> 对象：<code>Animal animal = new Dog();</code></li>
</ul>
<h3 id="Java中的引用不是直接的内存地址，而是对实际对象的间接引用。这使得Java程序员不需要关心内存管理，因为Java虚拟机（JVM）会自动管理对象的创建和销毁。"><a href="#Java中的引用不是直接的内存地址，而是对实际对象的间接引用。这使得Java程序员不需要关心内存管理，因为Java虚拟机（JVM）会自动管理对象的创建和销毁。" class="headerlink" title="Java中的引用不是直接的内存地址，而是对实际对象的间接引用。这使得Java程序员不需要关心内存管理，因为Java虚拟机（JVM）会自动管理对象的创建和销毁。"></a><code>Java中的引用</code>不是直接的内存地址，而是对实际对象的间接引用。这使得Java程序员不需要关心内存管理，因为Java虚拟机（JVM）会自动管理对象的创建和销毁。</h3><p>与C++中的指针不同。Java中的引用是一种高级抽象，它隐藏了对象的底层内存地址和操作，使得程序员不需要关心内存管理。<br>Java中的引用本质上是一个抽象的句柄（handle），它不直接指向对象的内存地址，而是指向Java虚拟机（JVM）内部的数据结构，该数据结构包含了对象的信息以及对象在堆内存中的位置。这种抽象层级使Java更安全，因为程序员无法直接操纵内存地址，从而避免了许多常见的内存错误，如指针溢出和内存泄漏。</p>
<h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>Java中的枚举类是一种特殊的类，用于定义一组常量。枚举类可以包含字段、方法和构造函数。</p>
<ol>
<li>定义简单的枚举类：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个简单的枚举类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Day</span> &#123;</span><br><span class="line">    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用枚举常量</span></span><br><span class="line">        <span class="type">Day</span> <span class="variable">today</span> <span class="operator">=</span> Day.MONDAY;</span><br><span class="line">        System.out.println(<span class="string">&quot;Today is: &quot;</span> + today);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>枚举类包含字段和方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义包含字段和方法的枚举类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    RED(<span class="string">&quot;#FF0000&quot;</span>), GREEN(<span class="string">&quot;#00FF00&quot;</span>), BLUE(<span class="string">&quot;#0000FF&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> String hexCode;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Color</span><span class="params">(String hexCode)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hexCode = hexCode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取颜色的十六进制代码</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getHexCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hexCode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumWithFieldsAndMethods</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用枚举常量和方法</span></span><br><span class="line">        <span class="type">Color</span> <span class="variable">color</span> <span class="operator">=</span> Color.BLUE;</span><br><span class="line">        System.out.println(<span class="string">&quot;Color is &quot;</span> + color + <span class="string">&quot; with hex code &quot;</span> + color.getHexCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Java中的枚举类可以包含抽象方法。在这种情况下，每个枚举常量都必须实现抽象方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义带有抽象方法的枚举类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    ADD &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">apply</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUBTRACT &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">apply</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x - y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 定义抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">apply</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumWithAbstractMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用带有抽象方法的枚举</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Operation.ADD.apply(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Result: &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String 被声明为 final，因此它不可被继承。内部使用 char 数组存储数据，该数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String类 不可变。</p>
<ul>
<li>String Pool ：如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。</li>
<li>String 不可变，StringBuffer 和 StringBuilder 可变。<br>String 不可变，因此是线程安全的，StringBuilder 不是线程安全的，StringBuffer 是线程安全的，内部使用 synchronized 进行同步<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2);           <span class="comment">// false; s1 和 s2 采用 new String() 的方式新建了两个不同对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1.intern();</span><br><span class="line">System.out.println(s1.intern() == s3);  <span class="comment">// true; s3 是通过 s1.intern() 方法 首先把 s1 引用的对象放到 String Pool(字符串常量池)中，然后返回这个对象引用。因此 s3 和 s1 引用的是同一个字符串常量池的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">System.out.println(s4 == s5);           <span class="comment">// true; 采用 &quot;bbb&quot; 这种使用双引号的形式创建字符串实例，会自动地将新建的对象放入 String Pool 中</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>

<h1 id="Java-容器"><a href="#Java-容器" class="headerlink" title="Java 容器"></a>Java 容器</h1><ul>
<li><strong>容器</strong>：Java 容器就是可以容纳其他 Java 对象的对象。<em>Java Collections Framework(JCF)</em> 为开发者提供了通用的容器，始于JDK 1.2<ul>
<li><strong>优点</strong>: 降低编程难度，提高程序性能，提高API间的互操作性，降低设计和实现相关API的难度，增加程序的重用性</li>
<li>对于基本类型(int, long, float, double等)，需要将其<strong>包装</strong>成对象类型后(Integer, Long, Float, Double等)才能放到容器里。很多时候拆包装和解包装能够自动完成。这虽然会导致额外的性能和空间开销，但简化了设计和编程。</li>
<li><strong>容器</strong>接口 主要包括 <strong>Collection(容器类) 和 Map</strong> 两种，<br>  Collection 存储着对象的集合，而 Map 存储着键值对(两个对象)的映射表。</li>
</ul>
</li>
</ul>
<p><img src="https://pdai.tech/images/java_collections_overview.png"></p>
<h2 id="1-Collection"><a href="#1-Collection" class="headerlink" title="1. Collection"></a>1. Collection</h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>主要功能是保证存储的集合不会重复，至于集体是有序还是无序的，需要看具体的实现类，比如 TreeSet 有序，HashSet 无序</p>
<ul>
<li>TreeSet： 基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</li>
<li>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</li>
<li>LinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。</li>
</ul>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul>
<li>ArrayList：基于动态数组实现，支持随机访问。</li>
<li>Vector：和 ArrayList 类似，但它是线程安全的。</li>
<li>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</li>
</ul>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>队列，有序，严格遵守先进先出。</p>
<ul>
<li>LinkedList：可以用它来实现双向队列。实现了 Queue 接口。</li>
<li>PriorityQueue：基于堆结构实现，可以用它来实现优先队列？？？内部是基于数组构建的，用法就是你自定义一个 comparator ，自己定义对比规则，这个队列就是按这个规则来排列出队的优先级。</li>
</ul>
<h2 id="2-Map"><a href="#2-Map" class="headerlink" title="2. Map"></a>2. Map</h2><p>存储的是键值对，也就是给对象（value）搞了一个 key，这样通过 key 可以找到那个 value。</p>
<ul>
<li>TreeMap：基于红黑树实现。有序。</li>
<li>HashMap：基于哈希表实现。</li>
<li>HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</li>
<li>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用(LRU)顺序。</li>
</ul>
<h2 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h2><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add(E e)     <span class="comment">// 向列表末尾添加元素</span></span><br><span class="line">get(<span class="type">int</span> index)     <span class="comment">// 获取指定索引位置的元素</span></span><br><span class="line">size()     <span class="comment">// 获取列表的大小</span></span><br><span class="line">remove(<span class="type">int</span> index)     <span class="comment">// 移除指定索引位置的元素</span></span><br><span class="line">contains(Object o)     <span class="comment">// 判断是否包含指定元素</span></span><br></pre></td></tr></table></figure>

<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add(E e)     <span class="comment">// 在列表末尾添加元素</span></span><br><span class="line">addFirst(E e)   </span><br><span class="line">addLast(E e)     <span class="comment">// 在列表开头或末尾添加元素</span></span><br><span class="line">get(<span class="type">int</span> index)     <span class="comment">// 获取指定索引位置的元素</span></span><br><span class="line">remove(<span class="type">int</span> index)    <span class="comment">// 移除指定索引位置的元素</span></span><br><span class="line">size()     <span class="comment">// 获取列表的大小</span></span><br></pre></td></tr></table></figure>


<h2 id="Stack-Queue"><a href="#Stack-Queue" class="headerlink" title="Stack &amp; Queue"></a>Stack &amp; Queue</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push(E e)     <span class="comment">// 将元素压入栈顶</span></span><br><span class="line">pop()     <span class="comment">// 移除栈顶元素</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">offer(E e)     <span class="comment">// 将元素添加到队列尾部</span></span><br><span class="line">poll()     <span class="comment">// 获取并移除队列头部元素</span></span><br></pre></td></tr></table></figure>


<h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add(E e)     <span class="comment">//  向队列中添加元素</span></span><br><span class="line">remove()     <span class="comment">// 移除队列头部的元素</span></span><br><span class="line">peek()     <span class="comment">// 获取但不移除队列头部的元素</span></span><br></pre></td></tr></table></figure>

<h2 id="HashSet-HashMap"><a href="#HashSet-HashMap" class="headerlink" title="HashSet &amp; HashMap"></a>HashSet &amp; HashMap</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add(E e)     <span class="comment">// 向集合中添加元素</span></span><br><span class="line">contains(Object o)     <span class="comment">// 判断集合是否包含指定元素</span></span><br><span class="line">remove(Object o)     <span class="comment">// 移除集合中指定的元素</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">put(K key, V value)     <span class="comment">// 将键值对存入 Map</span></span><br><span class="line">get(Object key)     <span class="comment">// 获取指定键的值</span></span><br><span class="line">containsKey(Object key)     <span class="comment">// 判断 Map 是否包含指定键</span></span><br><span class="line">remove(Object key)     <span class="comment">// 移除 Map 中指定键的键值对</span></span><br></pre></td></tr></table></figure>

<h2 id="LinkedHashSet-Map"><a href="#LinkedHashSet-Map" class="headerlink" title="LinkedHashSet&amp;Map"></a>LinkedHashSet&amp;Map</h2><h2 id="TreeSet-TreeMap"><a href="#TreeSet-TreeMap" class="headerlink" title="TreeSet &amp; TreeMap"></a>TreeSet &amp; TreeMap</h2><p>TreeSet<br>add(E e): 向集合中添加元素<br>contains(Object o): 判断集合是否包含指定元素<br>remove(Object o): 移除集合中指定的元素<br>TreeMap<br>put(K key, V value): 将键值对存入 Map<br>get(Object key): 获取指定键的值<br>containsKey(Object key): 判断 Map 是否包含指定键<br>remove(Object key): 移除 Map 中指定键的键值对</p>
<h2 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h2><hr>


<h1 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h1><p>在Java中，数据的存储方式涉及到内存的不同区域，主要包括堆内存和栈内存。</p>
<ol>
<li><strong>栈内存（Stack Memory）</strong>：<ul>
<li>存储特点：栈内存用于存储局部变量（方法内部定义的变量）和方法调用的执行上下文（包括方法的参数、返回地址等信息）。每个线程都有自己的栈内存，用于管理方法调用和局部变量的生命周期。</li>
<li>生命周期：局部变量的生命周期与方法的执行周期相关联。当方法被调用时，会在栈内存中为局部变量分配内存，当方法执行完毕时，栈内存会自动释放局部变量的内存。</li>
<li>线程安全：栈内存是线程私有的，因此它是线程安全的。不同线程的栈内存互相独立，不会发生竞态条件。</li>
</ul>
</li>
<li><strong>堆内存（Heap Memory）</strong>：<ul>
<li>存储特点：堆内存用于存储对象和数组等引用数据类型。是所有线程共享的内存区域，用于管理动态分配的对象的生命周期。</li>
<li>生命周期：对象在堆内存中的生命周期不受方法调用的限制。对象在被创建时分配内存，在不再被引用时会被垃圾回收器自动回收。</li>
<li>线程安全：由于堆内存是共享的，需要特别注意多线程访问的同步问题。Java提供了一些机制来确保堆内存中的数据安全，如 synchronized关键字和 java.util.concurrent 包中的工具类。</li>
</ul>
</li>
<li><strong>数据存储示例</strong>：<ul>
<li>当创建一个对象时，对象的引用存储在栈内存中，而对象的实际数据存储在堆内存中。例如，Person person &#x3D; new Person(); <ol>
<li>在堆内存中，会为Person对象分配内存空间，这个对象包含了Person类中定义的所有成员变量（属性）。例如，如果Person类有一个名为name的成员变量，那么堆内存中的Person对象将包含一个用于存储name属性值的内存位置。堆内存中的对象是独立的，每个new Person()创建一个新的对象，其数据在堆内存中不会重叠。</li>
<li>在栈内存中，会创建一个名为person的引用变量，这个引用变量存储了指向堆内存中Person对象的地址。也就是说，栈内存中的person变量实际上存储了对堆内存中Person对象的引用。当你访问person时，实际上是通过栈内存中的引用找到堆内存中的对象，然后可以操作对象的属性和方法。</li>
</ol>
</li>
<li>局部变量（例如方法中的局部变量）的值和引用都存储在栈内存中。</li>
<li>数组的引用存储在栈内存中，而数组的元素（对象引用或基本数据类型）存储在堆内存中。</li>
<li>静态变量（<code>static</code>关键字修饰的变量）存储在方法区（在JVM规范中称为永久代）。</li>
</ul>
</li>
<li>缓存池<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line">System.out.println(x == y);    <span class="comment">// false; new Integer() 每次都会新建一个对象</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">z</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">k</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">System.out.println(z == k);    <span class="comment">// true; valueOf()会使用缓存池中的对象，多次调用会取得同一个对象的引用</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line">System.out.println(m == n);    <span class="comment">// true; 编译器会在缓冲池范围内的基本类型自动装箱过程调用 valueOf() </span></span><br><span class="line"><span class="comment">// 因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>在Java中，方法参数的传递方式是<strong>按值传递</strong>，而不是引用传递。这意味着当你将参数传递给方法时，实际上是将参数的值传递给了方法，而不是参数本身。这包括基本数据类型和对象引用。<br><strong>1、基本数据类型：</strong> 作为参数传递的是该数据的副本。任何在方法内部对参数值的修改都不会影响到原始数据。<br><strong>2、对象引用：</strong> 对象引用也是按值传递的，但需要理解的是对象引用指的是对象在内存中的地址（间接引用，非直接地址）。当你将一个对象作为参数传递给方法时，传递的是对象引用的副本，而不是对象本身。这意味着在方法内部可以修改对象的状态，但不能改变对象引用指向的内存地址。</p>
<h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><ul>
<li>“2.5” 字面量属于 double 类型，不能直接将 2.5 直接赋值给 float 变量，因为Java 不能隐式执行向下转型，这会使得精度降低。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">2.5f</span>;  <span class="comment">// 错误写法：float f = 2.5;  </span></span><br></pre></td></tr></table></figure></li>
<li>字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地 下转型 。但是使用 +&#x3D; 运算符可以执行隐式类型转换。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 不能 s1 = s1 + 1;</span></span><br><span class="line">s1 += <span class="number">1</span>;       <span class="comment">// 相当于 s1 = (short) (s1 + 1);</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="有-无符号数，原-反-补码"><a href="#有-无符号数，原-反-补码" class="headerlink" title="有&#x2F;无符号数，原&#x2F;反&#x2F;补码"></a>有&#x2F;无符号数，原&#x2F;反&#x2F;补码</h3><p>在 Java 中，所有的整数类型都是有符号的。Java中并没有内置的无符号整数类型；如果真的需要，可以使用大整数类 <code>BigInteger</code>。<br>无符号整数通常用于表示大范围正整数值，以及位运算和处理原始数据。它们可以扩展表示的范围，因为不需要一位来表示符号。<br><strong>原码</strong>是最简单的表示形式，其中最高位表示符号（0正数，1负数），其余位表示数值的大小。例如，+3原码为0011，-3原码为1011。<br><strong>反码</strong>是对原码的符号位以外的位取反得到的结果。正数的反码与其原码相同，负数的反码是其原码除符号位外取反。<br><strong>补码</strong>是计算机中最常用的表示方式。补码的计算方法是对反码加1。正数的补码与其原码相同，负数的补码是其反码加1。<br><strong>在Java中，整数类型（如byte、short、int、long）使用补码来表示有符号整数</strong>。这种表示方式使得负数的加法和减法运算可以与正数的运算使用同一套算法来执行，简化了计算机中的运算。</p>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><ul>
<li>在 Java 中，位运算是操作二进制位的一种操作，它们可以用来执行诸如位移、与、或、非等操作。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>, b = <span class="number">3</span>;  <span class="comment">// 二进制表示：0101, 0011</span></span><br><span class="line"><span class="type">int</span> <span class="variable">andResult</span> <span class="operator">=</span> a &amp; b;  <span class="comment">// 0101 &amp; 0011 = 0001，结果为 1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">orResult</span> <span class="operator">=</span> a | b;   <span class="comment">// 0101 | 0011 = 0111，结果为 7</span></span><br><span class="line"><span class="type">int</span> <span class="variable">xorResult</span> <span class="operator">=</span> a ^ b;  <span class="comment">// 0101 ^ 0011 = 0110，结果为 6</span></span><br><span class="line"><span class="type">int</span> <span class="variable">complementA</span> <span class="operator">=</span> ~a;   <span class="comment">// ~0101 = 1010（补码表示），结果为 -6（-6的八位补码就是1111 1010）</span></span><br><span class="line"><span class="type">int</span> <span class="variable">leftShift</span> <span class="operator">=</span> a &lt;&lt; <span class="number">1</span>;            <span class="comment">// 0101 左移 1 位 = 1010，结果为 10</span></span><br><span class="line"><span class="type">int</span> <span class="variable">rightShift</span> <span class="operator">=</span> a &gt;&gt; <span class="number">1</span>;           <span class="comment">// 0101 右移 1 位 = 0010，结果为 2（使用符号位填充空位）</span></span><br><span class="line"><span class="type">int</span> <span class="variable">unsignedRightShift</span> <span class="operator">=</span> a &gt;&gt;&gt; <span class="number">1</span>;  <span class="comment">// 0101 无符号右移 1 位 = 0010，结果为 2（使用 0 填充空位）</span></span><br></pre></td></tr></table></figure></li>
<li>在 Java 中，十六进制表示使用前缀 <code>0x</code> 或者 <code>0X</code> 来标识一个十六进制数。<br>使用位运算符时：Java 内部会将这些十六进制数转换为对应的二进制形式，然后执行位运算操作，最后转换回十六进制的结果。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">hex1</span> <span class="operator">=</span> <span class="number">0xA</span>, hex2 = <span class="number">0x7</span>;          <span class="comment">// 十六进制数 A 对应十进制数 10, 十六进制数 7 对应十进制数 7</span></span><br><span class="line"><span class="type">int</span> <span class="variable">andResult</span> <span class="operator">=</span> hex1 &amp; hex2;         <span class="comment">// 十六进制数 A &amp; 7 = 1010 &amp; 0111 = 0010，结果为 2</span></span><br><span class="line"><span class="type">int</span> <span class="variable">complementHex1</span> <span class="operator">=</span> ~hex1;          <span class="comment">// ~1010 = 0101（补码表示），结果为 -11</span></span><br><span class="line"><span class="type">int</span> <span class="variable">rightShift</span> <span class="operator">=</span> hex1 &gt;&gt; <span class="number">1</span>;          <span class="comment">// 十六进制数 A 右移 1 位 = 1010 右移 1 位 = 0101，结果为 5</span></span><br><span class="line"><span class="type">int</span> <span class="variable">unsignedRightShift</span> <span class="operator">=</span> hex1 &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// A 无符号右移 1 位 = 1010 无符号右移 1 位 = 0101，结果为 5</span></span><br></pre></td></tr></table></figure></li>
<li><code>n &amp; (n−1)</code>，把 n 的二进制位中的最低位的 1 变为 0。</li>
<li><strong>颠倒</strong>给定的 32 位无符号整数 n 的二进制位<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span> &amp;&amp; n != <span class="number">0</span>; i++) &#123;</span><br><span class="line">    ans = ans | (n &amp; <span class="number">1</span>) &lt;&lt; (<span class="number">31</span> - i);</span><br><span class="line">    n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>

<h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><ol>
<li><strong>类（Class）：</strong> 类是对象的模板，它定义了对象的属性（成员变量）和行为（方法）。类是一种抽象的概念，描述了一类事物的共同特征。在Java中，类是一种引用数据类型。</li>
<li><strong>对象（Object）：</strong> 对象是类的实例，是具体的、实际存在的数据。每个对象都有自己的状态（成员变量的值）和行为（方法的调用)</li>
</ol>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul>
<li><strong>创建对象实例：</strong> 使用关键字 <code>new</code> 可以创建一个类的对象。例如：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">myObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br></pre></td></tr></table></figure></li>
<li><strong>通过反射：</strong> 使用 Java 的反射机制可以在运行时获取类的信息，创建对象实例。例如：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">myObject</span> <span class="operator">=</span> (MyClass) clazz.newInstance();</span><br></pre></td></tr></table></figure></li>
<li><strong>通过工厂方法：</strong> 有时候，对象的创建可能通过工厂方法，例如静态方法等来实现。</li>
<li>通过new创建<strong>实例对象</strong>demo，放在堆内存上；然后再main方法的栈帧中存放一个局部变量，存放了demo对象在堆上的地址，即建立起一个<strong>引用</strong>关系。将局部变量置null后，引用就不存在了，堆上的实例对象demo就可以回收了。<img src="https://github.com/leo710aka/bk/blob/main/java.png?raw=true" width="700" height="300" alt=""></li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一旦对象被创建，可以通过其引用调用其属性和方法</span></span><br><span class="line">myObject.setSomeProperty(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">propertyValue</span> <span class="operator">=</span> myObject.getSomeProperty();</span><br></pre></td></tr></table></figure>

<h3 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h3><ol>
<li><p><strong>对象的回收：</strong> Java虚拟机通过垃圾回收器（Garbage Collector）来自动回收不再被引用的对象。垃圾回收器会定期检查程序中的对象，识别哪些对象没有被任何引用指向，然后释放它们占用的内存。这个过程是自动的，开发者无需手动管理大部分对象的内存。<br>在某些情况下，可以通过手动设置对象引用为<code>null</code>来提示垃圾回收器回收对象。但这通常不是必要的，因为现代的垃圾回收器在大多数情况下能够很好地管理内存。<br>对象的生命周期从创建开始，直到没有任何引用指向它时结束。垃圾回收器负责在对象不再被引用时将其销毁。</p>
</li>
<li><p><strong>类的回收：</strong> 在Java中，类的回收通常不是显式的操作。类加载和卸载是由类加载器（ClassLoader）来管理的。当一个类不再被任何对象引用，并且ClassLoader不再需要这个类时，该类可能会被卸载。在标准的Java应用程序中，类的卸载通常不是很常见，因为大多数类在整个应用程序的生命周期内都是可见的。<br>需要注意的是，类的卸载是Java虚拟机实现的一个可选特性，不是所有的Java虚拟机都支持类的卸载。类的卸载通常发生在特定的环境中，比如一些动态生成和卸载类的场景。<br>总体而言，Java虚拟机通过垃圾回收器自动管理对象的内存，而类的加载和卸载通常由类加载器来处理。这种自动化的内存管理减轻了开发者的负担，使得Java程序更容易编写和维护。</p>
</li>
</ol>
<h1 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h1><h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><p>Java 中有三个访问权限修饰符: private、protected 以及 public。可以对类或类中的成员(字段以及方法)加上访问修饰符，如果不加访问修饰符，表示包级可见（<code>default</code>，介于private和protected之间）。<br><code>private</code>：私有访问修饰符。被 private 修饰的成员（字段、方法、内部类等）仅对定义它们的类可见。这意味着这些成员只能在同一个类内部访问，对于类的外部（其他类）是不可见的。<br><code>protected</code>：受保护的访问修饰符。被 protected 修饰的成员对于定义它们的类、同一包内的其他类以及子类可见。在不同包中的类无法访问受保护成员。<br><code>public</code>：公共访问修饰符。被 public 修饰的成员对于所有类都是可见的，无论是同一包内还是不同包中的类，都可以访问 public 成员。</p>
<h3 id="extend-与-implement"><a href="#extend-与-implement" class="headerlink" title="extend 与 implement"></a>extend 与 implement</h3><p><strong><code>extend</code>（扩展）</strong>：使用于类之间的关系。用于创建类的子类（子类继承父类）。子类可以继承父类的属性和方法。 一个类只能<code>extend</code>一个类，即Java是单继承的，但是可以通过接口实现来弥补这一不足。<br><strong><code>implement</code>（实现）</strong>：使用于接口与类之间的关系。 用于让类实现一个或多个接口，<code>implement</code>多个接口，实现多继承的效果。 <strong>类实现接口时，需要提供接口中定义的所有方法的具体实现。</strong></p>
<h3 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h3><p>抽象类和抽象方法都使用 abstract 关键字进行声明。抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。<br>抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。<br><strong>接口是抽象类的延伸</strong>，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。接口的成员(字段 + 方法)默认都是 public 的，并且不允许定义为 private 或者 protected。接口的字段默认都是 static 和 final 的。</p>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><ul>
<li>访问父类的构造函数: 可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。</li>
<li>访问父类的成员: 如果子类重写了父类的中某个方法的实现，可以通过使用 super 关键字来引用父类的方法实现。</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperExample</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SuperExample</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;                <span class="built_in">this</span>.x = x;     <span class="built_in">this</span>.y = y;     &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;                  System.out.println(<span class="string">&quot;SuperExample.func()&quot;</span>);       &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperExtendExample</span> <span class="keyword">extends</span> <span class="title class_">SuperExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> z;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SuperExtendExample</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;   <span class="built_in">super</span>(x, y);    <span class="built_in">this</span>.z = z;     &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;  <span class="built_in">super</span>.func();  System.out.println(<span class="string">&quot;SuperExtendExample.func()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">SuperExample</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SuperExtendExample</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">e.func();  <span class="comment">// 结果：SuperExample.func() SuperExtendExample.func()</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="重载与重写"><a href="#重载与重写" class="headerlink" title="重载与重写"></a>重载与重写</h3><ol>
<li>重载(Overload)存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。应该注意的是，返回值不同，其它都相同不算是重载。</li>
<li>重写(Override)存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。为了满足里式替换原则，重写有以下两个限制:子类方法的访问权限必须大于等于父类方法；子类方法的返回类型必须是父类方法返回类型或为其子类型。使用 @Override 注解，可以让编译器帮忙检查是否满足上面的两个限制条件。</li>
</ol>
<hr>

<h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><p>Java标准库包含多个类和函数，提供了许多基本的工具和功能，包括但不限于：<br>1、<code>java.lang</code> - 包含Java的基础类，例如<code>String</code>、<code>Object</code>、<code>System</code>等。这个包是默认导入的，不需要手动引入。<br>2、<code>java.util</code> - 提供集合框架、日期时间工具、随机数生成器等。<br>3、<code>java.io</code> - 包含用于进行输入和输出的类和接口，例如<code>File</code>、<code>InputStream</code>、<code>OutputStream</code>等。<br>4、<code>java.net</code> - 提供了网络相关的类，比如<code>URL</code>、<code>URLConnection</code>等。<br>5、<code>java.math</code> - 包含用于数学计算的类，例如<code>BigInteger</code>、<code>BigDecimal</code>等。<br>6、<code>java.nio</code> - 提供了新的I&#x2F;O类，支持非阻塞I&#x2F;O、内存映射文件等。<br>7、<code>java.util.concurrent</code> - 包含用于并发编程的实用工具和框架。<br>8、<code>java.awt</code> 和 <code>javax.swing</code> - 提供了GUI开发相关的类。<br>大部分情况下，这些库中的类和函数默认可用，无需手动引入。然而，有一些更特定或较为不常用的类可能需要显式地引入相应的包。</p>
<h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 保存两位小数；import java.text.DecimalFormat;（text在标准库中，通常不需要手动引入）</span></span><br><span class="line"><span class="type">double</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">123.45678</span>;</span><br><span class="line"><span class="type">DecimalFormat</span> <span class="variable">decimalFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;#.##&quot;</span>); <span class="comment">// 创建 DecimalFormat 对象并指定格式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">formattedNumber</span> <span class="operator">=</span> decimalFormat.format(number);   <span class="comment">// 将浮点数格式化为指定格式的字符串</span></span><br><span class="line"><span class="comment">// 2. 比大小：方法 java.lang.Math 中；小 Math.min()</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Math.max(<span class="number">647</span>, <span class="number">582</span>);</span><br><span class="line"><span class="comment">// 3. 随机数：生成范围介于 0（包括）和指定边界（不包括）之间的随机整数</span></span><br><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();                       <span class="comment">// 创建 Random 对象</span></span><br><span class="line"><span class="type">int</span> <span class="variable">randomNumber</span> <span class="operator">=</span> random.nextInt();                <span class="comment">// 生成整数范围在 int 类型的取值范围内</span></span><br><span class="line"><span class="type">int</span> <span class="variable">randomInRange</span> <span class="operator">=</span> random.nextInt(<span class="number">10</span> - <span class="number">5</span> + <span class="number">1</span>) + <span class="number">5</span>; <span class="comment">// 生成整数范围 5 - 10</span></span><br><span class="line"><span class="type">double</span> <span class="variable">randomDouble</span> <span class="operator">=</span> random.nextDouble();          <span class="comment">// 生成范围在 [0, 1) 之间的随机小数</span></span><br><span class="line"><span class="comment">// 4. 二进制，十六进制</span></span><br><span class="line"><span class="type">String</span> <span class="variable">binaryString</span> <span class="operator">=</span> Integer.toBinaryString(<span class="number">10</span>);      <span class="comment">// 整数表示为二进制字符串：1010</span></span><br><span class="line"><span class="type">String</span> <span class="variable">hexString</span> <span class="operator">=</span> Integer.toHexString(<span class="number">20</span>);            <span class="comment">// 整数表示为十六进制字符串：14</span></span><br><span class="line"><span class="type">int</span> <span class="variable">decimalNumber</span> <span class="operator">=</span> Integer.parseInt(binaryString, <span class="number">2</span>); <span class="comment">// 二进制字符串转整数：10</span></span><br><span class="line"><span class="type">int</span> <span class="variable">decimalNumber</span> <span class="operator">=</span> Integer.parseInt(hexString, <span class="number">16</span>);   <span class="comment">// 十六进制字符串转整数：20</span></span><br></pre></td></tr></table></figure>

<h2 id="Object-通用方法"><a href="#Object-通用方法" class="headerlink" title="Object 通用方法"></a>Object 通用方法</h2><p>在Java中，<code>Object</code>是所有类的基类。它是Java类继承层次结构的根，因此每个Java类都直接或间接地继承自<code>Object</code>类。<code>Object</code>类位于<code>java.lang</code>包中，这意味着它不需要显式导入就可以在Java程序中使用。</p>
<ul>
<li><code>java.lang</code>包是java语言的核心，提供基础类，包括基本Object类、Class类、String类、基本类型的包装类、基本的数学类等。</li>
<li><code>Object</code>类定义了一些基本的方法，这些方法可以被所有的Java对象继承和使用。其中一些重要的方法包括： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()     <span class="comment">// 返回对象的运行时类（`Class`对象）。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>                <span class="comment">// 返回对象的哈希码值。它通常与`equals`方法一起使用，以便在使用哈希表等数据结构时能够快速查找对象。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>           <span class="comment">// 用于比较两个对象是否相等。默认情况下，它比较的是对象的内存地址，但可以在子类中重写以实现自定义的相等性比较。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException    <span class="comment">// 用于创建对象的浅拷贝。需要注意的是，为了使对象可克隆，子类需要实现`Cloneable`接口并重写`clone`方法。</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>                    <span class="comment">// 返回对象的字符串表示。默认下，它返回一个由类名和对象的哈希码组成的字符串，但可以在子类中重写以提供更有意义的字符串表示。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>           <span class="comment">// 用于多线程同步的方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException   <span class="comment">// 使线程等待直到被通知。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;&#125;     <span class="comment">// 在对象被垃圾回收之前调用的方法。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><p>equals() 与 &#x3D;&#x3D; 对于基本类型，&#x3D;&#x3D; 判断两个值是否相等，基本类型没有 equals() 方法。<br>对于引用类型，&#x3D;&#x3D; 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line">System.out.println(x == y);      <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><p>返回对象的哈希码。默认实现是基于对象的内存地址生成哈希码。<br>在实际应用中，一般需要在类中重写该方法，以便相等的对象具有相同的哈希码，以提高哈希表等集合的性能。</p>
<h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><ol>
<li>cloneable：clone() 是 Object 的 protected 方法而非 public，一个类不显式去重写，其它类就不能直接调用该类实例的 clone()。</li>
<li>浅拷贝：拷贝对象和原始对象的引用类型引用同一个对象。</li>
<li>深拷贝：拷贝对象和原始对象的引用类型引用不同对象。</li>
<li>clone() 的替代方案：使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</li>
</ol>
<hr>

<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul>
<li>Throwable 可以用来表示任何可以作为异常抛出的类，分为两种: <strong>Error</strong> 和 <strong>Exception</strong>。<br>  其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种:<ul>
<li>受检异常 : 需要用 try…catch… 语句捕获并进行处理，并且可以从异常中恢复；</li>
<li>非受检异常 : 是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复<br><img src="https://pdai.tech/images/pics/PPjwP.png"></li>
</ul>
</li>
</ul>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>Java反射是一种强大的编程技术，允许在运行时检查、探索和操作类、对象、字段、方法以及其他成员。反射使你可以动态地创建对象、调用方法、获取和设置字段值，以及执行其他与类和对象相关的操作。</p>
<ul>
<li>每个类都有一个 Class 对象，包含与类有关的信息。当编译一个新类时会产生一个同名的<code>.class文件</code>，其内容保存着 Class 对象。</li>
<li>类加载相当于 Class 对象的加载。类在第一次使用时才动态加载到 JVM 中，可以使用 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> 这种方式来控制类的加载，该方法会返回一个 Class 对象。</li>
<li>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至编译时期该类的 .class 不存在也可以加载进来。</li>
<li>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类:<ul>
<li>Field : 可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li>
<li>Method : 可以使用 invoke() 方法调用与 Method 对象关联的方法；</li>
<li>Constructor : 可以用 Constructor 创建新的对象。</li>
</ul>
</li>
<li><strong>Class类</strong>：Java反射的核心类是<code>java.lang.Class</code>。每个类都有一个与之相关的<code>Class</code>对象，你可以使用这个<code>Class</code>对象来获取关于类的信息。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类的`Class`对象</span></span><br><span class="line">Class&lt;?&gt; myClass = MyClass.class; <span class="comment">// 通过类名</span></span><br><span class="line">Class&lt;?&gt; myClass = obj.getClass();  <span class="comment">// 通过对象</span></span><br><span class="line">Class&lt;?&gt; myClass = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>); <span class="comment">// 通过类的全名</span></span><br><span class="line"><span class="comment">// 获取有关类的信息</span></span><br><span class="line"><span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> myClass.getName(); <span class="comment">// 获取类名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">packageName</span> <span class="operator">=</span> myClass.getPackage().getName(); <span class="comment">// 获取包名</span></span><br><span class="line">Class&lt;?&gt; superClass = myClass.getSuperclass(); <span class="comment">// 获取父类</span></span><br><span class="line">Class&lt;?&gt;[] interfaces = myClass.getInterfaces(); <span class="comment">// 获取实现的接口</span></span><br><span class="line">Field[] fields = myClass.getDeclaredFields(); <span class="comment">// 获取所有字段</span></span><br><span class="line">Method[] methods = myClass.getDeclaredMethods(); <span class="comment">// 获取所有方法</span></span><br></pre></td></tr></table></figure></li>
<li><strong>实例化对象</strong>：通过反射，你可以动态地创建对象。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; myClass = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> myClass.newInstance(); <span class="comment">// 创建对象，需要无参构造函数</span></span><br><span class="line"><span class="comment">// 使用反射来获取、设置对象的字段值</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> myClass.getDeclaredField(<span class="string">&quot;fieldName&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>); <span class="comment">// 设置字段可访问</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> field.get(obj); <span class="comment">// 获取字段值</span></span><br><span class="line">field.set(obj, newValue); <span class="comment">// 设置字段值</span></span><br><span class="line"><span class="comment">// 反射允许你调用对象的方法。例如：</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> myClass.getDeclaredMethod(<span class="string">&quot;methodName&quot;</span>, param1Type, param2Type);</span><br><span class="line">method.setAccessible(<span class="literal">true</span>); <span class="comment">// 设置方法可访问</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(obj, arg1, arg2); <span class="comment">// 调用方法</span></span><br></pre></td></tr></table></figure></li>
<li><strong>数组与泛型</strong>：通过反射，你可以创建数组、获取数组元素的类型信息，以及处理泛型信息。</li>
<li><strong>代理</strong>：Java反射还可用于创建动态代理，这是一种强大的技术，允许你创建实现特定接口的代理类以在运行时拦截和处理方法调用。</li>
<li><strong>限制</strong>：尽管反射提供了强大的能力，但也有一些限制和性能开销。使用时需要小心处理异常、性能、访问控制等方面的问题。</li>
</ul>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ul>
<li>泛型是 Java 中的一个核心特性，有助于提高代码的可重用性和类型安全性。</li>
<li>泛型的主要目的是参数化类型，允许你在类、接口、方法中使用类型参数。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T t;  <span class="comment">// T stands for &quot;Type&quot;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T t)</span> &#123; <span class="built_in">this</span>.t = t; &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> t; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChildBox</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 子类继承父类的泛型类型参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>泛型通配符：Java中有通配符类型，允许你在不知道具体类型的情况下使用泛型。通配符包括?符号。<br>当你使用通配符作为方法参数时，可能需要捕获通配符以使用它。这可以通过在方法参数中使用?来实现。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processList</span><span class="params">(List&lt;?&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Object obj : list) &#123;        <span class="comment">// 处理每个元素    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>泛型上下界：你可以使用通配符来定义类型的上下界。例如，&lt;? extends Number&gt;表示类型必须是Number或其子类。&lt;? super Integer&gt;表示类型必须是Integer或其父类。</li>
<li>类型擦除：Java泛型通过类型擦除来实现。这意味着在编译时，泛型类型信息会被擦除，而在运行时，Java虚拟机将使用原始类型。这可能会导致一些限制，例如无法创建泛型数组。</li>
</ul>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><ul>
<li>Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。<a target="_blank" rel="noopener" href="https://pdai.tech/md/java/basic/java-basic-x-annotation.html">https://pdai.tech/md/java/basic/java-basic-x-annotation.html</a></li>
<li><strong>Spring框架中的注解</strong> 本质上是一种元数据，用于为应用程序的组件（例如类、方法、字段等）提供附加的信息，以指导Spring容器在应用程序运行时如何处理这些组件。这些注解告诉Spring容器如何创建、初始化、配置和管理这些组件，以及它们之间的关系。</li>
</ul>
<h3 id="Stream-流"><a href="#Stream-流" class="headerlink" title="Stream 流"></a>Stream 流</h3><p>在Java中，流（Stream）是用于处理集合数据的一种新的抽象。Java的流操作主要分为两种：中间操作和终端操作。流的处理操作通常应用于集合类（如List、Set、Map等）。<br>Java的流操作利用了函数式编程的思想，提供了一种更简洁、灵活、可读性更强的处理方式。通过合理使用中间操作和终端操作，可以实现丰富的数据处理功能。流操作也广泛应用于Java集合、文件IO、网络编程等场景。</p>
<ol>
<li><strong>中间操作：</strong><ul>
<li>中间操作主要用于对数据进行处理和转换，产生一个新的流。中间操作不会触发实际的处理，只是在流上进行各种操作。</li>
<li>常见的中间操作包括 <code>filter</code>（过滤）、<code>map</code>（映射）、<code>distinct</code>（去重）、<code>sorted</code>（排序）、<code>limit</code>（限制结果数量）等。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>, <span class="string">&quot;David&quot;</span>, <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"></span><br><span class="line">names.stream()</span><br><span class="line">     .filter(name -&gt; name.length() &gt; <span class="number">3</span>)</span><br><span class="line">     .distinct()</span><br><span class="line">     .sorted()</span><br><span class="line">     .map(String::toUpperCase)</span><br><span class="line">     .forEach(System.out::println);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>终端操作：</strong><ul>
<li>终端操作是流的最终处理步骤，触发流的遍历和数据处理。终端操作会返回一个非流的结果，例如集合、数组、某个值等。</li>
<li>常见的终端操作包括 <code>collect</code>（将流元素收集到集合中）、<code>reduce</code>（对元素进行归约操作）等。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>, <span class="string">&quot;David&quot;</span>, <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; filteredNames = names.stream()</span><br><span class="line">                                  .filter(name -&gt; name.length() &gt; <span class="number">3</span>)</span><br><span class="line">                                  .distinct()</span><br><span class="line">                                  .sorted()</span><br><span class="line">                                  .map(String::toUpperCase)</span><br><span class="line">                                  .collect(Collectors.toList());</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="??Lambda 表达式"></a>??Lambda 表达式</h2><p>学习 <a target="_blank" rel="noopener" href="http://doc.junbo.top/pages/viewpage.action?pageId=10798971">http://doc.junbo.top/pages/viewpage.action?pageId=10798971</a><br>Lambda 表达式提供了一种简洁、清晰的语法，允许以更为函数式的方式编写代码。<br>Lambda 的引入使得代码变得更加简洁，尤其在使用函数式接口（只有一个抽象方法的接口）时，可以直接传递 Lambda 表达式，而不再需要传递匿名内部类的实例。Lambda 表达式在处理集合、并发编程、事件处理等场景中广泛应用，它是 Java 8 引入的一个重要特性，使得 Java 语言更好地支持函数式编程风格。</p>
<ul>
<li>Lambda 表达式主要用于定义内联的、匿名的函数。它是一个函数式接口的实例，即只有一个抽象方法的接口。基本语法如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `parameters` 指定了 Lambda 表达式的参数，`-&gt;` 是 Lambda 操作符，</span></span><br><span class="line"><span class="comment">// `expression` 或 `&#123; statements; &#125;` 指定了 Lambda 表达式的主体。</span></span><br><span class="line">(parameters) -&gt; expression</span><br><span class="line">(parameters) -&gt; &#123; statements; &#125;</span><br><span class="line"><span class="comment">// 1. 一个简单的例子，计算两个数的和：</span></span><br><span class="line">(<span class="type">int</span> a, <span class="type">int</span> b) -&gt; a + b</span><br><span class="line"><span class="comment">// 2. 遍历列表并打印每个元素：</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>);</span><br><span class="line">list.forEach(s -&gt; System.out.println(s));</span><br><span class="line"><span class="comment">// 3. 使用 `Runnable` 接口创建一个线程：</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;Hello, Lambda!&quot;</span>)).start();</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Java-动态代理机制"><a href="#Java-动态代理机制" class="headerlink" title="Java 动态代理机制 ??"></a>Java 动态代理机制 ??</h2><p>代理可以分为 “静态代理” 和 “动态代理”，动态代理又分为 “JDK动态代理” 和 “CGLIB动态代理” 实现。</p>
<ul>
<li>静态代理<br>代理对象和实际对象都继承了同一个接口，在代理对象中指向的是实际对象的实例，这样对外暴露的是代理对象而真正调用的是实际对象。<br>优点：可以很好的保护实际对象的业务逻辑对外暴露，从而提高安全性。<br>缺点：不同的接口要有不同的代理类实现，会很冗余</li>
<li>JDK 动态代理<br>为了解决静态代理中，生成大量的代理类造成的冗余；JDK 动态代理只需要实现 InvocationHandler 接口，重写 invoke 方法便可以完成代理的实现，jdk的代理是利用反射生成代理类 Proxyxx.class 代理类字节码，并生成对象 jdk动态代理之所以只能代理接口是因为代理类本身已经extends了Proxy，而java是不允许多重继承的，但是允许实现多个接口。<br>优点：解决了静态代理中冗余的代理实现类问题。<br>缺点：JDK 动态代理是基于接口设计实现的，如果没有接口，会抛异常。</li>
<li>CGLIB 代理<br>由于 JDK 动态代理限制了只能基于接口设计，而对于没有接口的情况，JDK方式解决不了；CGLib 采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑，来完成动态代理的实现。实现方式实现 MethodInterceptor 接口，重写 intercept 方法，通过 Enhancer 类的回调方法来实现。但是CGLib在创建代理对象时所花费的时间却比JDK多得多，所以对于单例的对象，因为无需频繁创建对象，用CGLib合适，反之，使用JDK方式要更为合适一些。 同时，由于CGLib由于是采用动态创建子类的方法，对于final方法，无法进行代理。<br>优点：没有接口也能实现动态代理，而且采用字节码增强技术，性能也不错。<br>缺点：技术实现相对难理解些。</li>
</ul>
<h2 id="BIO、NIO-和-AIO-的区别"><a href="#BIO、NIO-和-AIO-的区别" class="headerlink" title="BIO、NIO 和 AIO 的区别"></a>BIO、NIO 和 AIO 的区别</h2><p>??</p>
<hr>

<h1 id="Java-设计模式"><a href="#Java-设计模式" class="headerlink" title="Java 设计模式"></a>Java 设计模式</h1><ul>
<li><p>设计模式是为了解决软件开发过程中常见的问题而提出的一种解决方案，它们是从实际应用中总结出来的一些经验和方法论。设计模式可以帮助开发人员更加容易地解决复杂问题，提高代码的可重用性、可扩展性、可维护性等，从而提高软件开发效率和代码质量。<br>具体来说，设计模式主要是为了解决以下几类问题：<br>（1）代码复杂度问题：在软件开发中，代码往往会变得越来越复杂，难以理解和维护。设计模式提供了一些组织代码的方式，让代码结构更加清晰，易于理解和维护。<br>（2）重用问题：在开发过程中，我们希望能够尽可能地复用代码，减少重复开发的工作量。设计模式提供了一些通用的解决方案，可以让我们更加容易地复用代码。<br>（3）扩展性问题：软件开发过程中，我们需要不断地对系统进行扩展和改进。设计模式提供了一些可扩展的解决方案，可以让系统更加容易地扩展和改进，同时保持代码的高可读性和可维护性。<br>（4）协作问题：在多人协作的开发过程中，代码的组织和沟通变得非常重要。设计模式提供了一些标准化的组织方式，可以让开发者更加容易地沟通和协作。</p>
</li>
<li><p>设计原则<br>软件设计原则是指在软件开发过程中遵循的一些通用的、经过验证的规则和指导原则。这些原则旨在提高软件的可维护性、可扩展性、可重用性和可靠性等方面的质量。<br>以下是一些常见的软件设计原则：<br>（1）单一职责原则（SRP）：一个类应该只有一个职责或只有一个引起变化的原因。<br>（2）开放-封闭原则（OCP）：软件实体（类、模块、函数等）应该是可扩展的，但是不可修改的。<br>（3）里氏替换原则（LSP）：任何基类可以出现的地方，子类一定可以出现，而且不会导致任何错误或异常。<br>（4）依赖倒置原则（DIP）：高层模块不应该依赖于底层模块，二者都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。<br>（5）接口隔离原则（ISP）：客户端不应该依赖于它不需要的接口。一个类对另一个类的依赖应该建立在最小的接口上。<br>（6）迪米特法则（LoD）：一个对象应该对其他对象有最少的了解。通俗地讲，就是一个类对自己依赖的类知道得越少越好。<br>（7）合成复用原则（CRP）：尽量使用对象组合，而不是继承来达到复用的目的。</p>
</li>
<li><p>高内聚，低耦合<br>高内聚低耦合是软件设计中的一个原则，它强调模块内部的联系应该紧密而模块之间的联系应该尽量松散。具体来说，高内聚指的是一个模块内部的各个组成部分之间的联系应该紧密，组成部分之间的关系应该尽量简单。低耦合指的是一个模块与其他模块之间的依赖关系应该尽量松散，即模块之间的耦合度应该尽量低。<br>高内聚的好处在于，一个模块内部的联系紧密，表示这个模块是一个独立的整体，对外部的干扰最小。同时，当需要对一个模块进行修改时，只需要修改该模块内部的某些部分，不会对其他部分造成影响，从而提高了系统的可维护性和可扩展性。<br>低耦合的好处在于，模块之间的联系松散，意味着这些模块之间的依赖性较小，当一个模块需要进行修改时，不会对其他模块产生影响，从而提高了系统的可维护性和可扩展性。</p>
</li>
<li><p>23种设计模式<br>  <img src="https://pdai.tech/images/design-pattern.png"></p>
<ul>
<li>创造型模式<ul>
<li>单例模式：确保一个类只有一个实例，并提供该实例的全局访问点</li>
<li>工厂方法模式：它定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类</li>
<li>抽象工厂模式：创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同</li>
<li>建造者模式：生成器(Builder)？模式，封装一个对象的构造过程，并允许按步骤构造</li>
<li>原型模式：使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象</li>
</ul>
</li>
<li>结构型模式<ul>
<li>适配器模式：将一个类的接口, 转换成客户期望的另一个接口。 适配器让原本接口不兼容的类可以合作无间。 对象适配器使用组合, 类适配器使用多重继承</li>
<li>代理模式：为另一个对象提供一个替身或占位符以控制对这个对象的访问</li>
<li>桥接模式：使用桥接模式通过将实现和抽象放在两个不同的类层次中而使它们可以独立改变</li>
<li>装饰器模式：动态地将责任附加到对象上, 若要扩展功能, 装饰者提供了比继承更有弹性的替代方案</li>
<li>外观模式：它提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用</li>
<li>组合模式：允许你将对象组合成树形结构来表现”整体&#x2F;部分”层次结构. 组合能让客户以一致的方式处理个别对象以及对象组合</li>
<li>享元模式：利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。 它让某个类的一个实例能用来提供许多”虚拟实例”</li>
</ul>
</li>
<li>行为型模式<ul>
<li>观察者模式：在对象之间定义一对多的依赖, 这样一来, 当一个对象改变状态, 依赖它的对象都会收到通知, 并自动更新</li>
<li>策略模式：定义了算法族, 分别封闭起来, 让它们之间可以互相替换, 此模式让算法的变化独立于使用算法的客户</li>
<li>命令模式：将”请求”封闭成对象, 以便使用不同的请求,队列或者日志来参数化其他对象. 命令模式也支持可撤销的操作</li>
<li>中介者模式：使用中介者模式来集中相关对象之间复杂的沟通和控制方式</li>
<li>备忘录模式：当你需要让对象返回之前的状态时(例如, 你的用户请求”撤销”), 你使用备忘录模式</li>
<li>模版方式模式：在一个方法中定义一个算法的骨架, 而将一些步骤延迟到子类中. 模板方法使得子类可以在不改变算法结构的情况下, 重新定义算法中的某些步骤</li>
<li>迭代器模式：提供一种方法顺序访问一个聚合对象中的各个元素, 而又不暴露其内部的表示</li>
<li>状态模式：允许对象在内部状态改变时改变它的行为, 对象看起来好象改了它的类</li>
<li>责任链模式：通过责任链模式, 你可以为某个请求创建一个对象链. 每个对象依序检查此请求并对其进行处理或者将它传给链中的下一个对象</li>
<li>解释器模式：使用解释器模式为语言创建解释器，通常由语言的语法和语法分析来定义</li>
<li>访问者模式：当你想要为一个对象的组合增加新的能力, 且封装并不重要时, 就使用访问者模式</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul>
<li><p>什么是单例设计模式？<br>单例模式是⼀种创建型设计模式， 它的核⼼思想是保证⼀个类只有⼀个实例，并提供⼀个全局访问点来访问这个实例。<br>只有⼀个实例的意思是，在整个应⽤程序中，只存在该类的⼀个实例对象，⽽不是创建多个相同类型的对象。<br>全局访问点的意思是，为了让其他类能够获取到这个唯⼀实例，该类提供了⼀个全局访问点（通常是⼀个静态⽅法），通过这个⽅法就能获得实例。</p>
</li>
<li><p>为什么要使⽤单例设计模式呢？</p>
<ol>
<li>全局控制：保证只有⼀个实例，这样就可以严格的控制客户怎样访问它以及何时访问它，简单的说就是对唯⼀实例的受控访问（引⽤⾃《⼤话设计模式》第21章）</li>
<li>节省资源：也正是因为只有⼀个实例存在，就避免多次创建了相同的对象，从⽽节省了系统资源，⽽且多个模块还可以通过单例实例共享数据。</li>
<li>懒加载：单例模式可以实现懒加载，只有在需要时才进⾏实例化，这⽆疑会提⾼程序的性能。</li>
</ol>
</li>
<li><p>单例设计模式的基本要求</p>
<ol>
<li>私有的构造函数：防⽌外部代码直接创建类的实例</li>
<li>私有的静态实例变量：保存该类的唯⼀实例</li>
<li>公有的静态⽅法：通过公有的静态⽅法来获取类的实例</li>
</ol>
</li>
<li><p>单例模式的实现⽅式有多种，包括懒汉式、饿汉式等。<br>饿汉式指的是在类加载时就已经完成了实例的创建，不管后⾯创建的实例有没有使⽤，先创建再说，所以叫做“饿汉”。<br>懒汉式指的是只有在请求实例时才会创建，如果在⾸次请求时还没有创建，就创建⼀个新的实例，如果已经创建，就返回已有的实例，意思就是需要使⽤了再创建，所以称为“懒汉”</p>
</li>
</ul>
<h3 id="饿汉模式（线程安全）：类⼀加载就创建对象，这种⽅式⽐较常⽤。"><a href="#饿汉模式（线程安全）：类⼀加载就创建对象，这种⽅式⽐较常⽤。" class="headerlink" title="饿汉模式（线程安全）：类⼀加载就创建对象，这种⽅式⽐较常⽤。"></a>饿汉模式（线程安全）：类⼀加载就创建对象，这种⽅式⽐较常⽤。</h3><p>优点：线程安全，没有加锁，执⾏效率较⾼。<br>缺点：不是懒加载，类加载时就初始化，浪费内存空间。<br>如何保证线程安全：基于类加载机制避免了多线程的同步问题，但是如果类被不同的类加载器加载就会创建不同的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>  &#123;</span><br><span class="line">    <span class="comment">// 1、私有化构造⽅法，防⽌外部实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 2、定义⼀个静态变量指向⾃⼰类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="comment">// 3、对外提供⼀个公共的⽅法获取实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="懒汉模式（线程安全）"><a href="#懒汉模式（线程安全）" class="headerlink" title="懒汉模式（线程安全）"></a>懒汉模式（线程安全）</h3><p>懒汉模式在单线程下使⽤没有问题，对于多线程是⽆法保证单例的。<br>通过 synchronized 关键字加锁保证线程安全，synchronized 可以添加在⽅法上⾯，也可以添加在代码块上⾯，这⾥演示添加在⽅法上⾯，存在的问题是 每⼀次调⽤ getInstance 获取实例时都需要加锁和释放锁，这样是⾮常影响性能的。<br>优点：懒加载，线程安全。<br>缺点：效率较低。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>  &#123;</span><br><span class="line">    <span class="comment">// 1、私有化构造⽅法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123; &#125;</span><br><span class="line">    <span class="comment">// 2、定义⼀个静态变量指向⾃⼰类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="comment">// 3、对外提供⼀个公共的⽅法获取实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="什么时候使⽤单例设计模式？"><a href="#什么时候使⽤单例设计模式？" class="headerlink" title="什么时候使⽤单例设计模式？"></a>什么时候使⽤单例设计模式？</h3><p>说了这么多，那在什么场景下应该考虑使⽤单例设计模式呢？可以结合单例设计模式的优点来看。</p>
<ol>
<li>资源共享<br>多个模块共享某个资源的时候，可以使⽤单例模式，⽐如说应⽤程序需要⼀个全局的配置管理器来存储和管理配置信息、亦或是使⽤单例模式管理数据库连接池。</li>
<li>只有⼀个实例<br>当系统中某个类只需要⼀个实例来协调⾏为的时候，可以考虑使⽤单例模式， ⽐如说管理应⽤程序中的缓存，确保只有⼀个缓存实例，避免重复的缓存创建和管理，或者使⽤单例模式来创建和管理线程池。</li>
<li>懒加载<br>如果对象创建本身就⽐较消耗资源，⽽且可能在整个程序中都不⼀定会使⽤，可以使⽤单例模式实现懒加载。<br>在许多流⾏的⼯具和库中，也都使⽤到了单例设计模式，⽐如Java中的 Runtime 类就是⼀个经典的单例，表示程序的运⾏时环境。此外 Spring 框架中的应⽤上下⽂ ( ApplicationContext ) 也被设计为单例，以提供对应⽤程序中所有 bean 的集中式访问点</li>
</ol>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><ul>
<li><p>什么是⼯⼚⽅法模式？<br>⼯⼚⽅法模式也是⼀种创建型设计模式，简单⼯⼚模式只有⼀个⼯⼚类，负责创建所有产品，如果要添加新的产品，通常需要修改⼯⼚类的代码。<br>⽽⼯⼚⽅法模式引⼊了抽象⼯⼚和具体⼯⼚的概念，每个具体⼯⼚只负责创建⼀个具体产品，添加新的产品只需要添加新的⼯⼚类⽽⽆需修改原来的代码，这样就使得产品的⽣产更加灵活，⽀持扩展，符合开闭原则。</p>
</li>
<li><p>⼯⼚⽅法模式分为以下⼏个⻆⾊：<br>抽象⼯⼚：⼀个接⼝，包含⼀个抽象的⼯⼚⽅法（⽤于创建产品对象）。<br>具体⼯⼚：实现抽象⼯⼚接⼝，创建具体的产品。<br>抽象产品：定义产品的接⼝。<br>具体产品：实现抽象产品接⼝，是⼯⼚创建的对象。</p>
</li>
<li><p>应⽤场景<br>⼯⼚⽅法模式使得每个⼯⼚类的职责单⼀，每个⼯⼚只负责创建⼀种产品，当创建对象涉及⼀系列复杂的初始化逻辑，⽽这些逻辑在不同的⼦类中可能有所不同时，可以使⽤⼯⼚⽅法模式将这些初始化逻辑封装在⼦类的⼯⼚中。在现有的⼯具、库中，⼯⼚⽅法模式也有⼴泛的应⽤，⽐如：<br>Spring 框架中的 Bean ⼯⼚：通过配置⽂件或注解，Spring 可以根据配置信息动态地创建和管理对象。<br>JDBC 中的 Connection ⼯⼚：在 Java 数据库连接中， DriverManager 使⽤⼯⼚⽅法模式来创建数据库连接。不同的数据库驱动（如 MySQL、PostgreSQL 等）都有对应的⼯⼚来创建连接</p>
</li>
</ul>
<h2 id="配适器模式"><a href="#配适器模式" class="headerlink" title="配适器模式"></a>配适器模式</h2><p>概念：适配器模式就是将⼀个类的接⼝，转换成客户期望的另⼀个接⼝。<br>作用：可以让原本两个不兼容的接⼝能够⽆缝完成对接。<br>原理 or 实现：适配器实现了其中一个对象的接口， 并对另一个对象进行封装。</p>
<hr>

<h2 id="Java-各版本的新特性"><a href="#Java-各版本的新特性" class="headerlink" title="Java 各版本的新特性"></a>Java 各版本的新特性</h2><p>New highlights in Java SE 8<br>Lambda Expressions，Pipelines and Streams，Date and Time API，Default Methods，Type Annotations，Nashhorn JavaScript Engine，Concurrent Accumulators，Parallel operations，PermGen Error Removed<br>New highlights in Java SE 7<br>Strings in Switch Statement，Type Inference for Generic Instance Creation，Multiple Exception Handling，Support for Dynamic Languages，Try with Resources，Java nio Package，Binary Literals,Underscore in literals，Diamond Syntax</p>
<h2 id="Java-与-C-的区别"><a href="#Java-与-C-的区别" class="headerlink" title="Java 与 C++ 的区别"></a>Java 与 C++ 的区别</h2><ul>
<li>Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。</li>
<li>Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。</li>
<li>Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。</li>
<li>Java 支持自动垃圾回收，而 C++ 需要手动回收。</li>
<li>Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。</li>
<li>Java 不支持操作符重载，而 C++ 可以。虽然可以对两个 String 对象支持加法运算，但是这是语言内置支持的操作，非操作符重载</li>
<li>Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。</li>
<li>Java 不支持条件编译，C++ 通过 #ifdef #ifndef 等预处理命令从而实现条件编译。</li>
</ul>
<h2 id="知识体系"><a href="#知识体系" class="headerlink" title="知识体系"></a>知识体系</h2><p>Java全栈知识体系：<a target="_blank" rel="noopener" href="https://pdai.tech/">https://pdai.tech/</a><br><img src="https://pdai.tech/images/java_basic.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/01/Java%E5%9F%BA%E7%A1%80/" data-id="cm2rjvvgm0008b4v5ghbg7utm" data-title="Java 基础" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Java后端开发" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/31/Java%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" class="article-date">
  <time class="dt-published" datetime="2021-08-31T03:49:42.000Z" itemprop="datePublished">2021-08-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/31/Java%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">java 后端开发 工程师</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h2><ul>
<li>Spring Boot：Java 生态首选框架之一，基于且进一步简化了Spring。</li>
<li>Spring：轻量级框架，用于构建企业级 Java 应用程序。<br>Spring MVC： 处理浏览器请求， 三层架构， MVC模式三层 集体解决表现层的问题<br>MyBatis： 处理访问数据库</li>
<li>Redis<strong>【6379】</strong> 操作内存的数据库，Kafka<strong>【9092】</strong>消息队列服务器，Elasticsearch<strong>【9200】</strong>搜索引擎</li>
<li>Spring Cloud： 微服务，project，module？？</li>
</ul>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul>
<li>构建工具：Apache Maven</li>
<li>集成开发工具：IntelliJ IDEA</li>
<li>数据库：MySQL、Redis</li>
<li>应用服务器：Apache Tomcat<strong>【8080】</strong>（Spring Boot 默认以jar包集成了 Tomcat 作为内嵌的 Servlet 容器）</li>
<li>版本控制工具：Git</li>
<li>运维工具：Kubernetes 容器编排平台，FinalShell连接linux服务器</li>
</ul>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>常用 Java8 即 jdk1.8，安装jdk-8u202-windows-x64，配环境：把主目录配到 JAVA_HOME，bin 目录配到 PATH<br>安装配置好<em>jdk，maven，git，idea</em>后，基本可以开始开发</p>
<h2 id="Apache-Maven"><a href="#Apache-Maven" class="headerlink" title="Apache Maven"></a>Apache Maven</h2><ul>
<li>Maven 帮助我们构建项目、管理项目中的jar包；系统环境：安装路径配到 MAVEN_HOME，bin 目录配到 PATH</li>
<li><strong>本地仓库 默认位置 ~&#x2F;.m2&#x2F;repository</strong>，存放从远程仓库获取的 jar 包；<strong>本机上的Maven主路径 D:&#x2F;apache-maven-3.6.1</strong>，对应的<strong>用户配置文件为 D:\apache-maven-3.6.1\conf\settings.xml</strong>（更换为公司的maven配置文件） </li>
<li>在 <a target="_blank" rel="noopener" href="https://mavenrepository.com/">https://mavenrepository.com</a> 查找需要的jar包。配置阿里云镜像仓库 <url><a target="_blank" rel="noopener" href="https://maven.aliyun.com/repository/central">https://maven.aliyun.com/repository/central</a></url></li>
<li>中央仓库：是 Maven 的默认仓库，包含了大量的开源 Java 类库、框架和插件，许多常用的第三方库，供开发者使用。<br>镜像仓库：中央仓库的镜像，如阿里云、华为云，从中央仓库同步数据，用来加速依赖的下载速度，减轻中央仓库的负担。<br>私服仓库：在本地或者组织内部搭建的仓库，用于存储内部开发所需的依赖和构建产物。</li>
<li>在 IntelliJ IDEA 中配置 maven仓库：”File” &gt; “Settings” &gt; “Build, Execution, Deployment” &gt; “Build Tools” &gt; “Maven”，配置maven主路径、用户设置文件和本地仓库。</li>
<li>Maven 是一个强大的构建工具，它可以执行各种命令来管理项目的构建、依赖、测试等方面的任务。<br>以下是一些常用的Maven指令，进入项目根目录命令行终端执行：(当然也可以直接在idea点击按钮执行)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mvn clean            <span class="comment"># 清除项目的目标目录，删除编译生成的文件。</span></span><br><span class="line">mvn compile          <span class="comment"># 编译项目中的Java源代码文件，并将编译结果放置在项目的目标目录(通常是target目录)中</span></span><br><span class="line">mvn <span class="built_in">test</span>             <span class="comment"># 运行项目的单元测试。</span></span><br><span class="line">mvn package          <span class="comment"># 将项目打包为可执行的JAR或WAR文件，通常用于构建最终的可部署应用程序。</span></span><br><span class="line">mvn install          <span class="comment"># 将项目构建输出的JAR或WAR文件安装到本地Maven仓库，以便其他项目可以引用它作为依赖。</span></span><br><span class="line">mvn deploy           <span class="comment"># 将项目构建输出的JAR或WAR文件部署到远程仓库，通常用于共享依赖。</span></span><br><span class="line">mvn clean install    <span class="comment"># 用于先清除项目目录，然后执行安装操作。（引入pom中新加的dependence）</span></span><br><span class="line">mvn clean package    <span class="comment"># 用于先清除项目目录，然后执行打包操作。</span></span><br></pre></td></tr></table></figure></li>
<li><strong>JAR</strong>（Java Archive）是Java平台中用于打包和分发Java类和相关资源的文件格式。它是一种压缩格式，通常包含Java类文件（.class文件），资源文件，清单文件（Manifest），以及其他可以用于Java应用程序的元数据。</li>
<li><strong>WAR</strong>（Web Application Archive）文件是一种Java Web应用程序的打包格式，通常用于部署Web应用程序到Java EE应用服务器，如Tomcat、WebSphere、或JBoss等。是一种压缩文件，通常以.war扩展名结尾，它包含了用于部署和运行Web应用程序的各种资源。</li>
</ul>
<h2 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h2><ul>
<li>Java作为一门世界级主流编程语言，有一款高效易用的项目管理工具是java开发者共同追求的心原和目标。<br>2012年基于 Ant 和Maven产生的Gradle，弥补了不足，带来了一些更高效的特点。它使用种基于Groovy的特定领域语言(DSL)来声明项目设置，抛弃了基于XML的各种繁琐配置。面向Java应用为主。</li>
<li>系统环境：安装路径配到 GRADLE_HOME，bin 目录配到 PATH<br>集成 IDEA：创建项目时，”Build System” 直接使用 Gradle 插件即可，选择本地安装的 Gradle 目录。</li>
<li>Gradle 目录结构与 Maven 完全一样：src&#x2F;main&#x2F;java 放置正式代码目录，src&#x2F;main&#x2F;resources 放置正式配置文件，src&#x2F;test&#x2F;java 放置单元测试代码，src&#x2F;test&#x2F;resources 放置测试配置文件，src&#x2F;main&#x2F;webapp 放置页面元素。</li>
<li>借助 spring 脚手架创建 Gradle 项目：<a target="_blank" rel="noopener" href="https://start.spring.io/">https://start.spring.io/</a></li>
<li>Gradle 配置文件 build.gradle，使用 Groovy 编写（一种脚本语言）<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Gradle会首先搜索本地仓库（默认C:\Users\admin\.gradle）以查找依赖项</span></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenLocal()</span><br><span class="line">    <span class="comment">// 如果未在本地仓库找到，Gradle将会去 mavenCentral() 仓库中查找</span></span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// gradle工程所有的jar包在 dependencies 属性中，每一个jar包坐标有三个元素组成：group、name、version</span></span><br><span class="line"><span class="comment">// testCompile 表示该 jar包在测试的时候起作用，该属性为包的作用域</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    testImplementation <span class="string">&#x27;org.junit.jupiter:junit-jupiter-api:5.8.1&#x27;</span></span><br><span class="line">    testRuntimeOnly <span class="string">&#x27;org.junit.jupiter:junit-jupiter-engine:5.8.1&#x27;</span></span><br><span class="line">    <span class="comment">// 到 https://mvnrepository.com/ 查到 Spring Context 的 Gradle 依赖</span></span><br><span class="line">    implementation <span class="attr">group:</span> <span class="string">&#x27;org.springframework&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;spring-context&#x27;</span>, <span class="attr">version:</span> <span class="string">&#x27;5.0.2.RELEASE&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
也可以直接把 Gradle 本地仓库 配置成 Mavne 本地仓库，合二为一。具体做法是新建环境变量 GRADLE_USER_HOME 为 Mavne本地仓库目录，这样 Gradle工程会从 Mavne本地仓库目录寻找 jar包。</li>
</ul>
<h2 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h2><ul>
<li>核心作用：起步依赖、自动配置、端点监控</li>
<li>在 <a target="_blank" rel="noopener" href="https://start.spring.io/">https://start.spring.io</a> 创建一个springboot项目</li>
<li><strong>Spring</strong>（Spring Framework）是一个开源的轻量级Java企业应用程序开发框架，旨在简化Java应用程序的开发。Spring本身并不直接管理Maven依赖，而是依赖Maven作为构建工具来管理项目中的依赖关系</li>
<li><strong>Spring Boot</strong> 是 Spring 框架的一个扩展，旨在简化 Spring 应用程序的开发和部署。引入了 Starter 依赖的概念，这些 Starter是预配置的依赖项集合，用于快速启动特定类型的应用程序（例如，spring-boot-starter-web 是用于构建 Web 应用程序的 Starter 依赖，它包含了 Spring MVC、Tomcat 等依赖）;可以根据项目需求选择性地引入 Starter 依赖，而不必手动添加一堆依赖项。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;    <span class="comment">// 在 pom.xml 中配置需要的各种 spring-boot-starter 包</span></span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><ul>
<li>Spring全家桶：Spring Framework, Spring Boot, Spring Cloud 微服务, Spring Cloud Data Flow 客户端</li>
<li>Spring Framework：<br>Spring Core - IoC, AOP 管理一切<br>Spring Data Access - Transactions, Spring MyBatis<br>Web Servlet - Spring MVC<br>Integration - Email, Scheduling, AMQP, Security</li>
<li><strong>for more -&gt;</strong> <a target="_blank" rel="noopener" href="https://leo710aka.github.io/2021/09/11/Spring/">https://leo710aka.github.io/2021/09/11/Spring/</a></li>
</ul>
<h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><ul>
<li>三层架构：表现层、业务层、数据访问层</li>
<li>MVC：解决表现层的问题（Model：模型层 - View：视图层 - Controller：控制层）</li>
<li>HTTP：用于传输HTML等内容的应用层协议，规定了浏览器和服务器(或本地tomcat)之间如何通信以及通信时的数据格式。</li>
<li>核心组件 - 前端控制器：DispatcherServlet，控制整个MVC</li>
<li>Thymeleaf（View层）：模板文件 + Model -&gt; 模板引擎（Thymeleaf） -&gt; Html （但现在更多是前后端分离，会使用HTML+AJAX(<strong>异步请求</strong>)，采用前端框架进行渲染会更好的解耦）<br>在controller中写一个函数，获取数据，用model封装返回给html，在html文件中链接Thymeleaf模板，将数据动态展现。</li>
</ul>
<h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><ul>
<li>社区版 下载zip文件：<a target="_blank" rel="noopener" href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a><br>mysql及navicat配置：<a target="_blank" rel="noopener" href="https://blog.csdn.net/taiyang3285/article/details/130115829">https://blog.csdn.net/taiyang3285/article/details/130115829</a><br>注意管理员运行cmd，然后把bin配到PATH、配置本机 <strong>username: root，password: “0xxxxx”</strong></li>
<li>在application.properties文件配置 java(spring)项目连接 mysql，然后通过 Mybatis这样的持久层框架对数据库操作<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/reggie?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;allowPublicKeyRetrieval=true</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">&quot;078114&quot;</span></span><br><span class="line"><span class="attr">mybatis-plus:</span> <span class="string">...</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><ul>
<li>在pom.xml中导包后，在application.properties文件配置 mybatis</li>
<li>SqlSessionFactory: 用于创建SqlSession的工厂类。</li>
<li>SqlSession：MyBatis的核心组件，用于向数据库执行SQL。</li>
<li>主配置文件：XML配置文件，可以对MyBatis的底层行为做出详细的配置</li>
<li>Mapper接口：就是DAO接口，在MyBatis中习惯性的称之为Mapper。<br><strong>Mapper映射器</strong>: 用于编写SQL，并将SQL和实体类映射的组件。采用XML、注解均可实现。<br><strong>方法1：</strong>在 &#x2F;java&#x2F;..&#x2F;dao 下创建xxMapper.java（mapper接口）后，在 &#x2F;resource&#x2F;mapper 下创建对应的 xx-mapper.xml（映射器）；<br><strong>方法2：</strong>直接在mapper中加@Select等注解里写sql（复杂sql还得方法1）</li>
</ul>
<h2 id="Mybatis-Plus"><a href="#Mybatis-Plus" class="headerlink" title="Mybatis-Plus"></a>Mybatis-Plus</h2><ul>
<li>是在MyBatis基础上的扩展。只做增强不做改变，为简化开发、提高效率而生。</li>
<li>MyBatisPlus官方提供了starter，其中集成了 Mybatis和 MybatisPlus的所有功能，并且实现了自动装配效果。因此可以用 MybatisPlus的starter直接代替 Mybatis的starter；<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><ul>
<li>Redis是一款<strong>基于键值对</strong>的 <strong>NoSQL 数据库</strong>，它的值支持多种数据结构：字符串(strings)、哈希(hashes)、列表(lists)、集合(sets)、有序集合(sorted sets)等。 Redis将所有的数据都存放在<strong>内存</strong>中，所以它的读写性能十分惊人。同时，Redis还可以将内存中的数据以快照或日的形式保存到硬盘上，以保证数据的安全性。</li>
<li>Redis典型的应用场景包括: 缓存、排行榜、计器、社交网络、消息队列等.</li>
<li>Spring整合Redis：<ul>
<li>引入依赖：在pom.xml中导包spring-boot-starter-data-redis</li>
<li>配置数据库参数：propert中 spring.redis.database&#x3D;11 spring.redis.host&#x3D;localhost spring.redis.port&#x3D;6379</li>
<li>编写配置类，构造RedisTemplate（spring本身对redis的配置使其key为object类型，但string用起来更方便<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(factory);                  </span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());     <span class="comment">// 设置key的序列化方式</span></span><br><span class="line">        template.setValueSerializer(RedisSerializer.json());     <span class="comment">// 设置value的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string()); <span class="comment">// 设置hash的key的序列化方式</span></span><br><span class="line">        template.setHashValueSerializer(RedisSerializer.json()); <span class="comment">// 设置hash的value的序列化方式</span></span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;      &#125;  &#125;</span><br></pre></td></tr></table></figure></li>
<li>访问Redis：redisTemplate.opsForValue()， redisTemplate.opsForHash， redisTemplate.opsForList()，redisTemplate.opsForSet()，redisTemplate.opsForZSet()</li>
</ul>
</li>
<li><strong>for more -&gt;</strong> <a target="_blank" rel="noopener" href="https://leo710aka.github.io/2022/03/12/Redis/">https://leo710aka.github.io/2022/03/12/Redis/</a></li>
</ul>
<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><ul>
<li>阻塞队列（消息系统的底层）:<ul>
<li>BlockingQueue：处理并发和线程间的通信，帮助避免竞态条件、死锁等问题，并提高了系统的可维护性和性能。主要用于多线程编程中，以协调多个线程之间的数据传递、任务调度和同步操作。阻塞方法: put、take。</li>
<li>生产者消费者模式 - 生产者:产生数据的线程  - 消费者:使用数据的线程。</li>
<li>实现类 - ArrayBlockingQueue - LinkedBlockingQueue - PriorityBlockingQueue、SSynchronousQueue、DelayQueue等</li>
</ul>
</li>
<li>Kafka是一个分布式的流媒体平台应用<ul>
<li>应用：消息系统（消息队列）、日志收集、用户行为追踪、流式处理</li>
<li>特点：高吞吐量、消息持久化（硬盘）、高可靠性（顺序读写）、高扩展性（集群部署）</li>
<li>术语：- Broker（服务器）、Zookeeper  - Topic（存放空间）、Partition（分区）、Offset（索引）<br>   Leader Replica（主副本）、Follower Replica</li>
</ul>
</li>
<li>启动服务<ul>
<li>配置：在 <code>\config\zookeeper.properties</code> 配置数据存放位置 <code>dataDir=d:/work/data/zookeeper</code>，在 <code>server.properties</code> 配置日志存放位置 <code>log.dirs=d:/work/data/kafka-logs</code></li>
<li>命令行启动<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在根目录 D:\kafka_2.12-2.3.0 打开cmd【1】，启动Apache Kafka的ZooKeeper服务器</span></span><br><span class="line">D:\kafka_2.12-2.3.0&gt;bin\windows\zookeeper-server-start.bat config\zookeeper.properties</span><br><span class="line"><span class="comment"># 在根目录 再打开一个cmd【2】，启动Kafka服务器 </span></span><br><span class="line">D:\kafka_2.12-2.3.0&gt;bin\windows\kafka-server-start.bat config\server.properties</span><br><span class="line"><span class="comment"># 在命令目录 D:\kafka_2.12-2.3.0\bin\windows 打开一个cmd【3】</span></span><br><span class="line"><span class="comment"># 创建topic，partition，replication，，， 开启 生产者</span></span><br><span class="line">D:\kafka_2.12-2.3.0\bin\windows&gt;kafka-topics.bat --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic <span class="built_in">test</span></span><br><span class="line">D:\kafka_2.12-2.3.0\bin\windows&gt;kafka-console-producer.bat --broker-list localhost:9092 --topic <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 在命令目录 再打开一个cmd【4】，， 开启 消费者</span></span><br><span class="line">D:\kafka_2.12-2.3.0\bin\windows&gt;kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic <span class="built_in">test</span> --from-beginning </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Spring整合Kafka<ul>
<li>引入依赖: spring-kafka</li>
<li>配置Kafka: spring.kafka.bootstrap-servers&#x3D;localhost:9092，spring.kafka.consumer.group-id&#x3D;community-consumer-group，spring.kafka.consumer.enable-auto-commit&#x3D;true，spring.kafka.consumer.auto-commit-interval&#x3D;3000</li>
<li>通过<code>KafkaTemplate</code>进行操作：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者（主动调用）</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> KafkaTemplate kafkaTemplate;</span><br><span class="line">kafkaTemplate.send(topic， data);</span><br><span class="line"><span class="comment">// 消费者（被动调用）</span></span><br><span class="line"><span class="meta">@KafkaListener(topics = &#123;&quot;test&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(ConsumerRecord record)</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Kafka使用<br>把kafka发送系统通知的行为当做“事件”，操作不同topic就是处理不同种类的事件。<ul>
<li>触发事件：评论后发布通知，点赞后发布通知，关注后发布通知</li>
<li>处理事件：封装事件对象（entity），开发事件的生产者，开发事件的消费者</li>
<li><strong>在需要使用消息队列的controller中调用生产者（评论后发通知，点赞后发通知，关注后发通知），消费者（用户收到系统通知）将被动调用</strong>；一个消费者可以消费多种事件</li>
</ul>
</li>
</ul>
<h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><ul>
<li>Elasticsearch简介 <strong>（Es可以看成是一个特殊的数据库，是在这个“数据库”中进行搜索）</strong><ul>
<li>一个分布式的、Restful风格的搜索引擎。支持对各种类型的数据的检索</li>
<li>搜索速度快，可以提供实时的搜索服务</li>
<li>便于水平扩展，每秒可以处理PB级海量数据</li>
</ul>
</li>
<li>Elasticsearch术语<ul>
<li>索引、类型、文档、字段。（相当于MySQL中的数据库、表、行、列）（6.0后类型被废弃，则索引直接对应mysql的表）</li>
<li>集群（分布式集群部署）、节点（集群中的一台服务器）、分片（进一步划分索引并发存储）、副本（对分片备份）。</li>
</ul>
</li>
<li>配置：目录D:\elasticsearch-6.4.3\config，文件<code>elasticsearch.yml</code>，修改 cluster.name: nowcoder、path.data: D:\work\data\elasticsearch-6.4.3\data、path.logs: D:\work\data\elasticsearch-6.4.3\logs；把bin目录配到环境变量<ul>
<li>中文分词插件 elasticsearch-analysis-ik，解压到 D:\elasticsearch-6.4.3\plugin\ik</li>
</ul>
</li>
<li>启动：（windows系统）双击 D:\elasticsearch-6.4.3\bin 下的 <code>elasticsearch.bat</code> 批处理文件即可。<ul>
<li>命令行操作（另开一个cmd）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\蔡枫&gt;curl -X GET <span class="string">&quot;localhost:9200/_cat/health?v&quot;</span>    <span class="comment"># 查看集群的健康状态</span></span><br><span class="line">C:\Users\蔡枫&gt;curl -X GET <span class="string">&quot;localhost:9200/_cat/nodes?v&quot;</span>     <span class="comment"># 查看节点</span></span><br><span class="line">C:\Users\蔡枫&gt;curl -X GET <span class="string">&quot;localhost:9200/_cat/indices?v&quot;</span>   <span class="comment"># 查看索引</span></span><br><span class="line">C:\Users\蔡枫&gt;curl -X GET <span class="string">&quot;localhost:9200/_cat/indices?v&quot;</span></span><br><span class="line">C:\Users\蔡枫&gt;curl -X PUT <span class="string">&quot;localhost:9200/test&quot;</span>             <span class="comment"># 以put创建索引</span></span><br><span class="line">&#123;<span class="string">&quot;acknowledged&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;shards_acknowledged&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;index&quot;</span>:<span class="string">&quot;test&quot;</span>&#125;</span><br><span class="line">C:\Users\蔡枫&gt;curl -X DELETE <span class="string">&quot;localhost:9200/test&quot;</span>          <span class="comment"># 用http协议中的delete，删除索引</span></span><br><span class="line">&#123;<span class="string">&quot;acknowledged&quot;</span>:<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>Postman</strong> 操作<ul>
<li>GET，发送指令 localhost:9200&#x2F;test&#x2F;_doc&#x2F;1 的<code>request</code>，查询test中的数据</li>
<li>PUT，发送指令 localhost:9200&#x2F;test&#x2F;_doc&#x2F;2 的<code>request</code>，向test中存数据，可以在Body中携带raw类型的json数据</li>
<li>搜索，GET，发送指令 localhost:9200&#x2F;test&#x2F;_search?q&#x3D;xx:yy，搜索test索引下xx中带有yy的数据</li>
<li>复杂搜索：要在Body中带raw的json查询条件</li>
</ul>
</li>
</ul>
</li>
<li>Spring 整合 Es<ul>
<li>引入依赖: spring-boot-starter-data-elasticsearch</li>
<li>配置Es：spring.data.elasticsearch.cluster-name&#x3D;nowcoder，spring.data.elasticsearch.cluster-nodes&#x3D;127.0.0.1:9300（<strong>9200是http端口，9300是tcp端口</strong>）</li>
<li>elasticsearch和redis同时依赖于netty，运行冲突，需要在 <code>CommunityApplication.java</code> 加上注解<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;		   <span class="comment">// 解决netty启动冲突问题</span></span><br><span class="line">    System.setProperty(<span class="string">&quot;es.set.netty.runtime.available.processors&quot;</span>, <span class="string">&quot;false&quot;</span>);	&#125;</span><br></pre></td></tr></table></figure></li>
<li>通过<code>ElasticsearchTemplate</code>(底层)，<code>ElasticsearchRwpository</code>(简易) 操作 Es<br>对实体类加注解，与Es索引、类型、文档、字段映射：@Document(indexName &#x3D; “”, type &#x3D; “”, shards &#x3D; , replicas &#x3D; )；<br>配置实体类中的属性：@Id，@Field(type &#x3D; FieldType.Text, analyzer &#x3D; “ik_max_word”, searchAnalyzer &#x3D; “ik_smart”)，，<br><strong>一种repository对一种实体类做Es操作</strong>（区别于@Mapper，mybatis专属的）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DiscussPostRepository 是对 DiscussPost 做 Es 操作</span></span><br><span class="line"><span class="meta">@Repository</span>                 </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DiscussPostRepository</span> </span><br><span class="line">          <span class="keyword">extends</span> <span class="title class_">ElasticsearchRepository</span>&lt;DiscussPost, Integer&gt; &#123;</span><br><span class="line">&#125;            <span class="comment">// 只要继承 ElasticsearchRepository，自带save(),delete()等方法</span></span><br></pre></td></tr></table></figure></li>
<li>搜索<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DiscussPostRepository discussRepository;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ElasticsearchTemplate elasticTemplate;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveDiscussPost</span><span class="params">(DiscussPost post)</span> &#123;</span><br><span class="line">    discussRepository.save(post);             <span class="comment">// 先要把（加了注解的）实体类存入 Es</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Page&lt;DiscussPost&gt; <span class="title function_">searchDiscussPost</span><span class="params">(String keyword, <span class="type">int</span> current, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">    <span class="type">SearchQuery</span> <span class="variable">searchQuery</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NativeSearchQueryBuilder</span>()</span><br><span class="line">            .withQuery(QueryBuilders.multiMatchQuery(keyword, <span class="string">&quot;title&quot;</span>, <span class="string">&quot;content&quot;</span>)) <span class="comment">// 搜索规则</span></span><br><span class="line">            .withSort(SortBuilders.fieldSort(<span class="string">&quot;type&quot;</span>).order(SortOrder.DESC))        <span class="comment">// 排序规则</span></span><br><span class="line">            .withPageable(PageRequest.of(current, limit))                          <span class="comment">// 分页</span></span><br><span class="line">            .withHighlightFields(                                                  <span class="comment">// 设置高亮</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">HighlightBuilder</span>.Field(<span class="string">&quot;title&quot;</span>).preTags(<span class="string">&quot;&lt;em&gt;&quot;</span>).postTags(<span class="string">&quot;&lt;/em&gt;&quot;</span>),</span><br><span class="line">            ).build();</span><br><span class="line">    <span class="keyword">return</span> elasticTemplate.queryForPage(searchQuery, DiscussPost.class, <span class="keyword">new</span> <span class="title class_">SearchResultMapper</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; AggregatedPage&lt;T&gt; <span class="title function_">mapResults</span><span class="params">(SearchResponse response, Class&lt;T&gt; aClass, Pageable pageable)</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AggregatedPageImpl</span>(...);          &#125;      &#125;);  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h2><p>账号：<code>1908454905@qq.com</code><br>Postman 是一个流行的 API测试工具和开发环境，它为开发人员提供了一种方便的方式来创建、测试、文档化和共享API。<br><strong>API 测试：</strong> Postman 的主要功能之一是允许用户发送 HTTP 请求以测试 API 端点。您可以创建 GET、POST、PUT、DELETE 等不同类型的请求，并附加参数、标头和正文数据以模拟与 API 交互。<br><strong>集合和环境：</strong> Postman 允许您组织测试请求到集合中。集合是一组相关的请求，可以方便地进行批量执行和管理。您还可以使用环境变量来动态地管理请求中的数据，以便在不同环境中轻松切换。<br><strong>自动化测试：</strong> Postman 提供了测试脚本功能，您可以使用 JavaScript 编写测试脚本，以验证 API 响应是否符合预期。这使得您可以创建自动化测试套件，确保 API 的稳定性和正确性。<br><strong>协作和共享：</strong> Postman 允许用户创建工作空间，多个团队成员可以在同一个工作空间中协作。您还可以共享 Postman 集合和环境，以便其他人可以重复您的测试或使用您的 API。</p>
<h2 id="项目调试技巧"><a href="#项目调试技巧" class="headerlink" title="项目调试技巧"></a>项目调试技巧</h2><ul>
<li>相应<strong>状态码</strong>：200 - 成功，302 - 重定向（让浏览器再发一个请求），404 - 找不到路径，500 - 服务器遇到问题（服务端有bug）</li>
<li>服务端断点调试：方法中一行代码前打断点，以debug形式启动类。启动服务后，停止在断点处，F8向下执行一步&#x2F;F7进入方法内部&#x2F;F9直接执行到下一个断点，观察参数如何变化。</li>
<li>客户端断点调试：在浏览器打开开发者工具，对js文件打断点</li>
<li>设置日志级别，并将日志输出到不同的终端<br>trace-debug-log-warn-error，按照级别记录日志，动态地启用级别。可以在<code>application.properties</code>配置 logger<br>或在&#x2F;resource下放置一个名为logback-spring.xml的文件，自动配置logger（日志存放文件大小、日志类型、存放位置、名字…）</li>
<li><strong>在&#x2F;test下创建带@Test注解的测试类，直接对某一个mapper&#x2F;service&#x2F;..类进行测试。</strong><br>通过以下注解结合在一起，可以在测试中创建一个与实际应用程序相似的Spring容器，并运行测试。这样可以确保测试能够在实际的Spring环境中运行，并且可以访问和测试应用程序中的各种组件。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span>  <span class="comment">// 此注解用于指定运行测试的运行器，通常与JUnit一起使用。`SpringRunner`是Spring提供的一个JUnit运行器，用于在测试中启用Spring支持。</span></span><br><span class="line"><span class="meta">@SpringBootTest</span>  <span class="comment">// 这个注解告诉Spring Boot测试框架要加载整个Spring应用程序上下文，包括所有的bean。它是一个高级版本的`@ContextConfiguration`，它会尝试自动配置Spring应用程序上下文，通常用于集成测试。</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = CommunityApplication.class)</span>  <span class="comment">// 这个注解用于指定要加载的Spring配置类。在这里，`CommunityApplication.class`是Spring Boot应用程序的主配置类，它包含了应用程序的配置信息。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><ul>
<li>Spring Boot Testing<ul>
<li>依赖：spring-boot-starter-test</li>
<li>包括：Junit、Spring Test、AssertJ、、、</li>
</ul>
</li>
<li>Test Case 测试用例<ul>
<li>要求：保证测试方法的独立性。</li>
<li>步骤：初始化数据、执行测试代码、验证测试结果、清理测试数据。</li>
<li>常用注解：@BeforeClass、@AfterClass、@Before、@After。</li>
</ul>
</li>
</ul>
<h2 id="项目监控"><a href="#项目监控" class="headerlink" title="项目监控"></a>项目监控</h2><ul>
<li>Spring Boot Actuator<ul>
<li>Endpoints：监控应用的入口，Spring Boot内置了很多端点，也支持自定义端点。</li>
<li>监控方式：HTTP 或 JMX。</li>
<li>访问路径：例如“&#x2F;actuator&#x2F;health”</li>
<li>注意事项：按需配置暴露的端点，并对所有端点进行权限控制。</li>
</ul>
</li>
</ul>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ul>
<li>本地缓存<br>将数据缓存在应用服务器上，性能最好。如热帖、、<br>常用缓存工具: Ehcache、Guava、Caffeine等</li>
<li>分布式缓存<br>将数据缓存在NoSQL数据库上，跨服务器。如登录信息（不管在哪台服务器上都要查得到）<br>常用缓存工具: MemCache、Redis等.</li>
<li>多级缓存<br>一级缓存(本地缓存) &gt; 二级缓存(分布式缓存) &gt; DB(避免访问数据库)，每级缓存的内存大小、存储时间都不一样<br>服务器受到请求，先查看本地缓存，再查redis（分布式缓存），都没有才查DB，同时同步到本地和分布式缓存上<br>避免<strong>缓存雪崩</strong>(缓存失效，大量请求直达DB)，提高系统的可用性<br><img src="https://github.com/leo710aka/bk/blob/main/cache.png?raw=true"></li>
</ul>
<h2 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h2><ul>
<li>节点：K8s中最小的<strong>计算硬件单元</strong>。它是集群中单个机器的表示。节点可能是物理机器或者虚拟机，理论上可以是任何东西。</li>
<li>集群：K8s中节点汇聚资源，形成更强大的机器。将程序部署到集群中时，它将智能地处理将工作分配给各个节点。如果添加或删除了任何节点，集群将根据需要在工作中进行转换。这对程序或程序员来说都不重要，因为机器实际上是在运行代码。</li>
<li>Namespace(命名空间, 是一个逻辑隔离的环境,用于资源分组和隔离) -&gt; InfluxDB集群，Pod(Kubernetes的基本计算单元) -&gt; InfluxDB集群节点(逻辑上)，容器 -&gt; InfluxDB单例(物理上，部署在服务器上) <ul>
<li>Pod 是 Kubernetes 中最小的部署单元，一个 Pod 可以包含一个或多个容器。（pod是逻辑概念；容器是物理概念？？存在于物理服务器上）<br>  K8s 使用控制器（如 Deployment、StatefulSet、DaemonSet 等）来管理 Pod 的生命周期，根据定义的期望状态（如副本数量、更新策略等）来创建、更新和删除 Pod。通过 <code>kubectl</code> 命令可以查看、管理和调试 Pod。</li>
<li>容器是运行在 Pod 中的实际应用实例。K8s 使用容器运行时（如 Docker、containerd 等）来管理容器的生命周期。<br>  每个容器运行一个镜像，容器的配置（如环境变量、挂载卷、资源限制等）在 Pod 的定义中指定。</li>
<li>镜像是容器的基础，包含了应用程序及其依赖环境。镜像通常存储在镜像仓库（如 Docker Hub、Google Container Registry 等）中。</li>
</ul>
</li>
<li>虽然 Pod 是 K8s 的<strong>基本计算单元</strong>，但它们通常不是直接在集群上启动的。相反，Pod 通常由一个抽象层来管理：部署。不必手动处理 Pod，只需声明系统的期望状态，它将自动管理。可以创建一个节点集群，并将Pod部署到集群上。如果需要允许外部通信流进入你的应用程序，与运行在Pod中的服务通信，必须打开一个通信通道，称作入口(ingress)。</li>
<li>关于 InfluxDB 集群的部署和通信：<ul>
<li>部署方式：对于一个命名空间下的几个Pod，这些节点会通过 StatefulSet 或者 Deployment 来进行管理和部署。</li>
<li>调度到主机：K8s 的调度器会根据资源需求、节点的可用资源以及调度策略（如反亲和性、亲和性等）来决定 Pod 部署到哪台主机上。你可以使用以下命令查看 Pod 所在的节点信息：<code>kubectl get pod -n influxdb -o wide</code></li>
<li>通信调度：K8s 中，Pod 之间的通信通常通过 Service 来进行。Service 会为一组 Pod 提供一个稳定的 IP 地址和 DNS 名称。对于 InfluxDB 集群，可能会有一个或多个 Service 来管理数据节点和元数据节点之间的通信。你可以使用以下命令查看 InfluxDB 命名空间中的 Service：<code>kubectl get svc -n influxdb</code></li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/31/Java%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" data-id="cm2rjvvgl0006b4v57qtref5v" data-title="java 后端开发 工程师" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-算法题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/09/08/%E7%AE%97%E6%B3%95%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2020-09-08T08:23:20.000Z" itemprop="datePublished">2020-09-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/09/08/%E7%AE%97%E6%B3%95%E9%A2%98/">算法 | 数组 / 链表 / 哈希表 / 字符串 / 栈 / 队列 / 二叉树 / 图 / 贪心 / 回溯 / 动态规划</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><ul>
<li><strong>二分查找：</strong> 前提是数组为有序数组，同时题目还强调数组中无重复元素。想清楚对<strong>区间</strong>的定义，区间的定义就是不变量。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是循环不变量规则。<br>写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;                     <span class="comment">// 第一种写法，我们定义 target 是在一个在左闭右闭的区间里，也就是[left, right] （这个很重要非常重要）。</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;                                     <span class="comment">// 要使用 &lt;= ，因为left == right有意义</span></span><br><span class="line">        <span class="type">int</span> middle = left + (right - left) / <span class="number">2</span>;                 <span class="comment">// 避免left + right溢出</span></span><br><span class="line">        <span class="keyword">if</span> (nums[middle] &gt; target) &#123; right = middle - <span class="number">1</span>; &#125;      <span class="comment">// 因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) &#123; left = middle + <span class="number">1</span>; &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="keyword">return</span> middle;&#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;                                                  <span class="comment">// 当right &lt; left，说明不存在targrt</span></span><br><span class="line">&#125;                                                              </span><br></pre></td></tr></table></figure></li>
<li><strong>二分查找第一个位置：</strong> 找出给定目标值在数组中的第一个位置（和结束位置）。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (l + r)/ <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[i] == target) &#123;</span><br><span class="line">        r = i - <span class="number">1</span>;</span><br><span class="line">        first = i;   <span class="comment">// 重点, 如果找最后一个位置的话就是 l = i + 1;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &lt; target) &#123;</span><br><span class="line">        l = i + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        r = i - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;                                                           </span><br></pre></td></tr></table></figure></li>
<li><font color= "#87CEFA"> <strong>二分查找插入</strong> </font>：在排序数组中寻找是否存在一个目标值，且如果不存在数组中的时候需要返回按顺序插入的位置。可以将两个条件合并得出最后的目标：「在一个有序数组中找第一个大于等于 target 的下标」，此时需要对二分法稍作修改，不断用二分法逼近查找第一个大于等于 target 的下标 。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> ((right - left) &gt;&gt; <span class="number">1</span>) + left;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) </span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><font color= "#87CEFA"> <strong>x 的平方根</strong> </font><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><ul>
<li><font color= "#87CEFA"> <strong>原地移除</strong> </font>（快慢指针法）通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。（前后指针）<br>给你一个数组 nums 和一个值 val，你需要 <strong>原地</strong> 移除所有数值等于 val 的元素，并返回移除后数组的新长度。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> fast = <span class="number">0</span>; fast &lt; nums.<span class="built_in">size</span>(); fast++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fast] != val) &#123;       <span class="comment">// 此时快指针指向 新数组（原数组去除了val）中的元素</span></span><br><span class="line">            nums[slow] = nums[fast];   <span class="comment">// 用慢指针，直接在原数组的基础上得到去除了 val 的新数组</span></span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>盛最多水的容器：给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>初始化：双指针 i, j 分列水槽左右两端；循环收窄：选定两板高度中的短板，向中间收窄一格，同时更新面积最大值 res，直至双指针相遇时跳出。</li>
<li><font color= "#87CEFA"> <strong>两数之和II</strong> </font>：</li>
</ul>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><ul>
<li>所谓滑动窗口，就是不断的调节子序列的起始位置和终止位置，用一个for循环代替两个for循环的功能实现，从而将O(n^2)暴力解法降为O(n)。只用一个for循环，那么这个循环的索引，一定是表示 滑动窗口的终止位置，问题是 如何移动滑动窗口的起始位置。</li>
<li><font color= "#87CEFA"> <strong>最小连续子数组：</strong> </font>找出数组中满足其和 ≥ target 的长度最小的 连续子数组 并返回其长度<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;   </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, sum = <span class="number">0</span>, ans = INT_MAX ;        <span class="comment">// i 滑动窗口起始位置，j 滑动窗口结束位置，当前活动窗口内和</span></span><br><span class="line">    <span class="keyword">for</span> (; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">        sum = sum + nums[j];                          <span class="comment">// j 后移</span></span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">            ans = (j - i + <span class="number">1</span>) &lt; ans ? (j - i + <span class="number">1</span>) : ans;</span><br><span class="line">            sum = sum - nums[i++];                    <span class="comment">// i 前移</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;         <span class="comment">// ！！！ O(n):不要以为for里放一个while就以为是O(n^2)啊，主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是 2 × n 也就是O(n)。</span></span><br><span class="line">    <span class="keyword">return</span> ans == INT_MAX ? <span class="number">0</span> : ans;                 <span class="comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a>模拟实现</h4><p>数组是非常基础的数据结构，在面试中，考察数组的题目一般在思维上都不难，主要是考察对代码的掌控能力。<br>螺旋数组，打印数组。。。</p>
<hr>

<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><ul>
<li><strong>链表操作中的头结点处理：</strong>在 Java 中，处理链表的头结点可以直接使用原始链表进行删除操作，也可以采用设置虚拟头结点的方式进行操作。虚拟头结点是一个不存储任何实际数据的头结点，它可以简化链表操作，避免对头结点进行特殊处理。</li>
<li>需要用到头结点时，使用 ListNode* cur &#x3D; head 进行链表操作，不要直接使用头结点操作！！！ </li>
<li><strong>空指针的判断：</strong>使用 <code>if (ptr != null)</code> 来判断一个对象是否为空。Java 中的空指针用 <code>null</code> 关键字（不是一个宏定义）表示，而不是像 C++ 中的 <code>nullptr</code>。</li>
<li><font color= "#87CEFA"> <strong>设计链表：</strong> </font>设计节点的结构，链表的结构和五个函数：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;  <span class="comment">// 设计链表中节点的数据结构</span></span><br><span class="line">        <span class="type">int</span> val;      <span class="comment">// 节点上存储的元素</span></span><br><span class="line">        ListNode next; <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line"></span><br><span class="line">        ListNode(<span class="type">int</span> x) &#123;  <span class="comment">// 节点的构造函数</span></span><br><span class="line">            val = x;</span><br><span class="line">            next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode dummyhead; <span class="comment">// 虚拟（假）头结点</span></span><br><span class="line">    <span class="type">int</span> size;           <span class="comment">// 记录链表长度，在add, delete操作前进行判断</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        dummyhead = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123; <span class="comment">// 获取链表中第 index 个节点的值。如果索引无效，则返回-1。</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummyhead.next;</span><br><span class="line">        <span class="keyword">while</span> (index-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123; <span class="comment">// 在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        cur.next = dummyhead.next;</span><br><span class="line">        dummyhead.next = cur;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123; <span class="comment">// 将值为 val 的节点追加到链表的最后一个元素</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummyhead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = tail;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123; <span class="comment">// 在链表中的第 index 个节点之前添加值为 val  的节点。</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;  <span class="comment">// 根据下标判断插入位置</span></span><br><span class="line">            addAtHead(val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">            addAtTail(val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummyhead;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">            <span class="keyword">while</span> (index-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            node.next = cur.next;</span><br><span class="line">            cur.next = node;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123; <span class="comment">// 如果索引 index 有效，则删除链表中的第 index 个节点。</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummyhead;</span><br><span class="line">        <span class="keyword">while</span> (index-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">nex</span> <span class="operator">=</span> cur.next.next;</span><br><span class="line">        cur.next = nex;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>链表翻转：</li>
<li><font color= "#87CEFA"> <strong>环：</strong> </font> 相遇<br>1.判断有无环： 定义快慢指针，慢的先走，快的后走，一次一步。若有环，快指针必然追上满指针，且相遇位置必然在环内。<br>2.确定环的入口： 定义两个指针，一个位于链表头指针，一个位于快慢指针相遇位置。这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点。</li>
</ul>
<hr>

<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><ul>
<li>在 Java 中，哈希（Hash）是将数据映射到固定大小的散列值的技术。哈希函数用于将输入数据转换为散列值，通常用于快速查找或存储数据。通过调用对象的 <code>hashCode()</code> 方法获得数据的散列码（hash code）。同时，Java 中也提供了 <code>java.util.Objects</code> 类，其中包含了 <code>hash()</code> 方法，用于计算对象的哈希值。<br>Java 的标准库提供了 <code>java.util</code> 包中的一些类和接口，比如 <code>HashMap</code>、<code>HashSet</code> 等。</li>
<li>什么时候使用哈希法？当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。</li>
<li><font color= "#87CEFA"> <strong>四数之和II：</strong> </font>四个数组各组一个元素，四元素和为0。找出四数的不同组合个数。<br><strong>两个哈希表</strong>：map1，map2，分别记录 num1与num2 各种组合的和的个数，num3与num4 各种组合的和的个数<br>for(auto pair : map1)，若 map2[0 - pair.first] 存在，则 ans +&#x3D; pair.second * map2[0 - pair.first]</li>
<li><font color= "#87CEFA"> <strong>三数之和：</strong> </font>一个数组，找出其中三个元素和为0。找出所有不重复的三元组。<br><strong>一层循环（a） + 每层循环中双指针（b，c）</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());                          <span class="comment">// 首先将数组排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">2</span>; i++) &#123;               <span class="comment">// 一层for循环（a）</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)  <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i<span class="number">-1</span>])  <span class="keyword">continue</span>;            <span class="comment">// 去重a！！！    </span></span><br><span class="line">        <span class="type">int</span> left = i + <span class="number">1</span>;                                    <span class="comment">// 循环内定义双指针（b，c）</span></span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;                               <span class="comment">// 循环条件！！</span></span><br><span class="line">            <span class="comment">// 不要在这里直接先去重b，c，免得一个答案都没有</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] == <span class="number">0</span>) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(&#123;nums[i], nums[left], nums[right]&#125;);  </span><br><span class="line">                <span class="comment">// 一定要先执行上一句代码，即先找到一个答案 【0,0,0,0,0】</span></span><br><span class="line">                <span class="comment">// 再去执行下两句，去重b，c！！！    </span></span><br><span class="line">                <span class="keyword">while</span> (left&lt;right &amp;&amp; nums[left]==nums[left+<span class="number">1</span>])    left++;</span><br><span class="line">                <span class="keyword">while</span> (left&lt;right &amp;&amp; nums[right]==nums[right<span class="number">-1</span>])  right--;</span><br><span class="line">                <span class="comment">// 找到答案，左右指针同时收缩 【-2，0，0,2,2】</span></span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>)     left++;</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>)     right--; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><font color= "#87CEFA"> <strong>四数之和：</strong> </font> 和三数之和是一个思路，都是使用双指针法, 基本解法就是在三数之和的基础上再套一层for循环。<br>四数之和的双指针解法是两层for循环nums[k] + nums[i]为确定值，依然是循环内有left和right下标作为双指针，找出nums[k] + nums[i] + nums[left] + nums[right] &#x3D;&#x3D; target的情况，三数之和的时间复杂度是O(n^2)，四数之和的时间复杂度是O(n^3) 。</li>
</ul>
<hr>


<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><ul>
<li>Java 中并没有像 Cpp中的 <code>getline</code> 函数，而是可以使用 <code>Scanner</code> 或者 <code>BufferedReader</code> 从控制台读取一行文本。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> scanner.nextLine(); <span class="comment">// ...</span></span><br><span class="line">scanner.close();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"><span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">reader.close();</span><br></pre></td></tr></table></figure></li>
<li><font color= "#87CEFA"> <strong>翻转字符串里的单词：</strong> </font>移除多余空格、将整个字符串反转、将每个单词反转<br>移除多余空格：参考快慢指针原地去除数组特定元素的方法<a target="_blank" rel="noopener" href="https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html#%E6%80%9D%E8%B7%AF">（题目见）</a><br><strong>翻转问题：</strong>考虑 <strong>部分翻转 + 整体翻转</strong><br><strong>同构字符串：</strong>需要我们判断 s 和 t 每个位置上的字符是否都一一对应，即 s 的任意一个字符被 t 中唯一的字符对应，同时 t 的任意一个字符被 s 中唯一的字符对应。这也被称为「双射」的关系。<br>因此，我们维护两张哈希表，第一张哈希表 s2t 以 s 中字符为键，映射至 t 的字符为值，第二张哈希表 t2s 以 t 中字符为键，映射至 s 的字符为值。从左至右遍历两个字符串的字符，不断更新两张哈希表，如果出现冲突（即遍历 s 当前下标 i 已经存在映射 s2t.get(s.charAt(i)) 且不为 t.charAt(i)，或遍历 t 当前下标 i 已经存在映射 t2s.get(t.charAt(i)) 且不为 s.charAt(i)）说明两个字符串无法构成同构，返回 false</li>
<li><font color= "#87CEFA"> <strong>KMP模式匹配：</strong> </font>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。<br><strong>子串和主串匹配出现冲突 -&gt; 寻找子、主串匹配冲突位置前部分的最长相等前后缀（查冲突位置前一位在前缀表中的值[next数组]） -&gt; 子串匹配位置返回到相等前缀后一位（即冲突位置在next中的值），主串匹配位置不移动（也即返回到相等后缀后一位），再次开始匹配。</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string&amp; s)</span> </span>&#123;      <span class="comment">// 1. 利用模式串s，构造前缀表next</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;                                  <span class="comment">// （若j为 -1，前缀表要进行统一减一的操作）</span></span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;                                <span class="comment">// next[i] 表示 i（包括i）之前最长相等的前后缀长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;         <span class="comment">// 注意i从1开始</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) &#123;         <span class="comment">// j前后缀不相同了（要保证大于0，因为下面有取j-1作为数组下标的操作</span></span><br><span class="line">            j = next[j - <span class="number">1</span>];                    <span class="comment">// 向前回退（注意这里，是要找前一位的对应的回退位置了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j]) &#123;                     <span class="comment">// 找到相同的前后缀</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j;                            <span class="comment">// 将j（前缀的长度）赋给next[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;        <span class="comment">// 2. 用模式串needle 匹配主串haystack </span></span><br><span class="line">    <span class="keyword">if</span> (needle.<span class="built_in">size</span>() == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> next[needle.<span class="built_in">size</span>()]; </span><br><span class="line">    <span class="built_in">getNext</span>(next, needle);                          <span class="comment">// 用模式串创建next数组 O(n)</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;                                      <span class="comment">// 模式串中当前匹配位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; haystack.<span class="built_in">size</span>(); i++) &#123;     <span class="comment">// O(m)，则KMP算法为O(m+n)</span></span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j]) &#123;  <span class="comment">// 不匹配，j 寻找之前匹配的位置</span></span><br><span class="line">            j = next[j - <span class="number">1</span>];                        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (haystack[i] == needle[j]) &#123;             <span class="comment">// 匹配，j和i同时向后移动</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == needle.<span class="built_in">size</span>() ) &#123;                  <span class="comment">// 文本串s里出现了模式串t</span></span><br><span class="line">            <span class="keyword">return</span> (i - needle.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>

<h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><ul>
<li><font color= "#87CEFA"> <strong>匹配问题都是栈的强项：</strong> </font>括号匹配，相邻元素匹配，逆波兰式匹配<strong>（注意后从栈中弹出的数，是操作符的左操作数）</strong>，，</li>
<li><font color= "#87CEFA"> <strong>滑动窗口最大值：</strong> </font>给定数组 nums，有大小为 k 的滑动窗口从数组的最左侧一位位移向最右侧。每次返回滑动窗口中的最大值。<br><code>单调队列</code>：<strong>维护一个单调递增（减）的队列，最大（小）值在队首。单调队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队列里的元素数值是由大到小（小到大）的。</strong>具体做法是：<br>pop()时：若要从滑动窗口中去掉的元素，其值等于此时单调队列队首值（即最大值），那么将队首元素从deque.front()弹出。滑动窗口每次向右滑动，先pop()，后push()。<br>push()时：从双向队列末尾push数值，若大于前面的数，那么将前面的数从deque.back()弹出，直到push的数值小于等于其前面元素的数值为止。这样就保持了队列里的数值是单调从大到小的了，且最大值在队首deque.front()。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:                 <span class="comment">// !!！ 注意别漏了public，否则默认private无法从变量访问</span></span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; que; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!que.<span class="built_in">empty</span>() &amp;&amp; value == que.<span class="built_in">front</span>()) &#123;</span><br><span class="line">            que.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>() &amp;&amp; value &gt; que.<span class="built_in">back</span>()) &#123;</span><br><span class="line">            que.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        que.<span class="built_in">push_back</span>(value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> que.<span class="built_in">front</span>();  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><font color= "#87CEFA"> <strong>前 K 个高频元素：</strong> </font>给定一个非空的整数数组，返回出现频率前 k 高的元素。<br><strong><code>优先级队列</code><strong>：</strong>其实就是一个披着队列外衣的堆，对外接口只是从队头取元素，从队尾添加元素，且优先级队列内部元素是自动依照元素的权值排列。</strong>  缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，这个大顶堆是以vector为表现形式的complete binary tree（完全二叉树）。<br><strong><code>堆</code></strong> 是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。每次pop()弹出堆顶元素。<br><code>priority_queue</code>：c++中已实现的数据结构，其底层实现等同于堆，从小到大排就是小顶堆，从大到小排就是大顶堆。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">mycomparison</span> &#123;                <span class="comment">// 小顶堆</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; lhs, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; rhs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.second &gt; rhs.second;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;                    </span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;        <span class="comment">// 要统计元素出现频率                  </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    map[nums[i]]++; &#125;</span><br><span class="line"><span class="comment">// 对频率排序, 维护一个大小固定为k的小顶堆，扫面所有频率的数值</span></span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, mycomparison&gt; pri_que;  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> pair : map) &#123;</span><br><span class="line">    pri_que.<span class="built_in">push</span>(pair);</span><br><span class="line">    <span class="keyword">if</span> (pri_que.<span class="built_in">size</span>() &gt; k) &#123;       <span class="comment">// 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k</span></span><br><span class="line">        pri_que.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="LinkedList（双向链表）"><a href="#LinkedList（双向链表）" class="headerlink" title="LinkedList（双向链表）"></a><code>LinkedList</code>（双向链表）</h3><p>在 Java 中，<code>LinkedList</code> 是双向链表的实现，每个元素都包含一个指向前一个元素和一个指向后一个元素的指针。这使得插入和删除操作在链表中非常高效，但随机访问较慢。以下是 <code>LinkedList</code> 的一些常见用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; myList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        myList.addLast(<span class="number">1</span>);                          <span class="comment">// 插入元素到链表尾部</span></span><br><span class="line">        myList.addFirst(<span class="number">2</span>);                         <span class="comment">// 插入元素到链表头部</span></span><br><span class="line">        myList.add(<span class="number">1</span>, <span class="number">3</span>);                           <span class="comment">// 在指定位置插入元素</span></span><br><span class="line">        myList.removeLast();                        <span class="comment">// 移除链表尾部元素</span></span><br><span class="line">        myList.removeFirst();                       <span class="comment">// 移除链表头部元素</span></span><br><span class="line">        myList.remove(<span class="number">1</span>);                            <span class="comment">// 移除指定位置的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> item : myList) &#123; System.out.print(item + <span class="string">&quot; &quot;</span>); &#125; <span class="comment">// 遍历链表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Deque（双端队列）"><a href="#Deque（双端队列）" class="headerlink" title="Deque（双端队列）"></a><code>Deque</code>（双端队列）</h3><p><code>Deque</code> 是双端队列容器的实现，支持在两端进行高效的插入和删除操作，并且允许随机访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Deque&lt;Integer&gt; myDeque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        myDeque.addLast(<span class="number">1</span>);                         <span class="comment">// 插入元素到队列尾部</span></span><br><span class="line">        myDeque.addFirst(<span class="number">2</span>);                        <span class="comment">// 插入元素到队列头部</span></span><br><span class="line">        myDeque.removeLast();                       <span class="comment">// 移除队列尾部元素</span></span><br><span class="line">        myDeque.removeFirst();                      <span class="comment">// 移除队列头部元素</span></span><br><span class="line">        myDeque.addLast(<span class="number">3</span>);                         <span class="comment">// 随机访问队列</span></span><br><span class="line">        myDeque.addLast(<span class="number">4</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> myDeque.peekFirst();            <span class="comment">// 访问第一个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> item : myDeque) &#123; System.out.print(item + <span class="string">&quot; &quot;</span>); &#125; <span class="comment">// 遍历队列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PriorityQueue（优先队列）"><a href="#PriorityQueue（优先队列）" class="headerlink" title="PriorityQueue（优先队列）"></a><code>PriorityQueue</code>（优先队列）</h3><p>在 Java 中，<code>PriorityQueue</code> 可以实现最大堆和最小堆。默认情况下是最小堆，可通过提供自定的比较器来实现最大堆或最小堆。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="comment">// 实现最大堆：</span></span><br><span class="line">PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b - a); <span class="comment">// 创建最大堆</span></span><br><span class="line">maxHeap.offer(<span class="number">5</span>);  maxHeap.offer(<span class="number">2</span>);  maxHeap.offer(<span class="number">8</span>);  maxHeap.offer(<span class="number">1</span>); <span class="comment">// 向堆中插入元素</span></span><br><span class="line">System.out.println(<span class="string">&quot;最大值：&quot;</span> + maxHeap.peek()); <span class="comment">// 访问堆顶元素（最大值）</span></span><br><span class="line">maxHeap.poll(); <span class="comment">// 弹出堆顶元素</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现最小堆：</span></span><br><span class="line">PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(); <span class="comment">// 创建最小堆</span></span><br><span class="line">minHeap.offer(<span class="number">5</span>);  minHeap.offer(<span class="number">2</span>);  minHeap.offer(<span class="number">8</span>);  minHeap.offer(<span class="number">1</span>); <span class="comment">// 向堆中插入元素</span></span><br><span class="line">System.out.println(<span class="string">&quot;最小值：&quot;</span> + minHeap.peek()); <span class="comment">// 访问堆顶元素（最小值）</span></span><br><span class="line">minHeap.poll(); <span class="comment">// 弹出堆顶元素</span></span><br></pre></td></tr></table></figure>

<br>
<hr>


<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><ol>
<li>满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则为满二叉树。</li>
<li>完全二叉树：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。<br>优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。</li>
<li><strong>二叉搜索树 BST：</strong>具有有序性质，适用于快速查找、插入和删除操作。<br>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>它的左、右子树也分别为二叉排序树</li>
<li><strong>平衡二叉搜索树 AVL：</strong> 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</li>
</ol>
<h3 id="递归（traversal）三要素-确定递归函数的参数和返回值-确定终止条件-确定单层递归的逻辑"><a href="#递归（traversal）三要素-确定递归函数的参数和返回值-确定终止条件-确定单层递归的逻辑" class="headerlink" title="递归（traversal）三要素: 确定递归函数的参数和返回值 -&gt; 确定终止条件 -&gt; 确定单层递归的逻辑"></a><code>递归（traversal）三要素</code>: 确定递归函数的参数和返回值 -&gt; 确定终止条件 -&gt; 确定单层递归的逻辑</h3><ul>
<li><strong>深度优先遍历</strong>：<br>前序遍历（递归法，迭代法）， 中序遍历（递归法，迭代法）， 后序遍历（递归法，迭代法）<br>也可以利用栈实现迭代形式的遍历。</li>
<li><strong>广度优先遍历</strong>：<br>层序遍历（迭代法）一个二叉树。就是从左到右一层一层的去遍历二叉树。借用队列来实现。<br>学会二叉树的层序遍历，可以一口气打下十题：二叉树的右视图，二叉树的层平均值，在每个树行中找最大值，填充每个节点的下一个右侧节点指针，填充每个节点的下一个右侧节点指针II，二叉树的最大深度，二叉树的最小深度，，，<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123; <span class="comment">// 前序遍历（递归法）</span></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(cur-&gt;val);                      <span class="comment">// 先 中间节点</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, vec);                    <span class="comment">// 再 左子树</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, vec);                   <span class="comment">// 再 右子树</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;   <span class="comment">// 前序遍历（迭代法）</span></span><br><span class="line">    stack&lt;TreeNode*&gt; st;                          <span class="comment">// 中、后序遍历的迭代法无法与之简单类比，但存在统一迭代法</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">    st.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* node = st.<span class="built_in">top</span>();                 <span class="comment">// 中</span></span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);     <span class="comment">// 右（空节点不入栈）</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left)  st.<span class="built_in">push</span>(node-&gt;left);      <span class="comment">// 左（空节点不入栈）</span></span><br><span class="line">    &#125;                                              <span class="comment">// 要先加入右孩子再加入左孩子呢,这样出栈的时候才是中左右的顺序。</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;   <span class="comment">// 层序遍历模板</span></span><br><span class="line">    queue&lt;TreeNode*&gt; que;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;  <span class="comment">// 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的</span></span><br><span class="line">            TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            <span class="comment">// for(int i = 0; i &lt; node-&gt;children.size(); i++) &#123;  // 如果有多个孩子节点</span></span><br><span class="line">            <span class="comment">//    if(node-&gt;children[i]) que.push(node-&gt;children[i]) &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><font color= "#87CEFA"> <strong>翻转二叉树：</strong> </font>前序遍历，翻转左右子树，翻转左、右子树的左右子树。</li>
<li><font color= "#87CEFA"> <strong>平衡二叉树：</strong> </font>同时操作两个二叉树。判断对称二叉树不是比较左右节点，要比较的是根节点的左子树与右子树是不是相互翻转的，即其实我们要比较的是两个树（这两个树是根节点的左右子树）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(TreeNode* left, TreeNode* right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先排除空节点的情况、数值不相同的情况</span></span><br><span class="line">    <span class="keyword">if</span> ((left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>)||(left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 左右节点都不为空，且数值相同的情况; 此时才做递归，做下一层的判断</span></span><br><span class="line">    <span class="type">bool</span> outside = <span class="built_in">compare</span>(left-&gt;left, right-&gt;right);   <span class="comment">// 左子树：左、 右子树：右</span></span><br><span class="line">    <span class="type">bool</span> inside = <span class="built_in">compare</span>(left-&gt;right, right-&gt;left);    <span class="comment">// 左子树：右、 右子树：左</span></span><br><span class="line">    <span class="keyword">return</span> outside &amp;&amp; inside;                           <span class="comment">// 左子树：中、 右子树：中 （逻辑处理）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><font color= "#87CEFA"> <strong>二叉树最大深度：</strong> </font>二叉树的最大深度就是根节点的最大深度。一个节点的最大深度 &#x3D; max{ 左孩子的最大深度， 右孩子的最大深度 }<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;         </span><br><span class="line">    <span class="keyword">if</span> (root == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left), <span class="built_in">maxDepth</span>(root-&gt;right)); &#125;</span><br></pre></td></tr></table></figure></li>
<li><font color= "#87CEFA"> <strong>二叉树最小深度：</strong> </font>不能简单地认为一点的最小深度为 1 + min{左,右孩子的深度}，要从根到<code>叶子节点</code>的路径才能算一个深度值。（根到一个中间节点，其某一孩子为空指针，的路径不算一个深度）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">traversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left)  <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">traversal</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;right) <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">traversal</span>(root-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">min</span>(<span class="built_in">traversal</span>(root-&gt;left), <span class="built_in">traversal</span>(root-&gt;right)); &#125;</span><br></pre></td></tr></table></figure></li>
<li><font color= "#87CEFA"> <strong>二叉搜索树：</strong> </font>二叉搜索树可是有序的。遇到在二叉搜索树上求什么最值啊，差值之类的，就把想成在它通过中序遍历转换成的一个有序数组上求最值，求差值，，</li>
<li><font color= "#87CEFA"> <strong>二叉搜索树中的众数：</strong> </font>遍历+双指针，，，，</li>
<li><font color= "#87CEFA"> <strong>从前序与中序遍历序列构造二叉树：</strong> </font>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; indexMap;</span><br><span class="line"><span class="comment">// 每次结合preorder和inorder数组确定一个根节点（画图看很清晰）</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">myBuildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder, <span class="type">int</span> preorder_left, <span class="type">int</span> preorder_right, </span></span><br><span class="line"><span class="params">                <span class="type">int</span> inorder_left, <span class="type">int</span> inorder_right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (preorder_left &gt; preorder_right) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[preorder_left]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">inorderIndex</span> <span class="operator">=</span> indexMap.get(preorder[preorder_left]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> inorderIndex - inorder_left;     </span><br><span class="line">    <span class="comment">// 递归地确定当前根节点的左右子树的根节点</span></span><br><span class="line">    root.left = myBuildTree(preorder, inorder, preorder_left+<span class="number">1</span>, preorder_left+leftSize, inorder_left, inorderIndex-<span class="number">1</span>);</span><br><span class="line">    root.right = myBuildTree(preorder, inorder, preorder_left+leftSize+<span class="number">1</span>, preorder_right, inorderIndex+<span class="number">1</span>, inorder_right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">    indexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> inorder.length;</span><br><span class="line">    <span class="comment">// 记录当前根节点（preorder数组第一位）在inorder数组中的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) indexMap.put(inorder[i], i);</span><br><span class="line">    <span class="keyword">return</span> myBuildTree(preorder, inorder, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><font color= "#87CEFA"> <strong>二叉树求最小公共祖先：</strong> </font>需要从底向上遍历，那么二叉树，只能通过后序遍历（即：回溯）实现从底向上的遍历方式。<br>在回溯的过程中，必然要遍历整棵二叉树，即使已经找到结果了，依然要把其他节点遍历完，因为要使用递归函数的返回值（也就是代码中的left和right）做逻辑判断。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> || root == p || root == q) &#123; <span class="comment">// 递归结束条件</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123; <span class="comment">// 若未找到节点 p 或 q</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123; <span class="comment">// 若找到一个节点</span></span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123; <span class="comment">// 若找到一个节点</span></span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">// 若找到两个节点</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>

<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h3 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a><strong>深度优先搜索（DFS）</strong></h3><ul>
<li>DFS从起始节点开始，沿着一条路径一直访问到最深处，然后回溯到上一层，继续访问其他路径。它通过递归或栈实现，保证深度遍历直到底部，然后回溯继续探索其他路径。</li>
<li>dfs的代码框架: （其实dfs就是回溯，其实二叉树的前中后序遍历就是dfs）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(参数)</span> </span>&#123;           </span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (选择：本节点所连接的其他节点) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="built_in">dfs</span>(图，选择的节点); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><font color= "#87CEFA"> <strong>所有可能的路径：</strong> </font>给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点 n-1 的路径并输出（不要求按特定顺序）。 graph[i] 是一个从节点 i 可以访问的所有节点的列表（即从节点 i 到节点 graph[i][j]存在一条有向边）。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; ans;  <span class="comment">// 结果路劲列表</span></span><br><span class="line">List&lt;Integer&gt; path;       <span class="comment">// 当前路劲</span></span><br><span class="line"><span class="comment">// index表示从当前深搜到哪个节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] graph, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(index == (graph.length - <span class="number">1</span>)) &#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));  <span class="comment">// ！！不要ans.add(path); 否则加入的是引用的同一个对象</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; graph[index].length; i++) &#123;</span><br><span class="line">        path.add(graph[index][i]);</span><br><span class="line">        dfs(graph, graph[index][i]);</span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">allPathsSourceTarget</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">    path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    path.add(<span class="number">0</span>);</span><br><span class="line">    dfs(graph, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a><strong>广度优先搜索（BFS）</strong></h3><ul>
<li>BFS从起始节点开始，依次访问其邻居节点，然后访问邻居节点的邻居，以此类推。它通过队列实现，保证先访问离起始节点近的节点，再访问离起始节点远的节点。</li>
<li>广搜代码模板：（该模板针对的 是 四方格地图模型）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;; <span class="comment">// 表示四个方向</span></span><br><span class="line"><span class="comment">// grid 是地图，也就是一个二维数组</span></span><br><span class="line"><span class="comment">// visited 标记访问过的节点，不要重复访问</span></span><br><span class="line"><span class="comment">// x, y 表示开始搜索节点的下标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; que;                       <span class="comment">// 定义队列</span></span><br><span class="line">    que.<span class="built_in">push</span>(&#123;x, y&#125;);                                <span class="comment">// 起始节点加入队列</span></span><br><span class="line">    visited[x][y] = <span class="literal">true</span>;                            <span class="comment">// 只要加入队列，立刻标记为访问过的节点</span></span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;                            <span class="comment">// 开始遍历队列里的元素</span></span><br><span class="line">        pair&lt;<span class="type">int</span> ,<span class="type">int</span>&gt; cur = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>(); <span class="comment">// 从队列取元素</span></span><br><span class="line">        <span class="type">int</span> curx = cur.first;</span><br><span class="line">        <span class="type">int</span> cury = cur.second;                       <span class="comment">// 当前节点坐标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;                <span class="comment">// 开始想当前节点的四个方向左右上下去遍历</span></span><br><span class="line">            <span class="type">int</span> nextx = curx + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nexty = cury + dir[i][<span class="number">1</span>];            <span class="comment">// 获取周边四个方向的坐标</span></span><br><span class="line">            <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= grid.<span class="built_in">size</span>() || nexty &lt; <span class="number">0</span> || nexty &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>())</span><br><span class="line">                <span class="keyword">continue</span>;                            <span class="comment">// 坐标越界了，直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[nextx][nexty]) &#123;            <span class="comment">// 如果节点没被访问过</span></span><br><span class="line">                que.<span class="built_in">push</span>(&#123;nextx, nexty&#125;);            <span class="comment">// 队列添加该节点为下一轮要遍历的节点</span></span><br><span class="line">                visited[nextx][nexty] = <span class="literal">true</span>;        <span class="comment">// 只要加入队列立刻标记，避免重复访问</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<br>




<hr>

<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优。</strong><br>难点就是如何通过局部最优，推出整体最优。靠自己手动模拟，如果模拟可行就可以试一试贪心策略，如果不可行可能需要动态规划。<br>如何验证可不可以用贪心算法呢？最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧。<br>如果需要严格的数学证明，一般有两种方法：数学归纳法、反证法。<br>可以说：刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心。</p>
<h3 id="贪心一般解题步骤"><a href="#贪心一般解题步骤" class="headerlink" title="贪心一般解题步骤"></a>贪心一般解题步骤</h3><p>一般分为如下四步：<br>1.将问题分解为若干个子问题  2. 找出适合的贪心策略  3. 求解每一个子问题的最优解  4. 将局部最优解堆叠成全局最优解<br>这个四步其实过于理论化了，，，做题的时候，只要想清楚 局部最优 是什么，如果推导出全局最优，其实就够了。</p>
<ul>
<li><p><font color= "#87CEFA"> <strong>最大子序和：</strong> </font>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>示例：输入 [-2,1,-3,4,-1,2,1,-5,4]，输出 6。解释:  连续子数组  [4,-1,2,1] 的和最大，为  6<br><strong>解答</strong>：直接遍历一路加过去就行，记录目前的“连续和”以及最大“连续和”，当目前的“连续和”为负数时置0，“重新”开始计算“连续和”。<br><strong>局部最优：</strong>当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。全局最优：选取最大“连续和”</p>
</li>
<li><p><font color= "#87CEFA"> <strong>摆动序列：</strong></font></p>
</li>
<li><p><font color= "#87CEFA"> <strong>买卖股票的最佳时机 II：</strong> </font>给定股票每天的价格，计算所能获取的最大利润，可以尽可能地完成更多的交易（多次买卖一支股票）。在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候最多只能持有 一股 股票。<br><strong>解答</strong>：想到选一个低的买入，再选个高的卖，再选一个低的买入…..循环反复。即最终利润是可以分解的，把利润分解为每天为单位的维度，而不是从 0 天到第 n 天整体去考虑，那么根据 prices 可以得到每天的利润序列：(prices[i] - prices[i - 1])…..(prices[1] - prices[0])。最大利润就是取其中的所有正值之和。</p>
</li>
<li><p><font color= "#87CEFA"> <strong>跳跃游戏 II：</strong></font></p>
</li>
<li><p><font color= "#87CEFA"> <strong>加油站：</strong></font>环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。从其中的一个加油站出发，开始时油箱为空。如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。<br><strong>解答</strong>：首先如果总油量减去总消耗大于等于零，那么一定可以跑完一圈，即各个站点的加油站 剩油量rest[i]&#x3D;gas[i] - cost[i] 相加之和一定是大于等于零的。令 i 从0开始累加 rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，因为这个区间选择任何一个位置作为起点，到i这里都会断油，那么起始位置从i+1算起，再从0计算curSum。<br><strong>局部最优：</strong>当前累加rest[i]的和curSum一旦小于0，起始位置至少要是i+1，因为从i之前开始一定不行。全局最优：找到可以跑一圈的起始位置。</p>
</li>
<li><p><font color= "#87CEFA"> <strong>分发糖果：</strong></font>ratings[] 表示每个孩子的评分。你需要按照以下要求，给这些孩子分发糖果：1、每个孩子至少分配到 1 个糖果。2、相邻两个孩子评分更高的孩子会获得更多的糖果。<br><strong>解答</strong>：这道题目<strong>一定是要确定一边之后，再确定另一边</strong>，例如比较每一个孩子的左边，然后再比较右边，如果两边一起考虑一定会顾此失彼。先确定右边评分大于左边的情况（也就是从前向后遍历）只要右边评分比左边大，右边的孩子就多一个糖果；再确定左孩子大于右孩子的情况（从后向前遍历）只要左边评分比右边大，左边的孩子就多一个糖果。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(ratings[i] &gt; ratings[i<span class="number">-1</span>])  candys[i] = candys[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span>(ratings[i] &gt; ratings[i+<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="comment">// 此时candyVec[i]（第i个小孩的糖果数量）就有两个选择了，一个是candyVec[i + 1] + 1（从右边这个加1得到的糖果数量），一个是candyVec[i]（之前比较右孩子大于左孩子得到的糖果数量），取最大值。</span></span><br><span class="line">        <span class="comment">// 即局部最优：取candyVec[i + 1] + 1 和 candyVec[i] 最大的糖果数量，保证第i个小孩的糖果数量既大于左边的也大于右边的。全局最优：相邻的孩子中，评分高的孩子获得更多的糖果。</span></span><br><span class="line">        candys[i] = <span class="built_in">max</span>(candys[i], candys[i+<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<br>
<hr>


<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><p>回溯法也可以叫做回溯搜索法，它是一种搜索的方式。回溯是<strong>递归</strong>的副产品，只要有递归就会有回溯。<br>回溯的本质是<strong>穷举</strong>，穷举所有可能，然后选出我们想要的答案，如果想让回溯法高效一些，可以加一些剪枝的操作。<br>回溯法解决的问题都可以抽象为<strong>树形结构</strong>，所有回溯法的问题都可以抽象为树形结构！<br>因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度，都构成的树的深度。递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。</p>
<h3 id="回溯（backtracking）三步曲：回溯函数模板返回值及参数-函数终止条件-回溯搜索的遍历过程"><a href="#回溯（backtracking）三步曲：回溯函数模板返回值及参数-函数终止条件-回溯搜索的遍历过程" class="headerlink" title="回溯（backtracking）三步曲：回溯函数模板返回值及参数 -&gt; 函数终止条件 -&gt; 回溯搜索的遍历过程"></a><code>回溯（backtracking）三步曲</code>：回溯函数模板返回值及参数 -&gt; 函数终止条件 -&gt; 回溯搜索的遍历过程</h3><h3 id="回溯函数模板："><a href="#回溯函数模板：" class="headerlink" title="回溯函数模板："></a><strong>回溯函数模板：</strong></h3><ul>
<li><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(参数)</span> </span>&#123;             </span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="built_in">backtracking</span>(路径，选择列表);  <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><font color= "#87CEFA"> <strong>组合问题：</strong> </font>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合;<br>示例: 输入: n &#x3D; 4, k &#x3D; 2 输出: [ [1,2], [1,3], [1,4], [2,3],[2,4], [3,4] ]<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;                        </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;                       <span class="comment">// 存放符合条件结果的集合</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;                                 <span class="comment">// 用来存放符合条件结果</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startIndex)</span> </span>&#123; <span class="comment">// startIndex记录下一层递归，搜索的起始位置</span></span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n; i++) &#123;   <span class="comment">// 控制树的横向遍历</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(i);                    <span class="comment">// 处理节点</span></span><br><span class="line">            <span class="built_in">backtracking</span>(n, k, i + <span class="number">1</span>);            <span class="comment">// 递归：控制树的纵向遍历，注意下一层搜索从i+1开始</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();                      <span class="comment">// 回溯，撤销处理的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><font color= "#87CEFA"> <strong>子集问题：</strong> </font>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。说明：解集不能包含重复的子集。<br>示例: 输入: nums &#x3D; [1,2,3] 输出: [ [], [1], [1, 2], [1,2,3],   ]<br>如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！</li>
<li><font color= "#87CEFA"> <strong>分割回文串：</strong> </font>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。<br>示例: 输入: “aab” 输出: [ [“aa”,”b”], [“a”,”a”,”b”] ]<br>其实切割问题类似组合问题，例如对于字符串abcdef：<br>组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中再选取第三个…..。<br>切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中再切割第三段…..。<br><img src="https://code-thinking.cdn.bcebos.com/pics/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg"><br><strong>！！！一定建立起for循环横向遍历，递归纵向遍历的概念！！！</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string s, <span class="type">int</span> startindex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startindex &gt;= s.<span class="built_in">size</span>()) &#123;   <span class="comment">// 0.终止条件_遍历到“叶子结点”，一组成功样例                               </span></span><br><span class="line">        ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = startindex; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ishuiwen</span>(s.<span class="built_in">substr</span>(startindex, i - startindex + <span class="number">1</span>))) &#123;   </span><br><span class="line">            path.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(startindex, i - startindex + <span class="number">1</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                    </span><br><span class="line">            <span class="keyword">continue</span>;               <span class="comment">// 1.处理节点：切割startindex~i的子串</span></span><br><span class="line">        &#125;                           <span class="comment">// ！！不要在终止条件里处理节点！！</span></span><br><span class="line">        <span class="built_in">backtracking</span>(s, i + <span class="number">1</span>);     <span class="comment">// 2.处理完节点后遍历  </span></span><br><span class="line">        path.<span class="built_in">pop_back</span>();            <span class="comment">// 3.回溯 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><font color= "#87CEFA"> <strong>排列问题：</strong> </font>给定一个 没有重复 数字的序列，返回其所有可能的全排列。排列是有序的，即[1,2] 和 [2,1] 是两个集合。<br>示例：输入[1,2,3]，输出 [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span> <span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">bool</span>&gt;&amp; used)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;     </span><br><span class="line">            <span class="comment">// 元素1在[1,2]中已经使用过了，但是在[2,1]中还要在使用一次1</span></span><br><span class="line">            <span class="comment">// 所以处理排列问题不使用startIndex，i从0开始遍历。</span></span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="literal">true</span>) <span class="keyword">continue</span>;   <span class="comment">// path里已经收录的元素，直接跳过</span></span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="comment">// used数组，其实就是记录此时path里都有哪些元素使用了，一个排列里一个元素只能使用一次。</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;      </span><br><span class="line">        <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>hhh</p>
<hr>

<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ul>
<li>动态规划，Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的。</li>
<li>动态规划算法一般分为自顶向下的记忆化搜索和自底向上的递推方法。自顶向下方法使用递归来解决问题，但在递归过程中使用记忆数组（或哈希表）来保存已经计算过的子问题的解，以避免重复计算。自底向上方法则从子问题的基础解逐步构建出问题的解。(递归到动规的一般转化方法：递归函数有n个参数，就定义一个n维的数组，数组的下标是递归函数参数的取值范围，数组元素的值是递归函数的返回值，这样就可以从边界值开始，逐步填充数组，相当于计算递归函数值的逆过程。)</li>
<li>动态规划通常适用于具备以下特点的问题：<br><strong>1. 重叠子问题：</strong> 问题的解可以由多个子问题的解组合而来，这些子问题可能会被重复解决。<br><strong>2. 最优子结构：</strong> 问题的最优解可以通过其子问题的最优解构造得到。<br><strong>3. 无后效性：</strong> 当前的若干个状态值一旦确定，则此后过程的演变就只和这若干个状态的值有关，和之前是采取哪种手段或经过哪条路径演变到当前的这若干个状态，没有关系。</li>
</ul>
<h3 id="动态（DP）规划五步曲-1-确定dp数组（dp-table）以及下标的含义-2-确定递推公式-3-dp数组如何初始化-4-确定遍历顺序-5-举例推导dp数组"><a href="#动态（DP）规划五步曲-1-确定dp数组（dp-table）以及下标的含义-2-确定递推公式-3-dp数组如何初始化-4-确定遍历顺序-5-举例推导dp数组" class="headerlink" title="动态（DP）规划五步曲 1. 确定dp数组（dp table）以及下标的含义 -&gt; 2. 确定递推公式 -&gt; 3. dp数组如何初始化 -&gt; 4. 确定遍历顺序 -&gt; 5. 举例推导dp数组"></a><code>动态（DP）规划五步曲</code> 1. 确定dp数组（dp table）以及下标的含义 -&gt; 2. 确定递推公式 -&gt; 3. dp数组如何初始化 -&gt; 4. 确定遍历顺序 -&gt; 5. 举例推导dp数组</h3><ul>
<li><font color= "#87CEFA"> <strong>01背包问题：</strong> </font>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。<br>1.dp数组以及下标含义：使用二维数组dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。<br>2.递推公式： <strong>dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</strong><br>不放物品i：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以背包内的价值依然和前面相同。)<br>放物品i：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值<br>3.dp数组初始化：关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱。<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210110103109140.png"><br>4.遍历顺序：先遍历物品、先遍历背包重量都可以。把dp表遍历填满就行。<br>5.举例推导dp：做动态规划的题目，最好的过程就是自己在纸上举一个例子把对应的dp数组的数值推导一下，然后在动手写代码！<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_2_wei_bag_problem1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> bagweight = <span class="number">4</span>; </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; weight = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; value = &#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;; </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(weight.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(bagweight + <span class="number">1</span>, <span class="number">0</span>));   <span class="comment">// 二维数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = weight[<span class="number">0</span>]; j &lt;= bagweight; j++)  dp[<span class="number">0</span>][j] = value[<span class="number">0</span>];      <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123;                               <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= bagweight; j++) &#123;                              <span class="comment">// 遍历背包容量</span></span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    cout &lt;&lt; dp[weight.<span class="built_in">size</span>() - <span class="number">1</span>][bagweight] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><font color= "#87CEFA"> <strong>打家劫舍：</strong> </font>每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。<br>1.dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]。<br>2.dp[i] &#x3D; max(dp[i - 2] + nums[i], dp[i - 1])；决定dp[i]的因素就是第i房间偷还是不偷。<br>如果偷第i房间，那么dp[i] &#x3D; dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。<br>如果不偷第i房间，那么dp[i] &#x3D; dp[i - 1]，即考虑 i-1 房，（注意这里是考虑，并不是一定要偷i-1房！）<br>3.dp数组初始化：递推公式的基础就是dp[0] 和 dp[1]；dp[0] 一定是 nums[0]，dp[1]就是nums[0]和nums[1]的最大值<br>4.遍历顺序：dp[i] 是根据dp[i - 2] 和 dp[i - 1] 推导出来的，那么一定是从前到后遍历！<br>5.举例推导dp数组<br><font color= "#87CEFA"> <strong>打家劫舍II：</strong> </font>房子首尾相连。<br>情况一：考虑不包含首尾元素； 情况二：考虑包含首元素，不包含尾元素； 情况三：考虑包含尾元素，不包含首元素<br>答案即情况二、三之间的大的值</li>
<li>最长递增子序列：找到整数数组 nums 中最长严格递增子序列的长度。例如，[3,6,2,7] 是 [0,3,1,6,2,2,7] 的子序列。<br>定义 dp[i] 为考虑前 i 个元素，以第 i 个数字结尾的最长上升子序列的长度，注意 nums[i] 必须被选取！！！<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; nums[j] &amp;&amp; (<span class="number">1</span> + dp[j]) &gt; dp[i])  dp[i] = dp[j] + <span class="number">1</span>;  <span class="comment">// 返回dp[]最大值    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><font color= "#87CEFA"> <strong>股票问题：</strong> </font>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。<br>dp[i][0] 表示第i天持有股票所得最多现金 ；dp[i][1] 表示第i天不持有股票所得最多现金。<br>dp[i][0] &#x3D; max(dp[i - 1][0], -prices[i]); dp[i][1] &#x3D; max(dp[i - 1][1], prices[i] + dp[i - 1][0]);</li>
<li><font color= "#87CEFA"> <strong>子序列问题：</strong> </font></li>
<li><font color= "#87CEFA"> <strong>单词拆分：</strong> </font>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。<br>输入 s &#x3D; “leetcode”, wordDict &#x3D; [“leet”, “code”]。返回 true 因为 “leetcode” 可以由 “leet” 和 “code” 拼接成。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>(wordDict);     <span class="comment">// 直接用数组构建set</span></span><br><span class="line"><span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length() + <span class="number">1</span>];  <span class="comment">// 考虑dp数组长度和元素意义！！</span></span><br><span class="line">Arrays.fill(dp, <span class="literal">false</span>);</span><br><span class="line">dp[<span class="number">0</span>] = <span class="literal">true</span>;                                <span class="comment">// 注意初始情况！！</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[j] &amp;&amp; set.contains(s.substring(j, i))) &#123;</span><br><span class="line">            dp[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[s.length()];</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/09/08/%E7%AE%97%E6%B3%95%E9%A2%98/" data-id="cm2rjvvgt000ub4v5101g7qeg" data-title="算法 | 数组 / 链表 / 哈希表 / 字符串 / 栈 / 队列 / 二叉树 / 图 / 贪心 / 回溯 / 动态规划" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Cpp基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/09/06/Cpp%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2020-09-06T08:23:20.000Z" itemprop="datePublished">2020-09-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/09/06/Cpp%E5%9F%BA%E7%A1%80/">C++ 基础</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><em>Cpp</em> 是一种通用编程语言，它扩展了 C 语言，加入了面向对象编程的特性。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>数据类型<ol>
<li>简单类型<ul>
<li>基本类型：<ul>
<li><strong>整型</strong>：<strong>int</strong>通常是机器的最自然大小，占<strong>4B</strong>。short：短整数 2B。long：长整数，4 或 8B(取决于编译器和系统)。long long：长长整数，至少64位(8 byte)。INT_MIN &#x3D; -2147483648 &#x3D; 1 + INT_MAX</li>
<li><strong>浮点型</strong>：float 单精度浮点数 4B；double双精度 8B；long double 8B 或 16B。</li>
<li><strong>字符型</strong>：C++ 中表示字符的基本类型<code>char</code>，通常是 1B。字符用 ASCII 编码，以 ASCII 值参与运算</li>
<li>空类型 void</li>
</ul>
</li>
<li>用户定义类型：枚举类型 enum</li>
</ul>
</li>
<li>结构类型：数组 [ ]，结构 struct，联合 union，类 class</li>
<li>指针类型（*）<table>
<thead>
<tr>
<th>类型</th>
<th>长度（字节）</th>
<th>表示范围</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>1</td>
<td>-128 ~ 127</td>
<td>-2^7 ~ 2^7-1</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>-2147483648 ~ 2147483647</td>
<td>-2^31 ~ 2^31-1</td>
</tr>
<tr>
<td>double双精度型</td>
<td>8</td>
<td>-1.7<em>10^308 ~ 1.7</em>10^308</td>
<td>15位有效数字</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><code>十六进制</code>[hexadecimal]：使用数字 0-9 和字母 A-F（或 a-f）来表示数值，每个十六进制位对应四个二进制位。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> hexValue = <span class="number">0x1A3F</span>;        <span class="comment">// 0x 表示十六进制，用位运算进行十六进制的操作，输出时显示为二进制</span></span><br><span class="line">cout &lt;&lt; hex &lt;&lt; value &lt;&lt; endl; <span class="comment">// 使用iomanip中的 hex 控制符来设置输出为十六进制格式</span></span><br></pre></td></tr></table></figure></li>
<li><code>ASCII码</code>：是一种将字符映射到数字的编码标准。ASCII码用于表示键盘上的字符，每个字符都对应一个唯一的数字。<br>0-“\0”(空字符,字符串结束标志)、9-“\t”(制表符：四个空格)、10-“\n”(换行符)、32-“ “(空格)<br>48-“0”(字符0)、65-“A”、 97-“a” 大小写差32（tolower()大写字符转换为小写）<br>转义字符 “\ character”：以 “\” 为前缀，表示改变后面 character 符号或整数值的意义，使其成为控制符或字符值。</li>
<li>char16_t：UTF-16字符类型。 char32_t：UTF-32字符类型。char16&#x2F;32_t 是引入的字符类型，用于支持 <code>Unicode</code> 字符。</li>
<li>类型转换<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">65</span>; string b = <span class="string">&#x27;9&#x27;</span>, s = <span class="string">&quot;80&quot;</span>;</span><br><span class="line"><span class="type">char</span> c = (<span class="type">char</span>)a;         <span class="comment">// ASCII -&gt; char: 65 -&gt; &#x27;65&#x27; 类型强制转换或显式转换</span></span><br><span class="line"><span class="type">char</span> d = a + <span class="string">&#x27;0&#x27;</span>;         <span class="comment">// int -&gt; char: 65 + &#x27;0&#x27; -&gt; &#x27;65&#x27;</span></span><br><span class="line"><span class="type">int</span> e = b - <span class="string">&#x27;0&#x27;</span>;          <span class="comment">// char -&gt; int: &#x27;9&#x27; - &#x27;0&#x27; -&gt; 9</span></span><br><span class="line"><span class="type">int</span> f = <span class="built_in">stoi</span>(s);          <span class="comment">// string -&gt; int</span></span><br><span class="line">string g = <span class="built_in">to_string</span>(a);  <span class="comment">// int - &gt; string</span></span><br></pre></td></tr></table></figure></li>
<li>常量<ul>
<li><strong>字面常量</strong>：字面常量是源代码中的常量值。例如，整数字面常量（ <code>5</code>、<code>-10</code>）、浮点数字面常量（ <code>3.14</code>、<code>-0.001</code>）、字符常量（<code>&#39;a&#39;</code>、<code>&#39;B&#39;</code>）、字符串字面常量（<code>&quot;Hello&quot;</code>、<code>&quot;C++&quot;</code>）等。值在程序编译时就已经确定。</li>
<li><strong>const 关键字创建的常量</strong>：在C++中，可以使用 <code>const</code> 关键字创建常量变量。这些变量在声明时被初始化，并且一旦被赋值后就不能再修改其值。例如：const double PI &#x3D; 3.14159;</li>
<li><strong>枚举常量（Enumeration Constants）</strong>：使用 <code>enum</code> 关键字定义的枚举类型也可以产生常量。枚举常量是一组具有整数值的符号常量。例如：enum Day { MON, TUE, WED, THU, FRI, SAT, SUN };</li>
</ul>
</li>
</ul>
<h3 id="数据访问"><a href="#数据访问" class="headerlink" title="数据访问"></a>数据访问</h3><ul>
<li>名访问：程序被编译后，系统对已声明对象保存一张名表，登记对象的属性 &lt; 名字，类型，地址 &gt;</li>
<li>地址访问<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span>  b  <span class="comment">// &lt; b, double, 0X0066FDEC &gt;</span></span><br><span class="line">&amp;b         <span class="comment">// 取对象b的地址	</span></span><br><span class="line">b          <span class="comment">// 访问对象b	</span></span><br><span class="line">*(&amp;b)      <span class="comment">// 间址访问		</span></span><br></pre></td></tr></table></figure></li>
<li>指针变量：能够存放对象地址的变量。定义形式：类型  * 标识符 ;<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * iptr; <span class="comment">// iptr 是指向整型对象的指针，可以存放一个整型变量的地址</span></span><br><span class="line"><span class="type">char</span> * s ;	  <span class="comment">// s 是指向字符对象的指针</span></span><br><span class="line"><span class="type">int</span>  ** p2;  <span class="type">int</span>  * p1;  <span class="type">int</span>  i = <span class="number">3</span>;  p1 = &amp; i;  p2 = &amp; p1; <span class="comment">// 指向指针的指针 </span></span><br></pre></td></tr></table></figure></li>
<li>引用：引用说明为对象建立引用名，即别名；<ul>
<li>引用在定义初始化时与对象名绑定，程序中不能对引用重定义；一个对象的别名，从使用方式和效果上与使用对象名一致 </li>
<li>定义形式:	类型 &amp; 引用名 &#x3D; 对象名 ；</li>
</ul>
</li>
<li>指向常量的指针 ：间址访问只读。定义形式：const 类型 * 指针 或 类型  const * 指针</li>
<li>指针常量：指针常量的值只能在定义的时候初始化。定义形式：类型  * const 指针</li>
<li>常引用：const  类型  &amp; 引用名  &#x3D; 对象名 ;</li>
</ul>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><ul>
<li>类型转换：表达式求值之前，要对操作数进行必要的类型转换<ol>
<li>将短数扩展为机器处理的长度：参与算术运算的只有5种类型数据<br>  char、short -&gt; int，unsigned char、unsigned short -&gt; unsigned int，float -&gt; double、long、unsigned long</li>
<li>使运算符两端的操作数具有相同的类型： “向高看齐”，向表达能力强的类型转换；逐个算符转换</li>
</ol>
</li>
<li>运算符的优先关系<ul>
<li>单目运算符 &gt; 乘除运算 &gt; 加减运算 &gt; 关系运算 &gt; 逻辑与 &gt; 逻辑或 &gt; 赋值 &gt; 逗号</li>
<li>i + 1 &lt; j * 4 &amp;&amp; ! P || Q  等价于 :    ( ( ( i +1 ) &lt; ( j * 4 ) ) &amp;&amp; ( ! P ) ) || Q</li>
<li>P !&#x3D; i &lt; j || Q &amp;&amp; S       等价于 :    ( P !&#x3D; ( i &lt; j ) ) || ( Q &amp;&amp; S )</li>
</ul>
</li>
<li>自增、自减<ul>
<li>前缀式：先增值后引用	例：x &#x3D; ++ i 	相当于	i &#x3D; i + 1 ;    x &#x3D; i ;</li>
<li>后缀式：先引用后增值	例：x &#x3D; i ++ 	相当于	x &#x3D; i ;     i &#x3D; i + 1 ; </li>
<li>自增、自减算符的运算对象只能是整型变量，不能为常量或表达式</li>
</ul>
</li>
<li>位运算<ul>
<li>16进制表示:  0xff -&gt; 1111 1111  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">3</span>;        <span class="comment">// a 二进制: 0101, b 二进制: 0011</span></span><br><span class="line"><span class="type">int</span> andResult = a &amp; b;   <span class="comment">// 0001 (1) 按位与 `&amp;`</span></span><br><span class="line"><span class="type">int</span> orResult = a | b;    <span class="comment">// 0111 (7) 按位或 `|`</span></span><br><span class="line"><span class="type">int</span> xorResult= a ^ b;    <span class="comment">// 0110 (6) 按位异或 `^`</span></span><br><span class="line"><span class="type">int</span> notA = ~a;           <span class="comment">// 1010 (-6 in two&#x27;s complement representation) 按位取反 `~`</span></span><br><span class="line"><span class="type">int</span> leftShift = a &lt;&lt; <span class="number">1</span>;  <span class="comment">// 1010 (10) 左移&lt;&lt;：将操作数的每个位向左移动指定的位数，右侧用零填充</span></span><br><span class="line"><span class="type">int</span> rightShift= a &gt;&gt; <span class="number">1</span>;  <span class="comment">// 0010(2) 右移&gt;&gt;：每个位右移指定位数，左侧用符号位(对于有符号数)或零填充</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="程序控制结构"><a href="#程序控制结构" class="headerlink" title="程序控制结构"></a>程序控制结构</h3><ul>
<li>所有程序都只能包含三种控制结构：顺序结构、选择结构和循环结构</li>
<li>if 语句，while语句，do-while语句，for语句</li>
<li>switch语句：根据一个整型表达式的值决定程序分支 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)</span><br><span class="line">&#123;   <span class="keyword">case</span> 常量表达式 <span class="number">1</span> : 语句 <span class="number">1</span>  <span class="comment">// case 标签是用来匹配 switch 后面表达式的值，执行相应的代码</span></span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">case</span> 常量表达式 n : 语句 n</span><br><span class="line">    <span class="keyword">default</span> : 语句 n+<span class="number">1</span>        <span class="comment">// 如果没有任何一个 case 匹配成功，用 default 标签来执行默认的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
表达式类型为非浮点型；各常量表达式类型要与之匹配；各常量表达式要求各不相等；default 子句可选。<br>缺省时，没有匹配值 switch 语句为空<br>case 和 default 仅起语句标号作用，不能控制程序流程；一旦选中一个case分支后，将继续往下顺序执行（剩余所有）语句序列。添加 break 语句可以跳出 switch 语句体，达到控制流程作用</li>
</ul>
<hr>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ul>
<li><code>库函数</code>：预定义的函数，它们提供了各种功能，可以通过包含相应的头文件来使用。<br>C++标准库是一个包含许多有用函数和类的集合，可以使用这些函数和类来构建程序，而不必从头开始编写所有功能。<br><strong>iostream</strong> 是一个C++标准库的头文件，提供了输入输出操作，包括 cin 和 cout。<br><strong>cmath</strong> 是另一个头文件，提供了数学函数如 指数函数pow(10.0, 2)、平方根sqrt()、三角cos()、绝对值abs() 等。<br><strong>algorithm</strong> 中含有sort()、reverse()、swap()等函数。<br><strong>string</strong> 是一个代表字符串string的类，它封装了许多处理字符串的函数和操作符。如substr()、find()函数等。<br><strong>vector</strong> vec.size()获取 vector 的大小</li>
<li><code>命名空间</code>：是用于组织代码标识符（如变量、函数、类等）的一种方式，以避免命名冲突。命名空间允许你在不同的命名空间中定义相同名称的标识符，从而使不同部分的代码可以使用相同的名字而不会产生冲突。C++标准库中的函数和类通常被放置在一个叫做 std 的命名空间中。你可以使用命名空间限定符 std:: 来访问其中的成员。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// 这是一个预处理指令，用于包含C++标准库中的 `iostream` 头文件。这个头文件包含了用于输入输出的流对象（如 `cin` 和 `cout`）以及其他相关函数。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;    <span class="comment">// 这是一个命名空间声明。`std` 是C++标准库的命名空间，包含了许多标准函数、对象和类。通过使用 `using namespace std;`，你可以在代码中直接使用 `cout` 和 `endl`，而无需在前面加上 `std::` 前缀。注意，虽然使用 using namespace std; 可以简化代码，但在大型项目中，为了避免命名冲突，可能会选择显式地使用命名空间限定符。</span></span><br></pre></td></tr></table></figure></li>
<li>函数定义形式：类型 函数名（形式参数表） { 语句序列 }</li>
<li>函数调用形式：函数名（实际参数表）</li>
<li>函数原型：作用是告诉编译器有关函数的信息：函数的名字、函数返回的数据类型、函数要接受的参数个数、参数类型和参数的顺序；编译器根据函数原型检查函数调用的正确性。函数原型的形式：类型 函数名（形式参数表）;</li>
<li>函数参数的传递：值传递，指针传递，引用传递 </li>
<li>传值参数：调用函数时，实参表达式的值被复制到相应形参标识的对象中，并按形参类型强制转换；函数内对形参的访问、修改，都在形参的标识对象进行；函数返回时，形参对象被撤消，不影响实参的值；值传送的实参可以是常量、有确定值的变量或表达式；函数返回值通过匿名对象传递<table>
<thead>
<tr>
<th></th>
<th>丨函数 FunctionObj</th>
<th>丨数据 DataObj</th>
<th>丨数组 DataObj</th>
</tr>
</thead>
<tbody><tr>
<td>地址</td>
<td>丨FunctionObj、&amp;FunctionObj、<em>FunctionObj、</em>&amp;FunctionObj</td>
<td>丨&amp;DataObj</td>
<td>丨第i行第j列元素：a[i]+j、*(a+i)+j、&amp;a[i][j]</td>
</tr>
</tbody></table>
</li>
<li>函数、应用程序是编译器处理的对象，每一个函数模块都有一个首地址，称为函数的入口地址。<br>函数调用：找到函数入口地址；传递参数。函数入口地址：就是不带括号的函数名。<br>  函数指针：指向函数的指针变量，值为函数的入口地址。函数的类型是函数的接口，可以通过指针变量的间址方式调用函数<ul>
<li>若有函数类型为：double  ( double, double ) ;  或 typedef double  functionType  ( double, double ) ;</li>
<li>定义指向这类函数的指针变量：double  ( * fp ) ( double, double );  或 functionType  * fp1 ,  * fp2 ;</li>
</ul>
</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul>
<li>结构由数目固定的成员构成，各成员可以具有不同的数据类型，一个结构变量在内存占有一片连续的存储空间</li>
<li>结构类型定义形式为：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>  标识符</span><br><span class="line">&#123;  类型   成员<span class="number">1</span> ;</span><br><span class="line">   …</span><br><span class="line">   类型   成员n ;</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure></li>
<li>可以用不同方法定义一个结构变量：(1) 声明类型之后声明变量 (2)声明类型的同时声明变量 (3)直接声明结构类型变量</li>
<li>访问结构变量的成员：（1）结构变量.成员 （2）结构指针 -&gt; 成员， (*结构指针 ) . 成员</li>
</ul>
<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><p>C++的STL（Standard Template Library，标准模板库）是C++标准库的一部分，它提供了一组通用的模板类和函数，用于实现常见的数据结构和算法。STL的设计目标是提供高效、通用、可复用的组件，以帮助开发者编写更加优雅和高效的C++代码。</p>
<ol>
<li>容器（Containers）：容器是用于存储和管理一组对象的类模板。STL提供多种容器，每个容器都有不同的特性和适用场景。<br><code>vector</code>：动态数组，支持快速的随机访问，底层实现是array，封装后使用更友好。<code>list</code>：双向链表，支持在任意位置插入和删除元素。<code>deque</code>：双端队列，类似于动态数组。<code>map</code>：关联数组，使用键值对存储数据。<code>set</code>：集合，存储不重复的值。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(cost.size() + <span class="number">1</span>)</span></span>;               <span class="comment">// 指定数据类型、数组大小</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">3</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>));     <span class="comment">// 创建一个包含3行4列的二维 vector</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;  </span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());                  <span class="comment">// 利用迭代器排序</span></span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="number">4</span>);  vec.<span class="built_in">pop_back</span>();             <span class="comment">// 添加数据、移除末尾元素</span></span><br></pre></td></tr></table></figure></li>
<li>算法（Algorithms）：STL提供了一组强大的通用算法，这些算法可以用于各种容器类型。这些算法涵盖了排序、查找、遍历、变换等多种操作。一些常见的算法包括： <code>sort</code>：对容器中的元素进行排序。<code>find</code>：在容器中查找特定元素。<code>for_each</code>：对容器中的每个元素执行操作。<code>transform</code>：将容器中的元素进行转换操作。</li>
<li>迭代器（Iterators）：迭代器用于遍历容器中的元素，提供了统一的访问接口，使得代码更具可扩展性。迭代器分为多种类型，包括输入迭代器、输出迭代器、前向迭代器、双向迭代器和随机访问迭代器。(begin()、end()、++、–、* 、&#x3D;&#x3D; 和 !&#x3D;)</li>
<li>函数对象（Function Objects）：函数对象是类的实例，可以像函数一样被调用。STL的算法和其他组件允许你使用函数对象来执行操作，或者使用标准库提供的一些预定义的函数对象。</li>
<li>适配器（Adapters）：适配器是用于转换或扩展容器或迭代器接口的类模板。例如，<code>std::stack</code> 是一个基于双端队列的堆栈容器适配器，<code>std::queue</code> 是一个基于双端队列的队列容器适配器。</li>
</ol>
<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><ul>
<li>通常通过标准库中的 <code>iostream</code> 完成，包括 <code>cin</code> 用于从用户获取数据， <code>cout</code> 向屏幕输出数据，<code>endl</code> 输出一个换行符。</li>
<li>格式化输出：用到 <code>iomanip</code> 库<br><strong>setw 和 setfill</strong>：这两个函数可以用来设置输出的宽度和填充字符。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; <span class="number">42</span>;  <span class="comment">// 将数字 42 输出为 &quot;000042&quot;，总宽度为 6，使用 &#x27;0&#x27; 填充</span></span><br></pre></td></tr></table></figure>
<strong>fixed + setprecision</strong>：用于输出指定小数位数的浮点数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; <span class="number">3.1415926</span>;</span><br></pre></td></tr></table></figure></li>
<li>如果要处理多行输入可以使用 <code>getline</code> 函数，需要包含 <code>iostream</code> 头文件<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line">string input; </span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line"><span class="built_in">getline</span>(cin, input);         <span class="comment">// 读取整行输入：1 -1 -1 0</span></span><br><span class="line"><span class="function">istringstream <span class="title">ss</span><span class="params">(input)</span></span>;     <span class="comment">// 使用 istringstream 来分割数字</span></span><br><span class="line"><span class="keyword">while</span> (ss &gt;&gt; number) &#123;```&#125;   <span class="comment">// 逐个获取数字</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>

<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>时间复杂度是一种用来衡量算法运行时间与输入规模之间关系的概念。它不是用来精确测量程序运行时间的，而是描述在输入规模变化时，算法运行时间的增长趋势。</li>
<li>大O表示上界，当用它作为算法的最坏情况运行时间的上界，就是对任意数据输入的运行时间的上界。<br>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!)</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li>数组（Array）是有序的元素序列。数组是一种固定大小的数据结构，用于存储相同类型的元素。在C++中，数组的长度在创建时就固定了，无法在运行时改变。数组的元素是连续存储在内存中的，可以通过索引访问。数组有一些限制，例如长度固定、不能动态扩展等。当数组作为函数参数传递时，实际上传递的是指向数组首元素的指针。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> myArray[<span class="number">5</span>];  <span class="type">int</span> numbers[<span class="number">3</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;  <span class="type">int</span> matrix[<span class="number">3</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;&#125;;  <span class="comment">// 声明并初始化一个整数数组</span></span><br></pre></td></tr></table></figure></li>
<li>在C++中，动态声明数组意味着在运行时根据需要分配数组的内存空间，而不是在编译时固定数组大小。<br><strong>使用指针声明数组：</strong> 首先，你需要声明一个指针变量，该指针变量将用于存储动态分配的数组的地址。然后，使用内存分配函数（如 <code>new</code> 或 <code>malloc</code>）分配所需大小的内存空间。<br><strong>释放内存：</strong> 在不再需要数组时，必须手动释放分配的内存，以避免内存泄漏。使用 <code>delete</code> 或 <code>free</code> 来释放内存。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* dynamicArray = <span class="keyword">new</span> <span class="type">int</span>[size];   <span class="keyword">delete</span>[] dynamicArray;   <span class="comment">// 动态分配数组内存 释放分配的内存</span></span><br></pre></td></tr></table></figure></li>
<li>数组容器（Array Container）：在C++中，数组（Array）和数组容器（Array Container）是两种不同的数据结构，它们在用法和特性上有一些区别。数组容器是C++标准库中提供的一种数据结构，用于存储相同类型的元素，并提供了一些更方便的功能。<br><code>array</code> 是一个数组容器，它在内部使用数组来存储元素，是一个类模板，具有类似对象的行为，可以使用成员函数和操作符进行操作，提供了更多的功能，如获取数组大小、迭代器、操作符重载等，还可以像其他C++容器一样与STL算法一起使用。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span>  array<span class="string">&lt;int, 5&gt;</span> myArray;  array<span class="string">&lt;int, 3&gt;</span> numbers = &#123;10, 20, 30&#125;;  <span class="comment">// 声明一个包含3个整数的array</span></span></span><br></pre></td></tr></table></figure></li>
<li>动态数组<code>vector</code>的底层实现是 array，严格来讲vector是容器，不是数组。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; myVector = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;   <span class="comment">// vector&lt;int&gt; myVector(n)  大小为n的空vector</span></span><br><span class="line"><span class="comment">// vector&lt;vector&lt;int&gt;&gt; myMatrix(n, vector&lt;int&gt;(n, 0))  n阶二维vector</span></span><br><span class="line">myVector.<span class="built_in">push_back</span>(<span class="number">1</span>);    <span class="comment">// 或直接下标索引 myVector[0] = 1;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; value : myVector)  cout &lt;&lt; value;  <span class="comment">// for (int i=0;i&lt;myVector.size();i++)&#123;..&#125;</span></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = myVector.<span class="built_in">begin</span>(); it != myVector.<span class="built_in">end</span>(); ++it)  cout &lt;&lt; *it;</span><br><span class="line">myVector.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="keyword">if</span> (myVector.<span class="built_in">empty</span>())  cout &lt;&lt; myVector.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure></li>
<li><code>sort</code>函数接受两个迭代器参数，即要排序的范围的开始和结束位置。排序默认是升序的，如果需要降序排序，可以使用 std::greater<int>() 作为第三个参数。在使用 sort 函数之前，请确保引入了 <algorithm> 头文件。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(arr, arr + n);</span><br><span class="line"><span class="built_in">sort</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul>
<li>处理头结点有两种方式：直接使用原来的链表来进行删除操作、设置一个虚拟头结点在进行删除操作。</li>
<li>使用 ListNode* cur &#x3D; head 进行链表操作，不要直接使用头结点操作！！！ </li>
<li>判断空指针为 <strong>if(ptr !&#x3D; nullptr)</strong> ，不要用 <strong>if(!ptr)</strong></li>
<li>nullptr与NULL：NULL 是一个宏定义，通常被定义为整数 0，NULL 用于表示空指针存在一些问题，因为它实际上是一个整数，可能会导致类型不匹配和模糊的代码。nullptr 是 C++11 标准引入的新关键字，用于表示空指针，是类型安全的，可以隐式转换为任何指针类型，但不会导致模糊的类型问题。推荐在现代 C++ 代码中使用 nullptr 来表示空指针。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">5</span>);             <span class="comment">// 初始化节点</span></span><br><span class="line"><span class="keyword">delete</span> head;                                  <span class="comment">// 删除节点，回收内存</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>在C++中，哈希（Hash）是一种将数据映射到固定大小的散列值的技术。哈希函数将输入数据转换为散列值，这个散列值通常用于快速查找或存储数据。C++标准库提供了一些哈希函数和相关的数据结构，让你可以在自己的程序中应用哈希。</p>
<ul>
<li>什么时候使用哈希法？当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。</li>
<li>哈希容器（Hash Containers）：C++标准库提供了一些哈希容器，它们使用哈希函数来快速存储和检索数据。<br><code>unordered_set</code>：基于哈希表的集合，用于实现无序映射。类似于 <code>set</code>，但具有更快的查找性能。set 是一个有序的容器，它存储一组唯一的元素。<br><code>unordered_map</code>：基于哈希表的关联数组，不保持元素的插入顺序，类似于 <code>map</code>但具有更快的查找性能。map 是一个有序（按键的字典顺序）的键-值对容器，它存储一组唯一的键，并且每个键关联一个值。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;Key, T&gt; mapp;                 <span class="comment">// 创建一个空的无序映射。</span></span><br><span class="line">mapp[x]                                     <span class="comment">// 直接访问指定键的值，如果键不存在，会创建一个新的键并初始化为默认值。</span></span><br><span class="line"><span class="built_in">insert</span>(&#123;key, value&#125;)   <span class="built_in">erase</span>(key)           <span class="comment">// 插入，删除一个键值对。</span></span><br><span class="line"><span class="built_in">at</span>(key)                                     <span class="comment">// 访问指定键的值，如果键不存在会抛出异常。</span></span><br><span class="line"><span class="built_in">find</span>(key)                                   <span class="comment">// 查找指定键，返回指向该键的迭代器，若不存在，返回mapp.end() </span></span><br><span class="line"><span class="built_in">empty</span>()   <span class="built_in">size</span>()                            <span class="comment">// 检查是否为空；返回键值对的数量</span></span><br><span class="line"><span class="built_in">begin</span>()   <span class="built_in">end</span>()                             <span class="comment">// 返回迭代器，用于遍历所有键值对。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : mapp) &#123;             <span class="comment">// 范围循环,遍历所有键值对。</span></span><br><span class="line">    cout &lt;&lt; pair.first &lt;&lt; pair.second;</span><br><span class="line">&#125;    </span><br><span class="line">                                            <span class="comment">// set的用法类似</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li>访问 string 字符串特定索引位置的字符时，返回的类型是 char</li>
<li>直接使用 <strong>+</strong> 连接字符串和字符串string&#x2F;字符char；<br>使用 <strong>&#x3D;&#x3D;、!&#x3D;、&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;</strong> 比较字符串和字符串string&#x2F;字符char；<br>使用<code>cstring</code>库中的字符串处理函数。其中，strcmp() 用于比较两个 C 风格字符串，strcpy()复制。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getline</span>(cin, str)                            <span class="comment">// cin以空格分隔string。而getline()会等待用户在终端输入一行字符串，然后将该字符串存储在 str 变量中。注意，getline() 会读取一行完整的输入，包括换行符，并且将换行符从输入中删除。</span></span><br><span class="line">str.<span class="built_in">append</span>(count, <span class="string">&#x27;0&#x27;</span>)                       <span class="comment">// 在str末尾加上count个&#x27;0&#x27;</span></span><br><span class="line">str.<span class="built_in">substr</span>(i, <span class="number">8</span>)                             <span class="comment">// 从位置i开始截取长度为8的str的子串</span></span><br><span class="line">str.<span class="built_in">erase</span>(i, <span class="number">5</span>);                             <span class="comment">// 从位置i开始，删除5个字符</span></span><br><span class="line">str1.<span class="built_in">compare</span>(str2)                           <span class="comment">// 逐字符比较字符串(字典顺序)大小，返回0/1/-1</span></span><br><span class="line"><span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + <span class="number">0</span>, s.<span class="built_in">begin</span>() + n);       <span class="comment">// algorithm库字符串翻转函数，翻转范围[0, n-1]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string&amp; s,<span class="type">int</span> start,<span class="type">int</span> end)</span></span>&#123;   <span class="comment">// 自制字符串反转函数，reverse(str, 0, str.size()-1)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start, j = end; i &lt; j; i++, j--)  <span class="built_in">swap</span>(s[i], s[j]);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><p>我们常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈、队列的底层结构。<br>不允许有遍历行为，不提供迭代器。<br>所以STL 栈、队列不被归类为容器，而被归类为container adapter（ 容器适配器）。</p>
<ul>
<li>栈（Stack）遵循后进先出（Last-In-First-Out，LIFO）的原则。 std::stack 容器用于实现栈。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; myStack;               <span class="comment">// 创建一个空的栈，存储整数</span></span><br><span class="line">myStack.<span class="built_in">push</span>(<span class="number">10</span>);                 <span class="comment">// 添加元素到栈</span></span><br><span class="line">myStack.<span class="built_in">top</span>();                    <span class="comment">// 访问栈顶元素</span></span><br><span class="line">myStack.<span class="built_in">pop</span>();                    <span class="comment">// 移除栈顶元素</span></span><br><span class="line"><span class="keyword">while</span> (!myStack.<span class="built_in">empty</span>()) &#123;...     <span class="comment">// 遍历栈</span></span><br></pre></td></tr></table></figure></li>
<li>队列（Queue）遵循先进先出（First-In-First-Out，FIFO）的原则。 std::queue 容器用于实现队列。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span>   </span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; myQueue;   myQueue.<span class="built_in">push</span>(<span class="number">10</span>);   myQueue.<span class="built_in">front</span>();   myQueue.<span class="built_in">pop</span>();   <span class="keyword">while</span> (!myQueue.<span class="built_in">empty</span>()) &#123;...   </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="list（双向链表）"><a href="#list（双向链表）" class="headerlink" title="list（双向链表）"></a><code>list</code>（双向链表）</h2><ul>
<li><code>std::list</code> 是一个双向链表容器，每个元素都包含一个指向前一个元素和一个指向后一个元素的指针。这使得插入和删除操作在链表中非常高效，但随机访问较慢。以下是一些 <code>std::list</code> 的常见用法：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; myList;</span><br><span class="line">    myList.<span class="built_in">push_back</span>(<span class="number">1</span>);                                 <span class="comment">// 插入元素</span></span><br><span class="line">    myList.<span class="built_in">push_front</span>(<span class="number">2</span>);          </span><br><span class="line">    myList.<span class="built_in">insert</span>(std::<span class="built_in">next</span>(myList.<span class="built_in">begin</span>()), <span class="number">3</span>);         <span class="comment">// 在迭代器位置后插入</span></span><br><span class="line">    myList.<span class="built_in">pop_back</span>();                                   <span class="comment">// 删除元素</span></span><br><span class="line">    myList.<span class="built_in">pop_front</span>();</span><br><span class="line">    myList.<span class="built_in">erase</span>(std::<span class="built_in">next</span>(myList.<span class="built_in">begin</span>()));             <span class="comment">// 删除迭代器位置的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; item : myList) &#123; cout &lt;&lt; item,,      <span class="comment">// 遍历元素</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="deque（双端队列）"><a href="#deque（双端队列）" class="headerlink" title="deque（双端队列）"></a><code>deque</code>（双端队列）</h2><ul>
<li><code>deque</code> 是双端队列容器，支持在两端进行高效的插入和删除操作，并且允许随机访问。它的特性使得它在需要在两端进行频繁操作的场景下很有用。以下是一些 <code>deque</code> 的常见用法：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line">std::deque&lt;<span class="type">int</span>&gt; myDeque;</span><br><span class="line">myDeque.<span class="built_in">push_back</span>(<span class="number">1</span>);                                   <span class="comment">// 插入元素</span></span><br><span class="line">myDeque.<span class="built_in">push_front</span>(<span class="number">2</span>);  </span><br><span class="line">myDeque.<span class="built_in">pop_back</span>();                                     <span class="comment">// 删除元素</span></span><br><span class="line">myDeque.<span class="built_in">pop_front</span>();</span><br><span class="line">myDeque.<span class="built_in">push_back</span>(<span class="number">3</span>);                                   <span class="comment">// 随机访问</span></span><br><span class="line">myDeque.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"><span class="type">int</span> value = myDeque[<span class="number">1</span>];                                 <span class="comment">// 访问第二个元素，值为4</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; item : myDeque) &#123; cout &lt;&lt; item ;;;      <span class="comment">// 遍历元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Heap（堆）"><a href="#Heap（堆）" class="headerlink" title="Heap（堆）"></a><code>Heap</code>（堆）</h2><p>在 C++ 中，你可以使用 <code>priority_queue</code> 来实现小顶堆和大顶堆。默认情况下，<code>priority_queue</code> 是大顶堆，但你可以通过改变比较函数来实现小顶堆或大顶堆。</p>
<ul>
<li>实现大顶堆：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="comment">// 创建一个大顶堆（默认情况）</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; maxHeap;</span><br><span class="line"><span class="comment">// 向大顶堆中插入元素</span></span><br><span class="line">maxHeap.<span class="built_in">push</span>(<span class="number">5</span>);    maxHeap.<span class="built_in">push</span>(<span class="number">2</span>);    maxHeap.<span class="built_in">push</span>(<span class="number">8</span>);    maxHeap.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 访问堆顶元素（最大值）</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;最大值：&quot;</span> &lt;&lt; maxHeap.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 弹出堆顶元素</span></span><br><span class="line">maxHeap.<span class="built_in">pop</span>(); ；；&#125;</span><br></pre></td></tr></table></figure></li>
<li>实现小顶堆：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="comment">// 创建一个小顶堆</span></span><br><span class="line"><span class="comment">// 第一个参数 int：这是容器中存储的元素的类型，也就是小顶堆中的元素类型。在这里，我们使用 int 类型。</span></span><br><span class="line"><span class="comment">// 第二个参数 vector&lt;int&gt;：这是容器类型，用于存储小顶堆的元素。通常情况下，我们使用 std::vector 作为容器，但你也可以使用其他容器类型，比如 std::deque。</span></span><br><span class="line"><span class="comment">// 第三个参数 greater&lt;int&gt;：这是比较函数对象，用于定义小顶堆的比较规则。在这里，greater&lt;int&gt; 是一个函数对象，它表示比较时采用递增的方式，即根节点的值小于子节点的值。</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; minHeap;</span><br><span class="line"><span class="comment">// 向小顶堆中插入元素</span></span><br><span class="line">minHeap.<span class="built_in">push</span>(<span class="number">5</span>);  minHeap.<span class="built_in">push</span>(<span class="number">2</span>);  minHeap.<span class="built_in">push</span>(<span class="number">8</span>);  minHeap.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 访问堆顶元素（最小值）</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;最小值：&quot;</span> &lt;&lt; minHeap.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 弹出堆顶元素</span></span><br><span class="line">minHeap.<span class="built_in">pop</span>();；；&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><ul>
<li>二叉树（Binary Tree）是一种常见的树状数据结构，其中每个节点最多有两个子节点，通常称为左子节点和右子节点。每个节点都存储一个值，这个值可以是任何类型，取决于树的应用。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left, *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则为满二叉树。</li>
<li>完全二叉树：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。<br>优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。</li>
<li><strong>二叉搜索树 BST：</strong>具有有序性质，适用于快速查找、插入和删除操作。<br>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>它的左、右子树也分别为二叉排序树</li>
<li><strong>平衡二叉搜索树 AVL：</strong> 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。<br>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，所以map、set的增删操作时间时间复杂度是logn。<br>而unordered_map、unordered_set底层实现是哈希表。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/09/06/Cpp%E5%9F%BA%E7%A1%80/" data-id="cm2rjvvgf0000b4v55p5g34vd" data-title="C++ 基础" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Shots" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/09/01/Shots/" class="article-date">
  <time class="dt-published" datetime="2020-08-31T16:04:42.000Z" itemprop="datePublished">2020-09-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/09/01/Shots/">Shots 📷</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="理念"><a href="#理念" class="headerlink" title="理念"></a>理念</h2><ol>
<li><strong>构图，色彩，内容</strong>，摄影艺术</li>
<li>审美，美是理念（客观真实）的感性显现 </li>
<li>生命力（动物拟人</li>
<li>拍照要有情感，不要刻意捕捉和渲染苦难，没有价值 没有温度 没有同理心</li>
<li>构图是为了故事呈现&#x2F;画面表达服务的</li>
<li>技术是基础 接下来 对自己生命情感的一个探索 把自己的理性和感性相交融 成为摄影的灵性</li>
<li>看一张照片 don’t think、feel、、快速四五条分析，用摄影师的眼光来解读，审美</li>
<li>摄影-习惯 快门-快感 积累-质变</li>
<li>用时间拍照 用时间沉淀<br>纪实摄影（对人的训练 记录时间 记录那一刻对世界的真实表达 摄影的冲动<br>艺术性不是生活的复制品 艺术的摄影点-生活化 趣味性 情绪化 幽默化 -耐人寻味</li>
<li>距离感 （全身和特写 表达不同的情感<br>手是人的第二张脸（外在美，情感，信息</li>
</ol>
<h2 id="构图"><a href="#构图" class="headerlink" title="构图"></a>构图</h2><ol>
<li>大多数照片较为平稳，同时有一些张力<br>物体的数量、大小、色彩、位置、方向、质感、吸引力会影响其视觉重力，画面中多个物体的视觉重力构成了平衡与张力。<br>平衡来源：静态，对称，稳定，横平竖直，客观<br>张力来源：动态，不对称，边角，斜线，情感</li>
<li>平面秩序: 事物变图形 抽象<br>照相不是出于构思作画，而是出于选择构图。三维世界在二维照片中有了原来不存在的关系（远近透视）</li>
<li>决定性瞬间:照片只叙述当下，恰好一个瞬间所有事情(人,地,物,所有细微之处)均各得其所，并同时展现出特定内涵和意义<br>布列松:“如果照片是为了最大程度上让人理解其被摄对象 那么形式关系必须被严格地建立起来 摄影的目的是在真实事物所构成的世界中甄别出韵律 在一张照片中 构图是同时发生的综合结果 是对于眼之所见的各元素的有机协作。”<br>形式即内容 但形式也离不开内容（不要只会拍老头环卫外卖小哥）</li>
</ol>
<h2 id="曝光"><a href="#曝光" class="headerlink" title="曝光"></a>曝光</h2><ol>
<li>曝光三要素：<strong>光圈，快门速度，感光度</strong>iso，与图像亮度有关<br>另外，光圈与景深相关，快门与凝固程度有关，感光度与图像细腻程度有关；<br><strong>M档</strong>手动挡（手动调节三要素），A档光圈优先（调节光圈和iso自动设置快门），S档快门优先（调节快门和iso自动光圈）</li>
<li>光圈：控制镜头进光量(通过镜头前面看得到光圈大小)，其数值等于 <code>焦距/通光直径</code><br>光圈越大数值越小，进光量越大，背景虚化越强，1.4 - 2 - 2.8 - …表示光圈半径差根号2倍光圈面积差2倍进光量差一倍曝光差一档<br><strong>景深</strong>指的是画面中清晰的一段(否则就被虚化)，光源与镜头（光圈）形成的角度越大，景深越小，所以，景深与被摄物体距离平方成正比，与光圈数值成正比，与镜头焦距平方成反比</li>
<li>安全快门：在光圈开到最大，快门尽量慢时，拉高iso（后期去除噪点）做到正常曝光，拍出来不糊（因为手抖）的快门。<br>安全快门的经验值是 <code>1/焦距</code>（远距离的狙击枪对瞄准的要求高），这里前提默认被摄对象是静止的。<br>快门速度应该考虑被摄体的移动速度，动态人像快门通常不能低于1&#x2F;200，还需考虑其与相机的距离（影响其在画面中的比例）<br>拍摄“背景清晰，行人模糊”：打开相机防抖，保持手的稳定，快门设置在1&#x2F;30或1&#x2F;50<br>拍摄“背行人清晰，背景模糊”：关闭防抖，相机跟随物体，移动的同时按下快门</li>
<li>iso：感光度指传感器对于光线的敏感程度，相当内置光源，数值越大噪点越大（牺牲图像细腻程度）事实上，是由于低进光量带来的噪点，只是iso提高亮度后使噪点更加清晰<br>iso只是一个配合的角色，90%的情况下应该自动（由曝光补偿控制）即可</li>
<li>曝光补偿：事实上还是通过支配三要素来控制曝光。<br>当m档时，曝光补偿是三要素的调整后的画面整体曝光偏向，做信息提示用。<br>当三要素自动&#x2F;半自动时，曝光补偿就是一个总控开关，我设置这个开关为-1，其他三要素就根据这个指令自动计算结果。</li>
<li>最起码的是亮度正常，看直方图（牢理论：暗处不死黑，高光不过曝）</li>
<li>测光功能：平均测光模式下，如果相机计算图像中所有像素的平均亮度为18度灰，则认为曝光补偿为0（前提是相机认为所有物体的平均反射率都是18%，自然界中物体的平均值确实如此，但对于具体物体不一定准确，需要调整曝光补偿，白加黑减）<br>不同的测光模式，区别只在采样范围(整体，中心，点)，使得曝光补偿为0时采样范围内平均亮度为18度灰<br>一般来说，无需改变测光模式，在多重测光（索尼，富士）下调整曝光补偿即可。</li>
</ol>
<h2 id="透视"><a href="#透视" class="headerlink" title="透视"></a>透视</h2><ol>
<li>焦段越大，拍得远，画面窄（相同画面下，人靠近背景（事实上大焦段需要在距离主体更远处拍摄出相同画面））<br>焦段越小越广角人越胖。 c画幅的35mm等效全画幅50mm</li>
<li>85mm-人像焦段。 35mm-人文扫街呼吸感。 50mm-两者折中</li>
<li>透视关系：与焦段没直接关系，和镜头离物体远近有关。<table>
<thead>
<tr>
<th>焦段</th>
<th>距离</th>
<th>透视</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>短焦</td>
<td>距离近</td>
<td>透视强</td>
<td>广角 拉伸感 有张力</td>
</tr>
<tr>
<td>中段</td>
<td>&#x2F;</td>
<td>透视自然 与人眼相似</td>
<td>没有明显拉伸感 背景较平但没有明显压缩感</td>
</tr>
<tr>
<td>长焦</td>
<td>距离远</td>
<td>透视弱</td>
<td>背景比例接近真实 压缩感</td>
</tr>
</tbody></table>
</li>
<li>定焦镜头的画质一般比变焦镜头好，光圈可以更大</li>
<li>对焦: 对焦的过程就是把对焦点锁定在主体的过程。定焦镜头<br>对焦点，对焦性能，，对焦距离</li>
<li>手动对焦。。</li>
</ol>
<h2 id="器材"><a href="#器材" class="headerlink" title="器材"></a>器材</h2><ol>
<li>画质：相同传感器下，像素越大画质越差。。</li>
<li>传感器cmos: 手机&lt;卡片机&lt;半画幅&lt;全画幅&lt;中画幅&lt;大画幅，大传感器成像更细腻噪点更少<br>相同距离下，取景范围：全画幅焦距 &#x3D; 半画幅焦距 * 1.5(1.6)（半画幅50mm的取景范围相当于全画幅75mm的取景范围）</li>
<li>档位：<strong>M档</strong>手动挡（手动调节三要素），<strong>A档</strong>光圈优先（调节光圈和iso自动设置快门），<strong>S档</strong>快门优先（调节快门和iso自动光圈）</li>
<li>图像质量：FINE(直出jpeg)+RAW(无损照片)</li>
<li>动态范围，宽容度<br>宽容度一般指的是RAW原始数据，能记录最暗和最亮信息的范围。<br>动态范围则是指照片或视频，能保留最暗和最亮有效信息的范围。<br>你可以解一张高宽容度的RAW格式照片，用它调出一张高动态范围的照片，大致就是这个意思。</li>
<li>白平衡：相机白平衡等于光源色温时展现为白光，越低越黄（暖色），越高越蓝（冷光）</li>
</ol>
<h2 id="用光"><a href="#用光" class="headerlink" title="用光"></a>用光</h2><ol>
<li>硬光：太阳&#x2F;小光源LED等离物体距离远，可以认为是平行光，能让物体产生清晰阴影的光，称为硬光。硬光会使画面显得精神、干脆，也会凸显脸上的沟壑、痘痘的高光。</li>
<li>柔光：随机的阴影模糊的光线。柔光会使脸部的光影过度更加柔和。硫酸纸、塑料袋等介质都能够冲散光线，在太阳前加柔光布，跳闪也是一种做法（打向天花板再均匀反射下来）原理都是让光线从规律变成随机。</li>
<li>光源距离主体越近，光线越柔和（发光面积越大？），光影的反差越大（平方反比定律，后期拉回来即可）<br>光柔与硬指的是光线的杂乱程度，体现在阴影的锐利程度上；反差的大小是指光面与阴影之间的亮度差异，体现在阴影的深浅。</li>
<li>直闪，热靴等，，</li>
<li>光比：背光面亮度&#x2F;受光面亮度。“逆光时人脸是黑的”“演唱会时艺人的脸过曝”“窗外过曝”“背景太亮&amp;太暗”等问题基本上都是由于主体受光和背景受光相差过大所导致的，无法通过曝光三要素调整，因为相机的宽容度优先，只能展现一段的亮度。<br>解决方法：拍摄raw后期拉回来，拍摄两张不同曝光的图像合成，人像摄影给暗处补光，亮部和暗部放弃其一</li>
</ol>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ol>
<li>人的精力是有限的，拍摄中应该注重拍摄本身而不是相机的设置，需要适当放权由相机决定参数。<br>拍摄时，需要思考和权衡的只有：<strong>档位选择，曝光补偿，快门速度设定，保证安全快门，光圈设置</strong><br>其他可以在拍摄现场外设置好的参数：照片格式的选择，白平衡的设置，防抖开启与否，测光模式的选择，对焦模式的选择，对焦区域的选择，连拍模式的选择，长时间曝光降噪与高iso降噪，色彩空间的选择，滤镜&#x2F;创意外观</li>
<li>风光参数<br>光圈: 白天建议光圈优先此时快门速度不必担心，一定够快；如果近处有景物时，要缩小光圈(一般取f7.1以上)；近处无景物而对焦点较远时，光圈可大可小。<br>快门: 夜晚建议快门优先。光线不足且手持时首先保证富裕的安全快门上三脚架时，可选慢快门，使得水、云等呈现丝绸状。<br>其他: RAW格式、ISO自动、白平衡自动、单次对焦、单点对焦如果没有快门线，设置2秒的延迟快门</li>
<li>扫街参数<br>光线不稳定时，快门优先:1&#x2F;200以上，保证移动的主体也清晰。<br>在光照很强时，可用光圈优先，设置大光圈，快门速度自然会很高<br>对焦: 区域选广域，来不及调整对焦点；模式选AFC连续对焦，锁住移动主体;<br>其他:光圈与ISO自动、曝光补偿控制亮度、白平衡自动。篮球赛、活动、会议类似。。</li>
<li>参数设定整体思路<br>白天光线充足时，安全快门不必担心，可光圈优先:风光f8左右，人像开到最大。<br>光线不足时。安全快门压力大，可选快门优先，根据不同情况，设置不同的安全快门。<br>一般，快门速度越快越安全，但需要拍摄丝绸状流水时，须设置慢快门，用三脚架固定，别忘记套上ND镜。<br>拍摄移动、随机主体时，对焦选择广域+AFC连续对焦，把对焦交给相机;拍摄风光、产品时，可选单点+单次对焦，精确把控。<br>测光模式保持默认不必调来调去，白平衡可前期设置好，也设置自动后期调整。</li>
</ol>
<h2 id="后期"><a href="#后期" class="headerlink" title="后期"></a>后期</h2><ol>
<li>RAW：无损照片，保留最多信息</li>
<li>Ligthroom</li>
</ol>
<hr>

<h1 id="Scut"><a href="#Scut" class="headerlink" title="Scut"></a>Scut</h1><p><img src="https://github.com/leo710aka/bk/blob/main/scut/DSCF2479.JPG?raw=true"><br><img src="https://github.com/leo710aka/bk/blob/main/scut/DSCF3089.JPG?raw=true"><br><img src="https://github.com/leo710aka/bk/blob/main/scut/DSCF3299.JPG?raw=true"><br><img src="https://github.com/leo710aka/bk/blob/main/scut/DSCF3309.JPG?raw=true"><br><img src="https://github.com/leo710aka/bk/blob/main/scut/DSCF3834.JPG?raw=true"><br><img src="https://github.com/leo710aka/bk/blob/main/scut/DSCF3942.JPG?raw=true"><br><img src="https://github.com/leo710aka/bk/blob/main/scut/DSCF4034.JPG?raw=true"></p>
<!-- ![](https://github.com/leo710aka/bk/blob/main/scut/DSCF6000.jpg?raw=true) -->
<!-- ![](https://github.com/leo710aka/bk/blob/main/scut/DSCF6392.JPG?raw=true) -->
<p><img src="https://github.com/leo710aka/bk/blob/main/scut/DSCF6415.JPG?raw=true"><br><img src="https://github.com/leo710aka/bk/blob/main/scut/DSCF6416.JPG?raw=true"><br><img src="https://github.com/leo710aka/bk/blob/main/scut/DSCF6529.JPG?raw=true"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/09/01/Shots/" data-id="cm2rjvvgo000eb4v55eoucrax" data-title="Shots 📷" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2046/12/">December 2046</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2046/08/">August 2046</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2046/12/30/nice-photo/">Nice Photo</a>
          </li>
        
          <li>
            <a href="/2046/08/27/Guitar/">Guitar 🎸</a>
          </li>
        
          <li>
            <a href="/2024/09/22/InfluxDB/">InfluxDB | DBAdvanced</a>
          </li>
        
          <li>
            <a href="/2024/09/22/Golang/">Golang</a>
          </li>
        
          <li>
            <a href="/2024/08/18/%E4%BF%9D%E9%99%A9/">保 险</a>
          </li>
        
          <li>
            <a href="/2024/07/07/%E7%BE%8E%E7%9A%84Midea/">美 的 Midea</a>
          </li>
        
          <li>
            <a href="/2024/05/01/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/">毕 业 🎓 设 计</a>
          </li>
        
          <li>
            <a href="/2024/01/11/RabbitMQ/">RabbitMQ</a>
          </li>
        
          <li>
            <a href="/2024/01/07/SpringCloud/">SpringCloud</a>
          </li>
        
          <li>
            <a href="/2024/01/04/%E9%AA%8F%E4%BC%AFJunbo/">骏 伯 Junbo</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 fengcai<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>