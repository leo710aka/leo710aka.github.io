<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Qué miras Bobo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Qué miras Bobo">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Qué miras Bobo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="fengcai">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Qué miras Bobo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="https://github.com/leo710aka/bk/blob/main/DT1.jpg?raw=true">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Qué miras Bobo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-SpringBoot" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/12/SpringBoot/" class="article-date">
  <time class="dt-published" datetime="2021-09-12T03:49:42.000Z" itemprop="datePublished">2021-09-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/12/SpringBoot/">SpringBoot</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>为什么有了SpringFramework还会诞生SpringBoot？简单而言，因为虽然Spring的组件代码是轻量级的，但它的配置却是重量级的；所以SpringBoot的设计策略是通过开箱即用和约定大于配置 来解决配置重的问题的。</p>
<p>Spring Boot 是一个用于简化 Spring 应用程序开发的框架，它提供了大量的注解来简化配置和开发。</p>
<h2 id="Spring-Boot-注解"><a href="#Spring-Boot-注解" class="headerlink" title="Spring Boot 注解"></a>Spring Boot 注解</h2><ol>
<li><code>@SpringBootApplication</code>：该注解用于标记主应用程序类，通常位于项目的顶层包中。它包含了 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code> 和 <code>@ComponentScan</code> 注解，用于自动配置和组件扫描。</li>
<li><code>@RestController</code>：用于标记一个类，表示它是一个控制器类，处理 HTTP 请求并返回 JSON 或 XML 等数据。</li>
<li><code>@RequestMapping</code>：用于将 HTTP 请求映射到控制器方法上，指定请求的 URL 路径和请求方法（GET、POST、PUT、DELETE 等） <strong>@RequestMapping(path &#x3D; “&#x2F;user&#x2F;detail”, method &#x3D; RequestMethod.POST)</strong></li>
<li><code>@GetMapping</code>、<code>@PostMapping</code>、<code>@PutMapping</code>、<code>@DeleteMapping</code>：这些注解分别用于将 HTTP GET、POST、PUT 和 DELETE 请求映射到相应的处理方法上。</li>
<li><code>@RequestParam</code>：用于从请求参数中获取值，并将其传递给控制器方法的参数。</li>
<li><code>@PathVariable</code>：用于从 URL 路径中获取值，并将其传递给控制器方法的参数。</li>
<li><code>@RequestBody</code>：用于将请求体中的数据绑定到控制器方法的参数上，通常用于接收 JSON 或 XML 数据。<br><code>@ResponseBody</code>： 表示方法返回的对象应该直接写入HTTP响应体，而不是通过视图解析器进行渲染。</li>
<li><code>@Autowired</code> 是 Spring 框架自带的注解用于进行<strong>依赖注入</strong>，将 Spring 托管的 bean 注入到需要它们的类中。<br><code>@Resource</code>是 Java EE 提供的注解，用于实现<strong>依赖注入</strong>。它可以用于字段、setter 方法、构造函数等地方，用于告诉容器注入指定名称或类型的 bean。</li>
<li><code>@Service</code>、<code>@Repository</code>、<code>@Controller</code>：这些注解分别用于标记服务类、仓库类和控制器类，以便 Spring Boot 可以自动扫描并创建这些组件。都属于 @Component 的衍生注解，用于更明确地表示类的职责。<br><code>@Component</code> 是 Spring 框架中用于<strong>声明一个类为 Spring 管理的组件（Bean）</strong>的注解。</li>
<li><code>@Configuration</code>：用于定义配置类，通常与 @Bean 注解一起使用，用于配置第三方库或复杂的 bean。<br><code>@Bean</code>： 用于定义Spring Bean，通常在 @Configuration 类中使用。</li>
<li><code>@Override</code> 是Java中的一个注解（Annotation），用于标识方法是否是一个覆盖（重写）了父类或接口中的方法。它提供了编译时的检查，确保您正确地重写了父类或接口中的方法，以防止由于拼写错误或方法签名不匹配而导致的错误。</li>
<li><code>@Value</code>：用于注入属性值，从配置文件中获取属性值。</li>
<li><code>@Profile</code>：用于定义不同环境下的配置文件，可以根据不同的配置文件加载不同的配置。</li>
<li><code>@Conditional</code>：用于根据条件决定是否创建某个 bean。</li>
<li><code>@EnableAutoConfiguration</code>：用于自动配置Spring Boot应用程序的组件，通常与 <code>@SpringBootApplication</code> 一起使用。</li>
<li><code>@Param</code>：给参数变量起别名。如果只有一个参数，并且在mapper对应的xml文件中<if>里使用，则必须加别名。</li>
<li><code>@Async</code> 是 Spring 框架中用于实现异步方法调用的注解。通过在方法上添加 @Async 注解，Spring Boot 就会在调用该方法时使用另一个线程来执行，而不是阻塞当前线程等待方法执行完成。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/12/SpringBoot/" data-id="clr24omj3000qswv5fiewarte" data-title="SpringBoot" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Spring" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/11/Spring/" class="article-date">
  <time class="dt-published" datetime="2021-09-11T03:49:42.000Z" itemprop="datePublished">2021-09-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/11/Spring/">Spring</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Spring 是一个开源的轻量级框架，用于构建企业级 Java 应用程序。它提供了广泛的基础设施支持和许多可重用的库，以<strong>简化企业级应用程序的开发</strong>。Spring 框架的设计目标是促进松耦合、可维护性和可测试性的编码实践。<br><strong>Spring的一个最大的目的就是使 JAVA EE 开发更加容易。</strong>同时，Spring之所以与Struts、Hibernate等单层框架不同，是因为Spring致力于提供一个以统一的、高效的方式构造整个应用，并且可以将单层框架以最佳的组合揉和在一起建立一个连贯的体系。可以说Spring是一个提供了更完善开发环境的一个框架，可以为POJO对象提供企业级的服务。</p>
<img src="https://github.com/leo710aka/bk/blob/main/spring.png?raw=true" width="500" height="200" alt=""> 

<p><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-framework">官方的项目和教程</a>地址，在学习Spring时，一定要把它当做生态体系，而是不是一个简单的开发框架。<br>Spring简单例子引入Spring要点：<a target="_blank" rel="noopener" href="https://pdai.tech/md/spring/spring-x-framework-helloworld.html">https://pdai.tech/md/spring/spring-x-framework-helloworld.html</a></p>
<h2 id="核心功能和特点"><a href="#核心功能和特点" class="headerlink" title="核心功能和特点"></a>核心功能和特点</h2><ul>
<li>非侵入式：基于Spring开发的应用中的对象可以不依赖于Spring的API</li>
<li><strong>控制反转（IoC）</strong>：Inversion of Control，指的是将对象的创建权交给 Spring 去创建。Spring 的 IoC 容器管理对象的生命周期和配置，开发者不再需要手动 new创建对象。这种反转控制的方式使得应用程序更加松散耦合、易于测试和维护。<strong>Spring 管理一切</strong>，管理项目中的对象和整合其他对象。</li>
<li><strong>依赖注入</strong>：DI——Dependency Injection，是指依赖的对象不需要手动调用 setXX 方法去设置，而是通过配置赋值。</li>
<li><strong>面向切面编程（AOP）</strong>：Spring 提供了强大的 AOP 支持，通过 AOP 可以更好地处理横切关注点，如事务管理、安全性、日志记录等。AOP 可以提高代码的模块性和可维护性。</li>
<li>容器：Spring 是一个容器，因为它包含并且管理应用对象的生命周期</li>
<li>组件化：Spring 实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用XML和Java注解组合这些对象。</li>
<li>一站式：在 IOC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库（实际上 Spring 自身也提供了表现层的 SpringMVC 和持久层的 Spring JDBC）<ul>
<li>模型视图控制器（MVC）：Spring MVC 是一个强大的 Web 框架，通过注解配置和可插拔的视图解析器简化了 Web 应用的开发。它提供了清晰的分层结构，使得开发更加模块化。</li>
<li>Spring 简化了数据访问的过程，提供了一致的编程模型，支持 JDBC 和 ORM 框架。这使得数据访问更加灵活、简单，且易于集成各种数据源。</li>
<li>Spring 真正的利用了一些现有的技术，像 ORM 框架、日志框架、JEE、Quartz 和 JDK 计时器，其他视图技术。</li>
<li>Spring 对 JavaEE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等）都提供了封装，使这些API应用难度大大降低。</li>
</ul>
</li>
<li>事务管理：Spring 提供了声明式事务管理，通过注解或 XML 配置来管理事务。这样可以将事务管理从业务代码中解耦，使代码更加干净和易于理解。Spring 提供了一致的事务管理接口，可向下扩展到（使用一个单一的数据库，例如）本地事务并扩展到全局事务（例如，使用 JTA）</li>
<li>灵活性和可扩展性：Spring 的模块化结构使得可以仅使用需要的功能，从而保持应用程序的轻量级。Spring 的组件是可插拔的，可以轻松地集成第三方库。<ul>
<li>？？Spring 可以使开发人员使用 POJOs 开发企业级的应用程序。只使用 POJOs 的好处是你不需要一个 EJB 容器产品，比如一个应用程序服务器，但是你可以选择使用一个健壮的 servlet 容器，比如 Tomcat 或者一些商业产品。</li>
<li>Spring 在一个单元模式中是有组织的。即使包和类的数量非常大，你只要担心你需要的，而其它的就可以忽略了。</li>
<li>轻量级的 IOC 容器往往是轻量级的，例如，特别是当与 EJB 容器相比的时候。这有利于在内存和 CPU 资源有限的计算机上开发和部署应用程序。</li>
</ul>
</li>
<li>测试支持：Spring 框架鼓励并支持测试驱动开发(TDD)。提供许多工具和类库来进行单元测试和集成测试，保障应用程序的质量。<br>？？测试一个用 Spring 编写的应用程序很容易，因为环境相关的代码被移动到这个框架中。此外，通过使用 JavaBean-style POJOs，它在使用依赖注入注入测试数据时变得更容易。</li>
</ul>
<h3 id="Spring-Framework"><a href="#Spring-Framework" class="headerlink" title="Spring Framework"></a>Spring Framework</h3><p>下图来自官方文档 Spring-framework 5.0；需要注意的是，虽然这个图来源于Spring Framwork5.0 M4 版本，但是它依然是V4版本的图，比如Spring 5版本中的web模块已经去掉了Portlet模块，新增了WebFlux模块等。<br>包含了 Spring 框架的所有模块，可以满足一切企业级应用开发的需求，在开发过程中可以根据需求有选择性地使用所需要的模块。<br><img src="https://pdai.tech/images/spring/springframework/spring-framework-introduce-8.png" width="700" height="200" alt=""> </p>
<h4 id="Core-Container（Spring的核心容器）"><a href="#Core-Container（Spring的核心容器）" class="headerlink" title="Core Container（Spring的核心容器）"></a>Core Container（Spring的核心容器）</h4><p>Spring 的核心容器是其他模块建立的基础，没有这些核心容器，也不可能有 AOP、Web 等上层的功能。</p>
<ul>
<li>Beans 模块：提供了框架的基础部分，包括控制反转和依赖注入。</li>
<li>Core 核心模块：封装了 Spring 框架的底层部分，包括资源访问、类型转换及一些常用工具类。</li>
<li>Context 上下文模块：建立在 Core 和 Beans 模块的基础之上，集成 Beans 模块功能并添加资源绑定、数据验证、国际化、Java EE 支持、容器生命周期、事件传播等。ApplicationContext 接口是上下文模块的焦点。</li>
<li>SpEL 模块：提供了强大的表达式语言支持，支持访问和修改属性值，方法调用，支持访问及修改数组、容器和索引器，命名变量，支持算数和逻辑运算，支持从 Spring 容器获取 Bean，它也支持列表投影、选择和一般的列表聚合等。</li>
</ul>
<h4 id="Data-Access-Integration（数据访问／集成）"><a href="#Data-Access-Integration（数据访问／集成）" class="headerlink" title="Data Access&#x2F;Integration（数据访问／集成）"></a>Data Access&#x2F;Integration（数据访问／集成）</h4><ul>
<li>JDBC 模块：提供了一个 JDBC 的样例模板，使用这些模板能消除传统冗长的 JDBC 编码还有必须的事务控制，而且能享受到 Spring 管理事务的好处。</li>
<li>ORM 模块：提供与流行的“对象-关系”映射框架无缝集成的 API，包括 JPA、JDO、Hibernate 和 MyBatis 等。而且还可以使用 Spring 事务管理，无需额外控制事务。</li>
<li>OXM 模块：提供了一个支持 Object &#x2F;XML 映射的抽象层实现，如 JAXB、Castor、XMLBeans、JiBX 和 XStream。将 Java 对象映射成 XML 数据，或者将XML 数据映射成 Java 对象。</li>
<li>JMS 模块：指 Java 消息服务，提供一套 “消息生产者、消息消费者”模板用于更加简单的使用 JMS，JMS 用于用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</li>
<li>Transactions 事务模块：支持编程和声明式事务管理。</li>
</ul>
<h4 id="Web模块"><a href="#Web模块" class="headerlink" title="Web模块"></a>Web模块</h4><ul>
<li>Web 模块：提供了基本的Web开发集成特性，例如多文件上传功能、使用的 Servlet监听器的IOC容器初始化以及Web应用上下文。</li>
<li>Servlet 模块：提供了一个 Spring MVC Web 框架实现。Spring MVC 框架提供了基于注解的请求资源注入、更简单的数据绑定、数据验证等及一套非常易用的 JSP 标签，完全无缝与 Spring 其他技术协作。</li>
<li>WebSocket 模块：提供了简单的接口，用户只要实现响应的接口就可以快速的搭建 WebSocket Server，从而实现双向通讯。</li>
<li>Webflux 模块： Spring WebFlux 是 Spring Framework 5.x中引入的新的响应式web框架。与Spring MVC不同，它不需要Servlet API，是完全异步且非阻塞的，并且通过Reactor项目实现了Reactive Streams规范。Spring WebFlux 用于创建基于事件循环执行模型的完全异步且非阻塞的应用程序。</li>
</ul>
<h4 id="AOP、Aspects、Instrumentation-和-Messaging"><a href="#AOP、Aspects、Instrumentation-和-Messaging" class="headerlink" title="AOP、Aspects、Instrumentation 和 Messaging"></a>AOP、Aspects、Instrumentation 和 Messaging</h4><ul>
<li>AOP 模块：提供了面向切面编程实现，提供比如日志记录、权限控制、性能统计等通用功能和业务逻辑分离的技术，并且能动态的把这些功能添加到需要的代码中，这样各司其职，降低业务逻辑和通用功能的耦合。<ol>
<li>AOP：即面向方面（切面）编程。是一种编程思想，是对OOP的补充，可以进一步提高编程的效率。<br>  例如，把多个业务组件的共同功能封装成一个“系统组件”，如对所有service类进行权限检查、记录日志、事务管理…</li>
<li>织入：将方面<strong>Aspect</strong>（处理系统组件的额外的bean）[切点<strong>Pointcut</strong>（声明织入到哪些对象的哪些位置）+ 通知<strong>Advice</strong>（处理的逻辑(前,后,返回,异常)] <strong>—&gt;</strong> 织入<strong>Weaving</strong>（编译时&#x2F;装载时&#x2F;运行时） <strong>—&gt;</strong> 目标对象<strong>Target</strong>（程序中开发好的bean）的连接点<strong>Joinpoint</strong>（可以织入代码的地方）</li>
<li>AOP的实现<ul>
<li>AspectJ：语言级的实现（一门新语言）。编译期织入代码。</li>
<li>Spring AOP：纯Java实现。运行时通过代理的方式织入代码，只支持方法类型的连接点。<ul>
<li>JDK动态代理：在运行时创建接口的代理实例。Spring AOP 默认方式，在接口的代理实例中织入代码。</li>
<li>CGLib动态代理：不要求目标类实现接口，通过继承目标类来创建代理对象。即可以代理没有实现接口的类。</li>
<li>如果你的目标类已经实现了接口，并且你希望代理对象是目标类的接口的实现，那么可以使用JDK动态代理。如果你的目标类没有实现接口，或者你需要代理非公共方法（final、private等），那么可以使用CGLib动态代理。</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceLogAspect</span> &#123;</span><br><span class="line">    <span class="comment">// 切点：service包下的所有方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.nowcoder.community.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointcut</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 前置通知</span></span><br><span class="line">    <span class="meta">@Before(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="comment">// 用户[1.2.3.4],在[xxx],访问了[com.nowcoder.community.service.xxx()].</span></span><br><span class="line">        <span class="type">ServletRequestAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> attributes.getRequest();</span><br><span class="line">        <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> request.getRemoteHost();</span><br><span class="line">        <span class="type">String</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="type">String</span> <span class="variable">target</span> <span class="operator">=</span> joinPoint.getSignature().getDeclaringTypeName() + <span class="string">&quot;.&quot;</span> + joinPoint.getSignature().getName();</span><br><span class="line">        logger.info(String.format(<span class="string">&quot;用户[%s],在[%s],访问了[%s].&quot;</span>, ip, now, target));    </span><br><span class="line">    &#125;  &#125;</span><br></pre></td></tr></table></figure></li>
<li>Aspects 模块：提供与 AspectJ 的集成，是一个功能强大且成熟的面向切面编程（AOP）框架。<br>Instrumentation 模块：提供了类工具的支持和类加载器的实现，可以在特定的应用服务器中使用。</li>
<li>messaging 模块：Spring 4.0 以后新增了消息（Spring-messaging）模块，该模块提供了对消息传递体系结构和协议的支持。</li>
<li>jcl 模块： Spring 5.x中新增了日志框架集成的模块。</li>
</ul>
<h4 id="Test模块"><a href="#Test模块" class="headerlink" title="Test模块"></a>Test模块</h4><p>Spring 支持 Junit 和 TestNG 测试框架，而且还额外提供了一些基于 Spring 的测试功能，比如在测试 Web 框架时，模拟 Http 请求的功能。包含Mock Objects, TestContext Framework, Spring MVC Test, WebTestClient。</p>
<hr>

<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>在Spring Boot中，你可以使用拦截器（Interceptor）来处理请求前、请求后或请求处理过程中的逻辑。拦截器通常用于执行一些跟请求处理相关的任务，例如身份验证、日志记录、权限检查等。以下是在Spring Boot中使用拦截器的基本步骤：</p>
<ol>
<li><strong>创建拦截器类</strong>：<br>首先，你需要创建一个Java类，实现<code>HandlerInterceptor</code>接口，该接口定义了拦截器的方法，包括<code>preHandle</code>、<code>postHandle</code>和<code>afterCompletion</code>等。这些方法分别用于在请求处理前、请求处理后和请求完成后执行相应的逻辑。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginTicketInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">// 登录信息拦截器（检查登录凭证是否有效）</span></span><br><span class="line">    <span class="comment">// 每次请求，不管是什么请求，都要检查登录信息；这在interceptor中完成，而不是在每个controller重写一遍</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HostHolder hostHolder;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ticket</span> <span class="operator">=</span> CookieUtil.getValue(request, <span class="string">&quot;ticket&quot;</span>);                 <span class="comment">// 从cookie中获取凭证</span></span><br><span class="line">        <span class="keyword">if</span> (ticket != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">LoginTicket</span> <span class="variable">loginTicket</span> <span class="operator">=</span> userService.findLoginTicket(ticket);      <span class="comment">// 查询凭证</span></span><br><span class="line">            <span class="keyword">if</span> (loginTicket != <span class="literal">null</span> &amp;&amp; loginTicket.getStatus() == <span class="number">0</span> &amp;&amp; loginTicket.getExpired().after(<span class="keyword">new</span> <span class="title class_">Date</span>())) &#123;      </span><br><span class="line">                <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findUserById(loginTicket.getUserId());  <span class="comment">// 若凭证有效，查询用户</span></span><br><span class="line">                hostHolder.setUser(user);                                       <span class="comment">// 在本次请求中持有用户</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 将登录用户的信息添加到ModelAndView对象中，这样在视图中可以方便地使用这些信息</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> hostHolder.getUser();</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span> &amp;&amp; modelAndView != <span class="literal">null</span>)  modelAndView.addObject(<span class="string">&quot;loginUser&quot;</span>, user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 清除hostHolder中持有的用户信息。确保每个请求处理完成后都不会泄漏用户信息或状态，以便下一个请求可以从头开始。</span></span><br><span class="line">        hostHolder.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>配置拦截器</strong>：<br>在Spring Boot应用程序中，通常在配置类中配置拦截器。你可以继承<code>WebMvcConfigurerAdapter</code>类（或实现<code>WebMvcConfigurer</code>接口）并覆盖<code>addInterceptors</code>方法，将你的拦截器添加到拦截器链中。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginTicketInterceptor loginTicketInterceptor;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置不拦截静态资源</span></span><br><span class="line">        registry.addInterceptor(loginTicketInterceptor)</span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/**/*.css&quot;</span>, <span class="string">&quot;/**/*.js&quot;</span>, <span class="string">&quot;/**/*.png&quot;</span>, <span class="string">&quot;/**/*.jpg&quot;</span>, <span class="string">&quot;/**/*.jpeg&quot;</span>);</span><br><span class="line">    &#125;  &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Spring-事务管理"><a href="#Spring-事务管理" class="headerlink" title="Spring 事务管理"></a>Spring 事务管理</h2><ol start="0">
<li>事务：是由N步数据库操作序列组成的逻辑扩行单元，这系列操作要么全执行，要么全放弃执行事务的特性(ACID)。报错会回滚。</li>
<li>常见的并发异常：第一类丢失更新、第二类丢失更新脏读、不可重复读、幻读。</li>
<li>事务隔离级别定义了多个并发事务之间的可见性和影响的程度。在关系型数据库中，常见的隔离级别包括：<br>DEFAULT：使用数据库的默认隔离级别。通常是READ_COMMITTED。<br>READ_UNCOMMITTED：允许一个事务读取另一个事务尚未提交的数据。最低的隔离级别，不推荐在生产环境中使用，因为可能会导致脏读、不可重复读和幻读问题。<br>READ_COMMITTED：保证一个事务不会读取到其他并发事务未提交的数据。这是大多数数据库的默认隔离级别。<br>SERIALIZABLE：最高的隔离级别，确保事务串行执行，完全隔离了其他事务的影响。通常性能较差，不常用。</li>
<li>悲观锁 (数据库)<br>共享锁 (S锁)：事务A对某数据加了共享锁后，其他事务只能对该数据加共享锁，但不能加排他锁。<br>排他锁 (X锁)：事务A对某数据加了排他锁后，其他事对该数据既不能加共享锁，也不能加排他锁。</li>
<li>乐观锁(自定义)：版本号、时间戳等；若变化则取消本次更新，否则就更新数据(版本号+1)在更新数据前，检查版本号是否发生变</li>
<li>声明式事务：通过XML &#x2F; 通过注解，声明某方法的事务特征。<br>通过 <code>@Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRED)</code> 注解配置事务的属性，以控制事务的隔离级别（isolation）、传播行为（propagation）等。<br>常见的传播行为包括：REQUIRED, REQUIRES_NEW, SUPPORTS, NESTED</li>
<li>编程式事务：通过 TransactionTemplate 管理事务并通过它执行数据库的操作。（业务复杂&#x2F;只处理其中几条代码时用）</li>
</ol>
<h2 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h2><ul>
<li>@ControllerAdvice：用于修饰类，表示该类是Controller的全局配置类（放在&#x2F;controller&#x2F;advice&#x2F;下）；<br>在此类中，可以对Controller进行如下三种全局配置：异常处理方案、绑定数据方案、绑定参数方案</li>
<li>@ExceptionHandler：用于修饰（@ControllerAdvice所修饰类中的）方法，在Controller出现异常后被调用，用于处理捕获到的异常</li>
<li>@ModelAttribute：用于修饰方法，使其在Controller方法执行前被调用，用于为Model对象绑定参数（如获取从页面post的数据）</li>
<li>@DataBinder：用于修饰方法，该方法会在Controller方法执行前被调用，用于绑定参数的转换器<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice(annotations = Controller.class)</span>          <span class="comment">// 表示扫描所有controller类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionAdvice</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(ExceptionAdvice.class);</span><br><span class="line">    <span class="meta">@ExceptionHandler(&#123;Exception.class&#125;)</span>                   <span class="comment">// 指处理所有类型的异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleException</span><span class="params">(Exception e, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;服务器发生异常: &quot;</span> + e.getMessage());  <span class="comment">// 打印日志</span></span><br><span class="line">        <span class="keyword">for</span> (StackTraceElement element : e.getStackTrace()) &#123;</span><br><span class="line">            logger.error(element.toString()); &#125;  &#125;         <span class="comment">// 打印具体报错</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h2><ul>
<li>Spring Security是一个专注于为Java应用程序提供身份认证和授权的框架，它的强大之处在于它可以轻松扩展以满足自定义的需求<ul>
<li>对身份的 <strong>认证</strong> <em>和</em> <strong>授权</strong> 提供全面的、可扩展的支持</li>
<li>防止各种攻击，如会话固定攻击、点击劫持、csrf攻击等</li>
<li>支持与Servlet API、Spring MVC等Web技术集成</li>
</ul>
</li>
<li>核心概念：<ul>
<li><strong>认证（Authentication）</strong>：验证用户的身份。</li>
<li><strong>授权（Authorization）</strong>：确定用户是否有权执行某个操作。</li>
<li><strong>过滤器链（Filter Chain）</strong>：一系列的过滤器，用于处理认证和授权的请求。Spring Security的处理在 Spring MVC之前（ Security底层是基于filter，可以拦截大量请求）<br><img src="https://github.com/leo710aka/bk/blob/main/spring_security.png?raw=true"></li>
</ul>
</li>
<li>基本配置：Spring Security 配置通常通过 Java 配置或 XML 配置完成。<ul>
<li>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span>   <span class="comment">// Java 配置示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;/home&quot;</span>).permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">                .loginPage(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">            .logout()</span><br><span class="line">                .permitAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureGlobal</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        auth</span><br><span class="line">            .inMemoryAuthentication()</span><br><span class="line">                .withUser(<span class="string">&quot;user&quot;</span>).password(<span class="string">&quot;&#123;noop&#125;password&quot;</span>).roles(<span class="string">&quot;USER&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>安全过滤器链：Spring Security 的核心是安全过滤器链，它负责处理请求的认证和授权过程。在配置中，你可以通过 <code>HttpSecurity</code> 来定制过滤器链。<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">http</span><br><span class="line">    .authorizeRequests()  <span class="comment">// 对请求进行授权</span></span><br><span class="line">        .antMatchers(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;/home&quot;</span>).permitAll()  <span class="comment">// 允许所有用户访问</span></span><br><span class="line">        .anyRequest().authenticated()  <span class="comment">// 其他请求需要身份验证</span></span><br><span class="line">        .and()</span><br><span class="line">    .formLogin()  <span class="comment">// 定义登录操作</span></span><br><span class="line">        .loginPage(<span class="string">&quot;/login&quot;</span>)  <span class="comment">// 指定登录页</span></span><br><span class="line">        .permitAll()</span><br><span class="line">        .and()</span><br><span class="line">    .logout()  <span class="comment">// 定义登出操作</span></span><br><span class="line">        .permitAll();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong><code>SecurityContext</code></strong> 是 Spring Security 中用于存储当前执行身份验证操作的上下文信息的接口。<br>它通常包含了与认证（Authentication）相关的信息，例如当前已认证的用户、用户的权限等。 <code>SecurityContextHolder</code> 负责管理 <code>SecurityContext</code>，而 <code>SecurityContext</code> 的实现则是 <code>SecurityContextImpl</code>。<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在认证成功后，将认证对象放入 SecurityContext</span></span><br><span class="line"><span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authenticationToken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(userDetails, <span class="literal">null</span>, userDetails.getAuthorities());</span><br><span class="line"><span class="type">SecurityContext</span> <span class="variable">context</span> <span class="operator">=</span> SecurityContextHolder.createEmptyContext();</span><br><span class="line">context.setAuthentication(authenticationToken);</span><br><span class="line">SecurityContextHolder.setContext(context);</span><br><span class="line"><span class="comment">// 在需要获取当前用户信息的地方</span></span><br><span class="line"><span class="type">SecurityContext</span> <span class="variable">context</span> <span class="operator">=</span> SecurityContextHolder.getContext();</span><br><span class="line"><span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> context.getAuthentication();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/11/Spring/" data-id="clr24omj3000oswv554bh9gq8" data-title="Spring" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Java并发" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/05/Java%E5%B9%B6%E5%8F%91/" class="article-date">
  <time class="dt-published" datetime="2021-09-05T03:49:42.000Z" itemprop="datePublished">2021-09-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/05/Java%E5%B9%B6%E5%8F%91/">Java 并发</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h1><h4 id="多线程的出现是要解决什么问题的"><a href="#多线程的出现是要解决什么问题的" class="headerlink" title="多线程的出现是要解决什么问题的?"></a>多线程的出现是要解决什么问题的?</h4><p>众所周知，CPU、内存、V0 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为:<br>CPU 增加了缓存，以均衡与内存的速度差异;                                    &#x2F;&#x2F; 导致 <code>可见性</code> 问题<br>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I&#x2F;0 设备的速度差异; &#x2F;&#x2F; 导致 <code>原子性</code> 问题<br>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。                   &#x2F;&#x2F; 导致 <code>有序性</code> 问题</p>
<h4 id="线程不安全是指什么"><a href="#线程不安全是指什么" class="headerlink" title="线程不安全是指什么?"></a>线程不安全是指什么?</h4><p>如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。</p>
<h4 id="举例说明并发出现线程不安全的本质什么-保障-可见性，原子性和有序性。"><a href="#举例说明并发出现线程不安全的本质什么-保障-可见性，原子性和有序性。" class="headerlink" title="举例说明并发出现线程不安全的本质什么? 保障 可见性，原子性和有序性。"></a>举例说明并发出现线程不安全的本质什么? 保障 可见性，原子性和有序性。</h4><p>可见性【CPU缓存引起】：一个线程对共享变量的修改，另外一个线程能够立刻看到。<br>原子性【分时复用引起】：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。<br>有序性【重排序引起】：即程序执行的顺序按照代码的先后顺序执行。</p>
<h4 id="Java是怎么解决并发问题的-3个关键字，JMM-和-8个-Happens-Before"><a href="#Java是怎么解决并发问题的-3个关键字，JMM-和-8个-Happens-Before" class="headerlink" title="Java是怎么解决并发问题的? 3个关键字，JMM 和 8个 Happens-Before"></a>Java是怎么解决并发问题的? 3个关键字，JMM 和 8个 Happens-Before</h4><ul>
<li>Java 内存模型是个很复杂的规范，推荐：<a target="_blank" rel="noopener" href="https://pdai.tech/md/java/jvm/java-jvm-jmm.html">https://pdai.tech/md/java/jvm/java-jvm-jmm.html</a></li>
<li><strong>理解的第一个维度：核心知识点</strong><br>JMM本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。<br>具体来说，这些方法包括（1）volatile、synchronized 和 final 三个关键字；（2）Happens-Before </li>
<li><strong>规则理解的第二个维度：可见性，有序性，原子性</strong><ul>
<li>原子性：在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行要么不执行。（Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。）</li>
<li>可见性：Java提供了<code>volatile</code>关键字来保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。（另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。）</li>
<li>有序性：通过<code>volatile</code>关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。当然JMM是通过Happens-Before 规则来保证有序性的。</li>
</ul>
</li>
<li><strong>关键字: volatile、synchronized 和 final</strong></li>
<li><strong>Happens-Before 规则：JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。</strong><ul>
<li>1.单一线程原则Single Thread rule：在一个线程内，在程序前面的操作先行发生于后面的操作。</li>
<li>2.管程锁定规则Monitor Lock Rule：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。</li>
<li><ol start="3">
<li></li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="线程安全是不是非真即假-…不是"><a href="#线程安全是不是非真即假-…不是" class="headerlink" title="线程安全是不是非真即假?…不是"></a>线程安全是不是非真即假?…不是</h4><p>一个类在可以被多个线程安全调用时就是线程安全的。<br>线程安全不是一个非真即假的命题，可以将共享数据按照安全程度的强弱顺序分成以下五类: 不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p>
<ol>
<li>不可变、</li>
<li>绝对线程安全、</li>
<li>相对线程安全、</li>
<li>线程兼容</li>
<li>线程对立。</li>
</ol>
<h4 id="线程安全有哪些实现思路"><a href="#线程安全有哪些实现思路" class="headerlink" title="线程安全有哪些实现思路?"></a>线程安全有哪些实现思路?</h4><ol>
<li>互斥同步<br>synchronized 和 ReentrantLock。</li>
<li>非阻塞同步</li>
<li>无同步方案</li>
</ol>
<h4 id="如何理解并发和并行的区别"><a href="#如何理解并发和并行的区别" class="headerlink" title="如何理解并发和并行的区别?"></a>如何理解并发和并行的区别?</h4><p><strong>并发</strong>：单核CPU宏观上可以处理多线程，是通过CPU调度实现的<strong>交替执行</strong><br><strong>并行</strong>：在多核CPU系统中利用每个处理器处理一个可以并发执行的程序，这样多个程序便可以<strong>同时执行</strong>。<br>上下文切换：线程上下文是指某一时间点 CPU寄存器和程序计数器的内容，CPU通过时间片分配算法来循环执行任务(线程)。多线程往往会比单线程更快更能够提高并发，但同时更多的线程意味着线程创建销毁开销加大、上下文非常频繁，程序反而不能支持更高的TPS。<br>时间片：时间片是CPU分配给各个任务(线程)的时间。多任务系统往往需要同时执行多道作业。作业数往往大于机器的CPU数，然而一颗CPU同时只能执行一项任务，利用了时间片轮转的方式进行调度。<br>建议：合理设置线程数目既可以最大化利用CPU，又可以减少线程切换的开销。高并发，低耗时的情况，建议少线程；低并发，高耗时的情况，建议多线程；高并发，高耗时的情况，要分析任务类型、增加排队、加大线程数</p>
<hr>


<h1 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h1><h3 id="进程、线程、纤程"><a href="#进程、线程、纤程" class="headerlink" title="进程、线程、纤程"></a>进程、线程、纤程</h3><ol>
<li><strong>Java 进程</strong>：在操作系统中，进程是基本的资源分配单位，操作系统通过进程来管理计算机的资源（进程可以看作是一个正在执行的程序 如QQ.exe）,每个进程有一个唯一的进程标识符 (PID)用来区分。<br>Java中，一个进程通常是指一个独立运行的 Java 虚拟机（JVM）实例；每个 Java 进程都有自己的内存空间、程序计数器、寄存器等资源，启动 Java 程序就启动了一个 Java 进程。<img src="https://github.com/leo710aka/bk/blob/main/juc1.png?raw=true" width="500" height="200" alt=""> </li>
<li><strong>Java 线程</strong>：线程是操作系统中的基本执行单元(能够直接执行的最小代码块)，是CPU调度和分派的基本单位。一个进程可包含多个线程，每个线程独立执行不同的任务，共享进程的资源。同一时刻一个CPU核心只能运行一线程，8核CPU同时可以执行8个线程代码。<br>线程是进程中的执行单元，Java 中线程是通过 <code>java.lang.Thread</code>类来表示和操作的。</li>
<li>纤程：Java19才支持虚拟线程(纤程【协程】)<br>1、纤程可以在一个线程内部创建多个纤程这些纤程之间可以共享同一个线程的资源<br>2、纤程是在同一个进程内部运行的，不需操作系统的介入，可以在用户空间内实现协作式多任务处理（jvm级别的）。因此纤程的创建和销毁开销很小，可更高效地利用系统资源。<br>3、先有进程，然后进程可以创建线程，线程是依附在进程里面的。<br>线程里面可以包含多个协程；进程之间不共亭全局变量。线程之间共享全局变量，但是要注意资源竞争的问题</li>
<li>常用方法<ul>
<li><strong>start() 与 run()</strong><ul>
<li>类型：run方法是同步方法（按代码顺序执行），而start方法是异步方法（创建新线程）</li>
<li>作用：run方法的作用是存放（执行）任务代码，不产生新线程；而start方法创建，并启动一个新线程</li>
<li>执行次数：run方法可以被执行无数次，而start方法只能被执行一次，原因在于线程不能被重复启动</li>
</ul>
</li>
<li>setName：给当前线程取名字</li>
<li>getName()：获取当前线程的名字。线程存在默认名称：子线程是 Thread-索引，主线程是 main</li>
<li><strong>sleep()：</strong>让当前线程休眠多少毫秒再继续执行，Thread.sleep(0):让操作系统立刻重新进行一次cpu竞争。<br>  在循环访问锁的过程中，可以加入sleep让线程阻塞时间，防止大量占用cpu资源其它线程。<ul>
<li>可以使用interrupt() 打断正在睡眠的线程，这时 sleep()会抛出InterruptedException.</li>
<li>建议用TimeUnit的sleep()代替Thread的sleep来获得更好的可读性，其底层还是sleep方法.</li>
</ul>
</li>
<li>yield()：提示线程调度器尽力让出当前线程对CPU的使用</li>
<li>setPriority()：更改该线程的优先级，1~15，越大被CPU调度的几率越高。getPriority()：返回该线程的优先级</li>
<li><strong>interrupt()：</strong>中断这个线程，异常处理机制？？？？？<br>  ？？？<ul>
<li>public static boolean interrupted()：判断当前线程是否被打断，清除打断标记</li>
<li>public boolean isInterrupted()：判断当前线程是否被打断，不清除打断标记</li>
</ul>
</li>
<li>join()：主线程将等待这个线程结束（异步变同步了。。）；可以设置等待millis毫秒。</li>
<li>setDaemon(true)：设置守护线程；可以通过 Thread.isDaemon()来判断<ul>
<li>默认情况下创建的线程都是用户线程(普通线程)，需要等待所有的线程执行完毕后，进程才会结束</li>
<li>当所有的用户线程退出后，守护线程会立马结束</li>
<li>应用：垃圾回收器线程属于守护线程，tomcat用来接受处理外部的请求的线程就是守护线程</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="线程有哪几种状态-分别说明从一种状态到另一种状态转变有哪些方式"><a href="#线程有哪几种状态-分别说明从一种状态到另一种状态转变有哪些方式" class="headerlink" title="线程有哪几种状态? 分别说明从一种状态到另一种状态转变有哪些方式?"></a>线程有哪几种状态? 分别说明从一种状态到另一种状态转变有哪些方式?</h4><ul>
<li>Java 中线程状态是用 <strong>6个</strong>enum 表示<ul>
<li><strong>NEW</strong>：初始状态，线程被构建，但是还没有调用start()</li>
<li><strong>RUNNABLE</strong>：可能正在运行，也可能正在等待 CPU 时间片。Java线程将操作系统中的就绪和运行两种状态统称为“运行中”</li>
<li><strong>BLOCKED</strong>：阻塞状态，表示线程阻塞于锁。等待获取一个排它锁，如果其线程释放了锁就会结束此状态。</li>
<li><strong>WAITING</strong>：无限期等待，等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。</li>
<li><strong>TIME_WAITING</strong>：限期等待，无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。<br>  调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。<br>  睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入。</li>
<li><strong>TERMINATED</strong>：终止状态。可以是线程结束任务之后自己结束，或者产生了异常而结束。<img src="https://pdai.tech/images/pics/ace830df-9919-48ca-91b5-60b193f593d2.png" width="500" height="200" alt=""></li>
</ul>
</li>
</ul>
<h4 id="通常线程有哪几种使用方式"><a href="#通常线程有哪几种使用方式" class="headerlink" title="通常线程有哪几种使用方式?"></a>通常线程有哪几种使用方式?</h4><p>有三种使用线程的方法：实现 Runnable 接口；实现 Callable 接口；继承 Thread 类。<br>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。<br>实现接口 VS 继承 Thread：实现接口会更好一些。因为 Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；类可能只要求可执行就行，继承整个 Thread 类开销过大。</p>
<ol>
<li>通过<strong>继承Thread类</strong>，重写run方法。<br>Thread 类也实现了 Runable 接口。当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> extend Thread &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; ...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">    mt.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>通过<strong>实现Runnable接口</strong>：<br>需要实现 run() 方法。通过 Thread 调用 start() 方法来启动线程。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; ...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 通过继承Thread。启动过程为: thread.start()-&gt;中间过程-&gt;thread.run() 即重写的方法</span></span><br><span class="line">    <span class="type">MyThread</span> <span class="variable">mythread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">    <span class="comment">// 开启异步线程：异步，创建一个新线程 mythread</span></span><br><span class="line">    mythread.start();  </span><br><span class="line">    <span class="comment">// 通过实现Runnable接口。实例化Thread，传递一个Runable任务</span></span><br><span class="line">    <span class="comment">// 启动过程为: thread.start()-&gt;中间过程&gt;thread.run() 默认逻辑-&gt;runable.run() 实际业务</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主线程main、线程mythread、线程thread 异步执行</span></span><br></pre></td></tr></table></figure></li>
<li><strong>实现 Callable 接口</strong>：与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="number">123</span>;    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="type">MyCallable</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">    FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(mc);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(ft.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="基础线程机制有哪些"><a href="#基础线程机制有哪些" class="headerlink" title="基础线程机制有哪些?"></a>基础线程机制有哪些?</h4><ul>
<li>Executor：管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。<br>  这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。主要有三种 Executor:<ul>
<li>CachedThreadPool: 一个任务创建一个线程；</li>
<li>FixedThreadPool: 所有任务只能使用固定大小的线程；</li>
<li>SingleThreadExecutor: 相当于大小为 1 的 FixedThreadPool。</li>
</ul>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Daemon：守护线程，是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。<br>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。main() 属于非守护线程。使用 setDaemon() 方法将一个线程设置为守护线程。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">    thread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>sleep()：Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>yield()：对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    Thread.<span class="keyword">yield</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="线程的中断方式有哪些"><a href="#线程的中断方式有哪些" class="headerlink" title="线程的中断方式有哪些?"></a>线程的中断方式有哪些?</h4><p>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。</p>
<ul>
<li>InterruptedException：通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I&#x2F;O 阻塞和 synchronized 锁阻塞。</li>
<li>interrupted()：如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。<br>但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。</li>
<li>Executor 的中断操作：调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。<br>？？？</li>
</ul>
<h4 id="线程的互斥同步方式有哪些-如何比较和选择"><a href="#线程的互斥同步方式有哪些-如何比较和选择" class="headerlink" title="线程的互斥同步方式有哪些? 如何比较和选择?"></a>线程的互斥同步方式有哪些? 如何比较和选择?</h4><p>Java 提供两种锁机制来控制多个线程对共享资源的互斥访问：JVM 实现的 <code>synchronized</code>，JDK 实现的 <code>ReentrantLock</code><br>???<br><a target="_blank" rel="noopener" href="https://pdai.tech/md/java/thread/java-thread-x-thread-basic.html#%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5">https://pdai.tech/md/java/thread/java-thread-x-thread-basic.html#%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5</a></p>
<h4 id="线程之间有哪些协作方式"><a href="#线程之间有哪些协作方式" class="headerlink" title="线程之间有哪些协作方式?"></a>线程之间有哪些协作方式?</h4><p>当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。</p>
<ul>
<li>join()：在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。<br>对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>wait() notify() notifyAll()<br>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。它们都属于 Object 的一部分，而不属于 Thread。只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateExeception。使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。</li>
<li>await() signal() signalAll()<br>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。</li>
</ul>
<hr>

<h1 id="Java中所有的锁"><a href="#Java中所有的锁" class="headerlink" title="Java中所有的锁"></a>Java中所有的锁</h1><p>Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。<br><img src="https://pdai.tech/images/thread/java-lock-1.png"></p>
<ol>
<li>乐观锁 VS 悲观锁<br> 乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。<ul>
<li>对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。</li>
<li>乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果数据没有被更新，当前线程将自己修改的数据成功写入；如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。<br> 乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。</li>
<li>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。<br> 乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</li>
</ul>
</li>
<li>独享锁(排他锁) VS 共享锁<br>独享锁也叫排他锁（写锁），是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。<br>共享锁（读锁）是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</li>
</ol>
<hr>


<h1 id="JUC-类汇总"><a href="#JUC-类汇总" class="headerlink" title="JUC 类汇总"></a>JUC 类汇总</h1><p>JUC是 <code>java.util.concurrent</code>包的缩写，说白了就是并发场景进行多线程编程的工具类。<br>总的来说就是在并发场景下，怎么让程序尽量通过有限的硬件，高效的处理请求，并且保证程序“线程安全”。<br>开发高并发、高性能系统（1）加快响应用户的时间（2）使代码模块化、异步化、简单化（3）充分利用CPU的多核资源</p>
<h2 id="Java-线程池-？？"><a href="#Java-线程池-？？" class="headerlink" title="Java 线程池 ？？"></a>Java 线程池 ？？</h2><ul>
<li>JDK 线程池<ul>
<li>ExecutorService</li>
<li>ScheduledExecutorService（定时任务）</li>
</ul>
</li>
<li>Spring 线程池<ul>
<li>ThreadPoolTaskExecutor</li>
<li>ThreadPoolTaskScheduler（定时任务）</li>
</ul>
</li>
<li>分布式定时任务<ul>
<li>Spring Quartz：不同服务器上的quartz线程依赖于同一个数据库</li>
</ul>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK普通线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// JDK可执行定时任务的线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">ScheduledExecutorService</span> <span class="variable">scheduedExecutorSevice</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// Spring普通线程池</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ThreadPoolTaskExecutor taskExecutor;</span><br><span class="line"><span class="comment">// Spring可执行定时任务的线程池</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ThreadPoolTaskScheduler taskScheduler;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 AlphaService 中给方法加上 @Async，使该方法在多线程环境下被异步的调用（被主线程并发并发，异步执行）</span></span><br><span class="line"><span class="comment">// 在 AlphaService 中给方法加上 @Scheduled，只要有程序再跑就会自动调用</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AlphaService alphaService;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.JDK普通线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testExecutorService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        executorService.submit(task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.JDK定时任务线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testScheduledExecutorService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;&#125;;</span><br><span class="line">    scheduledExecutorService.scheduleAtFixedRate(task, <span class="number">10000</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.Spring普通线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testThreadPoolTaskExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        taskExecutor.submit(task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4.Spring定时任务线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testThreadPoolTaskScheduler</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;&#125;;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">startTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + <span class="number">10000</span>);</span><br><span class="line">    taskScheduler.scheduleAtFixedRate(task, startTime, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5.Spring普通线程池(简化)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testThreadPoolTaskExecutorSimple</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 并发，异步执行 AlphaService 中的 加了@Async 的 execute1()</span></span><br><span class="line">        alphaService.execute1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 6.Spring定时任务线程池(简化)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testThreadPoolTaskSchedulerSimple</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 自动调用 AlphaService 中的加上 @Scheduled 的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/05/Java%E5%B9%B6%E5%8F%91/" data-id="clr24omj0000eswv59c19al1c" data-title="Java 并发" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-JVM" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/04/JVM/" class="article-date">
  <time class="dt-published" datetime="2021-09-04T03:49:42.000Z" itemprop="datePublished">2021-09-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/04/JVM/">JVM</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>JVM (Java虚拟机)本质上是一个计算机程序，他的职责是运行 Java字节码文件，解释为对应OS的机器指令。<br>JVM 包含内存管理、解释执行虚拟机指令、即时编译三大功能。<br>常见的JVM有HotSpot、GraalVM、OpenJ9等，另外DragonWell龙井JDK也提供了一款功能增强版的JVM。其中使用最广泛的是HotSpot。</p>
<h3 id="JVM-跨平台原理"><a href="#JVM-跨平台原理" class="headerlink" title="JVM 跨平台原理"></a>JVM 跨平台原理</h3><ul>
<li>本质是不同操作系统上提供了不同的JVM。（下载<code>JDK/JRE</code> for Linux&#x2F;Windows…）</li>
<li>Java 代码“一次编写，到处执行”，其实是指由<code>.java</code>文件编译来的<code>.class</code>字节码文件（高级语言java –&gt; <code>javac</code>编译 –&gt; 字节码(提升程序运行的效率，跨平台运行)）能够通过不同操作系统上的 JVM 解释为该操作系统的机器指令。</li>
<li>JVM 也不再只支持Java，由此衍生出了许多基于JVM的编程语言，如Groovy, Scala, Koltin等等。</li>
</ul>
<h2 id="JVM-知识要点"><a href="#JVM-知识要点" class="headerlink" title="JVM 知识要点"></a>JVM 知识要点</h2><img src="https://github.com/leo710aka/bk/blob/main/jvm.png?raw=true" width="500" height="200" alt=""> 
1. 类加载器：将class字节码文件中的内容加载到内存中。
2. 运行时数据区域：负责管理JVM 使用到的内存，比如创建对象和销毁对象。
3. 执行引擎：将字节码文件中的指令解释成机器码，同时使用即时编译器优化性能，用gc回收内存。
4. 本地接口：调用本地已经编译好的方法（不在字节码文件中）比如虚拟机中提供的cpp方法。

<p><img src="https://pdai.tech/images/jvm/java-jvm-overview.png"></p>
<hr>

<h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1><ul>
<li><code>类的生命周期：加载，连接，初始化，使用，卸载</code></li>
<li>其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。<br>在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定(也成为动态绑定或晚期绑定)。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。<br><img src="https://pdai.tech/images/jvm/java_jvm_classload_2.png"></li>
</ul>
<ol>
<li><strong>类的加载</strong>：查找并加载类的二进制数据<ul>
<li><strong>类加载器</strong>通过一个类的全限定名来获取其定义的二进制字节流。可以使用Java代码拓展的不同的渠道。</li>
<li>JVM 将字节码中的信息保存到内存的<strong>方法区</strong>（虚拟概念）</li>
<li>生成一个InstanceKlass对象（c++编写），保存类的所有信息，里边还包含实现特定功能比如多态的信息。</li>
<li>在Java堆中生成一个代表这个类的java.lang.Class对象（包含字段比InstanceKlass中的少，控制访问范围和保证安全性），作用是在Java代码中去获取类的信息（反射），以及存储静态字段的数据（JDK8后） <img src="https://pdai.tech/images/jvm/java_jvm_classload_1.png" width="500" height="200" alt="">
 加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。
 类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误(LinkageError错误)如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</li>
<li>加载.class文件的方式：从本地系统中直接加载、通过网络下载.class文件、从zip，jar等归档文件中加载.class文件、从专有数据库中提取.class文件、将Java源文件动态编译为.class文件</li>
</ul>
</li>
<li><strong>连接</strong><ul>
<li><em>2.1 <strong>验证</strong></em>: 确保被加载的类的正确性。验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。<ul>
<li><code>文件格式验证</code>: 验证字节流是否符合<strong>Class文件格式</strong>的规范；例如: 是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内（不能高于环境jdk版本）、常量池中的常量是否有不被支持的类型。</li>
<li><code>元数据验证</code>: 对<strong>字节码描述的信息进行语义</strong>分析(注意: 对比javac编译阶段的语义分析)，以保证其描述的信息符合Java语言规范的要求；例如: 这个类是否有父类，除了java.lang.Object之外。</li>
<li><code>字节码验证</code>: 通过数据流和控制流分析，确定<strong>程序语义</strong>是合法的、符合逻辑的。</li>
<li><code>符号引用验证</code>: 确保解析动作能正确执行。</li>
</ul>
</li>
<li><em>2.2 <strong>准备</strong></em>: 为类的<strong>静态变量</strong>分配内存，并将其初始化为默认值。这些内存都将在方法区中分配。<ul>
<li>这时进行内存分配的仅包括类变量(<strong>static</strong>)，而不包括实例变量，实例变量在对象实例化时随着对象一块分配在Java堆</li>
<li>这里所设置的初始值通常情况下是数据类型默认的零值(如0、0L、null、false等)，而不是被在Java代码中被显式地赋予的值。 假设一个类变量的定义为: public static int value &#x3D; 3；那么变量value在准备阶段过后的初始值为0，而非3，因为这时候尚未开始执行任何Java方法，把value赋值为3的动作将在初始化阶段才会执行。</li>
<li>对于同时被<code>static和final</code>修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，系统不会为其赋予默认零值。</li>
<li>对基本数据类型来说，对于类变量(static)和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值.而局部变量使用前必须显式地为其赋值，否则编译时不通过。</li>
<li>对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。</li>
</ul>
</li>
<li><em>2.3 <strong>解析</strong></em>: 把类中的<strong>符号引用</strong>（在字节码文件中使用编号来访问常量池中内容）转换为<strong>直接引用</strong>（符号-&gt;内存地址）<br> 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li>
</ul>
</li>
<li><strong>初始化</strong>：为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。<ul>
<li>在Java中对类变量进行初始值设定有两种方式: 声明类变量是指定初始值、使用静态代码块为类变量指定初始值</li>
<li>JVM初始化步骤<ul>
<li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li>
<li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li>
<li>假如类中有初始化语句，则系统依次执行这些初始化语句</li>
</ul>
</li>
<li>类初始化时机: 只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下:<ul>
<li>创建类的实例，也就是new的方式</li>
<li>访问某个类或接口的静态变量（注意final修饰且等号右边是常量的变量不会触发初始化）或者对该静态变量赋值</li>
<li>调用类的静态方法、执行Main方法的当前类</li>
<li>反射(如Class.forName(“com.pdai.jvm.Test”))</li>
<li>初始化某个类的子类，则其父类也会被初始化</li>
<li>Java虚拟机启动时被标明为启动类的类(Java Test)，直接使用java.exe命令来运行某个主类</li>
</ul>
</li>
</ul>
</li>
<li><strong>使用</strong><br> （即程序员工作阶段）类访问方法区内的数据结构的接口， 对象是Heap区的数据。</li>
<li><strong>卸载</strong><ul>
<li>Java虚拟机将结束生命周期的几种情况：<ul>
<li>执行了System.exit()方法</li>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>

<h1 id="JVM-类加载"><a href="#JVM-类加载" class="headerlink" title="JVM 类加载"></a>JVM 类加载</h1><p>【<font color= "#87CEFA"> <strong>类的生命周期的加载，连接，初始化阶段</strong> </font>】</p>
<h3 id="类字节码详解"><a href="#类字节码详解" class="headerlink" title="类字节码详解"></a>类字节码详解</h3><p>源代码通过编译器编译为字节码，再通过类加载子系统进行加载到JVM中运行；<br>字节码文件中保存了源代码编译之后的内容，以<strong>二进制</strong>的方式存储，无法直接用记事本打开阅读；<br>常用工具：对于本地&#x2F;服务器上的字节码文件：javap；<strong>jclasslib</strong>，有idea插件版本，在代码编译（构建项目）后实时看到字节码文件内容。<br>对于运行中的程序：<strong>Arthas</strong> 是一款线上监控诊断产品，通过全局视角实时查看应用load、内存、gc、线程的状态信息，并能在不修改应用代码的情况下，对业务问题进行诊断，大大提升线上问题排查效率。（jar包，使用<code>java -jar</code>启动 Arthas包）服务器上文件使用javap命令直接查看，也可以通过arthas的dump命令导出字节码文件再查看本地文件。还可以使用jad命令反编译出源代码。</p>
<ol>
<li>基础信息：<strong>magic魔数</strong>（Java文件头 <code>CAFEBABE</code>，软件通过文件头来校验文件的类型，而非文件扩展名），<strong>主副版本号</strong>（指编译字节码文件的JDK版本号(如主版本号52对应JDK8，减44) 用于判断当前字节码的版本与运行时的JDK是否兼容(低版本JDK不能运行高版本字节码)冲突时建议降低第三方依赖的版本号），<strong>访问标识</strong>（public，final等等），<strong>父类和接口</strong></li>
<li><strong>常量池：</strong>避免相同内容重复定义，节省空间。保存了字符串常量、类或接口名、字段名主要在字节码指令中使用。<br>常量池中的数据都有一个编号，编号从1开始。在字段或者字节码指令中通过编号可以快速的找到对应的数据。<br>字节码指令中通过编号引用到常量池的过程称之为符号引用。</li>
<li>字段：当前类或接口声明的字段信息</li>
<li><strong>方法：</strong>当前类或接口声明的方法信息，为<strong>字节码指令</strong>（在操作数栈和局部变量表上执行 iconst，istore，iload，iinc等指令，i++和++i区别就在指令iinc和iload的顺序颠倒）<br><code>main方法</code>：Java类的main方法是程序的入口点。在字节码文件中，这通常表示为public static void main(String[] args)方法。Java虚拟机（JVM）将通过public static void main(String[] args)方法来执行程序。字节码指令会调用这个方法，并它将启动程序的执行。<br><code>init方法</code>：类的构造函数，用于创建类的实例。在字节码文件中，<init>方法是类的构造函数，用于初始化新对象的状态。这个方法通常是由invokespecial指令调用的，用于初始化新对象。<br><code>clinit方法</code>：类的类构造函数，也称为静态初始化方法。这个方法用于执行类的静态初始化代码块。在字节码文件中，<clinit>方法通常由clinit指令表示。这个方法用于执行类级别的静态初始化操作<br><code>Code属性</code>：每个方法都有一个Code属性，其中包含了该方法的字节码指令，也就是方法体的实际执行代码</li>
<li>属性：类的属性，比如源码的文件名，内部类的列表等<img src="https://github.com/leo710aka/bk/blob/main/jvm7.png?raw=true" width="700" height="300" alt=""></li>
</ol>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>类加载器(ClassLoader)负责在类加载过程中的字节码获取并加载到内存这一部分。通过加载字节码数据放入内存转换成byte[]（只负责这一部分），接下来调用虚拟机底层方法将byte[]转换成方法区和堆中的数据。<br>站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：</p>
<ul>
<li><code>启动类加载器</code>: Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库(如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载)。启动类加载器是无法被Java程序直接引用的，无法直接通过代码查看，程序员难以直接调试。<br>它使用C++实现(这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的)，是虚拟机自身的一部分；所有其他的类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</li>
<li><code>扩展类加载器</code>: Extension ClassLoader，该加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库(如javax.*开头的类)，开发者可以直接使用扩展类加载器。</li>
<li><code>应用程序类加载器</code>: Application ClassLoader，该类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径(ClassPath)所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。<img src="https://github.com/leo710aka/bk/blob/main/jvm2.png?raw=true" width="600" height="200" alt=""></li>
</ul>
<p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入<code>自定义的类加载器</code>。<br>因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点: 1. 在执行非置信代码之前，自动验证数字签名。2. 动态地创建符合用户特定需要的定制化构建类。 3.从特定的场所取得java class，例如数据库中和网络中。<br><code>URLClassLoader</code>： 这是一个常见的用户自定义类加载器，可以从指定的URL加载类。在很多情况下，当需要从外部加载一些类或JAR文件时，使用URLClassLoader是比较方便的。URLClassLoader是Application ClassLoader的子类加载器。</p>
<h3 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h3><ul>
<li><code>全盘负责</code>，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li>
<li><code>父类委托</code>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li>
<li><code>缓存机制</code> ，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</li>
<li><code>双亲委派机制</code>，如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去<br>完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</li>
<li>在Java中如何使用代码的方式去主动加载一个类呢?<br>方式1：使用Class.forName方法，使用当前类的类加载器去加载指定的类<br>方式2：获取到类加载器，通过类加载器的loadClass方法指定某个类加载器加载</li>
</ul>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>由于Java虚拟机中有多个类加载器，双亲委派机制的核心是解决一个类到底由谁加载的问题。<br>双亲委派机制指的是：当一个类加载器接收到加载类的任务时，会自底向上查找是否（被这个类加载器）加载过，再由顶向下（如果位于这个类加载器的加载目录中）进行加载。<br>双亲委派机制的好处有两点: 第一是避免恶意代码替换JDK中的核心类库，确保的完整性和安全性；二是避免一个类重复地被加载<br><img src="https://github.com/leo710aka/bk/blob/main/jvm4.png?raw=true" width="600" height="200" alt=""></p>
<h3 id="打破双亲委派机制："><a href="#打破双亲委派机制：" class="headerlink" title="打破双亲委派机制："></a>打破双亲委派机制：</h3><ol>
<li><strong>自定义类加载器</strong><br>通常情况下，我们都是直接使用系统类加载器。但有时，我们也需要自定义类加载器。比如 应用通过网络传输 Java 类的字节码，为保证安全性经过了加密处理，这时系统类加载器就无法对其进行加载；Tomcat通过自定义类加载器实现应用之间类隔离；<br>自定义类加载器一般都是继承自 <code>ClassLoader</code> 类，重写 <code>findClass</code>方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">byte</span>[] classData = loadClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="literal">null</span>) &#123;  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);  <span class="comment">// 连接阶段</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] loadClassData(String className) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> root + File.separatorChar</span><br><span class="line">                + className.replace(<span class="string">&#x27;.&#x27;</span>, File.separatorChar) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">ins</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName);</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">bufferSize</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[bufferSize];</span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((length = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="type">MyClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>();</span><br><span class="line">        classLoader.setRoot(<span class="string">&quot;D:\\temp&quot;</span>);</span><br><span class="line">        Class&lt;?&gt; testClass = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            testClass = classLoader.loadClass(<span class="string">&quot;com.pdai.jvm.classloader.Test2&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> testClass.newInstance();</span><br><span class="line">            System.out.println(object.getClass().getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> () &#123;...        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>线程上下文类加载器</strong> ？？？实际上没打破。。？**?????????**<br>大量应用在 java底层，比如JDBC和JNDI等</li>
<li>Osgi框架的类加载器<br>历史上Osgi框架实现了一套新的类加载器机制，允许同级之间委托进行类的加载；还使用类加载器实现热部署功能。</li>
</ol>
<h3 id="JDK8-后的类加载器"><a href="#JDK8-后的类加载器" class="headerlink" title="JDK8 后的类加载器"></a>JDK8 后的类加载器</h3><p>由于JDK9引入了module的概念，类加载器在设计上发生了很多变化。</p>
<ol>
<li>启动类加载器使用<strong>Java编写</strong>，位于jdk.internal.loader.ClassLoaders类中Java中的BootClassLoader继承自BuiltinClassLoader实现从模块中找到要加载的字节码资源文件.启动类加载器依然无法通过java代码获取到，返回的仍然是null，保持了统一。</li>
<li>扩展类加载器被替换成了<strong>平台类加载器</strong>(Platform Class Loader)<br>平台类加载器遵循模块化方式加载字节码文件，所以继承关系从URLClassLoader变成了BuiltinClassLoader，BuiltinClassLoader实现了从模块中加载字节码文件。平台类加载器的存在更多的是为了与老版本的设计方案兼容，自身没有特殊的逻辑</li>
</ol>
<hr>

<h1 id="JVM-内存结构"><a href="#JVM-内存结构" class="headerlink" title="JVM 内存结构"></a>JVM 内存结构</h1><p>Java 虚拟机在运行Java程序过程中管理的内存区域，称之为运行时数据区。<strong>！！注意不要和Java内存模型混淆了，，</strong><br><img src="https://github.com/leo710aka/bk/blob/main/jvm5.png?raw=true" width="700" height="300" alt=""><br>Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程一一对应的数据区域会随着线程开始和结束而创建和销毁。【 <font color= "#87CEFA"> <strong>类的生命周期的使用，卸载阶段</strong>？</font>】<br>线程私有：程序计数器、虚拟机栈、本地方法区<br>线程共享：堆、方法区, 堆外内存（Java7的永久代或JDK8的元空间、代码缓存）</p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器(Program Counter Register)也叫PC寄存器，每个线程会通过程序计数器记录当前要执行的的字节码指令的内存地址。<br>它是一块很小的固定大小的内存空间，不会发生内存溢出 <code>&quot;OutOfMemoryError&quot;</code>。</p>
<ol>
<li>在代码执行过程中，程序计数器会记录下一行字节码指令的地址。执行完当前指令之后，虚拟机的执行引擎根据程序计数器执行下一行指令。程序计数器可以控制程序指令的进行，实现分支、跳转、异常等逻辑。</li>
<li>在多线程执行情况下，CPU会不停的做任务切换，这导致经常中断或恢复。JVM 需要通过程序计数器记录 CPU 切换前解释执行到那一句指令并继续解释运行。每个线程都有它自己的程序计数器，独立计算，不会互相影响。</li>
</ol>
<h2 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h2><ul>
<li>早期也叫 Java 栈。每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame），对应着一次次 Java 方法调用，是线程私有的，生命周期和线程一致。<br>作用：<strong>主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</strong></li>
<li>JVM栈 采用栈的数据结构来管理方法调用中的基本数据，先进后出，每一个方法的调用使用一个<strong>栈帧</strong>(Stack Frame)来保存。<br>IDEA 在 debug 时候，可以在 debug 窗口看到 Frames 中各种方法的压栈和出栈情况<img src="https://pdai.tech/images/jvm/jvm/0082zybply1gc8tjehg8bj318m0lbtbu.jpg" width="700" height="300" alt=""></li>
<li><em><strong>栈帧</strong></em>的组成<ul>
<li><strong>局部变量表</strong>：在运行过程中存放所以的局部变量，包括实例方法的this对象，方法的参数，方法体中声明的局部变量<ul>
<li>编译成字节码文件时就可以确定局部变量表的内容，包含局部变量的编号、生效范围等；<br>  局部变量表数据在 <em>字节码文件 - 方法 - Code - LocalVariableTable</em> 查看。</li>
<li>实际在栈帧中，局部变量表是一个数组，数组中每一个位置为<strong>槽</strong>(slot)，long和double类型占两个槽，其他类型占一个。</li>
<li>实例方法中的序号为0的位置存放的是this，指的是当前调用方法的对象，运行时会在内存中存放实例对象的地址。</li>
<li>方法参数也会保存在局部变量表中，其顺序与方法中参数定义的顺序一致局部变量表  <img src="https://github.com/leo710aka/bk/blob/main/jvm6.png?raw=true" width="700" height="300" alt=""></li>
</ul>
</li>
<li><strong>操作数栈</strong>：JVM在执行指令的过程中用来存放临时数据的一块区域。主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间<ul>
<li>它是一种栈式的数据结构，如果一条指令将一个值压入操作数栈，则后面的指令可以弹出并使用该值。</li>
<li>在编译期就可以确定操作数栈的最大深度，从而在执行时正确的分配内存大小</li>
</ul>
</li>
<li><strong>帧数据</strong><ul>
<li>动态链接：当前类的字节码指令引用了其他类的属性或者方法时，需要将符号引用(编号)转换成对应的运行时常量池中的内存地址。动态链接就保存了编号到运行时常量池的内存地址的映射关系。</li>
<li>方法出口：方法出口指的是方法在正确或者异常结束时，当前栈帧会被弹出，同时程序计数器应该指向上一个栈帧中的下一条指令的地址。所以在当前栈帧中，需要存储此方法出口的地址。</li>
<li>异常表的引用：异常表存放代码中异常的处理信息，包含了try代码块和catch代码块执行后跳转到的字节码指令位置</li>
</ul>
</li>
</ul>
</li>
<li>栈内存溢出：一个线程的Java 虚拟机栈中，如果栈帧过多，占用内存超过栈内存可分配的最大大小就会出现内存溢出，出现<code>StackOverflowError</code>错误<ul>
<li>如果我们不指定栈的大小，JVM 将创建一个具有默认大小的栈。大小取决于操作系统和计算机的体系结构，windows(64位)下的JDK8测试最小值为180k，最大值为1024m</li>
<li>要修改Java虚拟机栈的大小，可以使用虚拟机参数 -Xss。一般情况下，工作中即便使用了递归进行操作，栈的深度最多也只能到几百,不会出现栈的溢出。所以此参数可以手动指定为 -Xss256k 节省内存。</li>
</ul>
</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><ul>
<li>Java虚拟机栈存储了Java方法调用时的栈帧，而本地方法栈存储的是（c++编写的）native本地方法（如文件IO操作）的栈帧.</li>
<li>在Hotspot虚拟机中，Java虚拟机栈和本地方法栈实现上使用了同一个栈空间。本地方法栈会在栈内存上生成一个栈帧，临时保存方法的参数，同时方便出现异常时也把本地方法的栈信息打印出来</li>
</ul>
<h2 id="栈是运行时的单位，而堆是存储的单位"><a href="#栈是运行时的单位，而堆是存储的单位" class="headerlink" title="**栈是运行时的单位，而堆是存储的单位**"></a><code>**栈是运行时的单位，而堆是存储的单位**</code></h2><p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪。</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>一般Java程序中堆内存是空间最大的一块内存区域。<strong>创建出来的对象</strong>都存在于堆上，并且在栈上保存一个<strong>对象的引用</strong>（在堆上的地址）。<br>达到上限之后，就会抛出 <code>OutofMemory</code>错误。<br>栈上的局部变量表中，可以存放堆上对象的引用。静态变量也可以存放堆对象的引用，通过静态变量就可以实现对象在线程之间共享。</p>
<ul>
<li>堆内存中有三个值，used 指的是当前已使用的堆内存，total 是JVM已分配的可用堆内存，max 是JVM可以分配的最大堆内存。total 不足时，JVM会继续分配内存给堆，total 值增大但最多只能与 max 相等。</li>
<li>max 默认是系统内存的 1&#x2F;4，total 默认是系统内存的 1&#x2F;64。实际使用中一般都需要设置这两个值。<br>Java服务端程序开发时，建议将 <strong>-Xmx</strong>（max最大值）和 <strong>-Xms</strong>（初始的total）设置为相同的值，避免再次申请内存。</li>
</ul>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><ul>
<li>方法区是存放基础信息的位置，线程共享，主要包括三部分；<ul>
<li><strong>类的元信息</strong>：类的基本信息 (元信息)，一般称之为InstanceKlass对象。在类的加载阶段完成.  <img src="https://github.com/leo710aka/bk/blob/main/jvm9.png?raw=true" width="600" height="300" alt=""></li>
<li><strong>运行时常量池</strong>：放的是字节码中的常量池内容。字节码文件中通过编号查表的方式找到常量，这种常量池称为静态常量池。当常量池加载到内存中之后，可以通过内存地址快速的定位到常量池中的内容，这种常量池称为运行时常量池</li>
<li><strong>字符串常量池</strong>：字符串常量池存储在代码中定义的常量字符串内容。比如String s2 &#x3D; “abc” 的 “abc”即 s2这个字符串常量就会被放入字符串常量池（而String s1 &#x3D; new String(“abc”) 中的 s1这个对象会被放入堆内存）</li>
</ul>
</li>
<li>方法区是《Java虚拟机规范》中设计的<em><strong>虚拟概念</strong></em>，每款Java虚拟机在实现上都各不相同。Hotspot设计如下<ul>
<li>JDK7及之前的版本将方法区存放在<strong>堆区域中的</strong><code>永久代</code>空间，堆的大小由虚拟机参数来控制。</li>
<li>JDK8及之后的版本将方法区存放在<code>元空间</code>中，元空间位于OS维护的<strong>直接内存中</strong>，默认在不超过OS承受的上限可以一直分配</li>
<li>！！ JDK6中字符串常量池在方法区（永久代）中，永久代在堆中；JDK7中从字符串常量池永久代中移出，仍在堆中；而JDK8后方法区（永久代-&gt;元空间）从堆中移出，字符串常量池仍在堆中<img src="https://github.com/leo710aka/bk/blob/main/jvm8.png?raw=true" width="700" height="300" alt=""></li>
</ul>
</li>
</ul>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存(Direct Memory)并不在《Java虚拟机规范》中存在，所以并不属于Java运行时的内存区域.</p>
<ul>
<li>在JDK1.4中引入了NIO机制，使用了直接内存，主要为了解决以下两个问题:<br>1、Java堆中的对象如果不再使用要回收，回收时会影响对象的创建和使用。<br>2、I0操作比如读文件，需要先把文件读入直接内存(缓冲区)再把数据复制到Java堆中现在直接放入直接内存即可，同时Java堆上维护直接内存的引用，减少了数据复制的开销。写文件也是类似的思路.</li>
<li>要创建直接内存上的数据，可以使用ByteBuffer。语法: ByteBuffer directBuffer &#x3D; ByteBuffer.allocateDirect(size);<br>注意事项: arthas的memory命令可以查看直接内存大小，属性名direct。</li>
</ul>
<hr>

<h1 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h1><hr>

<h1 id="JVM-GC-垃圾回收"><a href="#JVM-GC-垃圾回收" class="headerlink" title="JVM GC 垃圾回收"></a>JVM GC 垃圾回收</h1><p>在C&#x2F;C++这类没有自动垃圾回收机制的语言中，一个对象如果不再使用，需要手动释放，否则就会出现<code>内存泄漏</code>。内存泄漏指的是不再使用的对象在系统中未被回收，内存泄漏的积累可能会导致<code>内存溢出</code>。<br>Java中为了简化对象的释放，引入了自动的<code>垃圾回收</code> (Garbage Collection 简称 GC) 机制。【 <font color= "#87CEFA"> <strong>类的生命周期的卸载阶段</strong> ？？</font>】<br>线程不共享的部分，都是伴随着线程的创建而创建，线程的销毁而销毁。而方法的栈帧在执行完方法之后就会自动弹出栈并释放掉对应的内存。所以只用考虑线程不共享部分。JVM GC主要负责对<strong>堆上</strong>的内存进行回收。</p>
<h2 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h2><p>方法区中能回收的内容主要就是不再使用的类.判定一个类可以被卸载。需要同时满足下面三个条件<br>1、此类所有实例对象都已经被回收，在堆中不存在任何该类的实例对象以及子类对象。<br>2、加载该类的类加载器已经被回收<br>3、该类对应的java.lang.Class 对象没有在任何地方被引用<br>开发中此类场景一般很少出现，主要在如 OSGi、JSP 的热部署等应用场景中。</p>
<h2 id="堆的回收"><a href="#堆的回收" class="headerlink" title="堆的回收"></a>堆的回收</h2><p>如何判断堆上的对象可以回收? Java中的对象是否能被回收，是根据对象是否被引用来决定的。引用说明该对象还在使用，不允许被回收。<br><img src="https://github.com/leo710aka/bk/blob/main/jvm10.png?raw=true" width="700" height="300" alt=""></p>
<p>常见的有两种判断方法:引用计数法和可达性分析法。</p>
<ul>
<li><strong>引用计数法</strong>：会为每个对象维护一个引用计数器，当对象被引用时加1，取消引用时减1.<ul>
<li>优点是实现简单，C++中的智能指针就采用了引用计数法</li>
<li>缺点主要有两点: 1.每次引用和取消引用都需要维护计数器，对系统性能会有一定的影响 2.存在循环引用问题，所谓循环引用就是当A引用B，B同时引用A时会出现对象无法回收的问题</li>
</ul>
</li>
<li><strong>可达性分析算法</strong>：Java使用的是可达性分析算法来判断对象是否可以被回收。可达性分析将对象分为两类:垃圾回收的根对象GRoot)和普通对象，对象与对象之间存在引用关系。如果其（反向？引用）到某个GC Root对象是可达的，对象就不可被回收。<ul>
<li>四大类 GCRoot 对象<ul>
<li>线程Thread对象（放在堆中，指向对应的栈）  <img src="https://github.com/leo710aka/bk/blob/main/jvm11.png?raw=true" width="700" height="300" alt=""></li>
<li>系统类加载器加载的java.lang.Class对象，引用类中的静态变量  ???、，，？？  <img src="https://github.com/leo710aka/bk/blob/main/jvm12.png?raw=true" width="700" height="300" alt=""></li>
<li>监视器对象，用来保存同步锁 synchronized关键字持有的对象</li>
<li>本地方法调用时使用的全局对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="五种引用"><a href="#五种引用" class="headerlink" title="五种引用"></a>五种引用</h3><ul>
<li><strong>强引用</strong>：可达性算法中描述的一般指的是强引用，即是GCRoot对象对普通对象有引用关系，只要关系存在普通对象就不会被回收。</li>
<li><strong>软引用</strong>：相对于强引用是一种比较弱的引用关系<ul>
<li>如果一个对象只有软引用关联到它，当程序内存不足时，就会将软引用中的数据进行回收。</li>
<li>软引用常用于缓存中（提高效率，不影响可用性）</li>
<li>在JDK 1.2版之后提供了sftReference类来实现软引用。软引用的执行过程如下：<br>  1.将对象使用软引用包装起来，new SoftReference&lt;对象类型&gt;(对象)<br>  2.内存不足时，虚拟机尝试进行垃圾回收。<br>  3.如果垃圾回收仍不能解决内存不足的问题，回收软引用中的对象<br>  4.如果依然内存不足，抛出OutofMemory异常  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>];    <span class="comment">// 建立数组（强引用对象？？                </span></span><br><span class="line">SoftReference&lt;<span class="type">byte</span>[]&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;<span class="type">byte</span>[]&gt;(bytes);  <span class="comment">// 建立软引用</span></span><br><span class="line">bytes = <span class="literal">null</span>;                                  <span class="comment">// 释放强引用</span></span><br><span class="line">System.out.println(softReference.get());       <span class="comment">// ：[B@2503dbd3</span></span><br><span class="line"><span class="type">byte</span>[] bytes2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>];   <span class="comment">// 内存不足，释放软引用对象</span></span><br><span class="line">System.out.printIn(softReference.get());       <span class="comment">// ：null</span></span><br><span class="line"><span class="type">byte</span>[] bytes2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>];   <span class="comment">// ：直接抛OutofMemory异常</span></span><br></pre></td></tr></table></figure></li>
<li><strong>？？？软引用队列</strong>：软引用中的对象如果在内存不足时回收，SoftReference对象本身也需要被回收。如何知道哪些SoftReference对象需要回收呢? SoftReference提供了一套队列机制:1、软引用创建时，通过构造器传入引用队列2、在软引用中包含的对象被回收时，该软引用对象会被放入引用队列3通过代码遍历引用队列，将SoftReference的强引用删除</li>
</ul>
</li>
<li><strong>弱引用</strong>：弱引用的整体机制和软引用基本一致，区别在于弱引用包含的对象在垃圾回收时不管内存够不够都会直接被回收<br>在JDK1.2版之后提供了WeakReference类来实现弱引用，弱引用主要在ThreadLocal中使用。<br>弱引用对象本身也可以使用引用队列进行回收。</li>
<li><strong>虚引用</strong>：虚引用也叫幽灵引用&#x2F;幻影引用，不能通过虚引用对象获取到包含的对象。虚引用唯一的用途是当对象被垃圾回收器回收时可以接收到对应的通知。Java中使用PhantomReference实现了虚引用，直接内存中为了及时知道直接内存对象不再使用，从而回收内存，使用了虚引用来实现。</li>
<li><strong>终结器引用</strong>：指的是在对象需要被回收时，对象将会被放置在Finalizer类中的引用队列中，并在稍后由一条由FinalizerThread线程从队列中获取对象，然后执行对象的finalize方法。在这个过程中可以在finalize方法中再将自身对象使用强引用关联上，但是不建议这样做，如果耗时过长会影响其他对象的回收。</li>
</ul>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><ul>
<li>垃圾回收要做的有两件事：1、找到内存中存活的对象； 2、释放不再存活对象的内存，使得程序能再次利用这部分空间</li>
<li>三种评价标准：堆使用效率、吞吐量，以及最大停时间不可兼得。<br>一般来说，堆内存越大，最大暂停时间就越长。想要减少最大暂停时间，就会降低吞吐量。不同的垃圾回收算法，适用不同的场景。</li>
<li>标记清除算法<ul>
<li>核心思想：1.标记阶段，将所有存活的对象进行标记。Java中使用可达性分析算法，从GC Root开始通过引用链遍历出所有存活对象。 2.清除阶段，从内存中删除没有被标记也就是非存活对象</li>
<li>优点：实现简单，只需要在第一阶段给每个对象维护标志位，第二阶段删除对象即可。</li>
<li>缺点：1.碎片化问题由于内存是连续的，所以在对象被删除之后，内存中会出现很多细小的可用内存单元。如果我们需要的是一个比较大的空间，很有可能这些内存单元的大小过小无法进行分配  2.分配速度慢。由于内存碎片的存在，需要维护一个空闲链表，极有可能发生每次需要遍历到链表的最后才能获得合适的内存空间。</li>
</ul>
</li>
<li>复制算法<ul>
<li>核心思想: 1.准备两块空间From空间和To空间，每次在对象分配阶段，只能使用其中一块空间 (From空间)   2.在垃圾回收GC阶段，将From中存活对象复制到To空间。  3.将两块空间的From和To名字互换</li>
<li>优点：吞吐量高、不会发生碎片化</li>
<li>缺点：内存使用效率低，每次只能让一半的内存空间来为创建对象使用</li>
</ul>
</li>
<li>标记整理算法：也叫标记压缩算法，是对标记清理算法中容易产生内存碎片问题的一种解决方案.<ul>
<li>核心思想：1.标记阶段，将所有存活的对象进行标记。Java中使用可达性分析算法，从GC Root开始通过引用链遍历出所有存活对象  2.整理阶段，将存活对象移动到堆的一端。清理掉存活对象的内存空间</li>
<li>优点：内存使用效率高，不会发生碎片化</li>
<li>缺点：整理阶段的效率不高</li>
</ul>
</li>
</ul>
<h3 id="分代垃圾回收算法"><a href="#分代垃圾回收算法" class="headerlink" title="分代垃圾回收算法"></a>分代垃圾回收算法</h3><ul>
<li><strong>分代垃圾回收算法</strong>(GenerationalGC)：将上述描述的垃圾回收算法组合进行使用，<ul>
<li>它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法</li>
<li>一般将堆分为新生代和老年代。新生代使用: 复制算法；老年代使用: 标记清除 或者 标记整理 算法</li>
<li>将新生代划分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。</li>
<li>HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间不够用，此时需要依赖于老年代进行分配担保，即借用老年代的空间存储放不下的对象。</li>
<li>系统中的大部分对象，都是创建出来之后很快就不再使用可以被回收，比如用户获取订单数据，订单数据返回给用户之后就可以释放了。 老年代中会存放长期存活的对象，比如Spring的大部分bean对象，在程序启动之后就不会被回收了。<br>  在虚拟机的默认设置中，新生代大小要远小于老年代的大小。  <img src="https://github.com/leo710aka/bk/blob/main/jvm13.png?raw=true" width="550" height="300" alt=""></li>
<li>分代GC算法将堆分成年轻代和老年代主要原因有：<br>  1、可以通过调整年轻代和老年代的比例来适应不同型的应用程序，提高内存的利用率和性能。  2、新生代和老年代使用不同的垃圾回收算法，新生一般选择复制算法，老年代可以选择标记-清除和标记-整理算法，由程序员来选择灵活度较高。 3、分代的设计中允许只回收新生代 (minor gc)，如果能满足对象分配的要求就不需要对整个堆进行回收(fullgc),STW时间就会减少</li>
</ul>
</li>
<li><strong>内存分配策略</strong><ol>
<li>分代回收时，创建出来的对象，首先会被放入Eden伊甸园区。随着对象在Eden区越来越多，如果Eden区满，新创建的对象已经无法放入，就会触发年轻代的GC，称为Minor GC或者Young GC<br>  大对象直接进入老年代：大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。<br>  -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免 Eden 和 Survivor 区之间的大量内存复制。</li>
<li>Minor GC 会把需要 eden中和 From需要回收的对象回收，把没有回收的对象放入To区。接下来，S0会变成To区，S1变成From区。当eden区满时再往里放入对象，依然会发生Minor GC此时会回收eden区和S1(from)中的对象，并把eden和from区中剩余的对象放入SO。 ！！如果to区满了，会将没有回收的对象放入老年代。<br>  注意:每次Minor GC中都会为对象记录他的年龄，初始值为0，每次GC完加1。</li>
<li>长期存活的对象进入老年代：为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。-XX:MaxTenuringThreshold 用来定义年龄阈值。<br>  动态对象年龄判定：虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，，，</li>
<li>当老年代中空间不足，无法放入新的对象时，先尝试minor gc（因为存在直接从 eden区放如老年代的情况）。如果还是不足，就会触发Full GC，Full GC会对整个堆进行垃圾回收。如果Full GC依然无法回收掉老年代的对象，那么当对象继续放入老年代时，就会抛出OutofMemory异常。</li>
<li>空间分配担保：在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。<br>  如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC。</li>
</ol>
</li>
<li>Full GC 的触发条件<br>对于 Minor GC，其触发条件非常简单：当 Eden 空间满时就将触发一次。而 Full GC 则相对复杂，有以下条件：<br>1.调用 System.gc()  2. 老年代空间不足  3. 空间分配担保失败  4. JDK 1.7及以前的永久代空间不足在   5. Concurrent Mode Failure</li>
<li><strong>内存回收策略</strong><br>  Minor GC、Major GC、Full GC<br>  JVM 在进行 GC 时，并非每次都对堆内存(新生代、老年代，方法区)区域一起回收的，大部分时候回收的都是指新生代。针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大类: 部分收集 (Partial GC)，整收集(Full GC)。<ul>
<li>部分收集: 不是完整收集整个 Java 堆的垃圾收集。其中又分为:<ol>
<li>新生代收集 (Minor GC&#x2F;Young GC) : 只是新生代的垃圾收集。 </li>
<li>老年代收集 (Major GC&#x2F;Old GC) : 只是老年代的垃圾收集<br>  目前，只有 CMS GC 会有单独收集老年代的行为。很多时候 Major GC 会和 Full GC 混合使用，需要具体分辨是老年代回收还是整堆回收</li>
<li>混合收集 (Mixed GC) : 收集整个新生代以及部分老年代的垃圾收集；目前只有 G1 GC 会有这种行为</li>
</ol>
</li>
<li>整堆收集 (Full GC) : 收集整个 Java 堆和方法区的垃圾</li>
</ul>
</li>
</ul>
<h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p>垃圾回收器是垃圾回收算法的具体实现<br>由于垃圾回收器分为年轻代和老年代，除了G1之外其他垃圾回收器必须成对组合进行使用。<br><img src="https://github.com/leo710aka/bk/blob/main/jvm15.png?raw=true" width="700" height="300" alt=""></p>
<ul>
<li><strong>Serial + Serial Old 收集器</strong><table>
<thead>
<tr>
<th></th>
<th>Serial</th>
<th>Serial Old</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>单线程串行回收年轻代的垃圾回收器</td>
<td>Serial垃圾回收器老年代版本，采用单线程串行回收</td>
</tr>
<tr>
<td></td>
<td>年轻代，复制算法</td>
<td>老年代，标记-整理算法</td>
</tr>
<tr>
<td>优点</td>
<td>单CPU处理器下吞吐量非常出色</td>
<td></td>
</tr>
<tr>
<td>缺点</td>
<td>多CPU下吞吐量不如其他垃圾回收器，堆如果偏大会让用户线程处于长时间的等待</td>
<td></td>
</tr>
<tr>
<td>适用场景</td>
<td>Java编写的客户端程序或者硬件配置有限的场景</td>
<td>与Serial垃圾回收器搭配使用或者在CMS特殊情况下使用</td>
</tr>
</tbody></table>
</li>
<li><strong>ParNew + CMS 收集器</strong><table>
<thead>
<tr>
<th></th>
<th>ParNew</th>
<th>CMS</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>本质上是对Serial在多CPU下的优化，使用多线程进行垃圾回收</td>
<td>关注的是系统的暂停时间。允许用户线程和垃圾回收线程在某些步骤中同时执行，减少了用户线程的等待时间。</td>
</tr>
<tr>
<td>参数</td>
<td>-XX:+UseParNewGC 新生代使用ParNew，回收器老年代使用串行回收器</td>
<td>XX:+UseConcMarkSweepGC</td>
</tr>
<tr>
<td></td>
<td>年轻代，复制算法</td>
<td>老年代，标记-清除算法</td>
</tr>
<tr>
<td>优点</td>
<td>多CPU处理器下停顿时间较短</td>
<td>系统由于垃圾回收出现的停顿时间较短，用户体验好</td>
</tr>
<tr>
<td>缺点</td>
<td>吞吐量和停顿时间不如G1，所以在JDK9之后不建议使用</td>
<td>1、内存碎片问题 2、退化问题 3、浮动垃圾问题</td>
</tr>
<tr>
<td>适用场景</td>
<td>Java编写的客户端程序或者硬件配置有限的场景</td>
<td>大型的互联网系统中用户请求数据量大、频率高的场景，比如订单接口、商品接口等</td>
</tr>
</tbody></table>
</li>
<li><strong>ParNew + CMS 收集器</strong><table>
<thead>
<tr>
<th></th>
<th>Parallel Scavenge</th>
<th>Parallel Old</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>JDK8默认的年轻代垃圾回收器多线程并行回收，关注的是系统的吞吐量。具备自动调整堆内存大小的特点</td>
<td>是为Parallel Scavenge收集器设计的老年代版本，利用多线程并发收集。</td>
</tr>
<tr>
<td>参数</td>
<td></td>
<td>-XX:+UseParallelGC 或-XX:+UseParallelOldGC，可以使用Parallel Scavenge + Parallel Old这种组合</td>
</tr>
<tr>
<td></td>
<td>年轻代，复制算法</td>
<td>老年代，标记-整理算法</td>
</tr>
<tr>
<td>优点</td>
<td>吞吐量高，而目手动可控为了提高吞吐量，虚拟机会动态调整堆的参数</td>
<td>并发收集，在多核CPU下效率较高</td>
</tr>
<tr>
<td>缺点</td>
<td>不能保证单次的停顿时间</td>
<td>暂停时间会比较长</td>
</tr>
<tr>
<td>适用场景</td>
<td>后台任务，不需要与用户交互，并且容易产生大量的对象。比如:大数据的处理，大文件导出</td>
<td>与Parallel Scavenge配套使用</td>
</tr>
</tbody></table>
</li>
<li>垃圾回收器的组合关系虽然很多，但是针对几个特定的版本，比较好的组合选择如下:<br>JDK8及之前：ParNew + CMS (关注暂停时间)、Parallel Scavenge + Parallel Old (关注吞吐量)、不建议 G1(较大堆并且关注暂停时间)<br>JDK9之后：G1 (默认)</li>
</ul>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><ul>
<li>它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。使命是未来可以替换掉 CMS 收集器。<br>G1 将 Parallel Scavenge与 CMS的优点融合：1.支持巨大的堆空间回收，并有较高的吞吐量。2.支持多CPU并行垃圾回收 3.允许用户设置最大暂停时间。</li>
<li>G1 把堆划分成多个大小相等的独立区域(Region)，新生代和老年代不再物理隔离，可以直接对新生代和老年代一起回收。</li>
<li>G1垃圾回收有两种方式：1、年轻代回收 (Young GC)  2、混合回收(Mixed GC)<ul>
<li>年轻代回收：回收Eden区和Survivor区中不用的对象。会导致STW，G1中可以通过参数设置每次垃圾回收时的最大暂停时间毫秒数，G1垃圾回收器会尽可能地XX:MaxGCPauseMillis&#x3D;n (默认200) 保证暂停时间。</li>
<li>混合回收分为：初始标记 (initial mark) 、并发标记 (concurrent mark)、最终标记(remark或者FinalizeMarking)、并发清理 (cleanup) ；G1对老年代的清理会选择存活度最低的区域来进行回收，这样可以保证回收效率最高，这也是G1(Garbagefirst)名称的由来。</li>
<li>注意:如果清理过程中发现没有足够的空Region存放转移的对象，会出现Full GC。单线程执行标记-整理算法此时会导致用户线程的暂停。所以尽量保证应该用的堆内存有一定多余的空间。</li>
</ul>
</li>
<li><strong>G1 执行流程</strong><br>1、新创建的对象会存放在Eden区。当G1判新年轻代区不足(max默认60%)，无法分配对象时需要回收时会执行Young GC<br>2、标记出Eden和Survivor区域中的存活对象<br>3、根据配置的最大暂停时间选择某些区域将存活对象复制到一个新的Survivor区中(年龄+1)，清空这些区域<br>4、后续Young GC时与之前相同，只不过Survivor区中存活对象会被搬运到另一个Survivor区<br>5、当某个存活对象的年龄到达值 (默认15)，将被放入老年代<br>6、部分对象如果大小超过Region的一半，会直接放入老年代，这类老年代被称为Humongous区。比如堆内存是4G，每个Region是2M，只要一个大对象超过了1M就被放入Humonous区，如果对象过大会横跨多个Region。<br>7、多次回收之后，会出现很多Old老年代区，此时总堆占有率达到闻值时(-XX:InitiatingHeap0ccupancyPercent默认45%)<br>会触发混合回收MixedGC。回收所有年轻代和部分老年代的对象以及大对象区。采用复制算法来完成？？？不会产生内存碎片</li>
</ul>
<hr>

<h1 id="JVM-排错调优"><a href="#JVM-排错调优" class="headerlink" title="JVM 排错调优"></a>JVM 排错调优</h1><hr>

<h1 id="JVM-知识体系"><a href="#JVM-知识体系" class="headerlink" title="JVM 知识体系"></a>JVM 知识体系</h1><p><img src="https://pdai.tech/images/jvm/jvm-overview.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/04/JVM/" data-id="clr24omiy0009swv5b7e7drz0" data-title="JVM" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Java集合" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/03/Java%E9%9B%86%E5%90%88/" class="article-date">
  <time class="dt-published" datetime="2021-09-03T03:49:42.000Z" itemprop="datePublished">2021-09-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/03/Java%E9%9B%86%E5%90%88/">Java 集合</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><strong>集合（Collection）</strong>：Java 集合框架是一组类和接口，用于存储和操作一组对象。<code>List, Set, Queue</code>都是 Java集合的接口。</li>
<li><strong>容器（Container）</strong>：Java 容器就是可以容纳其他 Java 对象的对象。<em>Java Collections Framework(JCF)</em> 为开发者提供了通用的容器，始于JDK 1.2<ul>
<li><strong>优点</strong>: 降低编程难度，提高程序性能，提高API间的互操作性，降低设计和实现相关API的难度，增加程序的重用性</li>
<li>对于基本类型(int, long, float, double等)，需要将其<strong>包装</strong>成对象类型后(Integer, Long, Float, Double等)才能放到容器里。很多时候拆包装和解包装能够自动完成。这虽然会导致额外的性能和空间开销，但简化了设计和编程。</li>
</ul>
</li>
<li>在 Java 中，常见的集合类和容器类都可以用于存储和管理数据，它们提供了不同的功能和特性，比如：<br><code>ArrayList</code> 和 <code>LinkedList</code> 是常见的列表（List）实现，提供了不同的插入、删除和访问元素的性能特性。<br><code>HashSet</code> 和 <code>TreeSet</code> 是 <code>Set</code> 接口的实现，分别基于哈希表和树结构，用于存储唯一元素，但没有顺序。<br><code>HashMap</code> 和 <code>TreeMap</code> 是 <code>Map</code> 接口的实现，用键值对的形式存储数据。</li>
</ul>
<p>Java 集合 主要包括 <strong>Collection 和 Map</strong> 两种，Collection 存储着对象的集合，而 Map 存储着键值对(两个对象)的映射表。</p>
<p><img src="https://pdai.tech/images/java_collections_overview.png"></p>
<h2 id="1-Collection"><a href="#1-Collection" class="headerlink" title="1. Collection"></a>1. Collection</h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>主要功能是保证存储的集合不会重复，至于集体是有序还是无序的，需要看具体的实现类，比如 TreeSet 有序，HashSet 无序</p>
<ul>
<li>TreeSet： 基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</li>
<li>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</li>
<li>LinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。</li>
</ul>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul>
<li>ArrayList：基于动态数组实现，支持随机访问。</li>
<li>Vector：和 ArrayList 类似，但它是线程安全的。</li>
<li>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</li>
</ul>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>队列，有序，严格遵守先进先出。</p>
<ul>
<li>LinkedList：可以用它来实现双向队列。实现了 Queue 接口。</li>
<li>PriorityQueue：基于堆结构实现，可以用它来实现优先队列？？？内部是基于数组构建的，用法就是你自定义一个 comparator ，自己定义对比规则，这个队列就是按这个规则来排列出队的优先级。</li>
</ul>
<h2 id="2-Map"><a href="#2-Map" class="headerlink" title="2. Map"></a>2. Map</h2><p>存储的是键值对，也就是给对象（value）搞了一个 key，这样通过 key 可以找到那个 value。</p>
<ul>
<li>TreeMap：基于红黑树实现。有序。</li>
<li>HashMap：基于哈希表实现。</li>
<li>HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</li>
<li>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用(LRU)顺序。</li>
</ul>
<hr>

<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>add(E e): 向列表末尾添加元素<br>get(int index): 获取指定索引位置的元素<br>size(): 获取列表的大小<br>remove(int index): 移除指定索引位置的元素<br>contains(Object o): 判断是否包含指定元素</p>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>add(E e): 在列表末尾添加元素<br>addFirst(E e), addLast(E e): 在列表开头或末尾添加元素<br>get(int index): 获取指定索引位置的元素<br>remove(int index): 移除指定索引位置的元素<br>size(): 获取列表的大小</p>
<h2 id="Stack-Queue"><a href="#Stack-Queue" class="headerlink" title="Stack &amp; Queue"></a>Stack &amp; Queue</h2><p>Stack:<br>push(E e): 将元素压入栈顶，pop(): 移除栈顶元素<br>Queue:<br>offer(E e): 将元素添加到队列尾部，poll(): 获取并移除队列头部元素</p>
<h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><p>add(E e): 向队列中添加元素<br>remove(): 移除队列头部的元素<br>peek(): 获取但不移除队列头部的元素</p>
<h2 id="HashSet-HashMap"><a href="#HashSet-HashMap" class="headerlink" title="HashSet &amp; HashMap"></a>HashSet &amp; HashMap</h2><p>HashSet<br>add(E e): 向集合中添加元素<br>contains(Object o): 判断集合是否包含指定元素<br>remove(Object o): 移除集合中指定的元素<br>HashMap<br>put(K key, V value): 将键值对存入 Map<br>get(Object key): 获取指定键的值<br>containsKey(Object key): 判断 Map 是否包含指定键<br>remove(Object key): 移除 Map 中指定键的键值对</p>
<h2 id="LinkedHashSet-Map"><a href="#LinkedHashSet-Map" class="headerlink" title="LinkedHashSet&amp;Map"></a>LinkedHashSet&amp;Map</h2><h2 id="TreeSet-TreeMap"><a href="#TreeSet-TreeMap" class="headerlink" title="TreeSet &amp; TreeMap"></a>TreeSet &amp; TreeMap</h2><p>TreeSet<br>add(E e): 向集合中添加元素<br>contains(Object o): 判断集合是否包含指定元素<br>remove(Object o): 移除集合中指定的元素<br>TreeMap<br>put(K key, V value): 将键值对存入 Map<br>get(Object key): 获取指定键的值<br>containsKey(Object key): 判断 Map 是否包含指定键<br>remove(Object key): 移除 Map 中指定键的键值对</p>
<h2 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/03/Java%E9%9B%86%E5%90%88/" data-id="clr24omj0000dswv5hpg55ebd" data-title="Java 集合" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Java数据结构" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/02/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date">
  <time class="dt-published" datetime="2021-09-02T03:49:42.000Z" itemprop="datePublished">2021-09-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/02/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">Java 数据结构</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><strong>数组</strong>是一种连续存储线性结构，数组尺寸不能改变。元素类型相同，大小相等，通过使用整型索引值来访问他们的元素。数组是多维的。数组能够容纳基本数据类型（int、char等）或者对象引用（如类对象）。<br><strong>数组的优点</strong>：存取速度快<br><strong>数组的缺点</strong>：事先必须知道数组的长度、插入删除元素很慢、空间通常有限制、需要大块连续内存块、插入删除元素的效率很低<br>Java没有指针，同时也不对程序员暴露其元素的地址，寻址操作完全交给虚拟机。所以看不到每个元素的地址情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers;                               <span class="comment">// 声明一个 int 数组</span></span><br><span class="line">numbers = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];                        <span class="comment">// 初始化一个长度为 5 的 int 数组</span></span><br><span class="line"><span class="type">int</span>[] values = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;              <span class="comment">// 声明并初始化一个 int 数组</span></span><br><span class="line">... <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, j&#125;;                  <span class="comment">// 在方法中返回</span></span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> arr.length;                     <span class="comment">// 获取数组的长度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> arr[<span class="number">1</span>];                          <span class="comment">// 获取索引为 1 的元素</span></span><br><span class="line"><span class="type">int</span>[][] twoDimArray = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">4</span>];         <span class="comment">// 创建一个 3x4 的二维数组</span></span><br><span class="line"><span class="type">int</span>[][][] threeDimArray = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">4</span>][<span class="number">2</span>];  <span class="comment">// 创建一个 3x4x2 的三维数组</span></span><br><span class="line">System.out.println(twoDimArray[<span class="number">0</span>]);          <span class="comment">// [I@7852e922：16进制数值，不是真正的地址，是处理后的</span></span><br></pre></td></tr></table></figure>
<p><code>int[] numbers;</code> 只是声明了一个名为 numbers 的整数数组的引用，它并没有创建数组对象，并没有分配内存或存储数据。<br><code>int[] numbers = new int[5];</code> 在这里，new int[5] 表示创建一个能够存储 5 个整数的整型数组，并将该数组的引用赋给 numbers 变量。这是一个基本的数组类型，而不是 Arrays、ArrayList 或 Vector 对象。<br>数组是基本的数据结构，而 Arrays 和 ArrayList 是 Java 中的类，提供了用于操作和管理数组的方法。</p>
<h4 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h4><p><code>Arrays 类</code>是 Java API 中的一个工具类，它提供了一系列静态方法来操作数组，比如排序、搜索、比较等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">Arrays.fill(arr, <span class="number">10</span>);                           <span class="comment">//  fill()：将数组的所有元素设置为指定值。</span></span><br><span class="line">String[] array = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(array);       <span class="comment">//  asList()：将数组转换为 `List`。</span></span><br><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">Arrays.sort(numbers);                           <span class="comment">//  sort()：对数组进行排序。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(numbers, <span class="number">3</span>);    <span class="comment">//  binarySearch()：在排序数组中执行二分查找。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Arrays.toString(numbers);          <span class="comment">//  toString()：将数组转换为字符串表示形式。</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEqual</span> <span class="operator">=</span> Arrays.equals(arr, numbers);  <span class="comment">//  equals()：比较两个数组是否相等。</span></span><br><span class="line"><span class="comment">//  copyOf() 和 copyOfRange()：复制数组或复制数组的指定范围。</span></span><br><span class="line"><span class="type">int</span>[] copy1 = Arrays.copyOf(arr, source.length);</span><br><span class="line"><span class="type">int</span>[] copy2 = Arrays.copyOfRange(arr, <span class="number">2</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p><code>Vector</code> 是一个同步的动态数组类，类似于 <code>ArrayList</code>，可以自动增长和缩小以容纳对象。<br><strong>ArrayList 和 Vector 都是动态数组实现的集合</strong>，而 <code>Arrays</code> 类主要用于数组的各种操作。<br><code>Vector</code> 是线程安全的（是同步的），而 <code>Arrays</code> 不是（没有提供同步）。<code>Vector</code> 在对集合进行操作时会进行同步，适用于多线程环境。单线程环境下，推荐使用 <code>ArrayList</code> 而不是 <code>Vector</code>，因为 <code>ArrayList</code> 不是同步的，性能更高。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt;String&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();            <span class="comment">// 创建 Vector</span></span><br><span class="line">vector.add(<span class="string">&quot;Element 1&quot;</span>);                           <span class="comment">// 添加元素</span></span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> vector.size();                          <span class="comment">// 获取 Vector 的大小</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> vector.isEmpty();                <span class="comment">// 检查 Vector 是否为空</span></span><br><span class="line"><span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> vector.get(<span class="number">0</span>);                    <span class="comment">// 访问 Vector 中的元素：获取索引为0的元素</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> vector.indexOf(<span class="string">&quot;Element 2&quot;</span>);           <span class="comment">// 查找元素在 Vector 中的位置</span></span><br><span class="line">vector.remove(<span class="number">1</span>);                                  <span class="comment">// 删除 Vector 中的元素：删除索引为1的元素</span></span><br><span class="line"><span class="keyword">for</span> (String element : vector) &#123; ...&#125;               <span class="comment">// 遍历 Vector 中的元素</span></span><br></pre></td></tr></table></figure>

<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>ArrayList是基于<strong>动态数组</strong>实现的，可以自动扩容。（动态数组是一种数据结构，而非类，是一种具有自动扩容能力的数组<br>它支持快速随机访问元素，但在插入和删除元素时可能会比较耗时。适用于需要随机访问元素、按索引查找和遍历集合的场景。<br>1、<code>add(E e)</code>：在尾部添加元素。<br>2、<code>get(int index)</code>：获取指定位置的元素。<br>3、<code>set(int index, E element)</code>：用于替换指定索引处的元素。<br>4、<code>remove(int index)</code>：移除指定位置的元素。<br>5、 <code>size()</code>：返回集合大小。</p>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList是基于<strong>双向链表</strong>实现的，每个节点都存储了对前一个和后一个元素的引用。它在插入和删除元素时效率较高，但在随机访问元素时效率较低。LinkedList适用于需要频繁的插入、删除操作的场景。<br>1、<code>add(E e)</code>：在尾部添加元素。<br>2、<code>addFirst(E e)</code>：在头部添加元素。<br>3、<code>get(int index)</code>：获取指定位置的元素。<br>4、<code>remove(int index)</code>：移除指定位置的元素。<br>5、<code>size()</code>：返回集合大小。</p>
<hr>


<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><strong>链表</strong>由一个节点序列组成，每个节点包含数据和指向下一个节点的引用。n个节点离散分配，每个节点只有一个前驱节点和一个后续节点，首节点没有前驱节点，尾节点没有后续节点。当你创建一个链表时，你持有的引用实际上指向链表中第一个节点的地址，也就是头节点。头节点存储了链表的起始地址，通过这个地址可以访问整个链表。<br><strong>链表优点</strong>：空间没有限制、插入删除元素很快。<strong>链表缺点</strong>：存取速度很慢</p>
<h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p>单链表的每个节点包含两个部分：数据和指向下一个节点的引用。第一个节点称为头节点，最后一个节点的下一个节点为空<code>null</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;   <span class="comment">// Java中单链表的节点（Node）通常会被定义为一个内部类。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> data;  <span class="comment">// 数据域</span></span><br><span class="line">    <span class="keyword">public</span> Node next; <span class="comment">// 指针域，指向下一个节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123;    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;        <span class="built_in">this</span>.data = data;    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data, Node next)</span> &#123;        <span class="built_in">this</span>.data = data;        <span class="built_in">this</span>.next = next;    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="comment">// 添加新节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(data);</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            head = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">while</span> (current.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current.next = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他操作（删除节点、查找节点等）可以根据需要实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>双向链表</strong> 中的每个节点都有两个指针：一个指向前一个节点，一个指向后一个节点。双向链表允许在节点之间双向遍历。<br>将两种(双向&#x2F;单向)链表的最后一个结点指向第一个结点从而实现 <strong>循环链表</strong>，能通过任何一个节点找到其他所有的节点。</p>
<hr>


<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。<br>哈希表使用 <strong>O(N)</strong> 空间复杂度存储数据，并且以 <strong>O(1)</strong> 时间复杂度求解问题。</p>
<ul>
<li><strong>HashSet</strong> 用于存储一个集合，可以查找元素是否在集合中。<br>但是，如果元素有穷，并且范围不大，那么可以用一个布尔数组来存储一个元素是否存在，就足够了。</li>
<li><strong>HashMap</strong> 主要用于映射关系，从而把两个元素联系起来。HashMap 也可以用来对元素进行计数统计，此时键为元素，值为计数。和 HashSet 类似，如果元素有穷并且范围不大，可以用整型数组来进行统计。</li>
</ul>
<h4 id="HashMap-常用方法"><a href="#HashMap-常用方法" class="headerlink" title="HashMap 常用方法"></a>HashMap 常用方法</h4><p><code>put(key, value)</code>：将指定的键值对添加到哈希表中；如果该键已存在于 HashMap 中，则其旧值会被新值替换。<br><code>get(key)</code>：根据键获取对应的值。<br><code>containsKey(key)</code>：检查哈希表中是否包含指定的键。<code>containsValue(value)</code>：检查哈希表中是否包含指定的值。<br><code>remove(key)</code>：根据键移除键值对。<br><code>size()</code>：返回哈希表中键值对的数量。<br><code>isEmpty()</code>：检查哈希表是否为空。<br><code>keySet()</code>：返回哈希表中所有键的集合。<code>values()</code>：返回哈希表中所有值的集合。<code>entrySet()</code>：返回键值对的集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line">Map&lt;String, Integer&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  <span class="comment">// 创建一个HashMap</span></span><br><span class="line">hashMap.put(<span class="string">&quot;Three&quot;</span>, <span class="number">3</span>);  hashMap.remove(<span class="string">&quot;Three&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!hashMap.containsKey(<span class="string">&quot;Three&quot;</span>))  hashMap.put(<span class="string">&quot;Three&quot;</span>, <span class="number">3</span>); </span><br><span class="line"><span class="comment">// 遍历kv：2种方法</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : hashMap.entrySet()) &#123;  </span><br><span class="line">    System.out.println(<span class="string">&quot;Key: &quot;</span> + entry.getKey() + <span class="string">&quot;, Value: &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(String s : hashMap.keySet()) System.out.println(<span class="string">&quot;Key: &quot;</span> + s + <span class="string">&quot;, Value: &quot;</span> + hashMap.get(s));</span><br></pre></td></tr></table></figure>

<h4 id="HashSet-常用方法"><a href="#HashSet-常用方法" class="headerlink" title="HashSet 常用方法"></a>HashSet 常用方法</h4><p><code>add(E e)</code>: 向集合中添加元素。<code>addAll(Collection&lt;? extends E&gt; c)</code>: 将另一个集合的所有元素添加到当前集合。<br><code>remove(Object o)</code>: 移除指定的元素。<code>removeAll(Collection&lt;?&gt; c)</code>: 移除当前集合中包含在指定集合中的所有元素。<br><code>contains(Object o)</code>: 判断集合中是否包含指定元素。containsAll(Collection&lt;?&gt; c): 判断集合是否包含指定集合中的所有元素。<br><code>size()</code>: 返回集合的大小（元素个数）。<br><code>isEmpty()</code>: 判断集合是否为空。<br><code>clear()</code>: 清空集合中的所有元素。<br><code>iterator()</code>: 返回用于遍历集合的迭代器。</p>
<hr>


<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><strong>String</strong> 内部使用 char 数组存储数据。该数组被声明为 final，因此它不可被继承，初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 <strong>不可变</strong>。String 是一个类，而不是基本数据类型或容器。表示的是一个字符序列。<br>字符串是一个<strong>引用类型</strong>，因此在创建 String 对象时，实际上是在内存中分配了一块存储空间来存储字符串的值。(字符串常量池，堆，栈，</p>
<ul>
<li><strong>获取字符串信息</strong>：<br><code>length()</code>：返回字符串的长度。<br><code>charAt(int index)</code>：返回指定索引处的字符。<br><code>substring(int beginIndex)</code>：返回从 beginIndex 开始到字符串末尾的子字符串。<br><code>substring(int beginIndex, int endIndex)</code>：返回从 beginIndex 到 endIndex（不含）之间的子字符串</li>
<li><strong>字符串拼接</strong>：直接使用 <code>+</code> 运算符，或 <code>concat(String str)</code>：将指定字符串 str 连接到原字符串的末尾。<br>String 不可变，+&#x3D; 操作符或 concat()实际上创建了一个新的字符串对象，该对象包含 字符串值修改后的内容，然后将其分配给了原 str变量，使 str 引用了新的字符串对象，而原始的空字符串对象仍然存在，没有被修改。</li>
<li><strong>字符串查找和比较</strong>：<br><code>indexOf(String str)</code>：返回指定子字符串 str 在主字符串中第一次出现的位置。<code>lastIndexOf()</code>：返回最后一次..<br><code>equals(Object another)</code>：比较两个字符串是否相等。<code>equalsIgnoreCase()</code>：忽略大小写比较..。</li>
<li><strong>字符串转换</strong>：<br><code>toLowerCase()</code>：将字符串转换为小写，<code>toUpperCase()</code>：转大写。对于字符，有 <code>Character.toLowerCase()</code> 方法；<br><code>trim()</code>：去除字符串首尾的空格。</li>
<li><strong>切割字符串：</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;Hello world! This is a Java example.&quot;</span>;</span><br><span class="line"><span class="comment">// 使用空格切割字符串: `\\s+` 是一个正则表达式，表示一个或多个空格</span></span><br><span class="line">String[] words = text.split(<span class="string">&quot;\\s+&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><strong>字符串替换</strong>：<br><code>replace(char oldChar, char newChar)</code>：将字符串中的 <code>oldChar</code> 替换为 <code>newChar</code>。<br><code>replaceAll(String regex, String replace)</code>：使用新字符串<code>replace</code>替换所有与 <code>regex</code>匹配的字符串。<br><code>replaceFirst(String regex, String replacement)</code>：替换第一个匹配的字符串。</li>
<li><strong>字符串翻转</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">original</span> <span class="operator">=</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">reversed</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(original).reverse();</span><br><span class="line"><span class="type">String</span> <span class="variable">reversedString</span> <span class="operator">=</span> reversed.toString();</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>

<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p>数组和链表都是线性存储结构的基础，栈和队列都是线性存储结构的应用</p>
<h3 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h3><p>栈是一种后进先出（LIFO，Last-In-First-Out）的数据结构。在Java中，可以使用 <code>java.util.Stack</code> 类实现栈的功能，也可以使用 <code>Deque</code> 接口（比如 <code>ArrayDeque</code> 或 <code>LinkedList</code>）来模拟栈的行为。<br>Java 中，Stack 类实际上继承自 Vector 类。Vector 类实现了一个动态数组，而 Stack 在 Vector 的基础上提供了栈的常见操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">stack.push(<span class="number">10</span>); stack.push(<span class="number">20</span>);         <span class="comment">// push(E item)：将元素压入栈顶。</span></span><br><span class="line">System.out.println(stack.pop());        <span class="comment">// pop()：移除并返回栈顶元素。输出 30</span></span><br><span class="line">System.out.println(stack.peek());       <span class="comment">// peek()：返回但不移除栈顶元素。输出 20</span></span><br><span class="line">System.out.println(stack.isEmpty());    <span class="comment">// isEmpty()：检查队列是否为空。输出 false</span></span><br></pre></td></tr></table></figure>

<h3 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h3><p>队列是一种先进先出（FIFO，First-In-First-Out）的数据结构。在Java中，可以使用 <code>java.util.Queue</code> 接口和它的实现类来实现队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">queue.offer(<span class="number">10</span>); queue.offer(<span class="number">20</span>);       <span class="comment">// offer(E e)：将元素插入队列。</span></span><br><span class="line">System.out.println(queue.poll());       <span class="comment">// poll()：移除并返回队列头部的元素。输出 10</span></span><br><span class="line">System.out.println(queue.peek());       <span class="comment">// peek()：返回但不移除队列头部的元素。输出 20</span></span><br><span class="line">System.out.println(queue.isEmpty());    <span class="comment">// isEmpty()：检查队列是否为空。输出 false</span></span><br></pre></td></tr></table></figure>

<p>JDK中实现：源码解析<a target="_blank" rel="noopener" href="https://pdai.tech/md/java/collection/java-collection-Queue&Stack.html">https://pdai.tech/md/java/collection/java-collection-Queue&amp;Stack.html</a></p>
<hr>

<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>树：它是n(n&gt;&#x3D;0)个节点的有限集。n&#x3D;0时为空树。n&gt;0时，有限集的元素构成一个具有层次感的数据结构。<br>区别于线性表一对一的元素关系，树中的节点是一对多的关系。树具有以下特点:<br>1、n&gt;0时，根节点是唯一的，不可能存在多个根节点。<br>2、每个节点有零个至多个子节点；除了根节点外，每个节点有且仅有一个父节点。根节点没有父节点。</p>
<ul>
<li>基本概念：<ul>
<li>子树: 除了根节点外，每个子节点都可以分为多个不相交的子树。</li>
<li>孩子与双亲: 若一个结点有子树，那么该结点称为子树根的”双亲”，子树的根是该结点的”孩子”。</li>
<li>兄弟: 具有相同双亲的节点互为兄弟。</li>
<li>节点的度: 一个节点拥有子树的数目。</li>
<li>叶子: 没有子树，也即是度为0的节点。</li>
<li>分支节点: 除了叶子节点之外的节点，也即是度不为0的节点。</li>
<li>内部节点: 除了根节点之外的分支节点。</li>
<li>层次: 根节点为第一层，其余节点的层次等于其双亲节点的层次加1.</li>
<li>树的高度: 也称为树的深度，树中节点的最大层次。</li>
<li>有序树: 树中节点各子树之间的次序是重要的，不可以随意交换位置。</li>
<li>无序树: 树种节点各子树之间的次序是不重要的。可以随意交换位置。</li>
<li>森林: 0或多棵互不相交的树的集合。</li>
</ul>
</li>
<li>二叉树：最多有两棵子树的树被称为二叉树<ul>
<li>满二叉树: 二叉树中所有非叶子结点的度都是2，且叶子结点都在同一层次上</li>
<li>完全二叉树: 如果一个二叉树与满二叉树前m个节点的结构相同，这样的二叉树被称为完全二叉树</li>
<li>插入</li>
<li>删除</li>
<li>遍历：前序遍历、中序遍历、后序遍历</li>
<li>搜索</li>
</ul>
</li>
<li>动态查找树<ul>
<li><strong>二叉搜索树 BST</strong><ul>
<li>指一棵空树或者具有下列性质的二叉树：若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；任意节点的左、右子树也分别为二叉查找树；没有键值相等的节点。</li>
<li>二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低为 O(logn) 。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、多重集、关联数组等。</li>
</ul>
</li>
<li><strong>二叉平衡树 AVL</strong><ul>
<li>含有相同节点的二叉查找树可以有不同的形态，而二叉查找树的平均查找长度与树的深度有关，所以需要找出一个查找平均长度最小的一棵，那就是平衡二叉树</li>
<li>具有以下性质：要么是棵空树，要么其根节点左右子树的深度之差的绝对值不超过1；其左右子树也都是平衡二叉树；二叉树节点的平衡因子定义为该节点的左子树的深度减去右子树的深度。则AVL的所有节点的平衡因子只可能是-1,0,1。</li>
</ul>
</li>
<li><strong>红黑树</strong>：红黑树也是一种自平衡的二叉查找树。<ul>
<li>1、每个结点要么是红的要么是黑的。(红或黑)  2、根结点是黑的。(根黑)  3、每个叶结点(叶结点即指树尾端NIL指针或NULL结点)都是黑的。(叶黑)  4、如果一个结点是红的，那么它的两个儿子都是黑的。(红子黑) 5、对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。(路径下黑相同)  <img src="https://pdai.tech/images/alg/alg-tree-14.png" width="400" height="300" alt=""></li>
<li>用法最广：Java ConcurrentHashMap &amp; TreeMap；C++ STL: map &amp; set；linux进程调度Completely Fair Scheduler,用红黑树管理进程控制块；epoll在内核中的实现，用红黑树管理事件块；nginx中，用红黑树管理timer等</li>
</ul>
</li>
<li>哈夫曼树：哈夫曼又称最优二叉树。是一种带权路径长度最短的二叉树，一般可以按下面步骤构建:<ul>
<li>将所有左，右子树都为空的作为根节点。在森林中选出两棵根节点的权值最小的树作为一棵新树的左，右子树，且置新树的附加根节点的权值为其左，右子树上根节点的权值之和。注意，左子树的权值应小于右子树的权值。从森林中删除这两棵树，同时把新树加入到森林中。重复2，3步骤，直到森林中只有一棵树为止，此树便是哈夫曼树。  <img src="https://pdai.tech/images/alg/alg-tree-13.png" width="400" height="300" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>多路查找树<ul>
<li><strong>B 树</strong>：是一种自平衡的树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一种自平衡的m阶树，与自平衡二叉查找树不同，B树适用于读写相对大的数据块的存储系统，例如磁盘。<ul>
<li>根结点至少有两个子女。</li>
<li>每个中间节点都包含k-1个元素和k个孩子，其中 m&#x2F;2 &lt;&#x3D; k &lt;&#x3D; m</li>
<li>每一个叶子节点都包含k-1个元素，其中 m&#x2F;2 &lt;&#x3D; k &lt;&#x3D; m</li>
<li>所有的叶子结点都位于同一层。</li>
<li>每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。<br>  B-Tree中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个3阶的B-Tree:  <img src="https://pdai.tech/images/alg/alg-tree-15.png" width="600" height="300" alt=""></li>
</ul>
</li>
<li><strong>B+ 树</strong>：B+ 树是一种树数据结构，通常用于关系型数据库(如Mysql)和操作系统的文件系统中。<ul>
<li>B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。自底向上插入，与二叉树相反。</li>
<li>在B树基础上，为叶子结点增加链表指针(B树+叶子有序链表)，所有关键字都在叶子结点 中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中。</li>
<li>b+树的非叶子节点不保存数据，只保存子树的临界值(最大或者最小)，所以同样大小的节点，b+树相对于b树能够有更多的分支，使得这棵树更加矮胖，查询时做的IO操作次数也更少。<br>  将上一节中的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示:  <img src="https://pdai.tech/images/alg/alg-tree-16.png" width="600" height="300" alt=""></li>
</ul>
</li>
<li>B* 树</li>
<li>R 树：R树是用来做空间数据存储的树状数据结构。例如给地理位置，矩形和多边形这类多维数据建立索引。</li>
</ul>
</li>
</ul>
<p><code>数组</code>的下标寻址十分迅速，但计算机的内存是有限的，故数组的长度也是有限的；而且无序数组的查找最坏情况需要遍历整个数组；后来人们提出了<code>二分查找</code>，要求数组的构造一定有序，二分法查找解决了普通数组查找复杂度过高的问题。任何一种数组无法解决的问题就是插入、删除操作比较复杂，因此，在一个增删查改比较频繁的数据结构中，数组不会被优先考虑<br><code>普通链表</code>由于它的结构特点被证明根本不适合进行查找<br><code>哈希表</code>是数组和链表的折中，同时它的设计依赖散列函数的设计，数组不能无限长、链表也不适合查找，所以也不适合大规模的查找 ??? ???<br><code>二叉查找树</code>因为可能退化成链表，同样不适合进行查找<br><code>AVL树</code>是为了解决可能退化成链表问题，但是AVL树的旋转过程非常麻烦，因此插入和删除很慢，也就是构建AVL树比较麻烦<br><code>红黑树</code>是平衡二叉树和AVL树的折中，是比较合适的。集合类中的Map、关联数组具有较高的查询效率，它们的底层实现就是红黑树。<br><code>多路查找树</code> 是大规模数据存储中，实现索引查询这样一个实际背景下，树节点存储的元素数量是有限的(如果元素数量非常多的话，查找就退化成节点内部的线性查找了)，这样导致二叉查找树结构由于树的深度过大而造成磁盘I&#x2F;O读写过于频繁，进而导致查询效率低下。<br><code>B树</code>与自平衡二叉查找树不同，B树适用于读写相对大的数据块的存储系统，例如磁盘。它的应用是文件系统及部分非关系型数据库索引。<br><code>B+树</code>在B树基础上，为叶子结点增加链表指针(B树+叶子有序链表)，所有关键字都在叶子结点 中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中。通常用于关系型数据库(如Mysql)和操作系统的文件系统中。<br><code>B* 树</code>是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针, 在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1&#x2F;2提高到2&#x2F;3。<br><code>R树</code>是用来做空间数据存储的树状数据结构。例如给地理位置，矩形和多边形这类多维数据建立索引。Trie树是自然语言处理中最常用的数据结构，很多字符串处理任务都会用到。<br><code>Trie树</code>本身是一种有限状态自动机，还有很多变体。什么模式匹配、正则表达式，都与这有关。<br><strong>针对大量数据，如果在内存中作业优先考虑红黑树(map,set之类多为RB-tree实现)，如果在硬盘中作业优先考虑B系列树</strong></p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>在Java中，二叉树是一种常见的树形数据结构，每个节点最多有两个子节点，分别为左子节点和右子节点。二叉树的节点类似于一个结构体，包含了数据、左子节点和右子节点的引用。以下是一个简单的二叉树的实现示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123;   <span class="built_in">this</span>.val = val;    <span class="built_in">this</span>.left = <span class="literal">null</span>;    <span class="built_in">this</span>.right = <span class="literal">null</span>;   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode root;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BinaryTree</span><span class="params">()</span> &#123;    root = <span class="literal">null</span>;   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        root = insertRec(root, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">insertRec</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (val &lt; root.val) &#123;</span><br><span class="line">            root.left = insertRec(root.left, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root.val) &#123;</span><br><span class="line">            root.right = insertRec(root.right, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他操作（搜索节点、删除节点等）可以根据需要实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>各树详解：<a target="_blank" rel="noopener" href="https://pdai.tech/md/algorithm/alg-basic-tree-search.html">https://pdai.tech/md/algorithm/alg-basic-tree-search.html</a></p>
<hr>

<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>图(Graph)是由顶点和连接顶点的边构成的离散结构。图是最灵活的数据结构之一，很多问题都可以使用图模型进行建模求解。<br>理解：图基础，图的遍历，最小生成树(Prim &amp; Kruskal)，最短路径(Dijkstra &amp; Frolyd)，拓扑排序(Topological sort)，AOE &amp; 关键路径等。</p>
<ul>
<li>图的定义：图是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为: G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。和线性表，树的差异:<ul>
<li>线性表中我们把数据元素叫元素，树中将数据元素叫结点，在图中数据元素，我们则称之为顶点(Vertex)。</li>
<li>线性表可以没有元素，称为空表；树中可以没有节点，称为空树；但是，在图中不允许没有顶点(有穷非空性)。</li>
<li>线性表中的各元素是线性关系，树中的各元素是层次关系，而图中各顶点的关系是用边来表示(边集可以为空)</li>
</ul>
</li>
<li>相关术语<ul>
<li>顶点的度：顶点Vi的度(Degree)是指在图中与Vi相关联的边的条数。对于有向图来说，有入度(In-degree)和出度(Out-degree)之分，有向图顶点的度等于该顶点的入度和出度之和。</li>
<li>邻接：若无向图中的两个顶点V1和V2存在一条边(V1,V2)，则称顶点V1和V2邻接(Adjacent)；若有向图中存在一条边&lt;V3,V2&gt;，则称顶点V3与顶点V2邻接，且是V3邻接到V2或V2邻接直V3；</li>
<li>路径：在无向图中，若从顶点Vi出发有一组边可到达顶点Vj，则称该顶点序列为从顶点Vi到顶点Vj的路径(Path)。</li>
<li>连通：若从Vi到Vj有路径可通，则称顶点Vi和顶点Vj是连通(Connected)的。</li>
<li>权(Weight)：有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做权(Weight)。</li>
</ul>
</li>
<li>类型<ul>
<li>无向图：如果图中任意两个顶点之间的边都是无向边(没有方向的边)，则称该图为无向图。边使用小括号“()”表示;如 (V1,V2);</li>
<li>有向图：如果图中任意两个顶点之间的边都是有向边(有方向的边)，则称该图为有向图。边使用尖括号“&lt;&gt;”表示;如 &lt;V1,V2&gt;</li>
<li>无向完全图: 在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。(有(n*(n-1))&#x2F;2条边)</li>
<li>有向完全图: 在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。(含有n个顶点的有向完全图有n*(n-1)条边)</li>
</ul>
</li>
<li>图的存储结构<ul>
<li>邻接矩阵表示法：用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组(称为邻接矩阵)存储图中的边或弧的信息。  <img src="https://pdai.tech/images/alg/alg-graph-store-1.png" width="400" height="300" alt="">
  <img src="https://pdai.tech/images/alg/alg-graph-store-2.png" width="400" height="300" alt="">
  不足: 由于存在n个顶点的图需要n*n个数组元素进行存储，当图为稀疏图时，使用邻接矩阵存储方法将会出现大量0元素，这会造成极大的空间浪费。这时，可以考虑使用邻接表表示法来存储图中的数据</li>
<li>邻接表表示法：邻接表由表头节点和表节点两部分组成，图中每个顶点均对应一个存储在数组中的表头节点。如果这个表头节点所对应的顶点存在邻接节点，则把邻接节点依次存放于表头节点所指向的单向链表中。  <img src="https://pdai.tech/images/alg/alg-graph-store-3.jpg" width="400" height="300" alt="">
  <img src="https://pdai.tech/images/alg/alg-graph-store-4.jpg" width="400" height="300" alt=""></li>
</ul>
</li>
</ul>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>深度优先搜索: 假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。显然，深度优先搜索是一个递归的过程。<br>DFS &amp; BFS 实现 <a target="_blank" rel="noopener" href="https://pdai.tech/md/algorithm/alg-basic-graph-bfs-dfs.html">https://pdai.tech/md/algorithm/alg-basic-graph-bfs-dfs.html</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">vexnode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">bool</span> visited;</span><br><span class="line">    vector&lt;vexnode*&gt; neighbors;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vexnode *g[], <span class="type">int</span> v1)</span> </span>&#123;</span><br><span class="line">    stack&lt;vexnode*&gt; stk;</span><br><span class="line">    stk.<span class="built_in">push</span>(g[v1]);</span><br><span class="line">    g[v1]-&gt;visited = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        vexnode *cur = stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; cur-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (vexnode *neighbor : cur-&gt;neighbors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!neighbor-&gt;visited) &#123;</span><br><span class="line">                neighbor-&gt;visited = <span class="literal">true</span>;</span><br><span class="line">                stk.<span class="built_in">push</span>(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>广度优先搜索算法(Breadth First Search)，又称为”宽度优先搜索”或”横向优先搜索”。<br>它的思想是: 从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。<br>换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1,2…的顶点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vexnode *g[], <span class="type">int</span> v1)</span> </span>&#123;</span><br><span class="line">    queue&lt;vexnode*&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(g[v1]);</span><br><span class="line">    g[v1]-&gt;visited = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        vexnode *cur = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; cur-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (vexnode *neighbor : cur-&gt;neighbors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!neighbor-&gt;visited) &#123;</span><br><span class="line">                neighbor-&gt;visited = <span class="literal">true</span>;</span><br><span class="line">                que.<span class="built_in">push</span>(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>java实现？</p>
<hr>

<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul>
<li>时间复杂度是一种用来衡量算法运行时间与输入规模之间关系的概念。它不是用来精确测量程序运行时间的，而是描述在输入规模变化时，算法运行时间的增长趋势。</li>
<li>大O表示上界，当用它作为算法的最坏情况运行时间的上界，就是对任意数据输入的运行时间的上界。<br>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!)</li>
</ul>
<h2 id="♥常见排序算法知识体系详解♥"><a href="#♥常见排序算法知识体系详解♥" class="headerlink" title="♥常见排序算法知识体系详解♥"></a>♥常见排序算法知识体系详解♥</h2><p><a target="_blank" rel="noopener" href="https://leo710aka.github.io/2020/09/09/5%20%E7%B4%A2%E5%BC%95_%E6%8E%92%E5%BA%8F_/">https://leo710aka.github.io/2020/09/09/5%20%E7%B4%A2%E5%BC%95_%E6%8E%92%E5%BA%8F_/</a><br><img src="https://pdai.tech/images/alg/alg-sort-overview-1.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/02/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" data-id="clr24omj0000fswv5b1a9cwff" data-title="Java 数据结构" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Java基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/01/Java%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2021-09-01T03:49:42.000Z" itemprop="datePublished">2021-09-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/01/Java%E5%9F%BA%E7%A1%80/">Java 基础</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol>
<li>Java 是一种高级编程语言和计算平台。它最初由Sun（后被Oracle收购）于1995年发布，旨在实现“一次编写，到处运行”的理念。</li>
<li><strong>Java SE（标准版）</strong>：是 Java 平台的基本版本，也是最基本的 Java 编程平台。提供了 Java 编程语言的核心功能，包括基本的语言结构、标准库、输入&#x2F;输出、多线程支持等。Java SE 适用于通用的桌面应用程序、命令行工具、小型服务、移动应用程序等各种领域。</li>
<li><strong>Java EE（企业版）</strong>：是在 Java SE 的基础上构建的，专门用于开发和运行企业级应用程序的平台。它提供了一组扩展和 API，用于构建大型、分布式、可伸缩、高性能的应用程序，如企业级 Web 应用、电子商务系统等。Java EE 包括了 Servlet、JSP、EJB、JPA等各种技术和规范，以支持不同类型的企业级应用。</li>
</ol>
<h2 id="面向对象-三大特性"><a href="#面向对象-三大特性" class="headerlink" title="面向对象 三大特性"></a>面向对象 三大特性</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承实现了 IS-A 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 向上转型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向上继承是面向对象编程中的一个关键概念，它通过创建一个统一的接口和通用的父类，支持多态性，减少代码重复，提高</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();  <span class="comment">// 代码的可维护性和可扩展性。使代码更灵活、通用和易于理解，有助于构建更高质量的程序</span></span><br></pre></td></tr></table></figure>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>编译时多态主要指方法的重载（一个类中的多个同名方法）<br>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定（父,子类之间）；有三个条件:继承、覆盖(重写)、向上转型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;  System.out.println(<span class="string">&quot;aoaoao..&quot;</span>); &#125;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;  System.out.println(<span class="string">&quot;旺旺旺&quot;</span>);    &#125;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;  System.out.println(<span class="string">&quot;喵喵喵&quot;</span>);    &#125;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Music</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Animal&gt; animals = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        animals.add(<span class="keyword">new</span> <span class="title class_">Cat</span>());  animals.add(<span class="keyword">new</span> <span class="title class_">Dog</span>());  animals.add(<span class="keyword">new</span> ..()).....</span><br><span class="line">        <span class="keyword">for</span>(Animal animal : animals) &#123;            animal.play();        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure>


<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>数据类型定义了数据的种类和取值范围，以及对这些数据执行的操作。在Java中，数据类型主要分为两类：</p>
<h3 id="1-基本数据类型"><a href="#1-基本数据类型" class="headerlink" title="1. 基本数据类型"></a>1. 基本数据类型</h3><ul>
<li><strong>基本数据类型</strong>：这些数据类型是Java语言的一部分，用于表示基本的数据值。有以下几种：<br>整数类型：byte、short、int、long; 浮点数类型：float、double; 字符类型：char; 布尔类型：boolean<br><code>Integer.MAX_VALUE</code>常量表示int类型的最大值，值为2147483647。</li>
<li><strong>包装类型</strong>：包装是指将基本数据类型包装在对象中的过程。这是因为 Java 是面向对象的编程语言，需要将基本数据类型封装在对象中，从而在面向对象的上下文中使用它们，在处理集合、泛型、反射等Java编程中的许多场景中非常有用。例如，你可以将一个 int 存储在一个 List&lt;Integer&gt; 中，而不是 List&lt;int&gt;<br>类型对应：byte - Byte, short - Short, int - Integer, long - Long, float - Float, double - Double, char - Character, boolean - Boolean<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">2</span>;  <span class="comment">// 装箱，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x;      <span class="comment">// 拆箱</span></span><br></pre></td></tr></table></figure></li>
<li>类型转换<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int 转 String</span></span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">strNumber1</span> <span class="operator">=</span> String.valueOf(number);  <span class="comment">// 使用 String 的静态方法 valueOf()</span></span><br><span class="line"><span class="type">String</span> <span class="variable">strNumber2</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> + number;             <span class="comment">// 使用字符串拼接</span></span><br><span class="line"><span class="type">String</span> <span class="variable">strNumber</span> <span class="operator">=</span> Integer.toString(number); <span class="comment">// 使用 Integer 对象的 toString()</span></span><br><span class="line"><span class="comment">// 将字符串转换为整数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> Integer.parseInt(str); </span><br><span class="line"><span class="comment">// int 与 char：利用 ASCII值 转换</span></span><br><span class="line">c = (<span class="type">char</span>)(c + <span class="number">32</span>);  <span class="comment">// 大小写字母差值32，与cpp中的一样</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="string">&#x27;9&#x27;</span> - <span class="string">&#x27;0&#x27;</span>; </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-引用数据类型"><a href="#2-引用数据类型" class="headerlink" title="2. 引用数据类型"></a>2. 引用数据类型</h3><p>引用数据类型用于引用对象，而不是直接存储数据值。引用数据类型包括类、接口、数组、枚举等。</p>
<ul>
<li>引用：引用是一个变量，用于存储对象的内存地址。它指向对象在堆内存中的位置，而不是对象本身。通过引用，可以访问和操作对象的数据和方法。</li>
<li>引用类型：引用类型是Java中的数据类型之一，用于声明引用变量。Java的引用类型包括类、接口、数组、枚举和注解。引用类型的变量可以用来引用相应类型的对象。</li>
<li><strong>堆内存：在Java中，所有的对象都存储在堆内存中。引用变量存储的是对象在堆内存中的地址。当创建一个新对象时，它被分配到堆内存中，然后引用变量被赋予该对象的地址。</strong></li>
<li><strong>栈内存：Java中的引用变量本身存储在栈内存中。栈内存用于存储局部变量，包括引用变量。引用变量在栈上分配内存，但它们指向的对象存储在堆内存中。</strong></li>
<li>强引用：强引用是最常见的引用类型。当一个对象被强引用变量引用时，它不会被垃圾回收器回收，直到引用变量不再引用该对象。如果没有任何强引用指向一个对象，该对象就会成为垃圾，可以被垃圾回收。</li>
<li>软引用：软引用用于描述一些还有用但并非必需的对象。当内存不足时，垃圾回收器可能会回收被软引用引用的对象，释放内存。这可以防止内存溢出，但不会保证垃圾回收器什么时候回收这些对象。</li>
<li>弱引用：弱引用用于描述非必需对象的引用。弱引用的对象会在垃圾回收器下次运行时被回收，不论内存是否足够。这使得弱引用适用于临时对象和缓存。</li>
<li>虚引用：虚引用是最弱的引用类型。虚引用的对象没有直接访问的权限，它主要用于跟踪对象是否被回收。虚引用必须和引用队列（ReferenceQueue）一起使用，以便在对象被回收时收到通知。</li>
</ul>
<h3 id="主要引用类型"><a href="#主要引用类型" class="headerlink" title="主要引用类型:"></a><strong>主要引用类型:</strong></h3><ul>
<li>类引用类型：类引用类型用于引用类的实例，即对象。这是Java中最常见的引用类型。例如，如果有一个类 <code>Person</code>，您可以创建 <code>Person</code> 类型的引用来引用不同的 <code>Person</code> 对象：<code>Person person = new Person();</code></li>
<li>接口引用类型：接口引用类型用于引用实现了特定接口的对象。例如，如果有一个接口 <code>Drawable</code>，您可以创建 <code>Drawable</code> 类型的引用来引用实现了 <code>Drawable</code> 接口的对象：<code>Drawable drawable = new Circle();</code></li>
<li>数组引用类型：数组引用类型用于引用数组对象。数组可以包含基本数据类型或引用类型的元素。例如，<code>int[] numbers</code> 是一个引用类型，用于引用整数数组。</li>
<li>枚举引用类型</li>
<li>泛型引用类型</li>
<li>父类引用类型：父类引用类型用于引用子类对象。这可以用于实现多态。例如，如果有一个父类 <code>Animal</code> 和一个子类 <code>Dog</code>，您可以创建 <code>Animal</code> 类型的引用来引用 <code>Dog</code> 对象：<code>Animal animal = new Dog();</code></li>
</ul>
<h3 id="Java中的引用不是直接的内存地址，而是对实际对象的间接引用。这使得Java程序员不需要关心内存管理，因为Java虚拟机（JVM）会自动管理对象的创建和销毁。"><a href="#Java中的引用不是直接的内存地址，而是对实际对象的间接引用。这使得Java程序员不需要关心内存管理，因为Java虚拟机（JVM）会自动管理对象的创建和销毁。" class="headerlink" title="Java中的引用不是直接的内存地址，而是对实际对象的间接引用。这使得Java程序员不需要关心内存管理，因为Java虚拟机（JVM）会自动管理对象的创建和销毁。"></a><code>Java中的引用</code>不是直接的内存地址，而是对实际对象的间接引用。这使得Java程序员不需要关心内存管理，因为Java虚拟机（JVM）会自动管理对象的创建和销毁。</h3><p>与C++中的指针不同。Java中的引用是一种高级抽象，它隐藏了对象的底层内存地址和操作，使得程序员不需要关心内存管理。<br>Java中的引用本质上是一个抽象的句柄（handle），它不直接指向对象的内存地址，而是指向Java虚拟机（JVM）内部的数据结构，该数据结构包含了对象的信息以及对象在堆内存中的位置。这种抽象层级使Java更安全，因为程序员无法直接操纵内存地址，从而避免了许多常见的内存错误，如指针溢出和内存泄漏。</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String 被声明为 final，因此它不可被继承。内部使用 char 数组存储数据，该数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String类 不可变。</p>
<ul>
<li>String Pool ：如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。</li>
<li>String 不可变，StringBuffer 和 StringBuilder 可变。<br>String 不可变，因此是线程安全的，StringBuilder 不是线程安全的，StringBuffer 是线程安全的，内部使用 synchronized 进行同步<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2);           <span class="comment">// false; s1 和 s2 采用 new String() 的方式新建了两个不同对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1.intern();</span><br><span class="line">System.out.println(s1.intern() == s3);  <span class="comment">// true; s3 是通过 s1.intern() 方法 首先把 s1 引用的对象放到 String Pool(字符串常量池)中，然后返回这个对象引用。因此 s3 和 s1 引用的是同一个字符串常量池的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">System.out.println(s4 == s5);           <span class="comment">// true; 采用 &quot;bbb&quot; 这种使用双引号的形式创建字符串实例，会自动地将新建的对象放入 String Pool 中</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>


<h1 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h1><p>在Java中，数据的存储方式涉及到内存的不同区域，主要包括堆内存和栈内存。</p>
<ol>
<li><strong>栈内存（Stack Memory）</strong>：<ul>
<li>存储特点：栈内存用于存储局部变量（方法内部定义的变量）和方法调用的执行上下文（包括方法的参数、返回地址等信息）。每个线程都有自己的栈内存，用于管理方法调用和局部变量的生命周期。</li>
<li>生命周期：局部变量的生命周期与方法的执行周期相关联。当方法被调用时，会在栈内存中为局部变量分配内存，当方法执行完毕时，栈内存会自动释放局部变量的内存。</li>
<li>线程安全：栈内存是线程私有的，因此它是线程安全的。不同线程的栈内存互相独立，不会发生竞态条件。</li>
</ul>
</li>
<li><strong>堆内存（Heap Memory）</strong>：<ul>
<li>存储特点：堆内存用于存储对象和数组等引用数据类型。是所有线程共享的内存区域，用于管理动态分配的对象的生命周期。</li>
<li>生命周期：对象在堆内存中的生命周期不受方法调用的限制。对象在被创建时分配内存，在不再被引用时会被垃圾回收器自动回收。</li>
<li>线程安全：由于堆内存是共享的，需要特别注意多线程访问的同步问题。Java提供了一些机制来确保堆内存中的数据安全，如 synchronized关键字和 java.util.concurrent 包中的工具类。</li>
</ul>
</li>
<li><strong>数据存储示例</strong>：<ul>
<li>当创建一个对象时，对象的引用存储在栈内存中，而对象的实际数据存储在堆内存中。例如，Person person &#x3D; new Person(); <ol>
<li>在堆内存中，会为Person对象分配内存空间，这个对象包含了Person类中定义的所有成员变量（属性）。例如，如果Person类有一个名为name的成员变量，那么堆内存中的Person对象将包含一个用于存储name属性值的内存位置。堆内存中的对象是独立的，每个new Person()创建一个新的对象，其数据在堆内存中不会重叠。</li>
<li>在栈内存中，会创建一个名为person的引用变量，这个引用变量存储了指向堆内存中Person对象的地址。也就是说，栈内存中的person变量实际上存储了对堆内存中Person对象的引用。当你访问person时，实际上是通过栈内存中的引用找到堆内存中的对象，然后可以操作对象的属性和方法。</li>
</ol>
</li>
<li>局部变量（例如方法中的局部变量）的值和引用都存储在栈内存中。</li>
<li>数组的引用存储在栈内存中，而数组的元素（对象引用或基本数据类型）存储在堆内存中。</li>
<li>静态变量（<code>static</code>关键字修饰的变量）存储在方法区（在JVM规范中称为永久代）。</li>
</ul>
</li>
<li>缓存池<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line">System.out.println(x == y);    <span class="comment">// false; new Integer() 每次都会新建一个对象</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">z</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">k</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">System.out.println(z == k);    <span class="comment">// true; valueOf()会使用缓存池中的对象，多次调用会取得同一个对象的引用</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line">System.out.println(m == n);    <span class="comment">// true; 编译器会在缓冲池范围内的基本类型自动装箱过程调用 valueOf() </span></span><br><span class="line"><span class="comment">// 因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>在Java中，方法参数的传递方式是<strong>按值传递</strong>，而不是引用传递。这意味着当你将参数传递给方法时，实际上是将参数的值传递给了方法，而不是参数本身。这包括基本数据类型和对象引用。<br><strong>1、基本数据类型：</strong> 作为参数传递的是该数据的副本。任何在方法内部对参数值的修改都不会影响到原始数据。<br><strong>2、对象引用：</strong> 对象引用也是按值传递的，但需要理解的是对象引用指的是对象在内存中的地址（间接引用，非直接地址）。当你将一个对象作为参数传递给方法时，传递的是对象引用的副本，而不是对象本身。这意味着在方法内部可以修改对象的状态，但不能改变对象引用指向的内存地址。</p>
<h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><ul>
<li>“2.5” 字面量属于 double 类型，不能直接将 2.5 直接赋值给 float 变量，因为Java 不能隐式执行向下转型，这会使得精度降低。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">2.5f</span>;  <span class="comment">// 错误写法：float f = 2.5;  </span></span><br></pre></td></tr></table></figure></li>
<li>字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地 下转型 。但是使用 +&#x3D; 运算符可以执行隐式类型转换。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 不能 s1 = s1 + 1;</span></span><br><span class="line">s1 += <span class="number">1</span>;       <span class="comment">// 相当于 s1 = (short) (s1 + 1);</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="有-无符号数，原-反-补码"><a href="#有-无符号数，原-反-补码" class="headerlink" title="有&#x2F;无符号数，原&#x2F;反&#x2F;补码"></a>有&#x2F;无符号数，原&#x2F;反&#x2F;补码</h3><p>在 Java 中，所有的整数类型都是有符号的。Java中并没有内置的无符号整数类型；如果真的需要，可以使用大整数类 <code>BigInteger</code>。<br>无符号整数通常用于表示大范围正整数值，以及位运算和处理原始数据。它们可以扩展表示的范围，因为不需要一位来表示符号。<br><strong>原码</strong>是最简单的表示形式，其中最高位表示符号（0正数，1负数），其余位表示数值的大小。例如，+3原码为0011，-3原码为1011。<br><strong>反码</strong>是对原码的符号位以外的位取反得到的结果。正数的反码与其原码相同，负数的反码是其原码除符号位外取反。<br><strong>补码</strong>是计算机中最常用的表示方式。补码的计算方法是对反码加1。正数的补码与其原码相同，负数的补码是其反码加1。<br><strong>在Java中，整数类型（如byte、short、int、long）使用补码来表示有符号整数</strong>。这种表示方式使得负数的加法和减法运算可以与正数的运算使用同一套算法来执行，简化了计算机中的运算。</p>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><ul>
<li>在 Java 中，位运算是操作二进制位的一种操作，它们可以用来执行诸如位移、与、或、非等操作。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>, b = <span class="number">3</span>;  <span class="comment">// 二进制表示：0101, 0011</span></span><br><span class="line"><span class="type">int</span> <span class="variable">andResult</span> <span class="operator">=</span> a &amp; b;  <span class="comment">// 0101 &amp; 0011 = 0001，结果为 1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">orResult</span> <span class="operator">=</span> a | b;   <span class="comment">// 0101 | 0011 = 0111，结果为 7</span></span><br><span class="line"><span class="type">int</span> <span class="variable">xorResult</span> <span class="operator">=</span> a ^ b;  <span class="comment">// 0101 ^ 0011 = 0110，结果为 6</span></span><br><span class="line"><span class="type">int</span> <span class="variable">complementA</span> <span class="operator">=</span> ~a;   <span class="comment">// ~0101 = 1010（补码表示），结果为 -6（-6的八位补码就是1111 1010）</span></span><br><span class="line"><span class="type">int</span> <span class="variable">leftShift</span> <span class="operator">=</span> a &lt;&lt; <span class="number">1</span>;            <span class="comment">// 0101 左移 1 位 = 1010，结果为 10</span></span><br><span class="line"><span class="type">int</span> <span class="variable">rightShift</span> <span class="operator">=</span> a &gt;&gt; <span class="number">1</span>;           <span class="comment">// 0101 右移 1 位 = 0010，结果为 2（使用符号位填充空位）</span></span><br><span class="line"><span class="type">int</span> <span class="variable">unsignedRightShift</span> <span class="operator">=</span> a &gt;&gt;&gt; <span class="number">1</span>;  <span class="comment">// 0101 无符号右移 1 位 = 0010，结果为 2（使用 0 填充空位）</span></span><br></pre></td></tr></table></figure></li>
<li>在 Java 中，十六进制表示使用前缀 <code>0x</code> 或者 <code>0X</code> 来标识一个十六进制数。<br>使用位运算符时：Java 内部会将这些十六进制数转换为对应的二进制形式，然后执行位运算操作，最后转换回十六进制的结果。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">hex1</span> <span class="operator">=</span> <span class="number">0xA</span>, hex2 = <span class="number">0x7</span>;          <span class="comment">// 十六进制数 A 对应十进制数 10, 十六进制数 7 对应十进制数 7</span></span><br><span class="line"><span class="type">int</span> <span class="variable">andResult</span> <span class="operator">=</span> hex1 &amp; hex2;         <span class="comment">// 十六进制数 A &amp; 7 = 1010 &amp; 0111 = 0010，结果为 2</span></span><br><span class="line"><span class="type">int</span> <span class="variable">complementHex1</span> <span class="operator">=</span> ~hex1;          <span class="comment">// ~1010 = 0101（补码表示），结果为 -11</span></span><br><span class="line"><span class="type">int</span> <span class="variable">rightShift</span> <span class="operator">=</span> hex1 &gt;&gt; <span class="number">1</span>;          <span class="comment">// 十六进制数 A 右移 1 位 = 1010 右移 1 位 = 0101，结果为 5</span></span><br><span class="line"><span class="type">int</span> <span class="variable">unsignedRightShift</span> <span class="operator">=</span> hex1 &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// A 无符号右移 1 位 = 1010 无符号右移 1 位 = 0101，结果为 5</span></span><br></pre></td></tr></table></figure></li>
<li><code>n &amp; (n−1)</code>，把 n 的二进制位中的最低位的 1 变为 0。</li>
<li><strong>颠倒</strong>给定的 32 位无符号整数 n 的二进制位<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span> &amp;&amp; n != <span class="number">0</span>; i++) &#123;</span><br><span class="line">    ans = ans | (n &amp; <span class="number">1</span>) &lt;&lt; (<span class="number">31</span> - i);</span><br><span class="line">    n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>

<h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><ol>
<li><strong>类（Class）：</strong> 类是对象的模板，它定义了对象的属性（成员变量）和行为（方法）。类是一种抽象的概念，描述了一类事物的共同特征。在Java中，类是一种引用数据类型。</li>
<li><strong>对象（Object）：</strong> 对象是类的实例，是具体的、实际存在的数据。每个对象都有自己的状态（成员变量的值）和行为（方法的调用)</li>
</ol>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul>
<li><strong>创建对象实例：</strong> 使用关键字 <code>new</code> 可以创建一个类的对象。例如：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">myObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br></pre></td></tr></table></figure></li>
<li><strong>通过反射：</strong> 使用 Java 的反射机制可以在运行时获取类的信息，创建对象实例。例如：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">myObject</span> <span class="operator">=</span> (MyClass) clazz.newInstance();</span><br></pre></td></tr></table></figure></li>
<li><strong>通过工厂方法：</strong> 有时候，对象的创建可能通过工厂方法，例如静态方法等来实现。</li>
<li>通过new创建<strong>实例对象</strong>demo，放在堆内存上；然后再main方法的栈帧中存放一个局部变量，存放了demo对象在堆上的地址，即建立起一个<strong>引用</strong>关系。将局部变量置null后，引用就不存在了，堆上的实例对象demo就可以回收了。<img src="https://github.com/leo710aka/bk/blob/main/java.png?raw=true" width="700" height="300" alt=""></li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一旦对象被创建，可以通过其引用调用其属性和方法</span></span><br><span class="line">myObject.setSomeProperty(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">propertyValue</span> <span class="operator">=</span> myObject.getSomeProperty();</span><br></pre></td></tr></table></figure>

<h3 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h3><ol>
<li><p><strong>对象的回收：</strong> Java虚拟机通过垃圾回收器（Garbage Collector）来自动回收不再被引用的对象。垃圾回收器会定期检查程序中的对象，识别哪些对象没有被任何引用指向，然后释放它们占用的内存。这个过程是自动的，开发者无需手动管理大部分对象的内存。<br>在某些情况下，可以通过手动设置对象引用为<code>null</code>来提示垃圾回收器回收对象。但这通常不是必要的，因为现代的垃圾回收器在大多数情况下能够很好地管理内存。<br>对象的生命周期从创建开始，直到没有任何引用指向它时结束。垃圾回收器负责在对象不再被引用时将其销毁。</p>
</li>
<li><p><strong>类的回收：</strong> 在Java中，类的回收通常不是显式的操作。类加载和卸载是由类加载器（ClassLoader）来管理的。当一个类不再被任何对象引用，并且ClassLoader不再需要这个类时，该类可能会被卸载。在标准的Java应用程序中，类的卸载通常不是很常见，因为大多数类在整个应用程序的生命周期内都是可见的。<br>需要注意的是，类的卸载是Java虚拟机实现的一个可选特性，不是所有的Java虚拟机都支持类的卸载。类的卸载通常发生在特定的环境中，比如一些动态生成和卸载类的场景。<br>总体而言，Java虚拟机通过垃圾回收器自动管理对象的内存，而类的加载和卸载通常由类加载器来处理。这种自动化的内存管理减轻了开发者的负担，使得Java程序更容易编写和维护。</p>
</li>
</ol>
<hr>

<h1 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h1><h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><p>Java 中有三个访问权限修饰符: private、protected 以及 public。可以对类或类中的成员(字段以及方法)加上访问修饰符，如果不加访问修饰符，表示包级可见（<code>default</code>，介于private和protected之间）。<br><code>private</code>：私有访问修饰符。被 private 修饰的成员（字段、方法、内部类等）仅对定义它们的类可见。这意味着这些成员只能在同一个类内部访问，对于类的外部（其他类）是不可见的。<br><code>protected</code>：受保护的访问修饰符。被 protected 修饰的成员对于定义它们的类、同一包内的其他类以及子类可见。在不同包中的类无法访问受保护成员。<br><code>public</code>：公共访问修饰符。被 public 修饰的成员对于所有类都是可见的，无论是同一包内还是不同包中的类，都可以访问 public 成员。</p>
<h3 id="extend-与-implement"><a href="#extend-与-implement" class="headerlink" title="extend 与 implement"></a>extend 与 implement</h3><p><strong><code>extend</code>（扩展）</strong>：使用于类之间的关系。用于创建类的子类（子类继承父类）。子类可以继承父类的属性和方法。 一个类只能<code>extend</code>一个类，即Java是单继承的，但是可以通过接口实现来弥补这一不足。<br><strong><code>implement</code>（实现）</strong>：使用于接口与类之间的关系。 用于让类实现一个或多个接口，<code>implement</code>多个接口，实现多继承的效果。 <strong>类实现接口时，需要提供接口中定义的所有方法的具体实现。</strong></p>
<h3 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h3><p>抽象类和抽象方法都使用 abstract 关键字进行声明。抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。<br>抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。<br><strong>接口是抽象类的延伸</strong>，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。接口的成员(字段 + 方法)默认都是 public 的，并且不允许定义为 private 或者 protected。接口的字段默认都是 static 和 final 的。</p>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><ul>
<li>访问父类的构造函数: 可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。</li>
<li>访问父类的成员: 如果子类重写了父类的中某个方法的实现，可以通过使用 super 关键字来引用父类的方法实现。</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperExample</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SuperExample</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;                <span class="built_in">this</span>.x = x;     <span class="built_in">this</span>.y = y;     &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;                  System.out.println(<span class="string">&quot;SuperExample.func()&quot;</span>);       &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperExtendExample</span> <span class="keyword">extends</span> <span class="title class_">SuperExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> z;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SuperExtendExample</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;   <span class="built_in">super</span>(x, y);    <span class="built_in">this</span>.z = z;     &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;  <span class="built_in">super</span>.func();  System.out.println(<span class="string">&quot;SuperExtendExample.func()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">SuperExample</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SuperExtendExample</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">e.func();  <span class="comment">// 结果：SuperExample.func() SuperExtendExample.func()</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="重载与重写"><a href="#重载与重写" class="headerlink" title="重载与重写"></a>重载与重写</h3><ol>
<li>重载(Overload)存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。应该注意的是，返回值不同，其它都相同不算是重载。</li>
<li>重写(Override)存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。为了满足里式替换原则，重写有以下两个限制:子类方法的访问权限必须大于等于父类方法；子类方法的返回类型必须是父类方法返回类型或为其子类型。使用 @Override 注解，可以让编译器帮忙检查是否满足上面的两个限制条件。</li>
</ol>
<hr>

<h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><p>Java标准库包含多个类和函数，提供了许多基本的工具和功能，包括但不限于：<br>1、<code>java.lang</code> - 包含Java的基础类，例如<code>String</code>、<code>Object</code>、<code>System</code>等。这个包是默认导入的，不需要手动引入。<br>2、<code>java.util</code> - 提供集合框架、日期时间工具、随机数生成器等。<br>3、<code>java.io</code> - 包含用于进行输入和输出的类和接口，例如<code>File</code>、<code>InputStream</code>、<code>OutputStream</code>等。<br>4、<code>java.net</code> - 提供了网络相关的类，比如<code>URL</code>、<code>URLConnection</code>等。<br>5、<code>java.math</code> - 包含用于数学计算的类，例如<code>BigInteger</code>、<code>BigDecimal</code>等。<br>6、<code>java.nio</code> - 提供了新的I&#x2F;O类，支持非阻塞I&#x2F;O、内存映射文件等。<br>7、<code>java.util.concurrent</code> - 包含用于并发编程的实用工具和框架。<br>8、<code>java.awt</code> 和 <code>javax.swing</code> - 提供了GUI开发相关的类。<br>大部分情况下，这些库中的类和函数默认可用，无需手动引入。然而，有一些更特定或较为不常用的类可能需要显式地引入相应的包。</p>
<h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 保存两位小数；import java.text.DecimalFormat;（text在标准库中，通常不需要手动引入）</span></span><br><span class="line"><span class="type">double</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">123.45678</span>;</span><br><span class="line"><span class="type">DecimalFormat</span> <span class="variable">decimalFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;#.##&quot;</span>); <span class="comment">// 创建 DecimalFormat 对象并指定格式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">formattedNumber</span> <span class="operator">=</span> decimalFormat.format(number);   <span class="comment">// 将浮点数格式化为指定格式的字符串</span></span><br><span class="line"><span class="comment">// 2. 比大小：方法 java.lang.Math 中；小 Math.min()</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Math.max(<span class="number">647</span>, <span class="number">582</span>);</span><br><span class="line"><span class="comment">// 3. 随机数：生成范围介于 0（包括）和指定边界（不包括）之间的随机整数</span></span><br><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();                       <span class="comment">// 创建 Random 对象</span></span><br><span class="line"><span class="type">int</span> <span class="variable">randomNumber</span> <span class="operator">=</span> random.nextInt();                <span class="comment">// 生成整数范围在 int 类型的取值范围内</span></span><br><span class="line"><span class="type">int</span> <span class="variable">randomInRange</span> <span class="operator">=</span> random.nextInt(<span class="number">10</span> - <span class="number">5</span> + <span class="number">1</span>) + <span class="number">5</span>; <span class="comment">// 生成整数范围 5 - 10</span></span><br><span class="line"><span class="type">double</span> <span class="variable">randomDouble</span> <span class="operator">=</span> random.nextDouble();          <span class="comment">// 生成范围在 [0, 1) 之间的随机小数</span></span><br><span class="line"><span class="comment">// 4. 二进制，十六进制</span></span><br><span class="line"><span class="type">String</span> <span class="variable">binaryString</span> <span class="operator">=</span> Integer.toBinaryString(<span class="number">10</span>);      <span class="comment">// 整数表示为二进制字符串：1010</span></span><br><span class="line"><span class="type">String</span> <span class="variable">hexString</span> <span class="operator">=</span> Integer.toHexString(<span class="number">20</span>);            <span class="comment">// 整数表示为十六进制字符串：14</span></span><br><span class="line"><span class="type">int</span> <span class="variable">decimalNumber</span> <span class="operator">=</span> Integer.parseInt(binaryString, <span class="number">2</span>); <span class="comment">// 二进制字符串转整数：10</span></span><br><span class="line"><span class="type">int</span> <span class="variable">decimalNumber</span> <span class="operator">=</span> Integer.parseInt(hexString, <span class="number">16</span>);   <span class="comment">// 十六进制字符串转整数：20</span></span><br></pre></td></tr></table></figure>


<h2 id="Object-通用方法"><a href="#Object-通用方法" class="headerlink" title="Object 通用方法"></a>Object 通用方法</h2><p>在Java中，<code>Object</code>是所有类的基类。它是Java类继承层次结构的根，因此每个Java类都直接或间接地继承自<code>Object</code>类。<code>Object</code>类位于<code>java.lang</code>包中，这意味着它不需要显式导入就可以在Java程序中使用。</p>
<ul>
<li><code>java.lang</code>包是java语言的核心，提供基础类，包括基本Object类、Class类、String类、基本类型的包装类、基本的数学类等。</li>
<li><code>Object</code>类定义了一些基本的方法，这些方法可以被所有的Java对象继承和使用。其中一些重要的方法包括： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()     <span class="comment">// 返回对象的运行时类（`Class`对象）。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>                <span class="comment">// 返回对象的哈希码值。它通常与`equals`方法一起使用，以便在使用哈希表等数据结构时能够快速查找对象。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>           <span class="comment">// 用于比较两个对象是否相等。默认情况下，它比较的是对象的内存地址，但可以在子类中重写以实现自定义的相等性比较。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException    <span class="comment">// 用于创建对象的浅拷贝。需要注意的是，为了使对象可克隆，子类需要实现`Cloneable`接口并重写`clone`方法。</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>                    <span class="comment">// 返回对象的字符串表示。默认情况下，它返回一个由类名和对象的哈希码组成的字符串，但可以在子类中重写以提供更有意义的字符串表示。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>           <span class="comment">// 用于多线程同步的方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException   <span class="comment">// 使线程等待直到被通知。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;&#125;     <span class="comment">// 在对象被垃圾回收之前调用的方法。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><ul>
<li>equals() 与 &#x3D;&#x3D; 对于基本类型，&#x3D;&#x3D; 判断两个值是否相等，基本类型没有 equals() 方法。<br>对于引用类型，&#x3D;&#x3D; 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line">System.out.println(x == y);      <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><ol>
<li>cloneable：clone() 是 Object 的 protected 方法而非 public，一个类不显式去重写，其它类就不能直接调用该类实例的 clone()。</li>
<li>浅拷贝：拷贝对象和原始对象的引用类型引用同一个对象。</li>
<li>深拷贝：拷贝对象和原始对象的引用类型引用不同对象。</li>
<li>clone() 的替代方案：使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</li>
</ol>
<hr>

<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul>
<li>Throwable 可以用来表示任何可以作为异常抛出的类，分为两种: <strong>Error</strong> 和 <strong>Exception</strong>。<br>  其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种:<ul>
<li>受检异常 : 需要用 try…catch… 语句捕获并进行处理，并且可以从异常中恢复；</li>
<li>非受检异常 : 是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复<br><img src="https://pdai.tech/images/pics/PPjwP.png"></li>
</ul>
</li>
</ul>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>Java反射是一种强大的编程技术，允许在运行时检查、探索和操作类、对象、字段、方法以及其他成员。反射使你可以动态地创建对象、调用方法、获取和设置字段值，以及执行其他与类和对象相关的操作。</p>
<ul>
<li>每个类都有一个 Class 对象，包含与类有关的信息。当编译一个新类时会产生一个同名的<code>.class文件</code>，其内容保存着 Class 对象。</li>
<li>类加载相当于 Class 对象的加载。类在第一次使用时才动态加载到 JVM 中，可以使用 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> 这种方式来控制类的加载，该方法会返回一个 Class 对象。</li>
<li>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至编译时期该类的 .class 不存在也可以加载进来。</li>
<li>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类:<ul>
<li>Field : 可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li>
<li>Method : 可以使用 invoke() 方法调用与 Method 对象关联的方法；</li>
<li>Constructor : 可以用 Constructor 创建新的对象。</li>
</ul>
</li>
<li><strong>Class类</strong>：Java反射的核心类是<code>java.lang.Class</code>。每个类都有一个与之相关的<code>Class</code>对象，你可以使用这个<code>Class</code>对象来获取关于类的信息。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类的`Class`对象</span></span><br><span class="line">Class&lt;?&gt; myClass = MyClass.class; <span class="comment">// 通过类名</span></span><br><span class="line">Class&lt;?&gt; myClass = obj.getClass();  <span class="comment">// 通过对象</span></span><br><span class="line">Class&lt;?&gt; myClass = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>); <span class="comment">// 通过类的全名</span></span><br><span class="line"><span class="comment">// 获取有关类的信息</span></span><br><span class="line"><span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> myClass.getName(); <span class="comment">// 获取类名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">packageName</span> <span class="operator">=</span> myClass.getPackage().getName(); <span class="comment">// 获取包名</span></span><br><span class="line">Class&lt;?&gt; superClass = myClass.getSuperclass(); <span class="comment">// 获取父类</span></span><br><span class="line">Class&lt;?&gt;[] interfaces = myClass.getInterfaces(); <span class="comment">// 获取实现的接口</span></span><br><span class="line">Field[] fields = myClass.getDeclaredFields(); <span class="comment">// 获取所有字段</span></span><br><span class="line">Method[] methods = myClass.getDeclaredMethods(); <span class="comment">// 获取所有方法</span></span><br></pre></td></tr></table></figure></li>
<li><strong>实例化对象</strong>：通过反射，你可以动态地创建对象。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; myClass = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> myClass.newInstance(); <span class="comment">// 创建对象，需要无参构造函数</span></span><br><span class="line"><span class="comment">// 使用反射来获取、设置对象的字段值</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> myClass.getDeclaredField(<span class="string">&quot;fieldName&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>); <span class="comment">// 设置字段可访问</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> field.get(obj); <span class="comment">// 获取字段值</span></span><br><span class="line">field.set(obj, newValue); <span class="comment">// 设置字段值</span></span><br><span class="line"><span class="comment">// 反射允许你调用对象的方法。例如：</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> myClass.getDeclaredMethod(<span class="string">&quot;methodName&quot;</span>, param1Type, param2Type);</span><br><span class="line">method.setAccessible(<span class="literal">true</span>); <span class="comment">// 设置方法可访问</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(obj, arg1, arg2); <span class="comment">// 调用方法</span></span><br></pre></td></tr></table></figure></li>
<li><strong>数组与泛型</strong>：通过反射，你可以创建数组、获取数组元素的类型信息，以及处理泛型信息。</li>
<li><strong>代理</strong>：Java反射还可用于创建动态代理，这是一种强大的技术，允许你创建实现特定接口的代理类以在运行时拦截和处理方法调用。</li>
<li><strong>限制</strong>：尽管反射提供了强大的能力，但也有一些限制和性能开销。使用时需要小心处理异常、性能、访问控制等方面的问题。</li>
</ul>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ul>
<li>泛型是 Java 中的一个核心特性，有助于提高代码的可重用性和类型安全性。</li>
<li>泛型的主要目的是参数化类型，允许你在类、接口、方法中使用类型参数。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T t;  <span class="comment">// T stands for &quot;Type&quot;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T t)</span> &#123; <span class="built_in">this</span>.t = t; &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> t; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChildBox</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 子类继承父类的泛型类型参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>泛型通配符：Java中有通配符类型，允许你在不知道具体类型的情况下使用泛型。通配符包括?符号。<br>当你使用通配符作为方法参数时，可能需要捕获通配符以使用它。这可以通过在方法参数中使用?来实现。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processList</span><span class="params">(List&lt;?&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Object obj : list) &#123;        <span class="comment">// 处理每个元素    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>泛型上下界：你可以使用通配符来定义类型的上下界。例如，&lt;? extends Number&gt;表示类型必须是Number或其子类。&lt;? super Integer&gt;表示类型必须是Integer或其父类。</li>
<li>类型擦除：Java泛型通过类型擦除来实现。这意味着在编译时，泛型类型信息会被擦除，而在运行时，Java虚拟机将使用原始类型。这可能会导致一些限制，例如无法创建泛型数组。</li>
</ul>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><ul>
<li>Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。<a target="_blank" rel="noopener" href="https://pdai.tech/md/java/basic/java-basic-x-annotation.html">https://pdai.tech/md/java/basic/java-basic-x-annotation.html</a></li>
<li><strong>Spring框架中的注解</strong> 本质上是一种元数据，用于为应用程序的组件（例如类、方法、字段等）提供附加的信息，以指导Spring容器在应用程序运行时如何处理这些组件。这些注解告诉Spring容器如何创建、初始化、配置和管理这些组件，以及它们之间的关系。</li>
</ul>
<h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="??Lambda 表达式"></a>??Lambda 表达式</h2><p>Lambda 表达式提供了一种简洁、清晰的语法，允许以更为函数式的方式编写代码。<br>Lambda 的引入使得代码变得更加简洁，尤其在使用函数式接口（只有一个抽象方法的接口）时，可以直接传递 Lambda 表达式，而不再需要传递匿名内部类的实例。Lambda 表达式在处理集合、并发编程、事件处理等场景中广泛应用，它是 Java 8 引入的一个重要特性，使得 Java 语言更好地支持函数式编程风格。</p>
<ul>
<li>Lambda 表达式主要用于定义内联的、匿名的函数。它是一个函数式接口的实例，即只有一个抽象方法的接口。基本语法如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `parameters` 指定了 Lambda 表达式的参数，`-&gt;` 是 Lambda 操作符，</span></span><br><span class="line"><span class="comment">// `expression` 或 `&#123; statements; &#125;` 指定了 Lambda 表达式的主体。</span></span><br><span class="line">(parameters) -&gt; expression</span><br><span class="line">(parameters) -&gt; &#123; statements; &#125;</span><br><span class="line"><span class="comment">// 1. 一个简单的例子，计算两个数的和：</span></span><br><span class="line">(<span class="type">int</span> a, <span class="type">int</span> b) -&gt; a + b</span><br><span class="line"><span class="comment">// 2. 遍历列表并打印每个元素：</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>);</span><br><span class="line">list.forEach(s -&gt; System.out.println(s));</span><br><span class="line"><span class="comment">// 3. 使用 `Runnable` 接口创建一个线程：</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;Hello, Lambda!&quot;</span>)).start();</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Java-各版本的新特性"><a href="#Java-各版本的新特性" class="headerlink" title="Java 各版本的新特性"></a>Java 各版本的新特性</h2><p>New highlights in Java SE 8<br>Lambda Expressions，Pipelines and Streams，Date and Time API，Default Methods，Type Annotations，Nashhorn JavaScript Engine，Concurrent Accumulators，Parallel operations，PermGen Error Removed<br>New highlights in Java SE 7<br>Strings in Switch Statement，Type Inference for Generic Instance Creation，Multiple Exception Handling，Support for Dynamic Languages，Try with Resources，Java nio Package，Binary Literals,Underscore in literals，Diamond Syntax</p>
<h2 id="Java-与-C-的区别"><a href="#Java-与-C-的区别" class="headerlink" title="Java 与 C++ 的区别"></a>Java 与 C++ 的区别</h2><ul>
<li>Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。</li>
<li>Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。</li>
<li>Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。</li>
<li>Java 支持自动垃圾回收，而 C++ 需要手动回收。</li>
<li>Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。</li>
<li>Java 不支持操作符重载，而 C++ 可以。虽然可以对两个 String 对象支持加法运算，但是这是语言内置支持的操作，非操作符重载</li>
<li>Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。</li>
<li>Java 不支持条件编译，C++ 通过 #ifdef #ifndef 等预处理命令从而实现条件编译。</li>
</ul>
<h2 id="知识体系"><a href="#知识体系" class="headerlink" title="知识体系"></a>知识体系</h2><p>Java全栈知识体系：<a target="_blank" rel="noopener" href="https://pdai.tech/">https://pdai.tech/</a><br><img src="https://pdai.tech/images/java_basic.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/01/Java%E5%9F%BA%E7%A1%80/" data-id="clr24omiz000bswv5hb4mc4u5" data-title="Java 基础" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Java后端" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/31/Java%E5%90%8E%E7%AB%AF/" class="article-date">
  <time class="dt-published" datetime="2021-08-31T03:49:42.000Z" itemprop="datePublished">2021-08-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/31/Java%E5%90%8E%E7%AB%AF/">java 后端开发 工程师</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h2><ul>
<li>Spring Boot： 进一步简化Spring</li>
<li>Spring：轻量级框架，用于构建企业级 Java 应用程序。<br>Spring MVC： 处理浏览器请求， 三层架构， MVC模式三层 集体解决表现层的问题<br>MyBatis： 处理访问数据库</li>
<li>Redis<strong>【6379】</strong>： 操作内存的数据库<br>Kafka<strong>【9092】</strong>： 消息队列服务器<br>Elasticsearch<strong>【9200】</strong>： 搜索引擎</li>
<li>Spring Security，Spring Actuator</li>
</ul>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul>
<li>构建工具：Apache Maven</li>
<li>集成开发工具：IntelliJ IDEA</li>
<li>数据库：MySQL、Redis</li>
<li>应用服务器：Apache Tomcat<strong>【8080】</strong></li>
<li>版本控制工具：Git</li>
</ul>
<h2 id="Apache-Maven"><a href="#Apache-Maven" class="headerlink" title="Apache Maven"></a>Apache Maven</h2><ul>
<li>可以帮助我们构建项目、管理项目中的jar包</li>
<li>Maven仓库：默认位置 ~&#x2F;.m2&#x2F;repository，远程仓库，中央仓库，镜像仓库，私服仓库<br><strong>在本机上 “D:\apache-maven-3.6.1”(主路径) 另外配置了一个maven仓库</strong>，避免占C盘空间<br>对应的<strong>用户配置文件为 “D:\apache-maven-3.6.1\conf\settings.xml”，本地仓库为 “D:\apache-maven-3.6.1\mvn_resp”</strong></li>
<li>在 IntelliJ IDEA 中配置maven仓库：”File” &gt; “Settings” &gt; “Build, Execution, Deployment” &gt; “Build Tools” &gt; “Maven”，配置maven主路径、用户设置文件和本地仓库。</li>
<li>在 https:\mavenrepository.com 查找需要的jar包。</li>
<li>Maven 是一个强大的构建工具，它可以执行各种命令来管理项目的构建、依赖、测试等方面的任务。<br>以下是一些常用的Maven指令，进入项目根目录命令行终端执行：(当然也可以直接在idea点击按钮执行)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mvn clean            <span class="comment"># 清除项目的目标目录，删除编译生成的文件。</span></span><br><span class="line">mvn compile          <span class="comment"># 编译项目中的Java源代码文件，并将编译结果放置在项目的目标目录(通常是target目录)中</span></span><br><span class="line">mvn <span class="built_in">test</span>             <span class="comment"># 运行项目的单元测试。</span></span><br><span class="line">mvn package          <span class="comment"># 将项目打包为可执行的JAR或WAR文件，通常用于构建最终的可部署应用程序。</span></span><br><span class="line">mvn install          <span class="comment"># 将项目构建输出的JAR或WAR文件安装到本地Maven仓库，以便其他项目可以引用它作为依赖。</span></span><br><span class="line">mvn deploy           <span class="comment"># 将项目构建输出的JAR或WAR文件部署到远程仓库，通常用于共享依赖。</span></span><br><span class="line">mvn clean install    <span class="comment"># 用于先清除项目目录，然后执行安装操作。（引入pom中新加的dependence）</span></span><br><span class="line">mvn clean package    <span class="comment"># 用于先清除项目目录，然后执行打包操作。</span></span><br></pre></td></tr></table></figure></li>
<li><strong>JAR</strong>（Java Archive）是Java平台中用于打包和分发Java类和相关资源的文件格式。它是一种压缩格式，通常包含Java类文件（.class文件），资源文件，清单文件（Manifest），以及其他可以用于Java应用程序的元数据。<br><strong>WAR</strong>（Web Application Archive）文件是一种Java Web应用程序的打包格式，通常用于部署Web应用程序到Java EE应用服务器，如Tomcat、WebSphere、或JBoss等。是一种压缩文件，通常以.war扩展名结尾，它包含了用于部署和运行Web应用程序的各种资源。</li>
</ul>
<h2 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h2><ul>
<li>核心作用：起步依赖、自动配置、端点监控</li>
<li>在 <a target="_blank" rel="noopener" href="https://start.spring.io/">https://start.spring.io</a> 创建一个springboot项目</li>
<li><strong>Spring</strong>（Spring Framework）是一个开源的轻量级Java企业应用程序开发框架，旨在简化Java应用程序的开发。Spring本身并不直接管理Maven依赖，而是依赖Maven作为构建工具来管理项目中的依赖关系</li>
<li><strong>Spring Boot</strong> 是 Spring 框架的一个扩展，旨在简化 Spring 应用程序的开发和部署。引入了 Starter 依赖的概念，这些 Starter是预配置的依赖项集合，用于快速启动特定类型的应用程序（例如，spring-boot-starter-web 是用于构建 Web 应用程序的 Starter 依赖，它包含了 Spring MVC、Tomcat 等依赖）;可以根据项目需求选择性地引入 Starter 依赖，而不必手动添加一堆依赖项。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;    <span class="comment">// 在 pom.xml 中配置需要的各种 spring-boot-starter 包</span></span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li>以jar包内置tomcat</li>
</ul>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><ul>
<li>Spring全家桶：Spring Framework, Spring Boot, Spring Cloud 微服务, Spring Cloud Data Flow 客户端</li>
<li>Spring Framework：<br>Spring Core - IoC, AOP 管理一切<br>Spring Data Access - Transactions, Spring MyBatis<br>Web Servlet - Spring MVC<br>Integration - Email, Scheduling, AMQP, Security</li>
<li><strong>for more -&gt;</strong> <a target="_blank" rel="noopener" href="https://leo710aka.github.io/2021/09/11/Spring/">https://leo710aka.github.io/2021/09/11/Spring/</a></li>
</ul>
<h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><ul>
<li>三层架构：表现层、业务层、数据访问层</li>
<li>MVC：解决表现层的问题（Model：模型层 - View：视图层 - Controller：控制层）</li>
<li>HTTP：用于传输HTML等内容的应用层协议，规定了浏览器和服务器(或本地tomcat)之间如何通信以及通信时的数据格式。</li>
<li>核心组件 - 前端控制器：DispatcherServlet，控制整个MVC</li>
<li>Thymeleaf（View层）：模板文件 + Model -&gt; 模板引擎（Thymeleaf） -&gt; Html （但现在更多是前后端分离，会使用HTML+AJAX(<strong>异步请求</strong>)，采用前端框架进行渲染会更好的解耦）<br>在controller中写一个函数，获取数据，用model封装返回给html，在html文件中链接Thymeleaf模板，将数据动态展现。</li>
</ul>
<h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><ul>
<li>在application.properties文件配置 java(spring)项目连接 mysql，然后通过 Mybatis这样的持久层框架对数据库操作<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/reggie?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;allowPublicKeyRetrieval=true</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">&quot;078114&quot;</span></span><br><span class="line"><span class="attr">mybatis-plus:</span> <span class="string">...</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><ul>
<li>在pom.xml中导包后，在application.properties文件配置 mybatis</li>
<li>SqlSessionFactory: 用于创建SqlSession的工厂类。</li>
<li>SqlSession：MyBatis的核心组件，用于向数据库执行SQL。</li>
<li>主配置文件：XML配置文件，可以对MyBatis的底层行为做出详细的配置</li>
<li>Mapper接口：就是DAO接口，在MyBatis中习惯性的称之为Mapper。<br><strong>Mapper映射器</strong>: 用于编写SQL，并将SQL和实体类映射的组件。采用XML、注解均可实现。<br><strong>方法1：</strong>在 &#x2F;java&#x2F;..&#x2F;dao 下创建xxMapper.java（mapper接口）后，在 &#x2F;resource&#x2F;mapper 下创建对应的 xx-mapper.xml（映射器）；<br><strong>方法2：</strong>直接在mapper中加@Select等注解里写sql（复杂sql还得方法1）</li>
</ul>
<h2 id="Mybatis-Plus"><a href="#Mybatis-Plus" class="headerlink" title="Mybatis-Plus"></a>Mybatis-Plus</h2><ul>
<li>是在MyBatis基础上的扩展。只做增强不做改变，为简化开发、提高效率而生。</li>
<li>MyBatisPlus官方提供了starter，其中集成了 Mybatis和 MybatisPlus的所有功能，并且实现了自动装配效果。因此可以用 MybatisPlus的starter直接代替 Mybatis的starter；<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="项目调试技巧"><a href="#项目调试技巧" class="headerlink" title="项目调试技巧"></a>项目调试技巧</h2><ul>
<li>相应<strong>状态码</strong>：200 - 成功，302 - 重定向（让浏览器再发一个请求），404 - 找不到路径，500 - 服务器遇到问题（服务端有bug）</li>
<li>服务端断点调试：方法中一行代码前打断点，以debug形式启动类。启动服务后，停止在断点处，F8向下执行一步&#x2F;F7进入方法内部&#x2F;F9直接执行到下一个断点，观察参数如何变化。</li>
<li>客户端断点调试：在浏览器打开开发者工具，对js文件打断点</li>
<li>设置日志级别，并将日志输出到不同的终端<br>trace-debug-log-warn-error，按照级别记录日志，动态地启用级别。可以在<code>application.properties</code>配置 logger<br>或在&#x2F;resource下放置一个名为logback-spring.xml的文件，自动配置logger（日志存放文件大小、日志类型、存放位置、名字…）</li>
<li><strong>在&#x2F;test下创建带@Test注解的测试类，直接对某一个mapper&#x2F;service&#x2F;..类进行测试。</strong><br>通过以下注解结合在一起，可以在测试中创建一个与实际应用程序相似的Spring容器，并运行测试。这样可以确保测试能够在实际的Spring环境中运行，并且可以访问和测试应用程序中的各种组件。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span>  <span class="comment">// 此注解用于指定运行测试的运行器，通常与JUnit一起使用。`SpringRunner`是Spring提供的一个JUnit运行器，用于在测试中启用Spring支持。</span></span><br><span class="line"><span class="meta">@SpringBootTest</span>  <span class="comment">// 这个注解告诉Spring Boot测试框架要加载整个Spring应用程序上下文，包括所有的bean。它是一个高级版本的`@ContextConfiguration`，它会尝试自动配置Spring应用程序上下文，通常用于集成测试。</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = CommunityApplication.class)</span>  <span class="comment">// 这个注解用于指定要加载的Spring配置类。在这里，`CommunityApplication.class`是Spring Boot应用程序的主配置类，它包含了应用程序的配置信息。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><ul>
<li>异步的JavaScript与XML <code>(Asynchronous JavaScript and XML)</code>，网页能够将增量更新呈现在页面上，而不需要刷新整个页面。虽然X代表XML，但目前JSON的使用比XML更加普遍。<br><strong>（在当前页面改一点东西用ajax（返回json字符串记得带@ResponseBody），展现新的页面用template）</strong></li>
<li>使用jQuery（框架）发送AJAX请求</li>
<li>判断是否为异步请求<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">xRequestedWith</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;x-requested-with&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;XMLHttpRequest&quot;</span>.equals(xRequestedWith)) &#123;...&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><ul>
<li>Redis是一款<strong>基于键值对</strong>的 <strong>NoSQL 数据库</strong>，它的值支持多种数据结构：字符串(strings)、哈希(hashes)、列表(lists)、集合(sets)、有序集合(sorted sets)等。 Redis将所有的数据都存放在<strong>内存</strong>中，所以它的读写性能十分惊人。同时，Redis还可以将内存中的数据以快照或日的形式保存到硬盘上，以保证数据的安全性。</li>
<li>Redis典型的应用场景包括: 缓存、排行榜、计器、社交网络、消息队列等.</li>
<li>Spring整合Redis：<ul>
<li>引入依赖：在pom.xml中导包spring-boot-starter-data-redis</li>
<li>配置数据库参数：propert中 spring.redis.database&#x3D;11 spring.redis.host&#x3D;localhost spring.redis.port&#x3D;6379</li>
<li>编写配置类，构造RedisTemplate（spring本身对redis的配置使其key为object类型，但string用起来更方便<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(factory);                  </span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());     <span class="comment">// 设置key的序列化方式</span></span><br><span class="line">        template.setValueSerializer(RedisSerializer.json());     <span class="comment">// 设置value的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string()); <span class="comment">// 设置hash的key的序列化方式</span></span><br><span class="line">        template.setHashValueSerializer(RedisSerializer.json()); <span class="comment">// 设置hash的value的序列化方式</span></span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;      &#125;  &#125;</span><br></pre></td></tr></table></figure></li>
<li>访问Redis：redisTemplate.opsForValue()， redisTemplate.opsForHash， redisTemplate.opsForList()，redisTemplate.opsForSet()，redisTemplate.opsForZSet()</li>
</ul>
</li>
<li><strong>for more -&gt;</strong> <a target="_blank" rel="noopener" href="https://leo710aka.github.io/2022/03/12/Redis/">https://leo710aka.github.io/2022/03/12/Redis/</a></li>
</ul>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ul>
<li>本地缓存<br>将数据缓存在应用服务器上，性能最好。如热帖、、<br>常用缓存工具: Ehcache、Guava、Caffeine等</li>
<li>分布式缓存<br>将数据缓存在NoSQL数据库上，跨服务器。如登录信息（不管在哪台服务器上都要查得到）<br>常用缓存工具: MemCache、Redis等.</li>
<li>多级缓存<br>一级缓存(本地缓存) &gt; 二级缓存(分布式缓存) &gt; DB(避免访问数据库)，每级缓存的内存大小、存储时间都不一样<br>服务器受到请求，先查看本地缓存，再查redis（分布式缓存），都没有才查DB，同时同步到本地和分布式缓存上<br>避免<strong>缓存雪崩</strong>(缓存失效，大量请求直达DB)，提高系统的可用性<br><img src="https://github.com/leo710aka/bk/blob/main/cache.png?raw=true"></li>
</ul>
<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><ul>
<li>阻塞队列（消息系统的底层）:<ul>
<li>BlockingQueue：处理并发和线程间的通信，帮助避免竞态条件、死锁等问题，并提高了系统的可维护性和性能。主要用于多线程编程中，以协调多个线程之间的数据传递、任务调度和同步操作。阻塞方法: put、take。</li>
<li>生产者消费者模式 - 生产者:产生数据的线程  - 消费者:使用数据的线程。</li>
<li>实现类 - ArrayBlockingQueue - LinkedBlockingQueue - PriorityBlockingQueue、SSynchronousQueue、DelayQueue等</li>
</ul>
</li>
<li>Kafka是一个分布式的流媒体平台应用<ul>
<li>应用：消息系统（消息队列）、日志收集、用户行为追踪、流式处理</li>
<li>特点：高吞吐量、消息持久化（硬盘）、高可靠性（顺序读写）、高扩展性（集群部署）</li>
<li>术语：- Broker（服务器）、Zookeeper  - Topic（存放空间）、Partition（分区）、Offset（索引）<br>   Leader Replica（主副本）、Follower Replica</li>
</ul>
</li>
<li>配置：在 <code>\config\zookeeper.properties</code> 配置数据存放位置 <code>dataDir=d:/work/data/zookeeper</code>，在 <code>server.properties</code> 配置日志存放位置 <code>log.dirs=d:/work/data/kafka-logs</code></li>
<li>启动：命令行方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在根目录 D:\kafka_2.12-2.3.0 打开cmd【1】，启动Apache Kafka的ZooKeeper服务器</span></span><br><span class="line">D:\kafka_2.12-2.3.0&gt;bin\windows\zookeeper-server-start.bat config\zookeeper.properties</span><br><span class="line"><span class="comment"># 在根目录 再打开一个cmd【2】，启动Kafka服务器 </span></span><br><span class="line">D:\kafka_2.12-2.3.0&gt;bin\windows\kafka-server-start.bat config\server.properties</span><br><span class="line"><span class="comment"># 在命令目录 D:\kafka_2.12-2.3.0\bin\windows 打开一个cmd【3】</span></span><br><span class="line"><span class="comment"># 创建topic，partition，replication，，， 开启 生产者</span></span><br><span class="line">D:\kafka_2.12-2.3.0\bin\windows&gt;kafka-topics.bat --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic <span class="built_in">test</span></span><br><span class="line">D:\kafka_2.12-2.3.0\bin\windows&gt;kafka-console-producer.bat --broker-list localhost:9092 --topic <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 在命令目录 再打开一个cmd【4】，， 开启 消费者</span></span><br><span class="line">D:\kafka_2.12-2.3.0\bin\windows&gt;kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic <span class="built_in">test</span> --from-beginning </span><br></pre></td></tr></table></figure></li>
<li>Spring整合Kafka<ul>
<li>引入依赖: spring-kafka</li>
<li>配置Kafka: spring.kafka.bootstrap-servers&#x3D;localhost:9092，spring.kafka.consumer.group-id&#x3D;community-consumer-group，spring.kafka.consumer.enable-auto-commit&#x3D;true，spring.kafka.consumer.auto-commit-interval&#x3D;3000</li>
<li>通过<code>KafkaTemplate</code>进行操作：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者（主动调用）</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> KafkaTemplate kafkaTemplate;</span><br><span class="line">kafkaTemplate.send(topic， data);</span><br><span class="line"><span class="comment">// 消费者（被动调用）</span></span><br><span class="line"><span class="meta">@KafkaListener(topics = &#123;&quot;test&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(ConsumerRecord record)</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Kafka使用<br>把kafka发送系统通知的行为当做“事件”，操作不同topic就是处理不同种类的事件。<ul>
<li>触发事件：评论后发布通知，点赞后发布通知，关注后发布通知</li>
<li>处理事件：封装事件对象（entity），开发事件的生产者，开发事件的消费者</li>
<li><strong>在需要使用消息队列的controller中调用生产者（评论后发通知，点赞后发通知，关注后发通知），消费者（用户收到系统通知）将被动调用</strong>；一个消费者可以消费多种事件</li>
</ul>
</li>
</ul>
<h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><ul>
<li>Elasticsearch简介 <strong>（Es可以看成是一个特殊的数据库，是在这个“数据库”中进行搜索）</strong><ul>
<li>一个分布式的、Restful风格的搜索引擎。支持对各种类型的数据的检索</li>
<li>搜索速度快，可以提供实时的搜索服务</li>
<li>便于水平扩展，每秒可以处理PB级海量数据</li>
</ul>
</li>
<li>Elasticsearch术语<ul>
<li>索引、类型、文档、字段。（相当于MySQL中的数据库、表、行、列）（6.0后类型被废弃，则索引直接对应mysql的表）</li>
<li>集群（分布式集群部署）、节点（集群中的一台服务器）、分片（进一步划分索引并发存储）、副本（对分片备份）。</li>
</ul>
</li>
<li>配置：目录D:\elasticsearch-6.4.3\config，文件<code>elasticsearch.yml</code>，修改 cluster.name: nowcoder、path.data: D:\work\data\elasticsearch-6.4.3\data、path.logs: D:\work\data\elasticsearch-6.4.3\logs；把bin目录配到环境变量<ul>
<li>中文分词插件 elasticsearch-analysis-ik，解压到 D:\elasticsearch-6.4.3\plugin\ik</li>
</ul>
</li>
<li>启动：（windows系统）双击 D:\elasticsearch-6.4.3\bin 下的 <code>elasticsearch.bat</code> 批处理文件即可。<ul>
<li>命令行操作（另开一个cmd）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\蔡枫&gt;curl -X GET <span class="string">&quot;localhost:9200/_cat/health?v&quot;</span>    <span class="comment"># 查看集群的健康状态</span></span><br><span class="line">C:\Users\蔡枫&gt;curl -X GET <span class="string">&quot;localhost:9200/_cat/nodes?v&quot;</span>     <span class="comment"># 查看节点</span></span><br><span class="line">C:\Users\蔡枫&gt;curl -X GET <span class="string">&quot;localhost:9200/_cat/indices?v&quot;</span>   <span class="comment"># 查看索引</span></span><br><span class="line">C:\Users\蔡枫&gt;curl -X GET <span class="string">&quot;localhost:9200/_cat/indices?v&quot;</span></span><br><span class="line">C:\Users\蔡枫&gt;curl -X PUT <span class="string">&quot;localhost:9200/test&quot;</span>             <span class="comment"># 以put创建索引</span></span><br><span class="line">&#123;<span class="string">&quot;acknowledged&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;shards_acknowledged&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;index&quot;</span>:<span class="string">&quot;test&quot;</span>&#125;</span><br><span class="line">C:\Users\蔡枫&gt;curl -X DELETE <span class="string">&quot;localhost:9200/test&quot;</span>          <span class="comment"># 用http协议中的delete，删除索引</span></span><br><span class="line">&#123;<span class="string">&quot;acknowledged&quot;</span>:<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>Postman</strong> 操作<ul>
<li>GET，发送指令 localhost:9200&#x2F;test&#x2F;_doc&#x2F;1 的<code>request</code>，查询test中的数据</li>
<li>PUT，发送指令 localhost:9200&#x2F;test&#x2F;_doc&#x2F;2 的<code>request</code>，向test中存数据，可以在Body中携带raw类型的json数据</li>
<li>搜索，GET，发送指令 localhost:9200&#x2F;test&#x2F;_search?q&#x3D;xx:yy，搜索test索引下xx中带有yy的数据</li>
<li>复杂搜索：要在Body中带raw的json查询条件</li>
</ul>
</li>
</ul>
</li>
<li>Spring 整合 Es<ul>
<li>引入依赖: spring-boot-starter-data-elasticsearch</li>
<li>配置Es：spring.data.elasticsearch.cluster-name&#x3D;nowcoder，spring.data.elasticsearch.cluster-nodes&#x3D;127.0.0.1:9300（<strong>9200是http端口，9300是tcp端口</strong>）</li>
<li>elasticsearch和redis同时依赖于netty，运行冲突，需要在 <code>CommunityApplication.java</code> 加上注解<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;		   <span class="comment">// 解决netty启动冲突问题</span></span><br><span class="line">    System.setProperty(<span class="string">&quot;es.set.netty.runtime.available.processors&quot;</span>, <span class="string">&quot;false&quot;</span>);	&#125;</span><br></pre></td></tr></table></figure></li>
<li>通过<code>ElasticsearchTemplate</code>(底层)，<code>ElasticsearchRwpository</code>(简易) 操作 Es<ul>
<li>对实体类加注解，与Es索引、类型、文档、字段映射：@Document(indexName &#x3D; “”, type &#x3D; “”, shards &#x3D; , replicas &#x3D; )；</li>
<li>配置实体类中的属性：@Id，@Field(type &#x3D; FieldType.Text, analyzer &#x3D; “ik_max_word”, searchAnalyzer &#x3D; “ik_smart”)，，</li>
<li><strong>一种repository对一种实体类做Es操作</strong>（区别于@Mapper，mybatis专属的）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DiscussPostRepository 是对 DiscussPost 做 Es 操作</span></span><br><span class="line"><span class="meta">@Repository</span>                 </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DiscussPostRepository</span> </span><br><span class="line">          <span class="keyword">extends</span> <span class="title class_">ElasticsearchRepository</span>&lt;DiscussPost, Integer&gt; &#123;</span><br><span class="line">&#125;            <span class="comment">// 只要继承 ElasticsearchRepository，自带save(),delete()等方法</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>搜索<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DiscussPostRepository discussRepository;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ElasticsearchTemplate elasticTemplate;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveDiscussPost</span><span class="params">(DiscussPost post)</span> &#123;</span><br><span class="line">    discussRepository.save(post);             <span class="comment">// 先要把（加了注解的）实体类存入 Es</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Page&lt;DiscussPost&gt; <span class="title function_">searchDiscussPost</span><span class="params">(String keyword, <span class="type">int</span> current, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">    <span class="type">SearchQuery</span> <span class="variable">searchQuery</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NativeSearchQueryBuilder</span>()</span><br><span class="line">            .withQuery(QueryBuilders.multiMatchQuery(keyword, <span class="string">&quot;title&quot;</span>, <span class="string">&quot;content&quot;</span>)) <span class="comment">// 搜索规则</span></span><br><span class="line">            .withSort(SortBuilders.fieldSort(<span class="string">&quot;type&quot;</span>).order(SortOrder.DESC))        <span class="comment">// 排序规则</span></span><br><span class="line">            .withPageable(PageRequest.of(current, limit))                          <span class="comment">// 分页</span></span><br><span class="line">            .withHighlightFields(                                                  <span class="comment">// 设置高亮</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">HighlightBuilder</span>.Field(<span class="string">&quot;title&quot;</span>).preTags(<span class="string">&quot;&lt;em&gt;&quot;</span>).postTags(<span class="string">&quot;&lt;/em&gt;&quot;</span>),</span><br><span class="line">            ).build();</span><br><span class="line">    <span class="keyword">return</span> elasticTemplate.queryForPage(searchQuery, DiscussPost.class, <span class="keyword">new</span> <span class="title class_">SearchResultMapper</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; AggregatedPage&lt;T&gt; <span class="title function_">mapResults</span><span class="params">(SearchResponse response, Class&lt;T&gt; aClass, Pageable pageable)</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AggregatedPageImpl</span>(...);          &#125;      &#125;);  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h2><p>账号：<code>1908454905@qq.com</code><br>Postman 是一个流行的 API测试工具和开发环境，它为开发人员提供了一种方便的方式来创建、测试、文档化和共享API。<br><strong>API 测试：</strong> Postman 的主要功能之一是允许用户发送 HTTP 请求以测试 API 端点。您可以创建 GET、POST、PUT、DELETE 等不同类型的请求，并附加参数、标头和正文数据以模拟与 API 交互。<br><strong>集合和环境：</strong> Postman 允许您组织测试请求到集合中。集合是一组相关的请求，可以方便地进行批量执行和管理。您还可以使用环境变量来动态地管理请求中的数据，以便在不同环境中轻松切换。<br><strong>自动化测试：</strong> Postman 提供了测试脚本功能，您可以使用 JavaScript 编写测试脚本，以验证 API 响应是否符合预期。这使得您可以创建自动化测试套件，确保 API 的稳定性和正确性。<br><strong>协作和共享：</strong> Postman 允许用户创建工作空间，多个团队成员可以在同一个工作空间中协作。您还可以共享 Postman 集合和环境，以便其他人可以重复您的测试或使用您的 API。</p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><ul>
<li>Spring Boot Testing<ul>
<li>依赖：spring-boot-starter-test</li>
<li>包括：Junit、Spring Test、AssertJ、、、</li>
</ul>
</li>
<li>Test Case 测试用例<ul>
<li>要求：保证测试方法的独立性。</li>
<li>步骤：初始化数据、执行测试代码、验证测试结果、清理测试数据。</li>
<li>常用注解：@BeforeClass、@AfterClass、@Before、@After。</li>
</ul>
</li>
</ul>
<h2 id="项目监控"><a href="#项目监控" class="headerlink" title="项目监控"></a>项目监控</h2><ul>
<li>Spring Boot Actuator<ul>
<li>Endpoints：监控应用的入口，Spring Boot内置了很多端点，也支持自定义端点。</li>
<li>监控方式：HTTP 或 JMX。</li>
<li>访问路径：例如“&#x2F;actuator&#x2F;health”</li>
<li>注意事项：按需配置暴露的端点，并对所有端点进行权限控制。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/31/Java%E5%90%8E%E7%AB%AF/" data-id="clr24omiz000aswv51f1kf025" data-title="java 后端开发 工程师" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-5 索引_排序_" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/09/09/5%20%E7%B4%A2%E5%BC%95_%E6%8E%92%E5%BA%8F_/" class="article-date">
  <time class="dt-published" datetime="2020-09-09T12:23:20.000Z" itemprop="datePublished">2020-09-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/09/09/5%20%E7%B4%A2%E5%BC%95_%E6%8E%92%E5%BA%8F_/">索引 | 排序</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是数据库中用于提高查询效率的数据结构，主要目的是加速对表中数据的检索操作，如图书的目录。</p>
<ul>
<li><strong>单列索引：</strong> 对表中的单一列建立的索引。</li>
<li><strong>复合索引：</strong> 对表中的多个列组合建立的索引。</li>
<li><strong>线性索引</strong>：对于保存在磁盘中的原始数据记录，在索引中保存对应的关键字，以及保存了数据记录位置的指针。</li>
<li><strong>哈希索引</strong>：基于哈希函数的原理，将关键字映射到索引的位置。通常用于等值查询，不适用于范围查询。存在哈希碰撞问题：当两个不同的关键字经过哈希函数得到相同的索引位置时，产生冲突。</li>
<li><strong>树索引</strong>：基于树结构的索引。树结构通常有更严格的平衡性和有序性。<br>每一个节点中保存了：（1）键值（关键字）即表中的主键。（2）指针，存储子节点的信息。（3）表记录中除主键外的数据。<ol>
<li><code>二叉排序树 BST</code>：每个节点的左子树包含的所有节点的值都小于该节点的值，右子树所有节点的值都大于该节点的值。<br>  但若子节点分布不均，查找效率就不高。</li>
<li><code>平衡二叉树 AVL</code>：插入数据的同时保持平衡的二叉排序树，左子树和右子树高度之差的绝对值不大于1。<br>  解决了 BST的问题。但若插入操作比查询操作频繁，效率就低。</li>
<li><code>红黑树</code>：最长子树不超过最短子树的 2倍即可。解决了 AVL的问题。<br>  但对于二叉树，随着数据的插入树的深度会变深，意味着IO次数越多，影响读取的效率；不适合做文件系统的索引。</li>
<li><code>B树</code>：有序的多路查询树（N叉树）为减少磁盘IO的次数，B树结点的大小通常设置为一次磁盘IO所能读取的最大数据量<br>  <strong>N叉树</strong>特点：(1)树中每个结点至多有<strong>N个</strong>孩子结点（即至多有<strong>N-1</strong>个关键字）。  (2)除根节点外，其他结点至少有<strong>m&#x2F;2的上取整个</strong>孩子结点；若根节点不是叶子结点，则根结点至少有两个孩子结点。  (3)所有叶子结点都在同一层上，即B树是所有结点的平衡因子均等于0的多路查找树。查找效率为O(log(n))，插入，，分裂，，<br>  但由于每个节点上都保存了数据，一次从硬盘上获取一个分页到内存，，？，数据增加会导致树的层数增大。</li>
<li><code>B+树</code>：在B树的基础上做了一些改进，将所有关键字都存放在叶子节点形成有序链表。</li>
</ol>
</li>
<li>红黑树、B树 和 B+树都是用于实现有序集合的树状数据结构，在数据库和文件系统等领域得到广泛应用，具体选择取决于应用场景和性能需求。在内存中，红黑树可能更适合，而在外部存储（内存&lt;–&gt;硬盘）中，B树和B+树通常更为合适。</li>
<li>索引的优点：<ol>
<li><strong>提高查询性能：</strong> 通过减少需要扫描的数据量，加速数据检索。</li>
<li><strong>加速排序和分组：</strong> 当排序或分组查询时，索引可以加速这些操作。</li>
<li><strong>加速连接操作：</strong> 在连接操作中，索引可以加速表的关联。</li>
</ol>
</li>
<li>索引的缺点：<ol>
<li><strong>占用存储空间：</strong> 索引需要额外的存储空间。</li>
<li><strong>降低写操作性能：</strong> 插入、更新和删除操作可能变得更慢，因为需要更新索引。</li>
<li><strong>维护成本：</strong> 随着表的变化，索引需要进行维护，增加了系统的开销。</li>
<li><strong>选择不当可能降低性能：</strong> 不正确选择索引或过多索引可能导致性能下降。</li>
</ol>
</li>
<li>如何选择索引：<ol>
<li><strong>根据查询模式：</strong> 根据实际查询模式选择建立合适的索引。</li>
<li><strong>根据表大小：</strong> 表较小时，全表扫描可能更有效；表较大时，索引更有优势。</li>
<li><strong>根据写操作频率：</strong> 如果写操作频繁，考虑减少索引。</li>
</ol>
</li>
</ul>
<h3 id="数据库中的实际应用："><a href="#数据库中的实际应用：" class="headerlink" title="数据库中的实际应用："></a>数据库中的实际应用：</h3><ol>
<li><strong>主键索引：</strong> 唯一标识表中的每一行数据，通常是单列索引。</li>
<li><strong>唯一索引：</strong> 确保列中的所有值都是唯一的，可以是单列或复合索引。</li>
<li><strong>聚集索引：</strong> 决定表的物理排序方式，通常是主键索引。</li>
<li><strong>非聚集索引：</strong> 不影响表的物理排序，通常是普通的单列或复合索引。</li>
</ol>
<h3 id="红黑树（Red-Black-Tree）："><a href="#红黑树（Red-Black-Tree）：" class="headerlink" title="红黑树（Red-Black Tree）："></a>红黑树（Red-Black Tree）：</h3><ol>
<li><strong>特性：</strong><ul>
<li>是一种自平衡的二叉搜索树。每个节点有两个子节点。</li>
<li>每个节点有一个颜色属性，红色或黑色。</li>
<li>保持了二叉搜索树的有序性。</li>
<li>通过一些规则保持了树的平衡，确保最长路径不超过最短路径的两倍。</li>
</ul>
</li>
<li><strong>插入和删除：</strong>插入和删除操作会通过颜色调整来保持红黑树的平衡，相对较快，但不适合范围查询。</li>
<li><strong>应用：</strong>通常用于内存中的数据结构。在很多语言的标准库中用于实现关联容器，如C++的<code>map</code>和<code>set</code>。</li>
</ol>
<h3 id="B树（B-Tree）："><a href="#B树（B-Tree）：" class="headerlink" title="B树（B-Tree）："></a>B树（B-Tree）：</h3><ol>
<li><strong>特性：</strong><ul>
<li>是一种自平衡的搜索树。多路搜索树，每个节点可以包含多个子节点。</li>
<li>保持了树的平衡，通过调整节点的大小，确保所有叶子节点到根节点的距离相等。</li>
</ul>
</li>
<li><strong>插入和删除：</strong>插入和删除操作可能需要调整节点的大小和结构。（分裂，，）</li>
<li><strong>应用：</strong>通常应用于文件系统和数据库索引，以提供高效的查找和插入操作。</li>
</ol>
<h3 id="B-树（B-Tree）："><a href="#B-树（B-Tree）：" class="headerlink" title="B+树（B+ Tree）："></a>B+树（B+ Tree）：</h3><ol>
<li><strong>特性：</strong><ul>
<li>是B树的一种变体。</li>
<li>所有关键字只出现在叶子节点的链表中，内部节点只包含关键字的信息和指向子树的指针。</li>
<li>叶子节点形成了一个有序链表，便于范围查询和顺序访问。</li>
</ul>
</li>
<li><strong>插入和删除：</strong>插入和删除操作可能需要调整节点的大小和结构，但与B树相比，B+树更简单。</li>
<li><strong>应用：</strong>常用于数据库索引设计，支持高效的范围查询和顺序访问。</li>
</ol>
<hr>

<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>A. 重点理解几个排序之间的对比，时间和空间复杂度，以及应用。PS：越简单越要提高认知效率，做到战略上藐视战术上重视。<br>B. 具体分析各种排序及其复杂度，查漏补缺；在综合复杂度及稳定性情况下，通常希尔, 快排和 归并需要重点掌握。<br><img src="https://pdai.tech/images/alg/alg-sort-overview-1.png"></p>
<ul>
<li>冒泡排序(Bubble Sort)它是一种较简单的排序算法。它会遍历若干次要排序的数列，每次遍历时，它都会从前往后依次的比较相邻两个数的大小；如果前者比后者大，则交换它们的位置。这样，一次遍历之后，最大的元素就在数列的末尾！ 采用相同的方法再次遍历时，第二大的元素就被排列在最大元素之前。重复此操作，直到整个数列都有序为止<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                swap(arr[j], arr[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;  <span class="comment">// 在一趟排序中，一次交换都没有发生过</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>快速排序(Quick Sort)是：采用分治的思想，将一个数组分成两个子数组，然后递归地对子数组进行排序。它选择一个元素作为”pivot”（基准），并将数组中小于基准的元素放在基准的左边，大于基准的元素放在基准的右边，然后对左右子数组进行递归排序。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> pivot = arr[left];</span><br><span class="line">        <span class="type">int</span> i = left, j = right;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= pivot) j--;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) arr[i++] = arr[j];</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pivot) i++;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) arr[j--] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = pivot;</span><br><span class="line">        <span class="built_in">quickSort</span>(arr, left, i - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(arr, i + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">quickSort</span>(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li>
<li>插入排序(Insertion Sort)的基本思想是: 把n个待排序的元素看成为一个有序表和一个无序表。开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次可完成排序过程。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">				<span class="built_in">swap</span>(arr[j], arr[j+<span class="number">1</span>]);</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Shell排序(Shell Sort)，希尔排序实质上是一种分组插入方法。它的基本思想是: 对于n个待排序的数列，取一个小于n的整数gap(gap被称为步长)将待排序元素分成若干个组子序列，所有距离为gap的倍数的记录放在同一个组中；然后，对各组内的元素进行直接插入排序。 这一趟排序完成之后，每一个组的元素都是有序的。然后减小gap的值，并重复执行上述的分组和排序。重复这样的操作，当gap&#x3D;1时，整个数列就是有序的。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> gap = n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> temp = arr[i];</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &gt;= gap &amp;&amp; arr[j - gap] &gt; temp; j -= gap) &#123;</span><br><span class="line">                arr[j] = arr[j - gap];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>选择排序(Selection sort)它的基本思想是: 首先在未排序的数列中找到最小(or最大)元素，然后将其存放到数列的起始位置；接着，再从剩余未排序的元素中继续寻找最小(or最大)元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectionSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123; </span><br><span class="line">		<span class="type">int</span> minIndex = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;len; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(a[j] &lt; a[minIndex]) &#123;</span><br><span class="line">				minIndex = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">swap</span>(a[i], a[minIndex]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>堆排序(Heap Sort)堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。<img src="https://github.com/leo710aka/bk/blob/main/HeapSort.png?raw=true" width="300" height="200" alt=""> 
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AdjustDwon</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> size, <span class="type">int</span> parent)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (child &lt; size) &#123;</span><br><span class="line">		<span class="keyword">if</span> (child + <span class="number">1</span> &lt; size &amp;&amp; a[child + <span class="number">1</span>] &gt; a[child]) &#123;</span><br><span class="line">			++child;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (a[child] &gt; a[parent]) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(a[child], a[parent]);</span><br><span class="line">			parent = child;</span><br><span class="line">			child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = (n - <span class="number">1</span> - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="built_in">AdjustDwon</span>(a, n, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> end = n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (end &gt; <span class="number">0</span>)	&#123;</span><br><span class="line">		<span class="built_in">swap</span>(a[<span class="number">0</span>], a[end]);</span><br><span class="line">		<span class="built_in">AdjustDwon</span>(a, end, <span class="number">0</span>);</span><br><span class="line">		--end;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>归并排序(Merge Sort)，采用分治的思想将一个大问题分割成多个小问题来解决。<br>具体来说，归并排序的过程包括分割、排序和合并三个步骤。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n1 = mid - left + <span class="number">1</span>, n2 = right - mid;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftArr</span><span class="params">(n1)</span>, <span class="title">rightArr</span><span class="params">(n2)</span></span>;                        <span class="comment">// 创建临时数组来存储左右两部分的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; i++)  leftArr[i] = arr[left + i];     <span class="comment">// 将数据复制到临时数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n2; i++)  rightArr[i] = arr[mid + <span class="number">1</span> + i];    </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = left;                                   <span class="comment">// 合并两个临时数组</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftArr[i] &lt;= rightArr[j]) arr[k++] = leftArr[i++];  </span><br><span class="line">        <span class="keyword">else</span> arr[k++] = rightArr[j++]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1)  arr[k++] = leftArr[i++];                      <span class="comment">// 处理剩余元素</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; n2)  arr[k++] = rightArr[j++];  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;           <span class="comment">// 归并排序主函数</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">mergeSort</span>(arr, left, mid);                                <span class="comment">// 分割左右两部分</span></span><br><span class="line">        <span class="built_in">mergeSort</span>(arr, mid + <span class="number">1</span>, right); </span><br><span class="line">        <span class="built_in">merge</span>(arr, left, mid, right);                             <span class="comment">// 合并已排序的两部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>桶排序(Bucket Sort)桶排序(Bucket Sort)的原理很简单，将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）</li>
<li>基数排序(Radix Sort)它的基本思想是: 将整数按位数切割成不同的数字，然后按每个位数分别比较。具体做法是: 将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列<table>
<thead>
<tr>
<th>排序场景</th>
<th>排序效率</th>
</tr>
</thead>
<tbody><tr>
<td>Random</td>
<td>希尔&gt;快排&gt;归并</td>
</tr>
<tr>
<td>Few unique</td>
<td>快排&gt;希尔&gt;归并</td>
</tr>
<tr>
<td>Reversed</td>
<td>快排&gt;希尔&gt;归并</td>
</tr>
<tr>
<td>Almost sorted</td>
<td>插入排序&gt;基数排序&gt;快排&gt;希尔&gt;归并</td>
</tr>
</tbody></table>
</li>
</ul>
<p>	</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/09/09/5%20%E7%B4%A2%E5%BC%95_%E6%8E%92%E5%BA%8F_/" data-id="clr24omiw0004swv5dlwva80t" data-title="索引 | 排序" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-4 回溯_动态规划_贪心_" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/09/08/4%20%E5%9B%9E%E6%BA%AF_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92_%E8%B4%AA%E5%BF%83_/" class="article-date">
  <time class="dt-published" datetime="2020-09-08T11:23:20.000Z" itemprop="datePublished">2020-09-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/09/08/4%20%E5%9B%9E%E6%BA%AF_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92_%E8%B4%AA%E5%BF%83_/">回溯 | 动态规划 | 贪心</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><p>回溯法也可以叫做回溯搜索法，它是一种搜索的方式。回溯是<strong>递归</strong>的副产品，只要有递归就会有回溯。<br>回溯的本质是<strong>穷举</strong>，穷举所有可能，然后选出我们想要的答案，如果想让回溯法高效一些，可以加一些剪枝的操作。<br>回溯法解决的问题都可以抽象为<strong>树形结构</strong>，所有回溯法的问题都可以抽象为树形结构！<br>因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度，都构成的树的深度。递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。</p>
<h3 id="回溯（backtracking）三步曲：回溯函数模板返回值及参数-函数终止条件-回溯搜索的遍历过程"><a href="#回溯（backtracking）三步曲：回溯函数模板返回值及参数-函数终止条件-回溯搜索的遍历过程" class="headerlink" title="回溯（backtracking）三步曲：回溯函数模板返回值及参数 -&gt; 函数终止条件 -&gt; 回溯搜索的遍历过程"></a><code>回溯（backtracking）三步曲</code>：回溯函数模板返回值及参数 -&gt; 函数终止条件 -&gt; 回溯搜索的遍历过程</h3><h3 id="回溯函数模板："><a href="#回溯函数模板：" class="headerlink" title="回溯函数模板："></a><strong>回溯函数模板：</strong></h3><ul>
<li><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(参数)</span> </span>&#123;             </span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="built_in">backtracking</span>(路径，选择列表);  <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><font color= "#87CEFA"> <strong>组合问题：</strong> </font>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合;<br>示例: 输入: n &#x3D; 4, k &#x3D; 2 输出: [ [1,2], [1,3], [1,4], [2,3],[2,4], [3,4] ]<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;                        </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;                       <span class="comment">// 存放符合条件结果的集合</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;                                 <span class="comment">// 用来存放符合条件结果</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startIndex)</span> </span>&#123; <span class="comment">// startIndex记录下一层递归，搜索的起始位置</span></span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n; i++) &#123;   <span class="comment">// 控制树的横向遍历</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(i);                    <span class="comment">// 处理节点</span></span><br><span class="line">            <span class="built_in">backtracking</span>(n, k, i + <span class="number">1</span>);            <span class="comment">// 递归：控制树的纵向遍历，注意下一层搜索从i+1开始</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();                      <span class="comment">// 回溯，撤销处理的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><font color= "#87CEFA"> <strong>子集问题：</strong> </font>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。说明：解集不能包含重复的子集。<br>示例: 输入: nums &#x3D; [1,2,3] 输出: [ [], [1], [1, 2], [1,2,3],   ]<br>如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！</li>
<li><font color= "#87CEFA"> <strong>分割回文串：</strong> </font>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。<br>示例: 输入: “aab” 输出: [ [“aa”,”b”], [“a”,”a”,”b”] ]<br>其实切割问题类似组合问题，例如对于字符串abcdef：<br>组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中再选取第三个…..。<br>切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中再切割第三段…..。<br><img src="https://code-thinking.cdn.bcebos.com/pics/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg"><br><strong>！！！一定建立起for循环横向遍历，递归纵向遍历的概念！！！</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string s, <span class="type">int</span> startindex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startindex &gt;= s.<span class="built_in">size</span>()) &#123;   <span class="comment">// 0.终止条件_遍历到“叶子结点”，一组成功样例                               </span></span><br><span class="line">        ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = startindex; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ishuiwen</span>(s.<span class="built_in">substr</span>(startindex, i - startindex + <span class="number">1</span>))) &#123;   </span><br><span class="line">            path.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(startindex, i - startindex + <span class="number">1</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                    </span><br><span class="line">            <span class="keyword">continue</span>;               <span class="comment">// 1.处理节点：切割startindex~i的子串</span></span><br><span class="line">        &#125;                           <span class="comment">// ！！不要在终止条件里处理节点！！</span></span><br><span class="line">        <span class="built_in">backtracking</span>(s, i + <span class="number">1</span>);     <span class="comment">// 2.处理完节点后遍历  </span></span><br><span class="line">        path.<span class="built_in">pop_back</span>();            <span class="comment">// 3.回溯 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><font color= "#87CEFA"> <strong>排列问题：</strong> </font>给定一个 没有重复 数字的序列，返回其所有可能的全排列。排列是有序的，即[1,2] 和 [2,1] 是两个集合。<br>示例：输入[1,2,3]，输出 [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span> <span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">bool</span>&gt;&amp; used)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;     </span><br><span class="line">            <span class="comment">// 元素1在[1,2]中已经使用过了，但是在[2,1]中还要在使用一次1</span></span><br><span class="line">            <span class="comment">// 所以处理排列问题不使用startIndex，i从0开始遍历。</span></span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="literal">true</span>) <span class="keyword">continue</span>;   <span class="comment">// path里已经收录的元素，直接跳过</span></span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="comment">// used数组，其实就是记录此时path里都有哪些元素使用了，一个排列里一个元素只能使用一次。</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;      </span><br><span class="line">        <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>hhh</p>
<hr>

<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ul>
<li>动态规划，Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的。</li>
<li>动态规划算法一般分为自顶向下的记忆化搜索和自底向上的递推方法。自顶向下方法使用递归来解决问题，但在递归过程中使用记忆数组（或哈希表）来保存已经计算过的子问题的解，以避免重复计算。自底向上方法则从子问题的基础解逐步构建出问题的解。(递归到动规的一般转化方法：递归函数有n个参数，就定义一个n维的数组，数组的下标是递归函数参数的取值范围，数组元素的值是递归函数的返回值，这样就可以从边界值开始，逐步填充数组，相当于计算递归函数值的逆过程。)</li>
<li>动态规划通常适用于具备以下特点的问题：<br><strong>1. 重叠子问题：</strong> 问题的解可以由多个子问题的解组合而来，这些子问题可能会被重复解决。<br><strong>2. 最优子结构：</strong> 问题的最优解可以通过其子问题的最优解构造得到。<br><strong>3. 无后效性：</strong> 当前的若干个状态值一旦确定，则此后过程的演变就只和这若干个状态的值有关，和之前是采取哪种手段或经过哪条路径演变到当前的这若干个状态，没有关系。</li>
</ul>
<h3 id="动态（DP）规划五步曲-1-确定dp数组（dp-table）以及下标的含义-2-确定递推公式-3-dp数组如何初始化-4-确定遍历顺序-5-举例推导dp数组"><a href="#动态（DP）规划五步曲-1-确定dp数组（dp-table）以及下标的含义-2-确定递推公式-3-dp数组如何初始化-4-确定遍历顺序-5-举例推导dp数组" class="headerlink" title="动态（DP）规划五步曲 1. 确定dp数组（dp table）以及下标的含义 -&gt; 2. 确定递推公式 -&gt; 3. dp数组如何初始化 -&gt; 4. 确定遍历顺序 -&gt; 5. 举例推导dp数组"></a><code>动态（DP）规划五步曲</code> 1. 确定dp数组（dp table）以及下标的含义 -&gt; 2. 确定递推公式 -&gt; 3. dp数组如何初始化 -&gt; 4. 确定遍历顺序 -&gt; 5. 举例推导dp数组</h3><ul>
<li><font color= "#87CEFA"> <strong>01背包问题：</strong> </font>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。<br>1.dp数组以及下标含义：使用二维数组dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。<br>2.递推公式： <strong>dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</strong><br>不放物品i：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以背包内的价值依然和前面相同。)<br>放物品i：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值<br>3.dp数组初始化：关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱。<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210110103109140.png"><br>4.遍历顺序：先遍历物品、先遍历背包重量都可以。把dp表遍历填满就行。<br>5.举例推导dp：做动态规划的题目，最好的过程就是自己在纸上举一个例子把对应的dp数组的数值推导一下，然后在动手写代码！<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_2_wei_bag_problem1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> bagweight = <span class="number">4</span>; </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; weight = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; value = &#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;; </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(weight.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(bagweight + <span class="number">1</span>, <span class="number">0</span>));   <span class="comment">// 二维数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = weight[<span class="number">0</span>]; j &lt;= bagweight; j++)  dp[<span class="number">0</span>][j] = value[<span class="number">0</span>];      <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123;                               <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= bagweight; j++) &#123;                              <span class="comment">// 遍历背包容量</span></span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    cout &lt;&lt; dp[weight.<span class="built_in">size</span>() - <span class="number">1</span>][bagweight] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><font color= "#87CEFA"> <strong>打家劫舍：</strong> </font>每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。<br>1.dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]。<br>2.dp[i] &#x3D; max(dp[i - 2] + nums[i], dp[i - 1])；决定dp[i]的因素就是第i房间偷还是不偷。<br>如果偷第i房间，那么dp[i] &#x3D; dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。<br>如果不偷第i房间，那么dp[i] &#x3D; dp[i - 1]，即考虑 i-1 房，（注意这里是考虑，并不是一定要偷i-1房！）<br>3.dp数组初始化：递推公式的基础就是dp[0] 和 dp[1]；dp[0] 一定是 nums[0]，dp[1]就是nums[0]和nums[1]的最大值<br>4.遍历顺序：dp[i] 是根据dp[i - 2] 和 dp[i - 1] 推导出来的，那么一定是从前到后遍历！<br>5.举例推导dp数组<br><font color= "#87CEFA"> <strong>打家劫舍II：</strong> </font>房子首尾相连。<br>情况一：考虑不包含首尾元素； 情况二：考虑包含首元素，不包含尾元素； 情况三：考虑包含尾元素，不包含首元素<br>答案即情况二、三之间的大的值</li>
<li>最长递增子序列：找到整数数组 nums 中最长严格递增子序列的长度。例如，[3,6,2,7] 是 [0,3,1,6,2,2,7] 的子序列。<br>定义 dp[i] 为考虑前 i 个元素，以第 i 个数字结尾的最长上升子序列的长度，注意 nums[i] 必须被选取！！！<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; nums[j] &amp;&amp; (<span class="number">1</span> + dp[j]) &gt; dp[i])  dp[i] = dp[j] + <span class="number">1</span>;  <span class="comment">// 返回dp[]最大值    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><font color= "#87CEFA"> <strong>股票问题：</strong> </font>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。<br>dp[i][0] 表示第i天持有股票所得最多现金 ；dp[i][1] 表示第i天不持有股票所得最多现金。<br>dp[i][0] &#x3D; max(dp[i - 1][0], -prices[i]); dp[i][1] &#x3D; max(dp[i - 1][1], prices[i] + dp[i - 1][0]);</li>
<li><font color= "#87CEFA"> <strong>子序列问题：</strong> </font></li>
<li><font color= "#87CEFA"> <strong>单词拆分：</strong> </font>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。<br>输入 s &#x3D; “leetcode”, wordDict &#x3D; [“leet”, “code”]。返回 true 因为 “leetcode” 可以由 “leet” 和 “code” 拼接成。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>(wordDict);     <span class="comment">// 直接用数组构建set</span></span><br><span class="line"><span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length() + <span class="number">1</span>];  <span class="comment">// 考虑dp数组长度和元素意义！！</span></span><br><span class="line">Arrays.fill(dp, <span class="literal">false</span>);</span><br><span class="line">dp[<span class="number">0</span>] = <span class="literal">true</span>;                                <span class="comment">// 注意初始情况！！</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[j] &amp;&amp; set.contains(s.substring(j, i))) &#123;</span><br><span class="line">            dp[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[s.length()];</span><br></pre></td></tr></table></figure></li>
</ul>
<p>wdnmd</p>
<hr>

<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优。</strong><br>难点就是如何通过局部最优，推出整体最优。靠自己手动模拟，如果模拟可行就可以试一试贪心策略，如果不可行可能需要动态规划。<br>如何验证可不可以用贪心算法呢？最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧。<br>如果需要严格的数学证明，一般有两种方法：数学归纳法、反证法。<br>可以说：刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心。</p>
<h3 id="贪心一般解题步骤"><a href="#贪心一般解题步骤" class="headerlink" title="贪心一般解题步骤"></a>贪心一般解题步骤</h3><p>一般分为如下四步：<br>1.将问题分解为若干个子问题  2. 找出适合的贪心策略  3. 求解每一个子问题的最优解  4. 将局部最优解堆叠成全局最优解<br>这个四步其实过于理论化了，，，做题的时候，只要想清楚 局部最优 是什么，如果推导出全局最优，其实就够了。</p>
<ul>
<li><p><font color= "#87CEFA"> <strong>最大子序和：</strong> </font>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>示例：输入 [-2,1,-3,4,-1,2,1,-5,4]，输出 6。解释:  连续子数组  [4,-1,2,1] 的和最大，为  6<br><strong>解答</strong>：直接遍历一路加过去就行，记录目前的“连续和”以及最大“连续和”，当目前的“连续和”为负数时置0，“重新”开始计算“连续和”。<br><strong>局部最优：</strong>当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。全局最优：选取最大“连续和”</p>
</li>
<li><p><font color= "#87CEFA"> <strong>摆动序列：</strong></font></p>
</li>
<li><p><font color= "#87CEFA"> <strong>买卖股票的最佳时机 II：</strong> </font>给定股票每天的价格，计算所能获取的最大利润，可以尽可能地完成更多的交易（多次买卖一支股票）。在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候最多只能持有 一股 股票。<br><strong>解答</strong>：想到选一个低的买入，再选个高的卖，再选一个低的买入…..循环反复。即最终利润是可以分解的，把利润分解为每天为单位的维度，而不是从 0 天到第 n 天整体去考虑，那么根据 prices 可以得到每天的利润序列：(prices[i] - prices[i - 1])…..(prices[1] - prices[0])。最大利润就是取其中的所有正值之和。</p>
</li>
<li><p><font color= "#87CEFA"> <strong>跳跃游戏 II：</strong></font></p>
</li>
<li><p><font color= "#87CEFA"> <strong>加油站：</strong></font>环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。从其中的一个加油站出发，开始时油箱为空。如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。<br><strong>解答</strong>：首先如果总油量减去总消耗大于等于零，那么一定可以跑完一圈，即各个站点的加油站 剩油量rest[i]&#x3D;gas[i] - cost[i] 相加之和一定是大于等于零的。令 i 从0开始累加 rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，因为这个区间选择任何一个位置作为起点，到i这里都会断油，那么起始位置从i+1算起，再从0计算curSum。<br><strong>局部最优：</strong>当前累加rest[i]的和curSum一旦小于0，起始位置至少要是i+1，因为从i之前开始一定不行。全局最优：找到可以跑一圈的起始位置。</p>
</li>
<li><p><font color= "#87CEFA"> <strong>分发糖果：</strong></font>ratings[] 表示每个孩子的评分。你需要按照以下要求，给这些孩子分发糖果：1、每个孩子至少分配到 1 个糖果。2、相邻两个孩子评分更高的孩子会获得更多的糖果。<br><strong>解答</strong>：这道题目<strong>一定是要确定一边之后，再确定另一边</strong>，例如比较每一个孩子的左边，然后再比较右边，如果两边一起考虑一定会顾此失彼。先确定右边评分大于左边的情况（也就是从前向后遍历）只要右边评分比左边大，右边的孩子就多一个糖果；再确定左孩子大于右孩子的情况（从后向前遍历）只要左边评分比右边大，左边的孩子就多一个糖果。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(ratings[i] &gt; ratings[i<span class="number">-1</span>])  candys[i] = candys[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span>(ratings[i] &gt; ratings[i+<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="comment">// 此时candyVec[i]（第i个小孩的糖果数量）就有两个选择了，一个是candyVec[i + 1] + 1（从右边这个加1得到的糖果数量），一个是candyVec[i]（之前比较右孩子大于左孩子得到的糖果数量），取最大值。</span></span><br><span class="line">        <span class="comment">// 即局部最优：取candyVec[i + 1] + 1 和 candyVec[i] 最大的糖果数量，保证第i个小孩的糖果数量既大于左边的也大于右边的。全局最优：相邻的孩子中，评分高的孩子获得更多的糖果。</span></span><br><span class="line">        candys[i] = <span class="built_in">max</span>(candys[i], candys[i+<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/09/08/4%20%E5%9B%9E%E6%BA%AF_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92_%E8%B4%AA%E5%BF%83_/" data-id="clr24omiw0005swv55i522ain" data-title="回溯 | 动态规划 | 贪心" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2046/12/">December 2046</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2046/12/30/nice-photo/">Nice Photo</a>
          </li>
        
          <li>
            <a href="/2023/10/11/%E9%9D%A2%E8%AF%95/">面 逝</a>
          </li>
        
          <li>
            <a href="/2023/10/10/%E6%8A%80%E8%83%BD/">寄 能</a>
          </li>
        
          <li>
            <a href="/2023/07/31/Colab/">Colab</a>
          </li>
        
          <li>
            <a href="/2023/07/14/Pytorch/">Pytorch</a>
          </li>
        
          <li>
            <a href="/2023/07/10/Anaconda/">Anaconda</a>
          </li>
        
          <li>
            <a href="/2023/04/14/Docker/">Docker</a>
          </li>
        
          <li>
            <a href="/2023/04/12/Git/">Git</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 fengcai<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>