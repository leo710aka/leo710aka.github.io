<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>InfluxDB | Qué miras Bobo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="InfluxDB 是一个由InfluxData开发的开源时序型数据库，专注于海量时序数据的高性能读、高性能写、高效存储与实时分析等；在DB-Engines Ranking时序型数据库排行榜上排名第一，广泛应用于DevOps监控、IoT监控、实时分析等场景。https:&#x2F;&#x2F;jasper-zhang1.gitbooks.io&#x2F;influxdb&#x2F;content&#x2F;Introduction&#x2F;gettin">
<meta property="og:type" content="article">
<meta property="og:title" content="InfluxDB">
<meta property="og:url" content="http://example.com/2024/09/22/InfluxDB/index.html">
<meta property="og:site_name" content="Qué miras Bobo">
<meta property="og:description" content="InfluxDB 是一个由InfluxData开发的开源时序型数据库，专注于海量时序数据的高性能读、高性能写、高效存储与实时分析等；在DB-Engines Ranking时序型数据库排行榜上排名第一，广泛应用于DevOps监控、IoT监控、实时分析等场景。https:&#x2F;&#x2F;jasper-zhang1.gitbooks.io&#x2F;influxdb&#x2F;content&#x2F;Introduction&#x2F;gettin">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-6685cdf3df810ad3e5ae44d4e1a9df22_720w.webp">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-abb99833337f84b3850e0f6484f013ef_720w.webp">
<meta property="article:published_time" content="2024-09-22T05:34:33.000Z">
<meta property="article:modified_time" content="2025-04-23T13:05:07.956Z">
<meta property="article:author" content="fengcai">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic3.zhimg.com/80/v2-6685cdf3df810ad3e5ae44d4e1a9df22_720w.webp">
  
    <link rel="alternate" href="/atom.xml" title="Qué miras Bobo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="https://github.com/leo710aka/bk/blob/main/DT1.jpg?raw=true">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Qué miras Bobo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-InfluxDB" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/22/InfluxDB/" class="article-date">
  <time class="dt-published" datetime="2024-09-22T05:34:33.000Z" itemprop="datePublished">2024-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      InfluxDB
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <!-- # InfluxDB | DBAdvanced -->

<p><strong>InfluxDB</strong> 是一个由InfluxData开发的开源时序型数据库，专注于海量时序数据的高性能读、高性能写、高效存储与实时分析等；<br>在DB-Engines Ranking时序型数据库排行榜上排名第一，广泛应用于DevOps监控、IoT监控、实时分析等场景。<br><a target="_blank" rel="noopener" href="https://jasper-zhang1.gitbooks.io/influxdb/content/Introduction/getting_start.html">https://jasper-zhang1.gitbooks.io/influxdb/content/Introduction/getting_start.html</a></p>
<p><em><strong>influxdb-cluster</strong></em> 是InfluxDB的集群版本，InfluxDB Enterprise 的开源替代方案，设计用于大规模数据存储和高可用性需求。<br>可以实现数据的分片和复制，从而提高系统的可用性和扩展性。数据安全。operator缺失<br><a target="_blank" rel="noopener" href="https://github.com/chengshiwen/influxdb-cluster/wiki">https://github.com/chengshiwen/influxdb-cluster/wiki</a></p>
<h3 id="集群体系结构"><a href="#集群体系结构" class="headerlink" title="集群体系结构"></a>集群体系结构</h3><p>InfluxDB Enterprise由两组软件进程组成： Data 数据节点 和 Meta 元节点。集群内的通信是这样的：</p>
<div style="display: flex; justify-content: space-around;">
  <img src="https://pic3.zhimg.com/80/v2-6685cdf3df810ad3e5ae44d4e1a9df22_720w.webp" width="450" height="300" alt="">
  <img src="https://pic4.zhimg.com/80/v2-abb99833337f84b3850e0f6484f013ef_720w.webp" width="450" height="300" alt="">
</div>

<p>influxdb使用的默认端口号为分别为用于meta集群内部服务的8091端口，meta节点通信的8089端口，data集群内部服务的8088端口，以及data节点对外提供http服务的8086端</p>
<ul>
<li>Meta 节点通过 TCP 协议和 Raft 共识协议相互通信，默认都使用端口 8089，此端口必须在 Meta 节点之间是可访问的。默认 Meta 节点还将公开绑定到端口 8091 的 HTTP API，influxd-ctl 命令使用该 API。</li>
<li>Data 节点通过绑定到端口 8088 的 TCP 协议相互通信。Data 节点通过绑定到 8091 的 HTTP API 与 Meta 节点通信。这些端口必须在 Meta 节点和 Data 节点之间是可访问的。</li>
<li>在集群内，所有 Meta 节点都必须与所有其它 Meta 节点通信。所有 Data 节点必须与所有其它 Data 节点和所有 Meta 节点通信。</li>
</ul>
<h2 id="Where-data-lives"><a href="#Where-data-lives" class="headerlink" title="Where data lives"></a>Where data lives</h2><p>InfluxDB 集群中，一个节点要么是专门用于存储和查询时间序列数据的数据节点，要么是专门用于存储集群元数据的元节点。数据节点负责存储实际的数据和处理查询请求，而元节点则负责管理集群的元数据，包括节点信息、数据库和保留策略等。</p>
<h3 id="Meta"><a href="#Meta" class="headerlink" title="Meta"></a>Meta</h3><p>元节点保存以下所有元数据：</p>
<ul>
<li>集群中的所有节点及其角色</li>
<li>集群中存在的所有数据库和保留策略</li>
<li>所有分片和分片组，以及它们存在于哪些节点上</li>
<li>集群用户及其权限</li>
<li>所有连续查询</li>
</ul>
<p>元节点将这些数据保存在磁盘上的Raft数据库中，由BoltDB提供支持。默认情况下，Raft数据库是&#x2F;var&#x2F;lib&#x2F;influxdb&#x2F;meta&#x2F;raft.db。<br>注意：Meta节点需要&#x2F; Meta目录。</p>
<ul>
<li><strong><code>influxd-meta</code> 元数据服务</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置文件示例（meta节点）</span></span><br><span class="line">[<span class="string">meta</span>]</span><br><span class="line">  <span class="string">dir</span> <span class="string">=</span> <span class="string">&quot;/var/lib/influxdb/meta&quot;</span>  <span class="comment"># 元数据存储路径 </span></span><br><span class="line">  <span class="string">bind-address</span> <span class="string">=</span> <span class="string">&quot;:8089&quot;</span>          <span class="comment"># Raft协议通信端口</span></span><br><span class="line">  <span class="string">http-bind-address</span> <span class="string">=</span> <span class="string">&quot;:8091&quot;</span>     <span class="comment"># 管理API端口 </span></span><br></pre></td></tr></table></figure></li>
<li><strong><code>influxd-ctl</code> 集群管理</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看分片分布</span></span><br><span class="line">kubectl <span class="built_in">exec</span> influxdb-meta-0 -- influxd-ctl show-shards </span><br><span class="line"><span class="comment"># 强制同步分片到新节点</span></span><br><span class="line">kubectl <span class="built_in">exec</span> influxdb-meta-0 -- influxd-ctl copy-shard 3 influxdb-data-0:8088 </span><br><span class="line"><span class="comment"># 节点维护操作</span></span><br><span class="line">influxd-ctl remove-data influxdb-data-0:8088  <span class="comment"># 下线节点 </span></span><br><span class="line"><span class="comment"># 检查Meta节点Raft状态</span></span><br><span class="line">kubectl <span class="built_in">exec</span> influxdb-meta-0 -- influxd-ctl raft-state </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h3><p>数据节点保存所有原始时间序列数据和元数据，包括：</p>
<ul>
<li>measurements</li>
<li>tag keys and values</li>
<li>field keys and values</li>
</ul>
<p>在磁盘上，数据总是按照<database>&#x2F;<retention_policy>&#x2F;<shard_id>组织。默认父目录为&#x2F;var&#x2F;lib&#x2F;influxdb&#x2F;data。注意：数据节点需要&#x2F;var&#x2F;lib&#x2F;influxdb&#x2F;的所有四个子目录，包括&#x2F;meta(specifically, the clients.json file)、&#x2F;data、&#x2F;wal和&#x2F;hh。</p>
<ul>
<li><strong><code>influx</code> CLI工具</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入容器执行CLI</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it influxdb-data-0 -n influxdb -- influx -username admin -password <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 常用命令</span></span><br><span class="line">SHOW DATABASES;        <span class="comment"># 显示所有数据库 </span></span><br><span class="line">SELECT * FROM cpu;     <span class="comment"># 查询数据</span></span><br><span class="line">CREATE RETENTION POLICY <span class="string">&quot;1d&quot;</span> ON db3 DURATION 1d REPLICATION 2;  <span class="comment"># 创建保留策略 </span></span><br></pre></td></tr></table></figure></li>
<li><strong><code>influxd</code> 数据节点服务</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看运行状态</span></span><br><span class="line">kubectl <span class="built_in">exec</span> influxdb-data-0 -- ps aux | grep influxd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键参数</span></span><br><span class="line">-data-dir /var/lib/influxdb/data   <span class="comment"># 数据存储目录 </span></span><br><span class="line">-wal-dir /var/lib/influxdb/wal     <span class="comment"># WAL日志目录</span></span><br></pre></td></tr></table></figure></li>
<li><strong><code>influx_inspect</code> 数据工具</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导出TSM文件（需进入容器）</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it influxdb-data-0 -- influx_inspect <span class="built_in">export</span> \</span><br><span class="line">  -datadir /var/lib/influxdb/data \</span><br><span class="line">  -waldir /var/lib/influxdb/wal \</span><br><span class="line">  -out backup.gz -compress </span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证数据完整性</span></span><br><span class="line">influx_inspect verify -<span class="built_in">dir</span> /var/lib/influxdb/data/db3 </span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Data-与-Meta节点交互机制"><a href="#Data-与-Meta节点交互机制" class="headerlink" title="Data 与 Meta节点交互机制"></a>Data 与 Meta节点交互机制</h4><ol>
<li><p>通信协议</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>端口</th>
<th>用途</th>
<th>协议</th>
</tr>
</thead>
<tbody><tr>
<td>Meta节点间</td>
<td>8089</td>
<td>Raft协议同步元数据</td>
<td>TCP</td>
</tr>
<tr>
<td>Data节点间</td>
<td>8088</td>
<td>分片数据复制</td>
<td>TCP</td>
</tr>
<tr>
<td>Data→Meta节点</td>
<td>8091</td>
<td>注册节点&#x2F;获取分片元信息</td>
<td>HTTP</td>
</tr>
</tbody></table>
</li>
<li><p>核心交互场景<br><strong>节点注册</strong>  ：   Data节点启动时通过HTTP API向Meta节点注册（<code>POST /data</code>）<br><strong>分片分配</strong>  ：   Meta节点根据<code>replication-factor</code>策略分配分片到Data节点<br><strong>写入协调</strong>  ：   客户端写入数据时，由Meta节点确定目标分片所在Data节点<br><strong>故障转移</strong>  ：   Meta节点检测Data节点离线后，自动通过Hinted Handoff机制转移副本</p>
</li>
</ol>
<p>一个集群至少要有三个独立的元节点才能允许一个节点的丢失，如果要容忍n个节点的丢失则需要2n+1个元节点。集群的元节点的数目应该为奇数。不要是偶数元节点，因为这样在特定的配置下会导致故障。<br>一个集群运行只有一个数据节点，但这样数据就没有冗余了。这里的冗余通过写数据的RP中的副本个数来设置。一个集群在丢失n-1个数据节点后仍然能返回完整的数据，其中n是副本个数。为了在集群内实现最佳数据分配，我们建议数据节点的个数为偶数。</p>
<h3 id="术语-Glossary"><a href="#术语-Glossary" class="headerlink" title="术语 &#x2F; Glossary"></a>术语 &#x2F; Glossary</h3><ul>
<li>measurement：描述了存在关联field中的数据的意义，measurement是字符串。作为tag，fields和time列的容器。相当于MySQL的table，关系&#x2F;表的意思。单个measurement可以有不同的retention policy（即 一个measurement 中的不同 tag set 可以有不同的 retention policy，构成多组 series）</li>
<li>Continuous Query (CQ)是在数据库内部自动周期性跑着的一个InfluxQL的查询，CQs需要在SELECT语句中使用一个函数，并且一定包括一个GROUP BY time()语句。</li>
<li>Retention Policy (RP)是InfluxDB数据结构的一部分，描述了InfluxDB保存数据的长短，数据存在集群里面的副本数，以及shard group的时间范围。RPs在每个database里面是唯一的，？连同measurement和tag set定义一个series。当创建一个database时，InfluxDB会自动创建一个叫做autogen的retention policy，其duration为永远，replication factor为1，shard group的duration设为七天。<ul>
<li>duration：决定InfluxDB中数据保留多长时间。在duration之前的数据会自动从database中删除掉。</li>
<li>replication factor：决定在集群模式下数据的副本的个数。InfluxDB在N个数据节点上复制数据，其中N就是replication factor。</li>
<li>shard group duration决定了每个shard group跨越多少时间。具体间隔由retention policy中的SHARD DURATION决定。例如，如果retention policy的SHARD DURATION设置为1w，则每个shard group将跨越一周，并包含时间戳在该周内的所有点。</li>
</ul>
</li>
<li>series：InfluxDB数据结构的集合，一个特定的series由measurement，tag set和retention policy组成。！field set不是series的一部分</li>
<li>schema：数据在InfluxDB里面怎么组织。InfluxDB的schema的基础是database，retention policy，series，measurement，tag key，tag value以及field keys。</li>
<li>shard：包含实际的编码和压缩数据，并由磁盘上的TSM文件表示。 每个shard都属于唯一的一个shard group。多个shard可能存在于单个shard group中。每个shard包含一组特定的series。给定shard group中的给定series上的所有点将存储在磁盘上的相同shard（TSM文件）中。</li>
<li>shard group：是shard的逻辑组合。shard group由时间和retention policy组织。包含数据的每个retention policy至少包含一个关联的shard group。给定的shard group包含其覆盖的间隔的数据的所有shard。每个shard group跨越的间隔是shard的持续时间。</li>
</ul>
<h2 id="InfluxDB读写"><a href="#InfluxDB读写" class="headerlink" title="InfluxDB读写"></a>InfluxDB读写</h2><ol>
<li>命令行工具<ul>
<li>influx命令行连接本地InfluxDB：直接通过InfluxDB的HTTP接口(如果没有修改，默认是8086)来和InfluxDB通信。（说明：也可以直接发送裸的HTTP请求来操作数据库，例如curl）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ influx -precision rfc3339</span><br><span class="line">Connected to http://localhost:8086 version 1.2.x // </span><br><span class="line">InfluxDB shell 1.2.x</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
InfluxDB的HTTP接口默认起在8086上，所以influx默认也是连的本地的8086端口。-precision参数表明了任何返回的时间戳的格式和精度，如 rfc3339是让InfluxDB返回RFC339格式(YYYY-MM-DDTHH:MM:SS.nnnnnnnnnZ)的时间戳。</li>
<li>数据格式：将数据点写入InfluxDB，只需要遵守如下的行协议：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;measurement&gt;[,&lt;tag-key&gt;=&lt;tag-value&gt;...] &lt;field-key&gt;=&lt;field-value&gt;[,&lt;field2-key&gt;=&lt;field2-value&gt;...] [unix-nano-timestamp]</span><br></pre></td></tr></table></figure>
InfluxDB里存储的数据被称为时间序列数据，其包含一个数值。时序数据有零个或多个数据点，每一个都是一个指标值。数据点包括time(一个时间戳)，measurement(例如cpu_load)，至少一个k-v格式的field(也即指标的数值例如 “value&#x3D;0.64”或者“temperature&#x3D;21.2”)，零个或多个tag，其一般是对于这个指标值的元数据(例如“host&#x3D;server01”, “region&#x3D;EMEA”)。<br>可以将measurement类比于SQL里的table，其主键索引总是时间戳。tag和field是在table里的其他列，tag是被索引起来的，field没有。不同之处在于InfluxDB里，你可以有几百万的measurements，不用事先定义数据的scheme，且null值不会被存储。</li>
<li><strong>使用CLI插入单条的时间序列数据到InfluxDB中，用INSERT后跟数据点：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; use testdb</span><br><span class="line">Using database testdb</span><br><span class="line">&gt; INSERT cpu,host=serverA,region=us_west value=0.64</span><br></pre></td></tr></table></figure>
这样一个measurement为cpu，tag是host和region，value值为0.64的数据点被写入了InfluxDB中。</li>
<li>现在我们查出写入的这笔数据：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT <span class="string">&quot;host&quot;</span>, <span class="string">&quot;region&quot;</span>, <span class="string">&quot;value&quot;</span> FROM <span class="string">&quot;cpu&quot;</span></span><br><span class="line">name: cpu</span><br><span class="line">---------</span><br><span class="line">time                                     host         region   value</span><br><span class="line">2015-10-21T19:28:07.580664347Z  serverA      us_west     0.64</span><br><span class="line"></span><br><span class="line">&gt; delete FROM <span class="string">&quot;cpu&quot;</span> WHERE <span class="string">&quot;host&quot;</span> = <span class="string">&#x27;serverA&#x27;</span> <span class="comment"># 不带where将删除measurement所有数据</span></span><br></pre></td></tr></table></figure>
我们在写入的时候没有包含时间戳，当没有带时间戳的时候，InfluxDB会自动添加本地的当前时间作为它的时间戳。</li>
</ul>
</li>
<li>HTTP 请求<ul>
<li>写数据 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -XPOST <span class="string">&#x27;http://localhost:8086/write?db=mydb&#x27;</span> --data-binary <span class="string">&#x27;cpu_load_short,host=server01,region=us-west value=0.64 1434055562000000000&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>读数据 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -G <span class="string">&#x27;http://localhost:8086/query?pretty=true&#x27;</span> --data-urlencode <span class="string">&quot;db=mydb&quot;</span> --data-urlencode <span class="string">&quot;q=SELECT \&quot;value\&quot; FROM \&quot;cpu_load_short\&quot; WHERE \&quot;region\&quot;=&#x27;us-west&#x27;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>客户端库，InfluxDB 提供了多种编程语言的客户端库，如Python、Go、Java等，可以方便地在应用程序中读写数据。</li>
<li>采样和数据保留 <a target="_blank" rel="noopener" href="https://jasper-zhang1.gitbooks.io/influxdb/content/Guide/downsampling_and_retention.html">https://jasper-zhang1.gitbooks.io/influxdb/content/Guide/downsampling_and_retention.html</a></li>
</ol>
<h2 id="集群读写"><a href="#集群读写" class="headerlink" title="集群读写"></a>集群读写</h2><ul>
<li>分片Shard：<strong>InfluxDB集群读写的基本单位分片是时间序列数据的物理存储单位</strong>，每个分片包含一段时间范围内的数据。<br>复制因子为X，则在每个分片的数据同步到X个节点（部署influxdb的主机）上。<br>分片的划分依据是时间范围和数据的存储策略（Retention Policy）。在集群环境中，分片可以分布在不同的节点上，以实现数据的分布式存储和负载均衡。这样可以提高数据的读写性能和系统的可扩展性。<br>确定数据属于哪个分片的过程主要涉及以下几个步骤：数据写入时，首先根据时间戳确定属于哪个Shard Group（分片组）。然后，基于Measurement和Tag的值计算哈希值。最后，根据哈希值将数据分配到具体的分片。<blockquote>
<p>shard :&#x3D; shardGroup.shards[fnv.New64a(key) % len(shardGroup.Shards)]</p>
</blockquote>
</li>
<li>分片组Shard groups：集群在一个分片组内创建分片，以最大限度地利用数据节点的数量。<br>分片数计算：当集群有 N 个数据节点且副本因子为 X 时，每个分片组中会创建 floor(N&#x2F;X) 个分片（向下取整）<br>示例：若集群有 4 个数据节点，副本因子为 2，则每个分片组包含 4&#x2F;2&#x3D;2 个分片（每个分片在 2 个节点上复制）<!-- 这意味着每天都会为写入的数据创建一个新的shard组。？在每个shard组中创建2个shard。由于复制因子为2，这两个分片中的每一个都在2个服务器上复制。例如，我们有一个2016年09月19日的shard组，它有两个shard 1和2。将Shard 1复制到服务器A和B，将Shard 2复制到服务器C和D。写入值时，集群必须首先确定shard组中的哪个shard应该接收写入，通过对测量+排序标记集（元序列）进行散列并将桶存储到正确的分片中来完成。 --></li>
<li>集群写入：<br>假设一个HTTP写操作被发送到服务器D，数据属于分片1。写操作需要被复制到分片1的所有者：数据节点A和B。当写操作进入D时，该节点从其亚转移的本地缓存中确定需要将写操作复制到A和B，并立即尝试对两者进行写操作。<br>每个对HTTP API的请求都可以通过一致性查询参数指定一致性级别。 <a target="_blank" rel="noopener" href="https://docs.influxdata.com/enterprise_influxdb/v1/concepts/clustering/#write-consistency">https://docs.influxdata.com/enterprise_influxdb/v1/concepts/clustering/#write-consistency</a></li>
<li>集群查询：<br>根据查询的时间段和数据的复制因子进行分布的。例如，如果保留策略的复制因子为4，则接收查询的协调数据节点将随机选择存储该分片副本的4个数据节点中的任何一个来接收查询。如果我们假设系统的分片持续时间为一天，那么对于查询覆盖的每一天，协调节点都会选择一个数据节点来接收当天的查询。<br>协调节点尽可能在本地执行和完成查询。如果一个查询必须扫描多个shard组（在上面的例子中是多个天），协调节点将查询转发给其他节点，以查找本地没有的shard。查询与扫描自己的本地数据并行转发。查询被分发到尽可能多的节点，以查询每个分片组一次。当结果从每个数据节点返回时，协调数据节点将它们组合成返回给用户的最终结果。</li>
<li><strong>Shard Group 与 Shard 的实战示例：</strong><ol>
<li>场景描述，假设有以下配置：<br>Retention Policy:  Duration: 30d  | Replication Factor: 2  | Shard Group Duration: 1d，<br>集群数据节点: 4 个（A&#x2F;B&#x2F;C&#x2F;D）</li>
<li><strong>分片组创建</strong><br>时间划分：每天 00:00 自动创建新的分片组（如 2025-04-02 ~ 2025-04-03）<br>分片数：<code>4/2=2</code> 个分片（Shard 1 &amp; 2）</li>
<li><strong>分片分布</strong><br>分片 1    | 副本节点 A, B          | 存储内容  所有哈希值模2&#x3D;0的 Series Key 数据<br>分片 2    | 副本节点 C, D          | 存储内容  所有哈希值模2&#x3D;1的 Series Key 数据   </li>
<li>数据写入示例<br>当写入 <code>cpu,host=svr1 usage=80</code>：Series Key &#x3D; <code>cpu,host=svr1</code>，哈希值模2&#x3D;1 ⇒ 分片2，数据同时写入节点 C 和 D</li>
<li>数据查询流程<br>查询 <code>SELECT * FROM cpu WHERE time &gt; &#39;2025-04-02&#39;</code>：定位到 2025-04-02 分片组，  协调节点同时向 A&#x2F;B（分片1）和 C&#x2F;D（分片2）发起查询， 合并结果后返回</li>
</ol>
</li>
</ul>
<h2 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h2><p>Docker安装操作单例InfluxDB <a target="_blank" rel="noopener" href="https://www.cnblogs.com/nhdlb/p/16409849.html">https://www.cnblogs.com/nhdlb/p/16409849.html</a><br>Docker快速开始集群InfluxDB <a target="_blank" rel="noopener" href="https://github.com/chengshiwen/influxdb-cluster/wiki#docker-%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B">https://github.com/chengshiwen/influxdb-cluster/wiki#docker-%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B</a></p>
<p>在使用容器多节点部署InfluxDB时，数据库、容器、Docker、主机和Kubernetes（k8s）之间的关系可以理解如下：</p>
<ul>
<li>数据库（InfluxDB）：InfluxDB是一个时序数据库，用于存储和查询时间序列数据。在多节点部署中，InfluxDB可以运行在多个容器中，以实现高可用性和负载均衡。</li>
<li>容器：容器是一个轻量级、独立的运行环境，用于打包和运行应用程序及其依赖项。InfluxDB可以被打包成一个容器镜像，并在多个容器实例中运行。</li>
<li>Docker：Docker是一个容器化平台，用于创建、部署和管理容器。Docker负责启动和管理运行InfluxDB的容器。</li>
<li>主机：主机是运行Docker和容器的物理或虚拟机器。在多节点部署中，可能有多个主机，每个主机上运行一个或多个InfluxDB容器。</li>
<li>Kubernetes（k8s）：一个开源的容器编排平台，用于自动化部署、扩展和管理容器化应用程序。Kubernetes可以管理多个主机上的容器，提供服务发现、负载均衡、自动扩展和自愈能力。在多节点部署中，Kubernetes可以管理InfluxDB容器的部署，确保它们在多个节点上运行，并提供高可用性和扩展性。</li>
<li>关系总结：InfluxDB 作为数据库运行在 容器 中。容器 由 Docker 创建和管理。Docker 运行在 主机 上。Kubernetes 管理多个 主机 上的 Docker 容器，提供编排和管理功能。通过这种方式，InfluxDB可以在一个分布式环境中高效运行，利用Kubernetes的编排能力实现自动化管理和扩展。</li>
</ul>
<p>Kubernetes 存储与 InfluxDB Shard 的关系解析</p>
<ol>
<li><strong>PV&#x2F;PVC</strong>：是 Kubernetes 管理存储资源的抽象层。PV 描述物理存储资源（如 NFS、云盘等），PVC 是 Pod 对存储资源的请求声明。PVC 绑定到 PV 后，Pod 通过挂载 PVC 使用持久化存储。</li>
<li><strong>Shard</strong>：是 InfluxDB 存储引擎的物理存储单元，表现为磁盘上的 TSM 文件（Time-Structured Merge Tree），每个 Shard 对应一个时间范围内的时序数据块。Shard 的存储路径通常位于 PVC 挂载的 <code>/var/lib/influxdb/data</code> 目录下。<br>每个 Shard 包含：时间序列索引（.tsi 文件），压缩后的时序数据块（.tsm 文件），WAL（Write-Ahead Log）日志文件（.wal） 其路径结构为：<code>/var/lib/influxdb/data/&lt;database&gt;/&lt;retention_policy&gt;/&lt;shard_id&gt;</code>。</li>
<li>重建 PVC 导致数据丢失的本质问题<br>• <strong>PVC 删除与 PV 回收策略</strong>：若 PVC 的回收策略为 <code>Delete</code>（默认），删除 PVC 会导致 Kubernetes 清理其绑定的 PV 及底层存储数据（如 NFS 目录、云盘等）。此时 <code>/var/lib/influxdb</code> 下的 <code>data</code>、<code>meta</code> 目录被清空，导致 Shard 文件丢失。<br>• Shard 文件丢失会导致对应时间范围的时序数据不可查询，触发 <code>ERR: shard not found</code> 错误。<br>• Meta 文件丢失会破坏集群元数据一致性，导致用户权限、分片策略等配置失效。</li>
</ol>
<h2 id="InfluxDB-备份与恢复"><a href="#InfluxDB-备份与恢复" class="headerlink" title="InfluxDB 备份与恢复"></a>InfluxDB 备份与恢复</h2><p><a target="_blank" rel="noopener" href="https://docs.influxdata.com/enterprise_influxdb/v1/administration/backup-and-restore/">https://docs.influxdata.com/enterprise_influxdb/v1/administration/backup-and-restore/</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46560589/article/details/127748939">https://blog.csdn.net/weixin_46560589/article/details/127748939</a></p>
<p>InfluxDB Enterprise支持在集群实例、单个数据库和保留策略以及单个分片中备份和恢复数据。</p>
<ol>
<li>备份整个实例，即所有数据库（全量备份）。命令如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">influxd backup -portable /path/to/backup</span><br></pre></td></tr></table></figure></li>
<li>备份单个数据库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">influxd backup -portable -database &lt;database_name&gt; /path/to/backup</span><br></pre></td></tr></table></figure></li>
<li>增量备份：对于较大的数据集，可以进行增量备份，只备份自上次全量或增量备份以来的数据<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">influxd backup -portable -start &lt;timestamp&gt; /path/to/backup</span><br></pre></td></tr></table></figure></li>
</ol>
<p>备份的数据可以恢复到新实例或现有实例中。</p>
<ol>
<li>恢复整个实例，包括所有的数据库。命令如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">influxd restore -portable /path/to/backup</span><br></pre></td></tr></table></figure></li>
<li>恢复单个数据库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">influxd restore -portable -db &lt;database_name&gt; /path/to/backup</span><br></pre></td></tr></table></figure></li>
<li>有时你可能希望将备份的数据恢复到另一个数据库，可以使用 <code>-newdb</code> 选项来实现：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">influxd restore -portable -db &lt;old_database_name&gt; -newdb &lt;new_database_name&gt; /path/to/backup</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="导出和导入数据"><a href="#导出和导入数据" class="headerlink" title="导出和导入数据"></a>导出和导入数据</h2><p>对于大多数InfluxDB Enterprise应用程序，备份和恢复实用程序提供了备份和恢复策略所需的工具。但是，在某些情况下，标准备份和恢复实用程序可能无法充分处理应用程序中的大量数据。作为标准备份和恢复实用程序的替代方案，可以使用InfluxDB influx_inspect export和涌入-import命令为灾难恢复和备份策略创建备份和恢复过程。</p>
<ol>
<li>数据库导出：容器层面命令，指定 数据文件和 写前日志(WAL)文件的存储目录，将指定数据库中指定时间的数据导出到指定文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@influxdb-e2cb6c913a191e56c134e-data-0:/<span class="comment"># influx_inspect export -datadir &quot;/var/lib/influxdb/data&quot; -waldir &quot;/var/lib/influxdb/wal&quot; -out &quot;influxdb_test01_dump_out&quot; -database &quot;test01&quot; -start &quot;2024-10-22T00:00:00Z&quot;</span></span><br><span class="line">writing out tsm file data <span class="keyword">for</span> test01/autogen...complete.</span><br><span class="line">writing out wal file data <span class="keyword">for</span> test01/autogen...complete.</span><br><span class="line">root@influxdb-e2cb6c913a191e56c134e-data-0:/<span class="comment"># cat influxdb_test01_dump_out</span></span><br><span class="line"><span class="comment"># INFLUXDB EXPORT: 2024-10-22T00:00:00Z - 2262-04-11T23:47:16Z</span></span><br><span class="line"><span class="comment"># DDL</span></span><br><span class="line">CREATE DATABASE test01 WITH NAME autogen</span><br><span class="line"><span class="comment"># DML</span></span><br><span class="line"><span class="comment"># CONTEXT-DATABASE:test01</span></span><br><span class="line"><span class="comment"># CONTEXT-RETENTION-POLICY:autogen</span></span><br><span class="line"><span class="comment"># writing tsm data</span></span><br><span class="line">temp,location=room1 value=24.5 1729589246099070937</span><br><span class="line">temp,location=room2 value=22.5 1729589253425715740</span><br><span class="line">temp,location=room3 value=22 1729649010554978701</span><br><span class="line"><span class="comment"># writing wal data</span></span><br></pre></td></tr></table></figure></li>
<li>数据库导入：容器层面执行命令，使用admin账号，指定文件、数据库、时间戳精度<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@influxdb-e73f149ff7192bd87d190-data-1:/<span class="comment"># influx -import -path=&#x27;influxdb_test01_dump_out&#x27; -precision=ns -username=&#x27;&#x27; -password=&#x27;&#x27;</span></span><br><span class="line">2024/10/25 03:21:47 Processed 1 commands</span><br><span class="line">2024/10/25 03:21:47 Processed 2 inserts</span><br><span class="line">2024/10/25 03:21:47 Failed 0 inserts</span><br></pre></td></tr></table></figure></li>
<li>实例导出：把influxdb集群实例中所有数据库的数据导出，不加 <code>-database</code>，加 <code>-compress</code></li>
<li>实例导入：加<code>-compressed</code> 导入压缩文件，本质上是先解压后倒入</li>
</ol>
<h2 id="InfluxDB节点迁移"><a href="#InfluxDB节点迁移" class="headerlink" title="InfluxDB节点迁移"></a>InfluxDB节点迁移</h2><p>Data节点迁移方案评审：先迁移后逐个恢复分片数据。已验证在分片副本大小70M、写入数据达2000point&#x2F;s的情况下直接copy-shard会导致增量数据丢失，考虑在copy-shard前先执行truncate-shards截断热分片（集群中所有写入最新数据的分片，截断后关闭写入，变成冷分片），并在所有Data节点上创建该分片的新热分片副本，也就是在迁移节点上恢复了全部原有分片的新热分片副本，最新数据写入这个副本，然后再逐个从健康节点上的冷分片副本copy-shard恢复出分片的历史数据（迁移前分片副本原有的数据&amp;迁移过程中未能写入的数据），该分片数据完全恢复；自测符合预期</p>
<ol>
<li>在做迁移操作前，先记录迁移节点拥有的分片副本，后续从健康节点的相同副本中恢复出来；<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -i influxdb-xx-meta-0 -n influxdb -- influxd-ctl show-shards <span class="comment"># 或influx命令行执行show shards</span></span><br></pre></td></tr></table></figure></li>
<li>迁移后更新节点&#x2F;分片元信息，新data-0节点丢失db1的shard3，另外_internal的db1转移到健康节点data-1上了<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -i influxdb-xx-meta-0 -n influxdb -- influxd-ctl remove-data influxdb-xx-data-0.influxdb-xx-data:8088</span><br><span class="line">kubectl <span class="built_in">exec</span> -i influxdb-xx-meta-0 -n influxdb -- influxd-ctl add-data influxdb-xx-data-0.influxdb-xx-data:8088</span><br></pre></td></tr></table></figure></li>
<li>持续写入数据到db1(只能写入健康节点上的db1分片副本)，某一时刻执行truncate-shards，db1的shard3切断，新热分片shard4的分片副本分配到data-1以及迁移后的data-0中，此刻开始写入db1的新数据在data-0和data-1上的分片中一致（一个数据库的分片可能有多个，但只有一个正在写入，其他都是冷分片）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -i influxdb-xx-meta-0 -n influxdb -- influxd-ctl truncate-shards</span><br></pre></td></tr></table></figure></li>
<li>最后再恢复历史数据，也就是执行迁移前的data-0节点拥有的分片副本数据，以及迁移完成前应该写入但没有写入data-0的数据。从健康的data-1上的分片副本copy-shard而来，导出文件可见data-0和data-1上的db1数据完全一致<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于_internal分片的转移 先copy后remove</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -i influxdb-xx-meta-0 -n influxdb -- influxd-ctl copy-shard influxdb-xx-data-1.influxdb-xx-data:8088 influxdb-xx-data-0.influxdb-xx-data:8088 1</span><br><span class="line">kubectl <span class="built_in">exec</span> -i influxdb-xx-meta-0 -n influxdb -- influxd-ctl remove-shard influxdb-xx-data-1.influxdb-xx-data:8088 1</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分片的物理文件 wal&amp;tsm</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -i influxdb-xx-data-0 -n influxdb -- <span class="built_in">ls</span> /var/lib/influxdb/data</span><br><span class="line">kubectl <span class="built_in">exec</span> -i influxdb-xx-data-0 -n influxdb -- <span class="built_in">ls</span> /var/lib/influxdb/wal</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可能要等wal落tsm</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -i influxdb-xx-data-0 -n influxdb -- influx_inspect <span class="built_in">export</span> -datadir <span class="string">&quot;/var/lib/influxdb/data&quot;</span> -waldir <span class="string">&quot;/var/lib/influxdb/wal&quot;</span> -out <span class="string">&quot;influxdb_dump_out&quot;</span> -database <span class="string">&quot;db1&quot;</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -i influxdb-xx-data-0 -n influxdb -- <span class="built_in">md5sum</span> influxdb_dump_out</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/22/InfluxDB/" data-id="cm7ri7u61000550v5ebkja95s" data-title="InfluxDB" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/10/22/Docker_Kubernetes/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Kubernetes
        
      </div>
    </a>
  
  
    <a href="/2024/09/22/Golang/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Golang</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2046/12/">December 2046</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2046/08/">August 2046</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2046/12/30/nice-photo/">Nice Photo</a>
          </li>
        
          <li>
            <a href="/2046/08/27/Guitar/">Guitar 🎸</a>
          </li>
        
          <li>
            <a href="/2024/10/22/Docker_Kubernetes/">Kubernetes</a>
          </li>
        
          <li>
            <a href="/2024/09/22/InfluxDB/">InfluxDB</a>
          </li>
        
          <li>
            <a href="/2024/09/22/Golang/">Golang</a>
          </li>
        
          <li>
            <a href="/2024/08/18/%E7%90%86%E8%B4%A2/">Lic Ai</a>
          </li>
        
          <li>
            <a href="/2024/07/07/%E7%BE%8E%E7%9A%84Midea/">美 的 Midea</a>
          </li>
        
          <li>
            <a href="/2024/05/01/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/">毕 业 设 计</a>
          </li>
        
          <li>
            <a href="/2024/01/11/RabbitMQ/">RabbitMQ</a>
          </li>
        
          <li>
            <a href="/2024/01/07/SpringCloud/">SpringCloud</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 fengcai<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>