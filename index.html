<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Qué miras Bobo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Qué miras Bobo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Qué miras Bobo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="fengcai">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Qué miras Bobo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="https://github.com/leo710aka/bk/blob/main/DT1.jpg?raw=true">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Qué miras Bobo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-nice-photo" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2046/12/30/nice-photo/" class="article-date">
  <time class="dt-published" datetime="2046-12-30T03:11:00.000Z" itemprop="datePublished">2046-12-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2046/12/30/nice-photo/">Nice Photo</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <br>
<br>
<img src="https://leo710aka.github.io/bk/bk.jpg" width="550" height="300" alt="">
<!-- <div style="text-align:center;text-shadow: 2px 2px 2px #888888;">Old Master</div> -->
<br>
<img src="https://leo710aka.github.io/bk/zq.jpg" width="550" height="300" alt="">
<br>
<img src="https://leo710aka.github.io/bk/3.jpg" width="550" height="300" alt="">
<br>
<!-- <img src="https://leo710aka.github.io/bk/4.jpg" width="750" height="300" alt=""> -->
<!-- <img src="https://leo710aka.github.io/bk/zq2.jpg" width="550" height="200" alt="">
<br>
<br>
<img src="https://leo710aka.github.io/bk/zq3.jpg" width="550" height="200" alt="">
<br> -->
<!-- <div style="display: flex; justify-content: center;">
    <img src="https://leo710aka.github.io/bk/zq2.jpg" style="width: 100%; margin-right: 5px;">
    <img src="https://leo710aka.github.io/bk/zq3.jpg" style="width: 100%; margin-left: 5px;">
</div> -->
<img src="https://leo710aka.github.io/bk/zq2.jpg" width="550" height="300" alt="">
<br>
<img src="https://leo710aka.github.io/bk/zq3.jpg" width="550" height="300" alt="">
<br>
<br>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2046/12/30/nice-photo/" data-id="cm3lnru63000of0v5hwdv2zbx" data-title="Nice Photo" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Guitar" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2046/08/27/Guitar/" class="article-date">
  <time class="dt-published" datetime="2046-08-27T13:55:11.000Z" itemprop="datePublished">2046-08-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2046/08/27/Guitar/">Guitar 🎸</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="指板"><a href="#指板" class="headerlink" title="指板"></a>指板</h2><img src="https://picx.zhimg.com/80/v2-05339b6d9510209ea9ca02a75c325c4f_720w.webp" width="575" height="300" alt="chords">
<br>
在乐音体系中，七个具有独立名称的音级叫做基本音级（也叫自然音级）。
基本音级用“C、D、E、F、G、A、B”七个字母来表示，这就是基本音级的<b>音名</b>。
<b>唱名</b>是人们在演唱音乐的谱子时所使用的名称，即：“Do，Re，Mi，Fa，Sol，La，Si” 这七个唱名。
<br>
<img src="https://picx.zhimg.com/80/v2-5ef1b97ef6814aa577390b0f422f2735_720w.webp" width="475" height="300" alt="简谱上 唱名、音名的表示">
<br>
<b>十二平均律</b>，是将一个八度的音程等分成十二个半音的律制，各相邻两律之间的波长之比完全相等。一等份为一个半音(小二度)，对应吉他一品的距离。两等份为一个全音(大二度)。将一个八度分成12等份有着惊人的一些巧合，这是因为它的纯五度音程的两个音的波长比为(1/2)^(7/12)≈0.6674，与2/3≈0.6667非常接近。
<img src="https://pic2.zhimg.com/80/v2-288e079f27e141774b5ba1736da17af7_720w.webp" width="350" height="300" alt="一个八度内 全全半全全全半">

<p>C大调音阶在吉他指板上可以有不同的把位 <a target="_blank" rel="noopener" href="https://www.zhihu.com/tardis/zm/art/496745355?source_id=1005">https://www.zhihu.com/tardis/zm/art/496745355?source_id=1005</a><br><img src="https://pic1.zhimg.com/80/v2-c23f869bcd3573fe54cb71fb6507aebc_720w.webp" width="475" height="300" alt="C大调音阶图"></p>
<h2 id="乐理"><a href="#乐理" class="headerlink" title="乐理"></a>乐理</h2><p>HUB GUITAR: <a target="_blank" rel="noopener" href="https://hubguitar.com/zh_han/music-theory">https://hubguitar.com/zh_han/music-theory</a> 指板: <a target="_blank" rel="noopener" href="https://hubguitar.com/zh_han/fretboard">https://hubguitar.com/zh_han/fretboard</a></p>
<p>弹奏第一品位上的B弦，这就是 C音，一个以一定频率振动的音波。接下来你拨第十三品的同一根弦，同样地，它听上去好像是同一个音，但这个音高更高。这是因为声波的振动是原来的两倍之快，可以表达为1:2， 它们是有同一特性的音。如果两种不同的乐器同时弹奏C音，这个比例是1:1，这称为 同音。在下图中，第一品的音符将会是最左边的C，第十三品的音则是在最右边。所有在这两者之间的音符都是特定的音符，但一旦重新回到C音，就重新按照这个顺序继续下去。<br><img src="https://hubguitar.com//images/the-musical-alphabet.png"></p>
<p><strong>音程</strong>：就是两个音符之间的高低关系。在较低的一个 “C” 音和另一个较高的 “C” 音之间的音程就是 八度（八音音阶）。八度是音高的基本来源，其余的还包括将它分成更小的部分而得到的音高，称为 音数。半音就是移动一格，从 C 到 C♯。全音移动两格，从 C 到 D。 大多数现代音乐将八度分割为12级，如图所示，你可以按照这个音符的顺序来弹奏，从第一品的 B 弦开始，每次移动一个品位，直到第十三品，重新回到 C，一边弹奏一边大声说出这个音符的名字。所有这十二个音符一起组成了 半音音阶。音阶就是音符的顺序，并且没有重复的音符，所有的音符以升序，从低到高的顺序来弹奏。</p>
<p><strong>根音</strong>？它就是一首歌的主调音，它是一个单音，其余的东西全在它的基础上变化，想像它是重力中心，它是一种吸引力，吸引着一首歌曲里其余所有的音，不管什么情况下都会回到根音上来。</p>
<h2 id="谱子"><a href="#谱子" class="headerlink" title="谱子"></a>谱子</h2><br>
<div style="display: flex; justify-content: space-around;">
    <img src="https://pic4.zhimg.com/80/v2-24c56092ae6d3db3f549e43db567c641_720w.webp" width="550" height="300" alt="">
    <img src="https://pica.zhimg.com/80/v2-641a56efd1addd3d667a97c7e414952e_720w.webp" width="550" height="300" alt="">
    <img src="https://pic4.zhimg.com/80/v2-1b9c2fe17cff4da5c4c4c706f10f5efb_720w.webp" width="550" height="300" alt="">
</div>

<div style="display: flex; justify-content: space-around;">
    <img src="https://pic1.zhimg.com/80/v2-fbc32cea2510f17af26f01c8669c67c8_720w.webp" width="550" height="300" alt="">
    <img src="https://pic4.zhimg.com/80/v2-2bfb757b3f8b47a7b7774660db0b750d_720w.webp" width="550" height="300" alt="">
    <img src="https://picx.zhimg.com/80/v2-0445476bb9d9077872debb83d4cd8857_720w.webp" width="550" height="300" alt="">
</div>

<blockquote>
<p>红豆 - 方大同</p>
</blockquote>
<div style="display: flex; justify-content: space-around;">
    <img src="https://pic2.zhimg.com/80/v2-183d0eb2a71fbc33812e2f54460f7969_720w.webp" width="550" height="300" alt="">
    <img src="https://picx.zhimg.com/80/v2-22fce8698cf92f174ecf81820e74d2d9_720w.webp" width="550" height="300" alt="">
    <img src="https://pic1.zhimg.com/80/v2-7daea7e2b74b31031a70c230cdd30fc0_720w.webp" width="550" height="300" alt="">
</div>

<blockquote>
<p>Hey Jued - The Beatles</p>
</blockquote>
<div style="display: flex; justify-content: space-around;">
    <img src="https://picx.zhimg.com/80/v2-72b358faba023c900a22a5642e3a3115_720w.webp" width="550" height="300" alt="">
    <img src="https://picx.zhimg.com/80/v2-2457aa5d0465be0c3dbfd53e4f6ec85b_720w.webp" width="550" height="300" alt="">
</div>

<blockquote>
<p>小情歌 - 苏打绿 <a href="https://www.bilibili.com/video/BV1R64y1p7WB/?spm_id_from=333.337.search-card.all.click&vd_source=ff210768dfaee27c0d74f9c8c50d7274" target="_blank">https://www.bilibili.com/video/BV1R64y1p7WB/</a></p>
</blockquote>
<img src="https://www.jitabang.com/img/2022/03/2022031203241555.png" width="550" height="300" alt="">
<img src="https://picx.zhimg.com/80/v2-5943b24a54e14501cb542a54b60ce55d_720w.webp?source=d16d100b" width="550" height="300" alt="">
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2046/08/27/Guitar/" data-id="cm3lnru5x0003f0v50qbu37e9" data-title="Guitar 🎸" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-InfluxDB" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/22/InfluxDB/" class="article-date">
  <time class="dt-published" datetime="2024-09-22T05:34:33.000Z" itemprop="datePublished">2024-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/22/InfluxDB/">InfluxDB | DBAdvanced</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <!-- # InfluxDB -->

<p><strong>InfluxDB</strong> 是一个由InfluxData开发的开源时序型数据库，专注于海量时序数据的高性能读、高性能写、高效存储与实时分析等；<br>在DB-Engines Ranking时序型数据库排行榜上排名第一，广泛应用于DevOps监控、IoT监控、实时分析等场景。<br><a target="_blank" rel="noopener" href="https://jasper-zhang1.gitbooks.io/influxdb/content/Introduction/getting_start.html">https://jasper-zhang1.gitbooks.io/influxdb/content/Introduction/getting_start.html</a></p>
<p><em><strong>influxdb-cluster</strong></em> 是InfluxDB的集群版本，InfluxDB Enterprise 的开源替代方案，设计用于大规模数据存储和高可用性需求。<br>可以实现数据的分片和复制，从而提高系统的可用性和扩展性。数据安全。operator缺失<br><a target="_blank" rel="noopener" href="https://github.com/chengshiwen/influxdb-cluster/wiki">https://github.com/chengshiwen/influxdb-cluster/wiki</a></p>
<h3 id="集群体系结构"><a href="#集群体系结构" class="headerlink" title="集群体系结构"></a>集群体系结构</h3><p>InfluxDB Enterprise由两组软件进程组成： Data 数据节点 和 Meta 元节点。集群内的通信是这样的：</p>
<div style="display: flex; justify-content: space-around;">
  <img src="https://pic3.zhimg.com/80/v2-6685cdf3df810ad3e5ae44d4e1a9df22_720w.webp" width="450" height="300" alt="">
  <img src="https://pic4.zhimg.com/80/v2-abb99833337f84b3850e0f6484f013ef_720w.webp" width="450" height="300" alt="">
</div>

<p>influxdb使用的默认端口号为分别为用于meta集群内部服务的8091端口，meta节点通信的8089端口，data集群内部服务的8088端口，以及data节点对外提供http服务的8086端</p>
<ul>
<li>Meta 节点通过 TCP 协议和 Raft 共识协议相互通信，默认都使用端口 8089，此端口必须在 Meta 节点之间是可访问的。默认 Meta 节点还将公开绑定到端口 8091 的 HTTP API，influxd-ctl 命令使用该 API。</li>
<li>Data 节点通过绑定到端口 8088 的 TCP 协议相互通信。Data 节点通过绑定到 8091 的 HTTP API 与 Meta 节点通信。这些端口必须在 Meta 节点和 Data 节点之间是可访问的。</li>
<li>在集群内，所有 Meta 节点都必须与所有其它 Meta 节点通信。所有 Data 节点必须与所有其它 Data 节点和所有 Meta 节点通信。</li>
</ul>
<h3 id="Where-data-lives"><a href="#Where-data-lives" class="headerlink" title="Where data lives"></a>Where data lives</h3><p>InfluxDB 集群中，一个节点要么是专门用于存储和查询时间序列数据的数据节点，要么是专门用于存储集群元数据的元节点。数据节点负责存储实际的数据和处理查询请求，而元节点则负责管理集群的元数据，包括节点信息、数据库和保留策略等。</p>
<p>元节点保存以下所有元数据：</p>
<ul>
<li>集群中的所有节点及其角色</li>
<li>集群中存在的所有数据库和保留策略</li>
<li>所有分片和分片组，以及它们存在于哪些节点上</li>
<li>集群用户及其权限</li>
<li>所有连续查询</li>
</ul>
<p>元节点将这些数据保存在磁盘上的Raft数据库中，由BoltDB提供支持。默认情况下，Raft数据库是&#x2F;var&#x2F;lib&#x2F;influxdb&#x2F;meta&#x2F;raft.db。<br>注意：Meta节点需要&#x2F; Meta目录。</p>
<p>数据节点保存所有原始时间序列数据和元数据，包括：</p>
<ul>
<li>measurements</li>
<li>tag keys and values</li>
<li>field keys and values</li>
</ul>
<p>在磁盘上，数据总是按照<database>&#x2F;<retention_policy>&#x2F;<shard_id>组织。默认父目录为&#x2F;var&#x2F;lib&#x2F;influxdb&#x2F;data。注意：数据节点需要&#x2F;var&#x2F;lib&#x2F;influxdb&#x2F;的所有四个子目录，包括&#x2F;meta(specifically, the clients.json file)、&#x2F;data、&#x2F;wal和&#x2F;hh。</p>
<p>一个集群至少要有三个独立的元节点才能允许一个节点的丢失，如果要容忍n个节点的丢失则需要2n+1个元节点。集群的元节点的数目应该为奇数。不要是偶数元节点，因为这样在特定的配置下会导致故障。<br>一个集群运行只有一个数据节点，但这样数据就没有冗余了。这里的冗余通过写数据的RP中的副本个数来设置。一个集群在丢失n-1个数据节点后仍然能返回完整的数据，其中n是副本个数。为了在集群内实现最佳数据分配，我们建议数据节点的个数为偶数。</p>
<h3 id="术语-Glossary"><a href="#术语-Glossary" class="headerlink" title="术语 &#x2F; Glossary"></a>术语 &#x2F; Glossary</h3><ul>
<li>measurement：描述了存在关联field中的数据的意义，measurement是字符串。作为tag，fields和time列的容器。相当于MySQL的table，关系&#x2F;表的意思。单个measurement可以有不同的retention policy（即 一个measurement 中的不同 tag set 可以有不同的 retention policy，构成多组 series）</li>
<li>Continuous Query (CQ)是在数据库内部自动周期性跑着的一个InfluxQL的查询，CQs需要在SELECT语句中使用一个函数，并且一定包括一个GROUP BY time()语句。</li>
<li>Retention Policy (RP)是InfluxDB数据结构的一部分，描述了InfluxDB保存数据的长短，数据存在集群里面的副本数，以及shard group的时间范围。RPs在每个database里面是唯一的，？连同measurement和tag set定义一个series。当创建一个database时，InfluxDB会自动创建一个叫做autogen的retention policy，其duration为永远，replication factor为1，shard group的duration设为七天。<ul>
<li>duration：决定InfluxDB中数据保留多长时间。在duration之前的数据会自动从database中删除掉。</li>
<li>replication factor：决定在集群模式下数据的副本的个数。InfluxDB在N个数据节点上复制数据，其中N就是replication factor。</li>
<li>shard group duration决定了每个shard group跨越多少时间。具体间隔由retention policy中的SHARD DURATION决定。例如，如果retention policy的SHARD DURATION设置为1w，则每个shard group将跨越一周，并包含时间戳在该周内的所有点。</li>
</ul>
</li>
<li>series：InfluxDB数据结构的集合，一个特定的series由measurement，tag set和retention policy组成。！field set不是series的一部分</li>
<li>schema：数据在InfluxDB里面怎么组织。InfluxDB的schema的基础是database，retention policy，series，measurement，tag key，tag value以及field keys。</li>
<li>shard：包含实际的编码和压缩数据，并由磁盘上的TSM文件表示。 每个shard都属于唯一的一个shard group。多个shard可能存在于单个shard group中。每个shard包含一组特定的series。给定shard group中的给定series上的所有点将存储在磁盘上的相同shard（TSM文件）中。</li>
<li>shard group：是shard的逻辑组合。shard group由时间和retention policy组织。包含数据的每个retention policy至少包含一个关联的shard group。给定的shard group包含其覆盖的间隔的数据的所有shard。每个shard group跨越的间隔是shard的持续时间。</li>
</ul>
<h2 id="InfluxDB读写"><a href="#InfluxDB读写" class="headerlink" title="InfluxDB读写"></a>InfluxDB读写</h2><ol>
<li>命令行工具<ul>
<li>influx命令行连接本地InfluxDB：直接通过InfluxDB的HTTP接口(如果没有修改，默认是8086)来和InfluxDB通信。（说明：也可以直接发送裸的HTTP请求来操作数据库，例如curl）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ influx -precision rfc3339</span><br><span class="line">Connected to http://localhost:8086 version 1.2.x // </span><br><span class="line">InfluxDB shell 1.2.x</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
InfluxDB的HTTP接口默认起在8086上，所以influx默认也是连的本地的8086端口。-precision参数表明了任何返回的时间戳的格式和精度，如 rfc3339是让InfluxDB返回RFC339格式(YYYY-MM-DDTHH:MM:SS.nnnnnnnnnZ)的时间戳。</li>
<li>数据格式：将数据点写入InfluxDB，只需要遵守如下的行协议：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;measurement&gt;[,&lt;tag-key&gt;=&lt;tag-value&gt;...] &lt;field-key&gt;=&lt;field-value&gt;[,&lt;field2-key&gt;=&lt;field2-value&gt;...] [unix-nano-timestamp]</span><br></pre></td></tr></table></figure>
InfluxDB里存储的数据被称为时间序列数据，其包含一个数值。时序数据有零个或多个数据点，每一个都是一个指标值。数据点包括time(一个时间戳)，measurement(例如cpu_load)，至少一个k-v格式的field(也即指标的数值例如 “value&#x3D;0.64”或者“temperature&#x3D;21.2”)，零个或多个tag，其一般是对于这个指标值的元数据(例如“host&#x3D;server01”, “region&#x3D;EMEA”)。<br>可以将measurement类比于SQL里的table，其主键索引总是时间戳。tag和field是在table里的其他列，tag是被索引起来的，field没有。不同之处在于InfluxDB里，你可以有几百万的measurements，不用事先定义数据的scheme，且null值不会被存储。</li>
<li>使用CLI插入单条的时间序列数据到InfluxDB中，用INSERT后跟数据点：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; use testdb</span><br><span class="line">Using database testdb</span><br><span class="line">&gt; INSERT cpu,host=serverA,region=us_west value=0.64</span><br></pre></td></tr></table></figure>
这样一个measurement为cpu，tag是host和region，value值为0.64的数据点被写入了InfluxDB中。</li>
<li>现在我们查出写入的这笔数据：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT <span class="string">&quot;host&quot;</span>, <span class="string">&quot;region&quot;</span>, <span class="string">&quot;value&quot;</span> FROM <span class="string">&quot;cpu&quot;</span></span><br><span class="line">name: cpu</span><br><span class="line">---------</span><br><span class="line">time                                     host         region   value</span><br><span class="line">2015-10-21T19:28:07.580664347Z  serverA      us_west     0.64</span><br><span class="line"></span><br><span class="line">&gt; delete FROM <span class="string">&quot;cpu&quot;</span> WHERE <span class="string">&quot;host&quot;</span> = <span class="string">&#x27;serverA&#x27;</span> <span class="comment"># 不带where将删除measurement所有数据</span></span><br></pre></td></tr></table></figure>
我们在写入的时候没有包含时间戳，当没有带时间戳的时候，InfluxDB会自动添加本地的当前时间作为它的时间戳。</li>
</ul>
</li>
<li>HTTP 请求<ul>
<li>写数据 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -XPOST <span class="string">&#x27;http://localhost:8086/write?db=mydb&#x27;</span> --data-binary <span class="string">&#x27;cpu_load_short,host=server01,region=us-west value=0.64 1434055562000000000&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>读数据 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -G <span class="string">&#x27;http://localhost:8086/query?pretty=true&#x27;</span> --data-urlencode <span class="string">&quot;db=mydb&quot;</span> --data-urlencode <span class="string">&quot;q=SELECT \&quot;value\&quot; FROM \&quot;cpu_load_short\&quot; WHERE \&quot;region\&quot;=&#x27;us-west&#x27;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>客户端库，InfluxDB 提供了多种编程语言的客户端库，如Python、Go、Java等，可以方便地在应用程序中读写数据。</li>
<li>采样和数据保留 <a target="_blank" rel="noopener" href="https://jasper-zhang1.gitbooks.io/influxdb/content/Guide/downsampling_and_retention.html">https://jasper-zhang1.gitbooks.io/influxdb/content/Guide/downsampling_and_retention.html</a></li>
</ol>
<h2 id="集群读写"><a href="#集群读写" class="headerlink" title="集群读写"></a>集群读写</h2><ol>
<li>分片Shard：InfluxDB集群读写的基本单位分片是时间序列数据的物理存储单位，每个分片包含一段时间范围内的数据。分片的划分依据是时间范围和数据的存储策略（Retention Policy）。在集群环境中，分片可以分布在不同的节点上，以实现数据的分布式存储和负载均衡。这样可以提高数据的读写性能和系统的可扩展性。复制因子为X，则在每个分片的数据同步到X个节点（部署influxdb的主机）上<br>确定数据属于哪个分片的过程主要涉及以下几个步骤：数据写入时，首先根据时间戳确定属于哪个Shard Group（分片组）。然后，基于Measurement和Tag的值计算哈希值。最后，根据哈希值将数据分配到具体的分片。<blockquote>
<p>shard :&#x3D; shardGroup.shards[fnv.New64a(key) % len(shardGroup.Shards)]</p>
</blockquote>
</li>
<li>分片组Shard groups：集群在一个分片组内创建分片，以最大限度地利用数据节点的数量。如果集群中有N个数据节点，复制因子为X，则在每个分片组中创建N&#x2F;X个分片，丢弃任何分数（？余数）<br>这意味着每天都会为写入的数据创建一个新的shard组。？在每个shard组中创建2个shard。由于复制因子为2，这两个分片中的每一个都在2个服务器上复制。例如，我们有一个2016年09月19日的shard组，它有两个shard 1和2。将Shard 1复制到服务器A和B，将Shard 2复制到服务器C和D。写入值时，集群必须首先确定shard组中的哪个shard应该接收写入，通过对测量+排序标记集（元序列）进行散列并将桶存储到正确的分片中来完成。</li>
<li>集群写入：<br>假设一个HTTP写操作被发送到服务器D，数据属于分片1。写操作需要被复制到分片1的所有者：数据节点A和B。当写操作进入D时，该节点从其亚转移的本地缓存中确定需要将写操作复制到A和B，并立即尝试对两者进行写操作。<br>每个对HTTP API的请求都可以通过一致性查询参数指定一致性级别。 <a target="_blank" rel="noopener" href="https://docs.influxdata.com/enterprise_influxdb/v1/concepts/clustering/#write-consistency">https://docs.influxdata.com/enterprise_influxdb/v1/concepts/clustering/#write-consistency</a></li>
<li>集群查询：<br>根据查询的时间段和数据的复制因子进行分布的。例如，如果保留策略的复制因子为4，则接收查询的协调数据节点将随机选择存储该分片副本的4个数据节点中的任何一个来接收查询。如果我们假设系统的分片持续时间为一天，那么对于查询覆盖的每一天，协调节点都会选择一个数据节点来接收当天的查询。<br>协调节点尽可能在本地执行和完成查询。如果一个查询必须扫描多个shard组（在上面的例子中是多个天），协调节点将查询转发给其他节点，以查找本地没有的shard。查询与扫描自己的本地数据并行转发。查询被分发到尽可能多的节点，以查询每个分片组一次。当结果从每个数据节点返回时，协调数据节点将它们组合成返回给用户的最终结果。</li>
</ol>
<h2 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h2><p>Docker安装操作单例InfluxDB <a target="_blank" rel="noopener" href="https://www.cnblogs.com/nhdlb/p/16409849.html">https://www.cnblogs.com/nhdlb/p/16409849.html</a><br>Docker快速开始集群InfluxDB <a target="_blank" rel="noopener" href="https://github.com/chengshiwen/influxdb-cluster/wiki#docker-%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B">https://github.com/chengshiwen/influxdb-cluster/wiki#docker-%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B</a></p>
<p>InfluxDB部署需要的配置</p>
<ul>
<li>CPU：是指InfluxDB所部署的主机的CPU资源。具体需求取决于你的数据写入和查询负载。一般来说，至少需要2个vCPU，但对于高负载场景，可能需要更多的CPU资源。</li>
<li>内存：InfluxDB对内存的需求也取决于数据量和查询复杂度。最低配置通常为2GB内存，但对于生产环境，建议至少8GB或更多。</li>
<li>节点：在Kubernetes中，节点是运行容器的主机。多节点部署可以提高系统的高可用性和扩展性。</li>
<li>IOPS：InfluxDB对磁盘I&#x2F;O性能有一定要求，特别是在高写入速率的场景下。建议使用SSD来提高I&#x2F;O性能。</li>
</ul>
<p>在使用容器多节点部署InfluxDB时，数据库、容器、Docker、主机和Kubernetes（k8s）之间的关系可以理解如下：</p>
<ul>
<li>数据库（InfluxDB）：InfluxDB是一个时序数据库，用于存储和查询时间序列数据。在多节点部署中，InfluxDB可以运行在多个容器中，以实现高可用性和负载均衡。</li>
<li>容器：容器是一个轻量级、独立的运行环境，用于打包和运行应用程序及其依赖项。InfluxDB可以被打包成一个容器镜像，并在多个容器实例中运行。</li>
<li>Docker：Docker是一个容器化平台，用于创建、部署和管理容器。Docker负责启动和管理运行InfluxDB的容器。</li>
<li>主机：主机是运行Docker和容器的物理或虚拟机器。在多节点部署中，可能有多个主机，每个主机上运行一个或多个InfluxDB容器。</li>
<li>Kubernetes（k8s）：一个开源的容器编排平台，用于自动化部署、扩展和管理容器化应用程序。Kubernetes可以管理多个主机上的容器，提供服务发现、负载均衡、自动扩展和自愈能力。在多节点部署中，Kubernetes可以管理InfluxDB容器的部署，确保它们在多个节点上运行，并提供高可用性和扩展性。</li>
<li>关系总结：InfluxDB 作为数据库运行在 容器 中。容器 由 Docker 创建和管理。Docker 运行在 主机 上。Kubernetes 管理多个 主机 上的 Docker 容器，提供编排和管理功能。通过这种方式，InfluxDB可以在一个分布式环境中高效运行，利用Kubernetes的编排能力实现自动化管理和扩展。</li>
</ul>
<h2 id="InfluxDB-备份与恢复"><a href="#InfluxDB-备份与恢复" class="headerlink" title="InfluxDB 备份与恢复"></a>InfluxDB 备份与恢复</h2><p><a target="_blank" rel="noopener" href="https://docs.influxdata.com/enterprise_influxdb/v1/administration/backup-and-restore/">https://docs.influxdata.com/enterprise_influxdb/v1/administration/backup-and-restore/</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46560589/article/details/127748939">https://blog.csdn.net/weixin_46560589/article/details/127748939</a></p>
<p>InfluxDB Enterprise支持在集群实例、单个数据库和保留策略以及单个分片中备份和恢复数据。</p>
<ol>
<li>备份整个实例，即所有数据库（全量备份）。命令如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">influxd backup -portable /path/to/backup</span><br></pre></td></tr></table></figure></li>
<li>备份单个数据库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">influxd backup -portable -database &lt;database_name&gt; /path/to/backup</span><br></pre></td></tr></table></figure></li>
<li>增量备份：对于较大的数据集，可以进行增量备份，只备份自上次全量或增量备份以来的数据<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">influxd backup -portable -start &lt;timestamp&gt; /path/to/backup</span><br></pre></td></tr></table></figure></li>
</ol>
<p>备份的数据可以恢复到新实例或现有实例中。</p>
<ol>
<li>恢复整个实例，包括所有的数据库。命令如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">influxd restore -portable /path/to/backup</span><br></pre></td></tr></table></figure></li>
<li>恢复单个数据库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">influxd restore -portable -db &lt;database_name&gt; /path/to/backup</span><br></pre></td></tr></table></figure></li>
<li>有时你可能希望将备份的数据恢复到另一个数据库，可以使用 <code>-newdb</code> 选项来实现：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">influxd restore -portable -db &lt;old_database_name&gt; -newdb &lt;new_database_name&gt; /path/to/backup</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="导出和导入数据"><a href="#导出和导入数据" class="headerlink" title="导出和导入数据"></a>导出和导入数据</h3><p>对于大多数InfluxDB Enterprise应用程序，备份和恢复实用程序提供了备份和恢复策略所需的工具。但是，在某些情况下，标准备份和恢复实用程序可能无法充分处理应用程序中的大量数据。作为标准备份和恢复实用程序的替代方案，可以使用InfluxDB influx_inspect export和涌入-import命令为灾难恢复和备份策略创建备份和恢复过程。</p>
<ol>
<li>数据库导出：容器层面命令，指定 数据文件和 写前日志(WAL)文件的存储目录，将指定数据库中指定时间的数据导出到指定文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@influxdb-e2cb6c913a191e56c134e-data-0:/<span class="comment"># influx_inspect export -datadir &quot;/var/lib/influxdb/data&quot; -waldir &quot;/var/lib/influxdb/wal&quot; -out &quot;influxdb_test01_dump_out&quot; -database &quot;test01&quot; -start &quot;2024-10-22T00:00:00Z&quot;</span></span><br><span class="line">writing out tsm file data <span class="keyword">for</span> test01/autogen...complete.</span><br><span class="line">writing out wal file data <span class="keyword">for</span> test01/autogen...complete.</span><br><span class="line">root@influxdb-e2cb6c913a191e56c134e-data-0:/<span class="comment"># cat influxdb_test01_dump_out</span></span><br><span class="line"><span class="comment"># INFLUXDB EXPORT: 2024-10-22T00:00:00Z - 2262-04-11T23:47:16Z</span></span><br><span class="line"><span class="comment"># DDL</span></span><br><span class="line">CREATE DATABASE test01 WITH NAME autogen</span><br><span class="line"><span class="comment"># DML</span></span><br><span class="line"><span class="comment"># CONTEXT-DATABASE:test01</span></span><br><span class="line"><span class="comment"># CONTEXT-RETENTION-POLICY:autogen</span></span><br><span class="line"><span class="comment"># writing tsm data</span></span><br><span class="line">temp,location=room1 value=24.5 1729589246099070937</span><br><span class="line">temp,location=room2 value=22.5 1729589253425715740</span><br><span class="line">temp,location=room3 value=22 1729649010554978701</span><br><span class="line"><span class="comment"># writing wal data</span></span><br></pre></td></tr></table></figure></li>
<li>数据库导入：容器层面执行命令，使用admin账号，指定文件、数据库、时间戳精度<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@influxdb-e73f149ff7192bd87d190-data-1:/<span class="comment"># influx -import -path=&#x27;influxdb_test01_dump_out&#x27; -precision=ns -username=&#x27;&#x27; -password=&#x27;&#x27;</span></span><br><span class="line">2024/10/25 03:21:47 Processed 1 commands</span><br><span class="line">2024/10/25 03:21:47 Processed 2 inserts</span><br><span class="line">2024/10/25 03:21:47 Failed 0 inserts</span><br></pre></td></tr></table></figure></li>
<li>实例导出：把influxdb集群实例中所有数据库的数据导出，不加 <code>-database</code>，加 <code>-compress</code></li>
<li>实例导入：加<code>-compressed</code> 导入压缩文件，本质上是先解压后倒入</li>
</ol>
<hr>

<h2 id="快速了解MySQL"><a href="#快速了解MySQL" class="headerlink" title="快速了解MySQL"></a>快速了解MySQL</h2><p>1.MySQL45讲 <a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100020801">https://time.geekbang.org/column/intro/100020801</a>  特点中文、有音频、快速了解相关背景<br>2.高性能MySQL <a target="_blank" rel="noopener" href="https://book.douban.com/subject/23008813/">https://book.douban.com/subject/23008813/</a><br>3.MySQL技术内幕（InnoDB存储引擎）<a target="_blank" rel="noopener" href="https://book.douban.com/subject/24708143/">https://book.douban.com/subject/24708143/</a><br>4.官方MySQL Internals Manual： <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/internals/en/guided-tour.html">https://dev.mysql.com/doc/internals/en/guided-tour.html</a><br>5.阿里云mysql内核月报：<a target="_blank" rel="noopener" href="http://mysql.taobao.org/monthly/">http://mysql.taobao.org/monthly/</a><br>6.Polardb-X知乎专栏：<a target="_blank" rel="noopener" href="https://www.zhihu.com/org/polardb-x">https://www.zhihu.com/org/polardb-x</a></p>
<h2 id="数据库架构"><a href="#数据库架构" class="headerlink" title="数据库架构"></a>数据库架构</h2><p>1.Architecture of a Database System 网上有中文翻译： <a target="_blank" rel="noopener" href="http://dblab.xmu.edu.cn/sites/default/files/files/linziyu-Architecture%20of%20a%20Database%20System%28Chinese%20Version%29-ALL.pdf">http://dblab.xmu.edu.cn/sites/default/files/files/linziyu-Architecture%20of%20a%20Database%20System%28Chinese%20Version%29-ALL.pdf</a><br>2.红宝书：<a target="_blank" rel="noopener" href="http://www.redbook.io/">http://www.redbook.io/</a><br>3.数据库系统实现：<a target="_blank" rel="noopener" href="https://book.douban.com/subject/4838430/">https://book.douban.com/subject/4838430/</a><br>4.Database Internals 有中文书籍：<a target="_blank" rel="noopener" href="https://book.douban.com/subject/35078474/">https://book.douban.com/subject/35078474/</a></p>
<p>通过以上书籍可以了解整体架构，数据库整体可以分为共识算法、存储引擎、事务处理（单机、分布式事务）、数据分析（执行引擎、分析引擎）<br>共识算法：<br>1)Paxos协议(basic paxos、multi paxos等） 蚂蚁金服Oceanbase实现了Paxos<br>paxos-simple.pdf  <a target="_blank" rel="noopener" href="https://lamport.azurewebsites.net/pubs/paxos-simple.pdf">https://lamport.azurewebsites.net/pubs/paxos-simple.pdf</a><br>paxos made live.pdf <a target="_blank" rel="noopener" href="https://www.cs.utexas.edu/users/lorenzo/corsi/cs380d/papers/paper2-1.pdf">https://www.cs.utexas.edu/users/lorenzo/corsi/cs380d/papers/paper2-1.pdf</a><br>2)Raft协议，本质上是Paxos的简化   开源版本ETCD使用的是raft共识算法、TiKV使用的复制算法最开始是改写的etcd的raft库<br>raft.pdf <a target="_blank" rel="noopener" href="https://raft.github.io/raft.pdf">https://raft.github.io/raft.pdf</a><br>存储引擎：<br>LSM Tree（LevelDB、RocksDB)<br>InnoDB引擎<br>单机事务（MySQL InnoDB事务可见性实现原理）<br>分布式事务<br>Percolator.pdf <a target="_blank" rel="noopener" href="https://www.usenix.org/legacy/event/osdi10/tech/full_papers/Peng.pdf">https://www.usenix.org/legacy/event/osdi10/tech/full_papers/Peng.pdf</a></p>
<p>实战<br>1.从0到1数据库内核实战教程 <a target="_blank" rel="noopener" href="https://open.oceanbase.com/activities/4921877">https://open.oceanbase.com/activities/4921877</a><br>2.MariaDB原理与实现  <a target="_blank" rel="noopener" href="https://book.douban.com/subject/26340413/">https://book.douban.com/subject/26340413/</a><br>3.字节云数据库架构设计与实战 <a target="_blank" rel="noopener" href="https://ke.segmentfault.com/course/1650000041697934/section/1500000041697942">https://ke.segmentfault.com/course/1650000041697934/section/1500000041697942</a><br>4.MySQL 原理与实践 <a target="_blank" rel="noopener" href="https://ke.segmentfault.com/course/1650000023669742/section/1500000023669752">https://ke.segmentfault.com/course/1650000023669742/section/1500000023669752</a></p>
<p>论文<br>Polardb计算存储分离论文<br>TiDB: a Raft-based HTAP database： TiDB 2020 VLDB上的文章，介绍TiDB的架构<br>Polardb-X分布式数据库论文<br>Spanner: Google’s Globally-Distributed Database: Google的tp数据库<a target="_blank" rel="noopener" href="https://www.usenix.org/system/files/conference/osdi12/osdi12-final-16.pdf%E2%80%8Bwww.usenix.org/system/files/conference/osdi12/osdi12-final-16.pdf">https://www.usenix.org/system/files/conference/osdi12/osdi12-final-16.pdf​www.usenix.org/system/files/conference/osdi12/osdi12-final-16.pdf</a><br>F1: A Distributed SQL Database That Scales 大G的F1系列<a target="_blank" rel="noopener" href="http://www.vldb.org/pvldb/vol6/p1068-shute.pdf%E2%80%8Bwww.vldb.org/pvldb/vol6/p1068-shute.pdf">http://www.vldb.org/pvldb/vol6/p1068-shute.pdf​www.vldb.org/pvldb/vol6/p1068-shute.pdf</a><br>Amazon Aurora: Design Considerations for High Throughput Cloud-Native Relational Databases; 亚马逊的Aurora</p>
<h2 id="快速了解kubernetes"><a href="#快速了解kubernetes" class="headerlink" title="快速了解kubernetes"></a>快速了解kubernetes</h2><ol>
<li>深入剖析kubernetes(geek)：<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100015201?tab=catalog">https://time.geekbang.org/column/intro/100015201?tab=catalog</a></li>
<li>kubernetes operator：<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/extend-kubernetes/operator/">https://kubernetes.io/docs/concepts/extend-kubernetes/operator/</a></li>
<li>kubernetes 入门资料：kubernetes概述、kubernetes-operator机制、k8s scheduler framework</li>
<li>容器网络插件：kube-ovn 、calico、Flannel、Weave、CNI</li>
<li>社区开源经典容器管理项目：tidb-operator、flink-operator</li>
<li>社区开源多k8s集群管理项目：kamada、clusternet</li>
<li>kubernetes 集群管理平台：kubesphere</li>
</ol>
<h2 id="快速了解中间件、基础技术"><a href="#快速了解中间件、基础技术" class="headerlink" title="快速了解中间件、基础技术"></a>快速了解中间件、基础技术</h2><ol>
<li>Spring cloud技术<ol>
<li>spring-cloud 中文文档：<a target="_blank" rel="noopener" href="https://www.springcloud.cc/spring-cloud-greenwich.html">https://www.springcloud.cc/spring-cloud-greenwich.html</a></li>
<li>spring-cloud API网关（gateway）：<a target="_blank" rel="noopener" href="http://c.biancheng.net/springcloud/gateway.html">http://c.biancheng.net/springcloud/gateway.html</a></li>
<li>spring-cloud 配置中心（Consul）：<a target="_blank" rel="noopener" href="https://www.springcloud.cc/spring-cloud-consul.html">https://www.springcloud.cc/spring-cloud-consul.html</a></li>
<li>spring-cloud 统一配置、服务注册和发现（Nacos）：社区git、what is nacos</li>
</ol>
</li>
<li>API网关<ol>
<li>APISIX：社区git、快速指南、插件开发</li>
<li>Kong：社区git、入门blog</li>
<li>nginx-ingress：nginx官网 ingress手册</li>
</ol>
</li>
<li>Spring <ol>
<li>官方手册</li>
<li>spring framework手册 <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-api">https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-api</a></li>
</ol>
</li>
<li>Springboot <a target="_blank" rel="noopener" href="https://www.springcloud.cc/spring-boot.html">https://www.springcloud.cc/spring-boot.html</a></li>
<li>Reids 推荐书籍：《Redis入门指南 （第2版）》、《Redis设计与实现》</li>
<li>Nginx <a target="_blank" rel="noopener" href="https://www.cnblogs.com/54chensongxia/p/12938929.html">https://www.cnblogs.com/54chensongxia/p/12938929.html</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/22/InfluxDB/" data-id="cm3lnru5y0005f0v5awp93h8u" data-title="InfluxDB | DBAdvanced" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Golang" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/22/Golang/" class="article-date">
  <time class="dt-published" datetime="2024-09-22T05:17:33.000Z" itemprop="datePublished">2024-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/22/Golang/">Golang</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <br>
<div style="display: flex; align-items: center;">
  <div style="flex: 0 0 30%;">
    <img src="https://www.runoob.com/wp-content/uploads/2015/06/go128.png" alt="" style="max-width: 100%;">
  </div>
  <div style="flex: 1; padding-left: 10px;">
    <p><em>Go 是一个开源的编程语言，它能让构造简单、可靠且高效的软件变得容易。<br>Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。 对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。</em></p>
  </div>
</div>


<p>除了OOP外，近年出现了一些小众的编程哲学，Go语言对这些思想亦有所吸收。例如，Go语言接受了函数式编程的一些想法，支持匿名函数与闭包。再如，Go语言接受了以Erlang语言为代表的面向消息编程思想，支持goroutine和通道，并推荐使用消息而不是共享内存来进行并发编程。总体来说，Go语言是一个非常现代化的语言，精小但非常强大。</p>
<h3 id="Go-语言最主要的特性"><a href="#Go-语言最主要的特性" class="headerlink" title="Go 语言最主要的特性"></a>Go 语言最主要的特性</h3><p>自动垃圾回收 更丰富的内置类型 函数多返回值 错误处理 匿名函数和闭包 类型和接口 并发编程 反射 语言交互性<br><a target="_blank" rel="noopener" href="https://www.runoob.com/go/go-tutorial.html">https://www.runoob.com/go/go-tutorial.html</a></p>
<h3 id="为-Java-程序员准备的-Go-语言入门-PPT"><a href="#为-Java-程序员准备的-Go-语言入门-PPT" class="headerlink" title="为 Java 程序员准备的 Go 语言入门 PPT"></a>为 Java 程序员准备的 Go 语言入门 PPT</h3><ul>
<li>Go 和 Java 有很多共同之处<br>C 系列 (强类型，括号) 静态类型 垃圾收集 内存安全 (nil 引用，运行时边界检查) 变量总是初始化 (zero&#x2F;nil&#x2F;false)<br>方法 接口 类型断言 (实例) 反射</li>
<li>Go 与 Java 的不同之处<br>代码程序直接编译成机器码，没有 VM<br>静态链接二进制 内存布局控制 函数值和词法闭包 内置字符串 (UTF-8) 内置泛型映射和数组&#x2F;片段 内置并发 </li>
<li>Go 特意去掉了大量的特性<br>没有类 没有构造器 没有继承 没有 final 没有异常 没有注解 没有自定义泛型<br><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/go-for-java-programmers.html">https://www.runoob.com/w3cnote/go-for-java-programmers.html</a></li>
</ul>
<h3 id="Go-项目构建"><a href="#Go-项目构建" class="headerlink" title="Go 项目构建"></a>Go 项目构建</h3><ul>
<li>Module：是 Go 语言用于管理项目依赖和版本的一种机制。go.mod 文件定义了模块的元数据和依赖关系。<br><code>go.mod</code> 文件是声明依赖的地方，记录了项目的依赖关系。如果项目中没有 <code>go.mod</code> 文件，需要先运行 <code>go mod init</code> 来初始化模块。然后使用 <code>go get</code>（或其他命令）来引入依赖，下载到本地缓存（<code>~/go/pkg/mod</code>），并更新 go.mod，添加对应的模块路径和版本要求。</li>
<li>Makefile：是一个用于自动化构建、测试和其他任务的工具。它允许你定义复杂的构建流程和依赖关系。<br>Makefile 可以包含多个targets，例如 build、test、clean 等。make 命令会查找当前目录下的 Makefile 并执行指定的目标。<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">build:</span></span><br><span class="line">    go build -v ./...</span><br><span class="line"></span><br><span class="line"><span class="section">test:</span></span><br><span class="line">    go test -v ./...</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f *.exe</span><br></pre></td></tr></table></figure>
构建过程（<code>go build</code>）本身不负责引入依赖，它假定所有必要的依赖已经通过 <code>go.mod</code> 文件声明并被解析，将编译代码并链接所有必要的依赖来生成最终的可执行文件或库文件。如果 go.mod 中声明的依赖尚未下载，Go 工具链会自动为你下载这些依赖。如果你的项目中没有 go.mod，go build 将无法正确识别和下载依赖（除非是 Go 1.11 前的版本）</li>
<li>构建新项目<ol>
<li>对于一个带有 <code>go.mod</code> 文件的 Go 项目，项目所需的依赖<strong>不会</strong>自动下载到本地环境中。需要手动运行 <code>go mod download</code> 或 <code>go mod tidy</code> 来下载依赖，或者直接运行 <code>go build</code> 以触发依赖的下载。</li>
<li>如果本地已有的依赖版本与 <code>go.mod</code> 文件中声明的版本不同，Go 工具链会优先使用 <code>go.mod</code> 文件中指定的版本。Go 会从远程仓库下载与 <code>go.mod</code> 兼容的依赖版本，并将其存储在本地缓存目录（通常是 <code>~/go/pkg/mod</code>）中。</li>
<li>Go 项目使用的依赖是项目特定的，存储在项目的本地缓存中，而不是全局的 GOPATH 或者 GOROOT 目录。这意味着不同的项目可以依赖同一库的不同版本，而不会发生冲突。</li>
</ol>
</li>
</ul>
<h3 id="Go-项目的基本结构"><a href="#Go-项目的基本结构" class="headerlink" title="Go 项目的基本结构"></a>Go 项目的基本结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">myproject/</span><br><span class="line">│</span><br><span class="line">├── cmd/             # 存放程序的入口点，每个应用程序的变体都放在这里</span><br><span class="line">│   ├── main.go</span><br><span class="line">│   └── otherapp.go</span><br><span class="line">│</span><br><span class="line">├── internal/        # 私有的应用程序和库代码</span><br><span class="line">│   ├── config/      # 配置文件和配置逻辑</span><br><span class="line">│   ├── service/     # 业务逻辑</span><br><span class="line">│   └── repository/  # 数据访问对象</span><br><span class="line">│</span><br><span class="line">├── pkg/             # 存放可以被外部项目导入的库代码</span><br><span class="line">│   ├── helper/      # 辅助工具函数</span><br><span class="line">│   └── logger/      # 日志库</span><br><span class="line">│</span><br><span class="line">├── api/             # API相关代码，如 OpenAPI/Swagger 定义</span><br><span class="line">│   ├── v1/          # API版本控制</span><br><span class="line">│   └── v2/</span><br><span class="line">│</span><br><span class="line">├── config/          # 配置文件和脚本</span><br><span class="line">│</span><br><span class="line">├── scripts/         # 项目脚本，如安装依赖、构建、测试等</span><br><span class="line">│</span><br><span class="line">├── test/            # 测试代码</span><br><span class="line">│   ├── integration/ # 集成测试</span><br><span class="line">│   └── unit/        # 单元测试</span><br><span class="line">│</span><br><span class="line">├── vendor/          # 依赖管理，存放第三方依赖</span><br><span class="line">│</span><br><span class="line">├── .git/            # Git 版本控制元数据</span><br><span class="line">├── .gitignore       # 忽略文件列表</span><br><span class="line">├── go.mod           # Go 模块文件</span><br><span class="line">└── README.md        # 项目说明文件</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/22/Golang/" data-id="cm3lnru5v0001f0v5g84pcjs6" data-title="Golang" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-保险" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/18/%E4%BF%9D%E9%99%A9/" class="article-date">
  <time class="dt-published" datetime="2024-08-18T08:55:11.000Z" itemprop="datePublished">2024-08-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/18/%E4%BF%9D%E9%99%A9/">保 险</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="社会保障"><a href="#社会保障" class="headerlink" title="社会保障"></a>社会保障</h2><p>通过对国民收入的再分配，使公民在遇到特定风险或困难时能够获得基本生活保障。本质是追求一种公平。</p>
<h2 id="社会保险"><a href="#社会保险" class="headerlink" title="社会保险"></a><strong>社会保险</strong></h2><ol>
<li><strong>养老保险</strong>：为了保障老年人退休后的基本生活，通过个人和单位的缴费，在退休后按月领取养老金。个人在达到法定退休年龄时，如果满足缴费年限等条件，就可以领取养老金。</li>
<li><strong>医疗保险</strong>：旨在为参保人员提供医疗费用的报销或补偿，以减轻医疗费用的负担。参保人员在生病住院或接受治疗时，可以通过医保报销一部分或全部的医疗费用。</li>
<li>失业保险：为因非个人原因失去工作的参保人员提供一定时间内的生活保障金，帮助他们在失业期间维持基本生活。</li>
<li>工伤保险：用于保障因工作原因遭受意外伤害或职业病的劳动者，提供医疗费用和伤残补助，甚至提供生活保障金等。</li>
<li>生育保险：主要为参保女性在生育期间提供一定的经济补助和医疗费用报销。</li>
</ol>
<h3 id="社保卡"><a href="#社保卡" class="headerlink" title="社保卡"></a>社保卡</h3><p>佛山社保卡如何申领？“一人一卡”清理又是个啥？ <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/9uQ5qGOYv35BGRgs4OvzvA">https://mp.weixin.qq.com/s/9uQ5qGOYv35BGRgs4OvzvA</a><br>没领佛山社保卡可以使用医保报销吗？可以，微信支付时会显示报销数额。</p>
<h3 id="医保"><a href="#医保" class="headerlink" title="医保"></a>医保</h3><ul>
<li>医疗保险是一种社会保障制度。通常由个人和单位共同缴纳，参保人员在医疗机构就诊时可以通过医保报销部分或全部的医疗费用。<br>通过医保报销的费用是由医保基金支付的，而这个基金是由全体参保人员（包括你和你的单位）共同缴纳的资金组成的。<strong>个人缴纳的那部分医保费用只是整个基金的一部分，而报销的金额往往远超过个人单独缴纳的部分，这正是医保体系的优势所在</strong>。</li>
<li><em>佛山医疗保险享受指引</em><ol>
<li>门诊选点：公众号-粤医保</li>
<li>异地就医备案<br>  办理条件：异地安置退休人员、异地长期居住人员、常驻异地工作人员、临时外出就医人员<br>  办理途径：公众号-粤医保-线上办理-异地就医备案</li>
<li>医保报销方式<br>  定点联网机构住院(?)费用：凭社保卡&#x2F;医保电子凭证&#x2F;身份证现场结算；未能即使结算的，先挂账后结算；无法补记账结算的，垫付费用后申请零星保险。（医保里的钱可以用吗？怎么用？<br>  零星报销：提供资料到参保所属医保经办机构办理<br>  <a target="_blank" rel="noopener" href="https://ihr.midea.com/selfhelp/ihr/selfhelp/pdf?businessId=8a928ead90719d3201907b3b580d00b7&mc_widget_identifier=com.midea.msd.ihrcommonmx&scene=selfhelp_sdc&page=showPdf&type=1">https://ihr.midea.com/selfhelp/ihr/selfhelp/pdf?businessId=8a928ead90719d3201907b3b580d00b7&amp;mc_widget_identifier=com.midea.msd.ihrcommonmx&amp;scene=selfhelp_sdc&amp;page=showPdf&amp;type=1</a></li>
</ol>
</li>
</ul>
<h3 id="住房公积金"><a href="#住房公积金" class="headerlink" title="住房公积金"></a>住房公积金</h3><ul>
<li>住房公积金是一种社会福利制度，而不是严格意义上的社会保障。住房公积金是国家为帮助职工解决住房问题而设立的一项长期住房储金。它由职工个人和单位共同缴纳，归职工个人所有，并在一定条件下用于购房、建房、房屋维修或者租房等住房相关支出。</li>
<li>职工可以在以下情况下提取住房公积金：购买、建造、翻建、大修自住住房。偿还住房贷款本息（利率低）。支付房租。离职或退休后可以提取全部住房公积金。</li>
<li>住房公积金可以断缴。如果有购房计划或其他需要公积金支持的需求，最好避免长时间断缴。<ul>
<li>可以断缴：如果你换工作、辞职、或者暂时没有固定工作，住房公积金可以暂时断缴。没有法律强制要求必须连续缴纳。一旦找到新工作或稳定下来，你可以恢复缴纳住房公积金。新单位会重新为你开设账户或继续使用之前的账户。</li>
<li>断缴的影响<br>  <strong>贷款购房影响</strong>：<strong>影响贷款资格</strong>，在申请住房公积金贷款时，很多地方要求申请人在最近的6个月或12个月内连续缴纳公积金。如果公积金断缴，可能会影响你申请住房公积金贷款的资格。<strong>贷款额度影响</strong>，公积金贷款额度通常与公积金的缴纳时间和余额挂钩。如果断缴时间较长，贷款额度可能会受到影响。<br>  <strong>影响提取条件</strong>：如果计划通过提取公积金支付房租或购房时，断缴可能会影响提取公积金的条件，因为很多地方要求提取前必须有一定的连续缴纳记录。</li>
<li>如何减少断缴的影响：1、补缴：在新单位入职后，你可以尝试与单位协商，进行断缴期间的补缴。以恢复在断缴期间的公积金记录。2、灵活就业人员公积金：有些城市允许灵活就业人员或个体工商户自行缴纳公积金，以避免断缴。</li>
</ul>
</li>
<li>住房公积金在中国是可以随着工作地点的变更而进行转移的。通常的步骤是：在新城市的新工作单位会为你开设一个新的住房公积金账户。向新单位的公积金管理中心申请将旧账户的公积金余额转入新账户。新单位所在的公积金管理中心会联系原城市的公积金管理中心，办理资金转移。公积金转移通常需要一定时间，一旦转移完成，你的住房公积金余额将会合并到新城市的账户中。</li>
<li><em>佛山公积金提取</em>：wx公众号办理租房提取业务，选择按年&#x2F;月提取，隔日到账。</li>
</ul>
<h2 id="商业保险"><a href="#商业保险" class="headerlink" title="商业保险"></a>商业保险</h2><p>【当代年轻人没了铁饭碗，还能负重奔跑多久？北京二胎家庭如何转移风险？】 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV16F4m1V7wv/?share_source=copy_web&vd_source=2cbe8cdd54a75d0c43fcdefa624d3fbe">https://www.bilibili.com/video/BV16F4m1V7wv/?share_source=copy_web&amp;vd_source=2cbe8cdd54a75d0c43fcdefa624d3fbe</a></p>
<p>“年纪轻的一定要买百万医疗险和意外险，还有抗癌险，关键时候真的能救命的，有余裕买个重疾险，如果生病了确证了就能拿到几十万的保额，可以作为治疗和康复期的生活费开销，医疗费有医保和百万医疗险，到时候真生比较严重的病百分之九十能报销，年纪轻买了便宜加起来一年千把块，父母没生病可以给他们买众民保和中银全名保，还有当地的惠民保三个加起来六百块不到，不看健康告知年龄大可以报销，配合医保大概能报销八十花的多甚至能报销到九十，给家里老人多套保障，不会出现得了病只能放弃的人间惨剧，如果老人没医保可以买城乡医保一年几百块”</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/18/%E4%BF%9D%E9%99%A9/" data-id="cm3lnru6c000sf0v50fbvgb3u" data-title="保 险" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-美的Midea" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/07/%E7%BE%8E%E7%9A%84Midea/" class="article-date">
  <time class="dt-published" datetime="2024-07-07T02:58:11.000Z" itemprop="datePublished">2024-07-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/07/%E7%BE%8E%E7%9A%84Midea/">美 的 Midea</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="2024-07-08"><a href="#2024-07-08" class="headerlink" title="2024.07.08"></a>2024.07.08</h2><p>入职第一天，熟悉运维平台，目标实现其自动化，后续参与到美的云,?<br><img src="https://leo710aka.github.io/bk/midea.jpg"></p>
<p>熟悉新旧平台的功能和调用关系，拆分业务需求开发步骤，编写文档，每日汇报进展，熟悉开发流程、、<br>软工院作为非互联网公司的非核心业务的底层平台建设部门，结果导向，组员多一年社招；)无校招培养。？</p>
<h4 id="7-17-7-29"><a href="#7-17-7-29" class="headerlink" title="7.17 - 7.29"></a>7.17 - 7.29</h4><p>EDP培训 ＋ MGC（头脑风暴&#x2F;产品调研&#x2F;拉通对齐&gt;&gt;技术）<br>T型人才(广度＋深度)，开发技术+产品思维-&gt;架构师<br>不设限，主动承担任务，机会莫名来：) take other people’s jobs and become indispensable to the team..</p>
<!-- <img src="https://leo710aka.github.io/bk/midea2.jpg" width="450" height="300" alt=""> -->

<p>复杂的事情简单化(思考简化)，简单的事情复杂化(做到极致)<br>工作就是生活，生活就是工作，不需要平衡（找到热爱的工作）<br>成功的百分比 &#x3D; 做事 &#x2F; (个人 + 做事)；做事的比例越大，成功的概率越大<br><img src="https://leo710aka.github.io/bk/midea3.jpg" width="450" height="300" alt="7.23 Alex : scope of teamwork minus everyone's responsibility is not null.."></p>
<p>Allen: 向上管理?× 向上反馈，同步进展<br>MGC结营<br>融入团队？主动承担？谈论未知？如何选择自己在团队中的角色，人设？？<br>圈子</p>
<h4 id="8-17"><a href="#8-17" class="headerlink" title="8.17"></a>8.17</h4><p>佛山校友会迎新<br>“努力会发光，先有为后有位”，“头三年不要动，把这一套学会”<br>程序员的本质核心竞争力是什么？1.开发都是那一套 2.专精一个领域 3.meet新公司的需求 4.解决问题的能力</p>
<h4 id="8-19-ALEX"><a href="#8-19-ALEX" class="headerlink" title="8.19 ALEX"></a>8.19 ALEX</h4><p>最近和一些软工院同学深入聊了一下他们的职业发展规划，</p>
<!-- 我发现很多同学对自己的职业发展方向是模糊不清的，对职业发展的规划很大程度上是基于自己想象的不切实际的路径。当然，职业发展规划是一个极难的事情，就像一个组织的战略方向最难把握，一个人的职业发展方向也是极难把握的，因为看清未来和把握方向需要极高的认知能力和丰富的实践经验。
职业发展规划的核心是两个问题：目标是什么，路径是什么。假定你的理想是成为一名企业家型人才，这里企业家型人才不只包括企业创始人，还包括这个企业里面那些每天负责做各种商业决策并且负责拿到商业结果的人。这里，我不建议把目标制定成升级或者当上什么官职，因为这样目标能否实现不是你能掌控的。命运要掌握在自己手里，不是别人手里。那切实可行的路径是什么？路径要提前想清楚，否则就行开车没有导航，随性开，那你大概率会走很多弯路，甚至掉进坑里。这里我假定你是普通人家的孩子，你父母没法轻飘飘给你十几个“小目标”让你去随便创业练手，亏了也无所谓；这里我还假定你不是马云张一鸣这样的天才，如果你是，那你可以直奔主题，直接去创业；如果你不是，还直奔主题，那大概率会失败。我这里给大家指清一个对普通家庭出身的普通人来说，只要肯努力肯学习，就能够成为企业家型人才的实现路径：专家型人才—》领军型人才—》企业家型人才。
如何成为专家型人才？第一步，你经过努力成为你团队的top performer，就是S员工。怎么才能成为团队的top performer呢？思路很简单，首先和你的主管对齐目标，其次做到结果远超预期。怎么才能做到结果远超预期呢？思路也很简单：最大的努力程度+需要啥学啥。学习的途径包括读书（推荐微信读书），向优秀的同事学经验，向失败的同事学教训。第二步，你成为团队专家，即你要用你的技术能力赋能和帮助你团队的其他同学。怎么判断你是否是你团队的专家呢？很简单，大家遇到技术难题的时候，他们首先找你帮忙么？你经常向其他同学传授经验和技能么？当你团队有同学遇到搞不定的难题的时候，你的主管是不是第一个想到你，让你去辅导这个同学搞定难题。第三步，你成为行业专家，在这个行业，你是技术最牛之一，你非常清楚这个行业的技术水位，你做出的东西的技术水平比肩甚至超越业界同行的最高水平。要想成为专家型人才，我建议你要有一个role model。软工院的部长和TL们都是专家型人才，你可以把你团队的TL或者部长作为你的role model。正如我之前所说，软工院是你成长的平台，是你成为专家型人才的平台，不要把软工院当做你打工当做你用劳动换取报酬的地方。认知决定思维，思维决定行动，行动决定结果。
如何成为领军型人才？你要具备在一个公司把一大块领域从零做起的能力，你要具备带几百人大团队的能力，你要具备战略思维能力，你要具备为几百甚至上千人的团队制定战略目标和实现路径的能力。
如何成为企业家型人才？你要具备商业思维能力，你要能把一块业务从零做起来，你要知道你竞争对手是谁，他们在做什么，你怎么在竞争中战胜他们。
美的鼓励内部企业家，鼓励人人成为企业家，鼓励每个人每个组织把自己的蛋糕做大。**等软工院把商业化输出做起来，随着我们外部蛋糕越做越大，我们这个平台自然需要你成为专家型人才，领军型人才，和企业家型人才**。让我们大家携起手来，把我们的事业做大！ -->


<h4 id="8-22-需求一："><a href="#8-22-需求一：" class="headerlink" title="8.22 需求一："></a>8.22 <strong>需求一</strong>：</h4><p><em>华为云主机开&#x2F;关机&#x2F;重启自动化</em> : mq、定时任务、公有云api、crud、、<br>完成第一版8.14，自测8.15，，merge request，code review，sit，测试，uat，发版8.22、、<br>反思、、在开发同事的指导下完成了开发，不具备独立调研和开发能力，，<br>缺少对产品的思考？？没有对需求进行120%的思考和完成。。</p>
<h4 id="8-24"><a href="#8-24" class="headerlink" title="8.24"></a>8.24</h4><p>顺德校友会迎新<br>why Midea？1.生活成本低（特别是住宿好通勤方便）2.相比下工作轻松（能够有自己的时间学习业务以外的东西）<br>思考自己在..年后会到什么层次（本科毕业+6y ?&#x3D; 博士毕业起步）。。阶段性目标</p>
<h4 id="8-27-Steven"><a href="#8-27-Steven" class="headerlink" title="8.27 Steven"></a>8.27 Steven</h4><p>深入一个领域，，<br>先做一点功能点，然后负责一个模块，到不同系统的交互、、<br>多学基础，与外包的区别。。与人沟通的能力<br>幂等，整体设计，微服务治理，看项目源码，，<br>干半年就不是应届生了。社会很残酷，前两年要快速成长；思考两&#x2F;五年后的情况、、<br>开发整个过一遍，打包，发版，，<br>多讨论，多问，code review<br><strong>！！邮件</strong>：设计一个功能，，关注点，逻辑路径，通用性，，如何表述。。?！ –&gt;</p>
<p>Linux基本命令：<br>netstat ; top;  awk ; dstat;  iostat; lsof; free；uptime；dmesg ；dig ； nslookup</p>
<p>vim&#x2F;vi的基本快捷命令（shift + g； dd；yy等）</p>
<p>终端的一些快捷命令（ctrl + a; ctrl + e）</p>
<!-- 请大家各自熟悉使用，以后值班和问题处理不希望看到大家还要自己想半天命令 -->


<h4 id="9-9-并发先查后改"><a href="#9-9-并发先查后改" class="headerlink" title="9.9 并发先查后改"></a>9.9 并发先查后改</h4><p>方法：事务+行锁【悲观锁】，避免在高并发场景下<strong>先读后写</strong>导致多个线程同时读取相同的值然后同时写入引发数据不一致的问题<br>测试：线程池多线程访问，打印数据，排查重复值；考虑数据库连接池配置<br>思考：项目部署到多节点下，则是多进程的多线程环境，需要用Redis分布式锁，或者唯一的全局数据库节点加锁；<br>单节点的多线程才能用synchronized？、<br>优化：事实上，update方法会加行锁，所以直接先update后select即可，无需select…for update</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumberService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> NumberMapper numberMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span> <span class="comment">// 在业务逻辑层开启事务，确保整个操作是原子的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incrementNumber</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 查询并锁定行</span></span><br><span class="line">        <span class="type">NumberEntity</span> <span class="variable">numberEntity</span> <span class="operator">=</span> numberMapper.selectForUpdate(id);</span><br><span class="line">        <span class="comment">// 读取后进行计算并更新，保证只有当前事务可以操作该行</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">currentNumber</span> <span class="operator">=</span> numberEntity.getNumber();</span><br><span class="line">        numberEntity.setNumber(currentNumber + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 更新数据库</span></span><br><span class="line">        numberMapper.updateById(numberEntity);</span><br><span class="line">        <span class="comment">// 更新完成后提交事务，释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NumberMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;NumberEntity&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 FOR UPDATE 读取并锁定行，防止其他事务并发读取该行</span></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM number_table WHERE id = #&#123;id&#125; FOR UPDATE&quot;)</span></span><br><span class="line">    NumberEntity <span class="title function_">selectForUpdate</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="9-12-需求二："><a href="#9-12-需求二：" class="headerlink" title="9.12 需求二："></a>9.12 <strong>需求二</strong>：</h4><p><em>Azure公有云主机申请</em> :根据云管界面配置配齐参数发送报文到作业平台，完成自动化主机创建和标准化<br>对其参数，连续加班，9.9完成第一版，9.10上sit前端联调，9.11开发部分发邮件，9.12上uat，6.同步DDL&amp;DML，7.发版，验收成功<br>接触运维，，code review，联调，，集成，部署，流水线，，</p>
<h4 id="9-14"><a href="#9-14" class="headerlink" title="9.14"></a><strong>9.14</strong></h4><p>窝囊费:）120</p>
<!-- 00+440(补贴)-2674.81(代扣代缴:898.9+1151+480补充公积金+144.91扣税)-762.1(房租水电)(+2302公积金) = 9003.09(+2302)
| 个人住房公积金 | 个人补充公积金 | 公司缴纳金额 | 月缴纳金额合计 |
| ------- | ------- | ------- | ------- |
| 1151 | 480 | 671 | 2302 |

| 五险 | 个人缴纳金额 | 公司缴纳金额 | 总计 |
| ------- | ------- | ------- | ------- |
| 养老保险 | 767.2 | 1438.5 | 2205.7 |
| 医疗保险 | 115.2 | 281.3 | 393.82 |
| 失业保险 | 19.18 | 76.72 | 95.9 |
| 工伤保险 | 0 | 38.36 | 38.36 |
| 生育保险 | 0 | 0 | 0 |
| 总计    | 898.9 | 1834.88 | 2733.78 | -->


<h4 id="9-26-需求三："><a href="#9-26-需求三：" class="headerlink" title="9.26 需求三："></a>9.26 需求三：</h4><p><em>Azure公有云主机回收&#x2F;开&#x2F;关机&#x2F;重启</em> : 调研AzureApi和测试方法，开发，，<br>9.23回收上sit，9.24开关机重启代码重构(原华为云方法过于通用)，9.25bug毁了我的足球梦，9.26配置ngix上uat，验收<br>思考：自测可以 1.全流程验证 2.单独功能验证 3.考虑开发与测试环境的区别（ping的包装方法&#x2F;命令行执行在开发&#x2F;测试环境的区别）<br>后续：完善公有云开发（Azure回收配额，ip，失败邮件），后续由<em>运维平台MOPS</em> -&gt; 参与到数据库开发</p>
<h4 id="10-12-需求四："><a href="#10-12-需求四：" class="headerlink" title="10.12 需求四："></a>10.12 需求四：</h4><p>任务触发式失败邮件完成，改造为工单定时任务扫描式，10.17上线<br>邮件通用性？？工单+定时任务层面的通用，，</p>
<h4 id="10-14"><a href="#10-14" class="headerlink" title="10.14"></a>10.14</h4><p><strong>数据管控平台DataMars:</strong> 云管cmcloud开发功能，先提供内部服务，后到SAAS，，<br>InfluxDB备份恢复 1 调研 2 手工实现 3 详细文档<br>2-3月时间，不要求11月上线，整体设计，转正答辩<br>api，数据库内核？，容器，k8s<br>容器，登录主机，查看docker实例，操作数据库实例</p>
<h4 id="10-22-K8S验证InfluxDB-Cluster实例导入导出"><a href="#10-22-K8S验证InfluxDB-Cluster实例导入导出" class="headerlink" title="10.22 K8S验证InfluxDB Cluster实例导入导出"></a>10.22 K8S验证InfluxDB Cluster实例导入导出</h4><ol>
<li>FinalShell客户端：主要用于服务器管理和运维。支持 SSH、SFTP 等多种协议，方便用户通过图形界面进行远程连接和操作。</li>
<li>跳板机&#x2F;堡垒机： SSH连接，登录堡垒机opsec.midea.com，mip账密 + OTP验证</li>
<li>资产列表中选择指定环境下的主机，InfluxDB多节点部署在对应环境的几台主机上</li>
<li>切换用户：rouser，apps，root<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rouser20@(datamars)mhpl74337-10.20.248.65 ~$ sudo su - apps</span><br></pre></td></tr></table></figure></li>
<li>K8S入门 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/32618563">https://zhuanlan.zhihu.com/p/32618563</a><ul>
<li>Namespace(命名空间,是一个逻辑隔离的环境,用于资源分组和隔离) -&gt; InfluxDB集群(可以有多个)，Pod(Kubernetes的基本计算单元) -&gt; InfluxDB集群节点(逻辑上)，容器 -&gt; InfluxDB单例(物理上) </li>
<li>Namespace：作为最顶层的资源，实现了资源的逻辑隔离。</li>
<li>StatefulSet：对于有状态的服务如数据库，K8s 推荐使用 StatefulSet 进行管理，确保每个 Pod 都有一个持久的唯一标识并提供稳定的网络标识和存储。 InfluxDB 集群中，StatefulSet 用于管理数据节点和元节点。</li>
<li>Pod 是最基本的部署单元，它是可以被创建和管理的最小部署对象。当创建一个 InfluxDB 集群实例时，StatefulSet 会用来管理 Pod 的生命周期(而不是直接创建Pod)。</li>
<li>InfluxDB 集群部署：对于一个 Namespace下的几个  Pod，这些节点会通过 StatefulSet或者 Deployment来进行管理和部署。在实际操作中，创建 InfluxDB 集群实例的 Helm Chart 或者 Operator 通常会自动化这些资源的创建过程。</li>
<li>通信调度：K8s 中，Pod 之间的通信通常通过 Service 来进行。Service 会为一组 Pod 提供一个稳定的 IP 地址和 DNS 名称。对于 InfluxDB 集群，可能会有一个或多个 Service 来管理数据节点和元数据节点之间的通信。</li>
<li>查看实例root密码<br> kubectl get secrets -n influxdb<br> kubectl get secrets -n influxdb influxdb-e73f149ff7192bd87d190-influxdb -o yaml</li>
</ul>
</li>
<li>连接主机mhpl74337（datamars-uat的三台服务器之一），查看 <code>influxdb</code> 命名空间下的所有 Stateful<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apps@(datamars)mhpl74337-10.20.248.65 ~$ kubectl get sts -n influxdb</span><br><span class="line">NAME                                  READY   AGE</span><br><span class="line">influxdb-e2cb6c913a191e56c134e-data   2/2     47d</span><br><span class="line">influxdb-e2cb6c913a191e56c134e-meta   3/3     47d</span><br><span class="line">influxdb-e73f149ff7192bd87d190-data   2/2     5d22h</span><br><span class="line">influxdb-e73f149ff7192bd87d190-meta   3/3     5d22h</span><br></pre></td></tr></table></figure>
查看 <code>influxdb</code> 命名空间下的所有 Pod 的状态和节点信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apps@(datamars)mhpl74337-10.20.248.65 ~$ kubectl get pod -n influxdb -o wide</span><br><span class="line">influxdb-e2cb6c913a191e56c134e-data-0   1/1     Running   0              20d     10.20.205.88    mhpl74338   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">influxdb-e2cb6c913a191e56c134e-data-1   1/1     Running   52 (44h ago)   20d     10.20.206.129   mhpl74344   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">influxdb-e2cb6c913a191e56c134e-meta-0   1/1     Running   28 (11d ago)   20d     10.20.205.170   mhpl74337   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">influxdb-e2cb6c913a191e56c134e-meta-1   1/1     Running   53 (44h ago)   20d     10.20.205.238   mhpl74344   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">influxdb-e2cb6c913a191e56c134e-meta-2   1/1     Running   27 (11d ago)   20d     10.20.206.160   mhpl74337   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">influxdb-e73f149ff7192bd87d190-data-0   1/1     Running   14 (44h ago)   5d22h   10.20.204.68    mhpl74344   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">influxdb-e73f149ff7192bd87d190-data-1   1/1     Running   14 (44h ago)   5d22h   10.20.204.78    mhpl74344   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">influxdb-e73f149ff7192bd87d190-meta-0   1/1     Running   14 (44h ago)   5d22h   10.20.204.62    mhpl74344   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">influxdb-e73f149ff7192bd87d190-meta-1   1/1     Running   0              5d22h   10.20.204.73    mhpl74338   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">influxdb-e73f149ff7192bd87d190-meta-2   1/1     Running   0              5d22h   10.20.204.83    mhpl74338   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>
可以看到，<strong>在 Kubernetes上创建了2个 InfluxDB集群实例，它们共用一个 Namespace：influxdb</strong>，使用 StatefulSet 来创建和管理 Pod。这些 Pod 负责运行 InfluxDB 服务，并由 StatefulSet 确保它们的高可用性和数据持久化。<br>对于每个集群实例，<strong>有 2个 sts为 meta和 data，分别有2和3个复制，即2个元节点和3个数据节点 Pod，部署在3台服务器上</strong>；pod内部共用数据卷，pod之间数据不互通，部署在同一主机上的pod之间可以通过本地机器为中介复制文件。</li>
<li>查看 <code>influxdb</code> 命名空间下的 service 信息。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apps@(datamars)mhpl74337-10.20.248.65 ~$ kubectl get svc -n influxdb</span><br><span class="line">NAME                                  TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)                                                  AGE</span><br><span class="line">influxdb-e2cb6c913a191e56c134e-data   ClusterIP   None         &lt;none&gt;        8086/TCP,8088/TCP,2003/TCP,4242/TCP,25826/UDP,8089/UDP   39d</span><br><span class="line">influxdb-e2cb6c913a191e56c134e-meta   ClusterIP   None         &lt;none&gt;        8089/TCP,8091/TCP                                        39d</span><br></pre></td></tr></table></figure>
有 2 个Service，用来定义一组Pod的访问策略的抽象。它提供了一种方式，使得外部客户端可以通过一个固定的IP地址和端口访问这些Pod，而不需要关心Pod的实际IP地址和端口。Service会通过选择器（selector）将这些端口映射到后端的Pod上。</li>
<li><code>kubectl exec</code> 进入指定的 Pod(默认进入其中的第一个容器)，并启动一个 bash shell；可以看到当前 InfluxDB 版本是v1.8.10-c1.1.2<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apps@(datamars)mhpl74337-10.20.248.65 ~$ kubectl <span class="built_in">exec</span> -it influxdb-e2cb6c913a191e56c134e-data-0 -n influxdb -- bash</span><br><span class="line">root@influxdb-e2cb6c913a191e56c134e-data-0:/<span class="comment"># influxd version</span></span><br><span class="line">InfluxDB v1.8.10-c1.1.2 (git: master 529251fda5d776cf47bb0c247cf81075f2980fed, build: go1.16.15 linux/amd64)</span><br></pre></td></tr></table></figure>
在使用InfluxDB进行备份和恢复操作时，通常需要在数据节点上执行相关命令（元节点上都没有influx指令。。）</li>
<li>进入influx命令行界面，验证身份信息；事实上，进入到influxdb实例中，便无需考虑节点，部署，，，了，直接操作数据库和数据<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@influxdb-e2cb6c913a191e56c134e-data-0:/<span class="comment"># influx</span></span><br><span class="line">Connected to http://localhost:8086 version 1.8.10-c1.1.2</span><br><span class="line">InfluxDB shell version: 1.8.10-c1.1.2</span><br><span class="line">&gt; auth</span><br><span class="line">username: </span><br><span class="line">password: </span><br></pre></td></tr></table></figure></li>
<li>数据库导出：容器层面命令，指定 数据文件和 写前日志(WAL)文件的存储目录，将指定数据库中指定时间的数据导出到指定文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@influxdb-e2cb6c913a191e56c134e-data-0:/<span class="comment"># influx_inspect export -datadir &quot;/var/lib/influxdb/data&quot; -waldir &quot;/var/lib/influxdb/wal&quot; -out &quot;influxdb_test01_dump_out&quot; -database &quot;test01&quot; -start &quot;2024-10-22T00:00:00Z&quot;</span></span><br></pre></td></tr></table></figure>
数据文件复制：1、从pod1复制到本地机器 2、从本地机器复制到部署在同一服务器上的pod2（NODE: mhpl74344）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo kubectl <span class="built_in">cp</span> influxdb/influxdb-e2cb6c913a191e56c134e-data-1:/influxdb_test01_dump_out data/influxdb_test01_dump_out</span><br><span class="line">sudo kubectl <span class="built_in">cp</span> data/influxdb_test01_dump_out influxdb/influxdb-e73f149ff7192bd87d190-data-1:/influxdb_test01_dump_out </span><br></pre></td></tr></table></figure>
获取密码：查看对应实例的admin账密，解密data<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl get secrets -n influxdb <span class="comment"># 看命名空间</span></span><br><span class="line">kubectl get secrets -n influxdb influxdb-e73f149ff7192bd87d190-influxdb -o yaml <span class="comment"># 看选定实例</span></span><br></pre></td></tr></table></figure>
数据库导入：容器层面执行命令，使用admin账号，指定文件、数据库、时间戳精度<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@influxdb-e73f149ff7192bd87d190-data-1:/<span class="comment"># influx -import -path=&#x27;influxdb_test01_dump_out&#x27; -precision=ns -username=&#x27;admin&#x27; -password=&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
实例导出：把influxdb集群实例中所有数据库的数据导出，不加 <code>-database</code>，加 <code>-compress</code><br>实例导入：加<code>-compressed</code> 导入压缩文件，本质上是先解压后倒入</li>
</ol>
<h4 id="10-28-k8s添加datamars-agent-Container到Pod"><a href="#10-28-k8s添加datamars-agent-Container到Pod" class="headerlink" title="10.28 k8s添加datamars-agent Container到Pod"></a>10.28 k8s添加datamars-agent Container到Pod</h4><ol>
<li>从已有的MongoDB实例中的statefulset配置文件中，找到datamars-agent容器修改配置<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导出配置文件</span></span><br><span class="line">apps@(datamars)mhpl74337-10.20.248.65 ~$ kubectl get sts  mg-84df6d638f192e1b200c1-rs0 -n mongodb -o yaml &gt; mongodb-sts.yaml</span><br><span class="line"><span class="comment"># 文件下载本地</span></span><br><span class="line">apps@(datamars)mhpl74337-10.20.248.65 ~$ sz mongodb-sts.yaml </span><br></pre></td></tr></table></figure></li>
<li>本地编辑器打开（for convenience）<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span>     </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">command:</span>  <span class="comment"># 找到datamars-agent容器</span></span><br><span class="line">        <span class="comment"># 配置</span></span><br><span class="line">        <span class="attr">image:</span> </span><br><span class="line">        <span class="attr">name:</span> </span><br><span class="line">        <span class="attr">volumeMounts:</span>  <span class="comment"># volumeMounts 是在容器层面配置的，定义了容器内的挂载点</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/etc/localtime</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">host-local-time</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/etc/mongodb-config</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/log</span>  <span class="comment"># /log 挂载了名为 log 的卷。</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">log</span></span><br><span class="line">      <span class="attr">volumes:</span>  <span class="comment"># volumes 是在 Pod 层面配置的，定义了 Pod 中可以使用的卷</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">configMap:</span></span><br><span class="line">          <span class="attr">defaultMode:</span> <span class="number">420</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">influxdb-e73f149ff7192bd87d190-data</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">config</span>  <span class="comment"># config 卷是一个 configMap，实际路径在物理机上并不固定，由 Kubernetes 动态管理</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/etc/localtime</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">File</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">host-local-time</span>  <span class="comment"># host-local-time 卷是一个 hostPath，路径为 /etc/localtime，类型为 File</span></span><br><span class="line">  <span class="attr">volumeClaimTemplates:</span>  <span class="comment"># volumeClaimTemplates 是在 StatefulSet 层面配置的，定义了持久化存储卷的声明</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">annotations:</span></span><br><span class="line">        <span class="attr">ext.datamars.org/blkio.throttle.read_iops_device:</span> <span class="string">&quot;8000&quot;</span></span><br><span class="line">        <span class="attr">ext.datamars.org/blkio.throttle.write_iops_device:</span> <span class="string">&quot;8000&quot;</span></span><br><span class="line">      <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">log</span>  <span class="comment"># log 卷声明了一个 PersistentVolumeClaim，请求 50Gi 的存储，实际路径在物理机上由存储类 datamars-default-lvm 管理，具体路径取决于存储类的实现</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">mongodb</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">accessModes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">storage:</span> <span class="string">50Gi</span></span><br><span class="line">      <span class="attr">storageClassName:</span> <span class="string">datamars-default-lvm</span></span><br><span class="line">      <span class="attr">volumeMode:</span> <span class="string">Filesystem</span></span><br><span class="line">    <span class="attr">status:</span></span><br><span class="line">      <span class="attr">phase:</span> <span class="string">Pending</span></span><br></pre></td></tr></table></figure>
查看pv（集群层面的存储），pvc（pv的使用规则）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apps@(datamars)mhpl74337-10.20.248.65 ~$ kubectl get pv -n influxdb</span><br><span class="line">apps@(datamars)mhpl74337-10.20.248.65 ~$ kubectl get pvc -n influxdb</span><br></pre></td></tr></table></figure></li>
<li>添加到influxdb-data Statefulset的配置中，手动更新sts配置（导出influxdb-sts.yaml，sz到本地，修改后rz传到服务器）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f influxdb-sts.yaml</span><br></pre></td></tr></table></figure>
或者，直接修改influxdb-data Statefulset的配置中，:wq 保存，成功后自动更新到Pod<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apps@(datamars)mhpl74337-10.20.248.65 ~$ kubectl edit sts -n influxdb influxdb-e73f149ff7192bd87d190-data</span><br><span class="line">statefulset.apps/influxdb-e73f149ff7192bd87d190-data edited</span><br><span class="line">apps@(datamars)mhpl74337-10.20.248.65 ~$ kubectl describe sts -n influxdb influxdb-e73f149ff7192bd87d190-data</span><br><span class="line"><span class="comment"># 最下面可以看到事件信息</span></span><br><span class="line">Events:</span><br><span class="line">  Type     Reason            Age                 From                    Message</span><br><span class="line">  ----     ------            ----                ----                    -------</span><br><span class="line">  Warning  FailedCreate      50m                 statefulset-controller  create Pod influxdb-e73f149ff7192bd87d190-data-0 <span class="keyword">in</span> StatefulSet influxdb-e73f149ff7192bd87d190-data failed error: Pod <span class="string">&quot;influxdb-e73f149ff7192bd87d190-data-0&quot;</span> is invalid: spec.containers[1].volumeMounts[0].name: Not found: <span class="string">&quot;conf&quot;</span></span><br><span class="line">  Normal   SuccessfulCreate  48m (x2 over 12d)   statefulset-controller  create Pod influxdb-e73f149ff7192bd87d190-data-0 <span class="keyword">in</span> StatefulSet influxdb-e73f149ff7192bd87d190-data successful</span><br><span class="line"><span class="comment"># 或者看日志</span></span><br><span class="line">apps@(datamars)mhpl74337-10.20.248.65 ~$ kubectl logs influxdb-e73f149ff7192bd87d190-data-0 -n influxdb -c datamars-agent</span><br></pre></td></tr></table></figure></li>
<li>注意以上操作只是手动修改一个Pod，要想新建Pod中的配置更新，需要到helm配置。。</li>
</ol>
<h4 id="11-4-Datamars-Agent开发备份task"><a href="#11-4-Datamars-Agent开发备份task" class="headerlink" title="11.4 Datamars-Agent开发备份task"></a>11.4 Datamars-Agent开发备份task</h4><ol>
<li>配置go开发环境<br>下载g，安装go版本，配置GOROOT&#x3D;go安装目录，GOPATH&#x3D;go工作目录(安装包的目录)，配置vscode(Go extension, code runner)</li>
<li>构造Golang项目<br>安装protoc，添加到PATH；通过chocolatey安装 make 工具，运行 Makefile 文件中的目标，构造go项目<br>datamars-agent接入新engine：在proto&#x2F;common.proto 新增engine，根目录下执行 make pb 命令，调用 Makefile 中定义的 pb 目标，进而执行 scripts&#x2F;gen_proto.sh 脚本来编译 proto 文件，生成Go，grpc程序<br><strong>Protobuf</strong> 是一种由 Google 开发的用于序列化结构化数据的语言中立、平台中立的可扩展机制，Protoc 可以将 定义了数据结构和序列化规则的 .proto 文件编译生成包括 Go， Java的多种语言。</li>
<li>task对接<br>bakserver(Java系统)下发task到datamars-agent(Go系统)，事实上是将DaataBackupCfg包装成message，用grpc发送至指定pod，通过protoc同步配置</li>
</ol>
<h4 id="11-11-调研与开发：InfluxDB备份与恢复"><a href="#11-11-调研与开发：InfluxDB备份与恢复" class="headerlink" title="11.11 调研与开发：InfluxDB备份与恢复"></a>11.11 调研与开发：<em>InfluxDB备份与恢复</em></h4><p>10.14-10.18：看文档，建立InfluxDB集群概念(前期已经也在看了..)，建立整体框架概念（apiserver–bakserver–agent）<br>10.21-10.25：本地容器搭建influxdb集群×，连接服务器测试实例验证功能，了解K8S概念，手动验证实例(库级)导入导出即逻辑备份<br>10.28-11.01：对其需求(能做但没用户??)，完成技术文档框架，开始将功能接入datamars-bakserver，了解golang开发<br>11.04-11.08：搭建go开发和agent项目环境，，无法理解go项目结构，尝试从bakserver侧理解task下发-接收-执行全流程<br>11.11：理解所有业务代码(after2weeks)发现task下发无需改动，只需适配influxdb(修改配置类和表)，接着打包至sit环境打印log调试<br>技术文档先行？？将需求拆分成一步步，便于开发与汇报<br>关注重要的事情（功能接入不是重要的，，对齐需求和功能验证√）<br>进度评估。。buffer<br>好心态😇不怕叼</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/07/%E7%BE%8E%E7%9A%84Midea/" data-id="cm3lnru6d000tf0v56tlv57tc" data-title="美 的 Midea" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-毕业设计" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/05/01/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/" class="article-date">
  <time class="dt-published" datetime="2024-05-01T03:11:00.000Z" itemprop="datePublished">2024-05-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/05/01/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/">毕 业 🎓 设 计</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="选-题"><a href="#选-题" class="headerlink" title="选 题"></a><strong>选 题</strong></h2><p><em>基于内地与香港金融平台的在线量化投资的数据原型系统的设计与开发_</em>_</p>
<h3 id="论文结构"><a href="#论文结构" class="headerlink" title="论文结构"></a>论文结构</h3><p>摘 要 II<br>Abstract III<br>目 录 V<br>第一章 绪论<br>1.1 引言<br>1.2 研究背景<br>1.3 研究现状<br>1.4 课题来源及意义<br>1.5 论文结构<br>第二章 数据原型系统开发环境和工具<br>2.1 Python爬虫<br>2.2 Django框架<br>2.3 设计模式<br>2.4 前端开发框架<br>2.5 开源图形库 ECharts<br>2.6 本章小结<br>第三章 数据原型系统架构设计<br>3.1 综合性金融系统架构设计<br>3.2 数据原型系统架构设计<br>3.3 功能接口设计<br>3.4 数据库设计<br>第四章 数据原型系统的实现<br>4.1从金融平台获取数据实现<br>4.2 数据库查询实现<br>4.3 数据可视化实现<br>4.4 Echarts 图形库渲染生成统计图表<br>4.5 数据下载接口实现<br>4.6 数据维护接口实现<br>第五章 数据原型系统的测试及结果<br>5.1 数据更新模块测试<br>5.2 数据下载模块测试<br>5.3 数据分析模块测试<br>5.4 数据维护模块测试<br>5.5 本章小结<br>第六章 结论<br>1.论文工作总结<br>2.工作展望<br>参考文献<br>致谢</p>
<h3 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h3><ul>
<li>香港市场股票数据库的构建<ul>
<li>MySql数据库：股票、基金、期货</li>
<li>数据库表结构：参考旧论文&#x2F;直接用东方财富网表头</li>
<li>用python爬虫爬取数据, 数据清洗, 爬取历史数据</li>
</ul>
</li>
<li>获取香港期货代码 \spider\Get_Future_Info.py<ul>
<li>数据库创建  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CreateDatabase</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, new_database</span>):</span><br><span class="line">        self.new_database = new_database</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_new_database</span>(<span class="params">self</span>):</span><br><span class="line">        connection = pymysql.connect(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, user=<span class="string">&#x27;root&#x27;</span>, password=<span class="string">&#x27;078114&#x27;</span>, cursorclass=pymysql.cursors.DictCursor)</span><br><span class="line">        new_database_name = self.new_database</span><br><span class="line">        cursor = connection.cursor()</span><br><span class="line">        cursor.execute(<span class="string">f&quot;CREATE DATABASE <span class="subst">&#123;new_database_name&#125;</span>&quot;</span>)</span><br><span class="line">        cursor.close()</span><br><span class="line">        connection.close()</span><br></pre></td></tr></table></figure></li>
<li>数据库操作  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Database</span>:          </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">InsertFutureInfo</span>(<span class="params">self, item</span>):  <span class="comment"># 插入数据</span></span><br><span class="line">        mydb = pymysql.connect(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">3306</span>, user=<span class="string">&#x27;root&#x27;</span>, password=<span class="string">&#x27;078114&#x27;</span>, database=<span class="string">&#x27;finance&#x27;</span>, charset=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">        cursor = mydb.cursor()</span><br><span class="line">        sql = <span class="string">&quot;insert into futureinfo values(%s, %s)&quot;</span></span><br><span class="line">        cursor.executemany(sql, item) <span class="comment"># 要传入一个二维列表或元组的列表作为参数 item，每个子列表或元组应包含两个元素，对应着 SQL 语句中的两个 %s，用于插入数据库表中的两个字段的值</span></span><br><span class="line">        mydb.commit()</span><br><span class="line">        cursor.close()</span><br><span class="line">        mydb.close()</span><br></pre></td></tr></table></figure></li>
<li>爬虫操作  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取期货列表：东方财富网今天期货市场中港交所的期货列表信息（??不确定是不是完整期货信息）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getInfo</span>(<span class="params">self</span>): </span><br><span class="line">    url_base = <span class="string">&#x27;https://futsseapi.eastmoney.com/list/HKSTOCKF?callback=aaa_callback&amp;xx&#x27;</span></span><br><span class="line">    all_data = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>): <span class="comment"># 默认30页？</span></span><br><span class="line">        url = url_base.<span class="built_in">format</span>(size=<span class="number">20</span>, page=i)</span><br><span class="line">        data_str = requests.get(url).text</span><br><span class="line">        json_str = data_str[data_str.index(<span class="string">&#x27;(&#x27;</span>) + <span class="number">1</span>:-<span class="number">1</span>] <span class="comment"># 去除 JSON 数据中的回调函数</span></span><br><span class="line">        data_list = json.loads(json_str)[<span class="string">&quot;list&quot;</span>]</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> data_list:</span><br><span class="line">            tmp = [item[<span class="string">&#x27;dm&#x27;</span>], item[<span class="string">&#x27;name&#x27;</span>]] <span class="comment"># 期货代码，期货名称</span></span><br><span class="line">            all_data.append(tmp)</span><br><span class="line">    Database().InsertFutureInfo(all_data) </span><br></pre></td></tr></table></figure>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取历史期货数据：通过之前获取的期货列表信息，根据期货代码获取其历史（日线）数据（??不确定完整）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getHistory</span>(<span class="params">self</span>): </span><br><span class="line">    url_base = <span class="string">&#x27;https://push2his.eastmoney.com/api/qt/stock/kline/get?secid=130.&#123;secid&#125;&amp;xx&#x27;</span></span><br><span class="line">    all_data = <span class="built_in">list</span>()</span><br><span class="line">    code_list = Database().GetCodeList() <span class="comment"># 获取期货列表信息</span></span><br><span class="line">    <span class="keyword">for</span> dm <span class="keyword">in</span> tqdm(code_list):</span><br><span class="line">        url = url_base.<span class="built_in">format</span>(secid=dm) <span class="comment"># 日线数据</span></span><br><span class="line">        response = requests.get(url=url, timeout=<span class="number">15</span>)</span><br><span class="line">        klines_data = json.loads(response.text)[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;klines&#x27;</span>]</span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> klines_data:</span><br><span class="line">            res_data = data.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">            res_data = [dm] + res_data <span class="comment"># 元组首位加上期货代码</span></span><br><span class="line">            all_data.append(res_data)</span><br><span class="line">    Database().InsertFutureHistory(all_data)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="系统开发"><a href="#系统开发" class="headerlink" title="系统开发"></a>系统开发</h2><ul>
<li>系统架构<ul>
<li>前端：Django+Template，Echarts</li>
<li>后端：Django，MySQL，定时任务</li>
</ul>
</li>
<li>主要工作（原）<ul>
<li>四大模块：数据更新、数据下载、数据分析、数据维护<ul>
<li>一、香港数据<ol>
<li>数据实时更新 （1.1 数据列表(香港股票，香港基金，香港指数，香港期货，香港交易所),1.2 基本信息数据（股票、基金、期货），1.3 基本信息， 1.4 财务报表， 1.5 香港历史交易数据（香港股票，香港基金，香港指数，香港期货）， 1.6 当日交易数据（香港股票，香港基金，香港指数，香港期货）） </li>
<li>数据下载 （2.1 列表数据下载(香港股票，香港基金，香港指数，香港期货，香港交易所)，2.2 基本信息数据下载（股票、基金、期货），2.3 基本信息下载， 2.4 财务报表数据下载， 2.5 香港历史交易数据下载（大陆股票，大陆基金，大陆指数，大陆期货）， 2.6 当日交易数据下载（香港股票，香港基金，香港指数，香港期货））</li>
<li>数据分析 （3.1 列表数据分析(香港股票，香港基金，香港指数，香港期货，香港交易所)，3.2 基本信息数据分析（股票、基金、期货），3.3 基本信息分析， 3.4 财务报表数据分析， 3.5 大陆历史交易数据分析（大陆股票，大陆基金，大陆指数，大陆期货）， 3.6 当日交易数据分析（大陆股票，大陆基金，大陆指数，大陆期货））</li>
<li>数据维护 （4.1 数据导出 4.1.1 数据列表导出(香港股票，香港基金，香港指数，香港期货，香港交易所),4.1.2 基本信息数据导出（股票、基金、期货），4.1.3 基本信息数据导出， 4.1.4 财务报表导出， 4.1.5 香港历史交易数据导出（香港陆股票，香港基金，香港指数，香港期货）， 4.1.6 当日交易数据导出（香港股票，香港基金，香港指数，香港期货）， 4.2 数据导入 4.2.1 数据列表导入(香港股票，香港基金，香港指数，香港期货，香港交易所),4.2.2 基本信息数据导入（股票、基金、期货），4.2.3 基本信息数据导入， 4.2.4 财务报表导入， 4.2.5 香港历史交易数据导入（香港股票，香港基金，香港指数，香港期货）， 4.2.6 当日交易数据导入（香港股票，香港基金，香港指数，香港期货））】</li>
</ol>
</li>
<li>二、香港相关数据还要包括 【1 深港通、沪港通数据；2. 在港上市的大陆股票；3. 在港国企股；4. 港股的科创板】</li>
</ul>
</li>
</ul>
</li>
<li><strong>主要工作（真）</strong><ul>
<li><strong>主要是要多完成港股中相关数据内容：</strong><a target="_blank" rel="noopener" href="https://quote.eastmoney.com/center/ggsc.html">港股主板、港股创业板、知名港股、蓝筹股、红筹股、红筹成分股、国企股、国企成分股、港股通成份股、人民币交易港股、AH股比价、香港指数</a> </li>
<li><strong>突出两地股市的差别：对这几个港股数据，提供数据展示（调用其他同学的接口同时展现大陆数据），数据更新、维护、下载的功能；最好论文还要有一些分析的结果，需要自己做一些结果和图表出来，系统上时间不够可以不加</strong></li>
</ul>
</li>
<li>开发流程<ul>
<li>港股数据爬取（spider）：<br>  创建各类港股基本信息表：获取“港股市场xx股”（在今日）的信息列表，将“股票代码”、“股票名称”等保存在数据库对应的基本信息表中，同时保存“更新时间”为今日<br>  创建各类港股历史数据表：根据“港股市场xx股”的基本信息表中的股票代码，获取该股至今的历史数据，将“股票代码, 名称, k线数据, 时间”存入对应的历史数据表中</li>
<li>港股数据更新（spider）：<br>  更新各类港股基本信息表：获取“港股市场xx股”（在今日）的信息列表，将对应表中不存在的“股票代码”的数据存入并且保存“更新时间”为今日，将原本存在的股票信息和“更新时间”更新<br>  更新各类港股历史数据表：根据“港股市场xx股”的基本信息表中的“股票代码”和“更新时间”，获取从“更新时间”至今的历史数据，存入对应的历史数据表中（无序）</li>
<li>港股基本数据展示（Django）：展示各类港股基本信息表</li>
<li>港股K线图展示（Django）：根据股票代码，结合Echarts展示各类港股历史数据的K线图</li>
<li>提供数据接口供其他的模块使用（Django）：以JSON形式返回各类港股历史数据到页面上</li>
<li>数据下载（Django）：以JSON形式返回各类港股历史数据到页面上，右键“另存为”下载</li>
<li>数据维护：导入，导出</li>
</ul>
</li>
</ul>
<h3 id="数据库建设"><a href="#数据库建设" class="headerlink" title="数据库建设"></a>数据库建设</h3><ol>
<li>创建数据库和表（\spider\DB_Fund.py）<ul>
<li>xx股基本信息表 xxinfo<table>
<thead>
<tr>
<th>股票代码</th>
<th>股票名称</th>
<th>最新价</th>
<th>涨跌额</th>
<th>涨跌幅</th>
<th>今开</th>
<th>最高</th>
<th>最低</th>
<th>昨收</th>
<th>成交量(股)</th>
<th>成交额</th>
<th>更新日期</th>
</tr>
</thead>
<tbody><tr>
<td>code</td>
<td>name</td>
<td>now</td>
<td>change</td>
<td>changerate</td>
<td>open</td>
<td>high</td>
<td>low</td>
<td>yesterday_close</td>
<td>volume</td>
<td>amount</td>
<td>date_updated</td>
</tr>
</tbody></table>
</li>
<li>xx股历史数据表 xxhistory<table>
<thead>
<tr>
<th>code</th>
<th>date</th>
<th>open</th>
<th>now</th>
<th>high</th>
<th>low</th>
<th>volume</th>
<th>amount</th>
<th>rate</th>
<th>changerate</th>
<th>per</th>
<th>zero</th>
</tr>
</thead>
</table>
</li>
<li>A-H股基本信息表 AHStockComparisoninfo<table>
<thead>
<tr>
<th>名称</th>
<th>H股代码</th>
<th>最新价(HKD)</th>
<th>涨跌幅</th>
<th>A股代码</th>
<th>最新价(RMB)</th>
<th>涨跌幅</th>
<th>比价（A&#x2F;H）</th>
<th>溢价（A&#x2F;H）%</th>
<th>更新时间</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>code_hkd</td>
<td>now_hkd</td>
<td>changerate_hkd</td>
<td>code_rmb</td>
<td>now_rmb</td>
<td>changerate_rmb</td>
<td>AHcomparison</td>
<td>AHcomparisonrate</td>
<td>date_updated</td>
</tr>
</tbody></table>
</li>
<li>港股市场术语英文表示：<ol>
<li>港股主板：HKEXMainBoardinfo</li>
<li>港股创业板：GEMofHKEXinfo</li>
<li>知名港股</li>
<li>蓝筹股</li>
<li>红筹股</li>
<li>红筹成分股</li>
<li>国企股：SOEStocksinfo</li>
<li>国企成分股：SOEConstituentStocksinfo</li>
<li>港股通成份股：HKStockConnectConstituentStocksinfo</li>
<li>人民币交易港股</li>
<li>AH股比价：AHStockComparisoninfo</li>
<li>ADR</li>
<li>香港指数：HKStockIndexinfo</li>
</ol>
</li>
</ul>
</li>
<li>爬取港股基本信息（\spider\Get_HKStock\HKStockSpider().getxxInfo()）<ul>
<li>使用F12抓包，点击如“港股主板”按钮查询出对应的股票数据，刷新页面，过滤出js文件，找到对应的股票数据的get请求api（默认pn&#x3D;1，pz&#x3D;20，表示获取第一页大小为20的股票数据列表）；从中获取总数据行数”data”&#x2F;“total”，再次发送get请求（设置pn&#x3D;1，pz&#x3D;total）获取完整的该股票数据列表    </li>
<li>港股主板：’<a target="_blank" rel="noopener" href="https://86.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112408726538243180275_1714550583811&pn=1&pz=20&po=1&np=1&ut=bd1d9ddb04089700cf9c27f6f7426281&fltt=2&invt=2&wbp2u=8413067108550254%7C0%7C1%7C0%7Cweb&fid=f3&fs=m:116+t:3&fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&_=1714550583816">https://86.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112408726538243180275_1714550583811&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=8413067108550254|0|1|0|web&amp;fid=f3&amp;fs=m:116+t:3&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&amp;_=1714550583816</a>‘</li>
<li>港股创业板：<a target="_blank" rel="noopener" href="https://86.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112408726538243180275_1714550583811&pn=1&pz=20&po=1&np=1&ut=bd1d9ddb04089700cf9c27f6f7426281&fltt=2&invt=2&wbp2u=8413067108550254%7C0%7C1%7C0%7Cweb&fid=f3&fs=m:116+t:4&fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&_=1714550583886">https://86.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112408726538243180275_1714550583811&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=8413067108550254|0|1|0|web&amp;fid=f3&amp;fs=m:116+t:4&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&amp;_=1714550583886</a></li>
<li>知名港股：<a target="_blank" rel="noopener" href="https://86.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112408726538243180275_1714550583811&pn=1&pz=20&po=1&np=1&ut=bd1d9ddb04089700cf9c27f6f7426281&fltt=2&invt=2&wbp2u=8413067108550254%7C0%7C1%7C0%7Cweb&fid=f3&fs=b:MK0106&fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&_=1714550583906">https://86.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112408726538243180275_1714550583811&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=8413067108550254|0|1|0|web&amp;fid=f3&amp;fs=b:MK0106&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&amp;_=1714550583906</a></li>
<li>蓝筹股：<a target="_blank" rel="noopener" href="https://57.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112407221764962597832_1714570944282&pn=1&pz=20&po=1&np=1&ut=bd1d9ddb04089700cf9c27f6f7426281&fltt=2&invt=2&wbp2u=8413067108550254%7C0%7C1%7C0%7Cweb&fid=f3&fs=b:MK0105&fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&_=1714570944470">https://57.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112407221764962597832_1714570944282&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=8413067108550254|0|1|0|web&amp;fid=f3&amp;fs=b:MK0105&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&amp;_=1714570944470</a></li>
<li>红筹股：<a target="_blank" rel="noopener" href="https://57.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112407221764962597832_1714570944286&pn=1&pz=20&po=1&np=1&ut=bd1d9ddb04089700cf9c27f6f7426281&fltt=2&invt=2&wbp2u=8413067108550254%7C0%7C1%7C0%7Cweb&fid=f3&fs=b:MK0102&fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&_=1714570944490">https://57.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112407221764962597832_1714570944286&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=8413067108550254|0|1|0|web&amp;fid=f3&amp;fs=b:MK0102&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&amp;_=1714570944490</a></li>
<li>红筹成分：<a target="_blank" rel="noopener" href="https://57.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112407221764962597832_1714570944286&pn=1&pz=20&po=1&np=1&ut=bd1d9ddb04089700cf9c27f6f7426281&fltt=2&invt=2&wbp2u=8413067108550254%7C0%7C1%7C0%7Cweb&fid=f3&fs=b:MK0111&fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&_=1714570944499">https://57.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112407221764962597832_1714570944286&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=8413067108550254|0|1|0|web&amp;fid=f3&amp;fs=b:MK0111&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&amp;_=1714570944499</a></li>
<li>国企股：<a target="_blank" rel="noopener" href="https://86.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112408726538243180275_1714550583811&pn=1&pz=20&po=1&np=1&ut=bd1d9ddb04089700cf9c27f6f7426281&fltt=2&invt=2&wbp2u=8413067108550254%7C0%7C1%7C0%7Cweb&fid=f3&fs=b:MK0103&fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&_=1714550583915">https://86.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112408726538243180275_1714550583811&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=8413067108550254|0|1|0|web&amp;fid=f3&amp;fs=b:MK0103&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&amp;_=1714550583915</a></li>
<li>国企成分股：<a target="_blank" rel="noopener" href="https://86.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112408726538243180275_1714550583811&pn=1&pz=20&po=1&np=1&ut=bd1d9ddb04089700cf9c27f6f7426281&fltt=2&invt=2&wbp2u=8413067108550254%7C0%7C1%7C0%7Cweb&fid=f3&fs=b:MK0112&fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&_=1714550583919">https://86.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112408726538243180275_1714550583811&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=8413067108550254|0|1|0|web&amp;fid=f3&amp;fs=b:MK0112&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&amp;_=1714550583919</a></li>
<li>股港股通成份股：<a target="_blank" rel="noopener" href="https://57.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112407221764962597832_1714570944286&pn=1&pz=20&po=1&np=1&ut=bd1d9ddb04089700cf9c27f6f7426281&fltt=2&invt=2&wbp2u=8413067108550254%7C0%7C1%7C0%7Cweb&fid=f3&fs=b:MK0146,b:MK0144&fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&_=1714570944503">https://57.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112407221764962597832_1714570944286&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=8413067108550254|0|1|0|web&amp;fid=f3&amp;fs=b:MK0146,b:MK0144&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&amp;_=1714570944503</a></li>
<li>人民币交易港股：<a target="_blank" rel="noopener" href="https://57.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112407221764962597832_1714570944286&pn=1&pz=20&po=1&np=1&ut=bd1d9ddb04089700cf9c27f6f7426281&fltt=2&invt=2&wbp2u=8413067108550254%7C0%7C1%7C0%7Cweb&fid=f3&fs=m:116+s:64&fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&_=1714570944509">https://57.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112407221764962597832_1714570944286&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=8413067108550254|0|1|0|web&amp;fid=f3&amp;fs=m:116+s:64&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&amp;_=1714570944509</a></li>
<li>AH股比价：<a target="_blank" rel="noopener" href="https://57.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112407221764962597832_1714570944286&pn=1&pz=20&po=1&np=1&ut=bd1d9ddb04089700cf9c27f6f7426281&fltt=2&invt=2&wbp2u=8413067108550254%7C0%7C1%7C0%7Cweb&fid=f3&fs=b:MK0101&fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f20,f21,f23,f24,f25,f22,f11,f62,f128,f136,f115,f152,f191,f192,f193,f186,f185,f187,f189,f188&_=1714570944513">https://57.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112407221764962597832_1714570944286&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=8413067108550254|0|1|0|web&amp;fid=f3&amp;fs=b:MK0101&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f20,f21,f23,f24,f25,f22,f11,f62,f128,f136,f115,f152,f191,f192,f193,f186,f185,f187,f189,f188&amp;_=1714570944513</a></li>
<li>香港指数：<a target="_blank" rel="noopener" href="https://86.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112408726538243180275_1714550583811&pn=1&pz=20&po=1&np=1&ut=bd1d9ddb04089700cf9c27f6f7426281&fltt=2&invt=2&wbp2u=8413067108550254%7C0%7C1%7C0%7Cweb&fid=f3&fs=m:124,m:125,m:305&fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&_=1714550583922">https://86.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112408726538243180275_1714550583811&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=8413067108550254|0|1|0|web&amp;fid=f3&amp;fs=m:124,m:125,m:305&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&amp;_=1714550583922</a></li>
</ul>
</li>
<li>爬取港股历史数据（\spider\Get_HKStock\HKStockSpider().getxxHistory()）<ul>
<li>从各类港股基本信息表中获取股票代码替换secid，date为今日，查询其历史k线数据</li>
<li>一般情况，MySQL每张表最好不要超过2000万条数据，阿里的Java开发手册上也提出：单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。或者说，要根据实际场景分析。</li>
<li>港股日线数据(除A-H股价比，港股指数外)：<a target="_blank" rel="noopener" href="https://push2his.eastmoney.com/api/qt/stock/kline/get?cb=jQuery35106242902488344593_1714571208625&secid=116.%7Bsecid%7D&ut=fa5fd1943c7b386f172d6893dbfba10b&fields1=f1,f2,f3,f4,f5,f6&fields2=f51,f52,f53,f54,f55,f56,f57,f58,f59,f60,f61&klt=101&fqt=1&beg=0&end=20500101&smplmt=755&lmt=1000000&_=1714571208630">https://push2his.eastmoney.com/api/qt/stock/kline/get?cb=jQuery35106242902488344593_1714571208625&amp;secid=116.{secid}&amp;ut=fa5fd1943c7b386f172d6893dbfba10b&amp;fields1=f1%2Cf2%2Cf3%2Cf4%2Cf5%2Cf6&amp;fields2=f51%2Cf52%2Cf53%2Cf54%2Cf55%2Cf56%2Cf57%2Cf58%2Cf59%2Cf60%2Cf61&amp;klt=101&amp;fqt=1&amp;beg=0&amp;end=20500101&amp;smplmt=755&amp;lmt=1000000&amp;_=1714571208630</a></li>
<li>A-H股价比，港股指数日线数据先不弄。。</li>
</ul>
</li>
<li>数据更新（\spider\Update_HKStock.py）<ul>
<li>更新港股基本信息</li>
<li>更新港股历史数据</li>
<li>定时任务</li>
</ul>
</li>
<li>数据接口（Django实现）：以JSON形式返回各类港股历史数据到页面上，供其他的模块使用</li>
<li>数据下载（Django实现）：以JSON形式返回各类港股历史数据到页面上，右键“另存为”保存</li>
<li>数据维护</li>
</ol>
<h3 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h3><ul>
<li>项目结构 <img src="https://leo710aka.github.io/bk/datasite.png" width="550" height="300" alt=""></li>
</ul>
<h3 id="示例1：展示香港指数基本信息表-HKStockIndexinfo"><a href="#示例1：展示香港指数基本信息表-HKStockIndexinfo" class="headerlink" title="示例1：展示香港指数基本信息表 HKStockIndexinfo"></a><strong>示例1：展示香港指数基本信息表 HKStockIndexinfo</strong><img src="https://github.com/leo710aka/bk/blob/main/bishe1.png?raw=true" width="700" height="300" alt=""></h3><ol>
<li>编写model（datasite&#x2F;mainapp&#x2F;models.py）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HKStockIndexinfo</span>(models.Model):</span><br><span class="line">    code = models.CharField(max_length=<span class="number">12</span>, primary_key=<span class="literal">True</span>)  <span class="comment"># 假设code是主键</span></span><br><span class="line">    name = models.FloatField(max_length=<span class="number">20</span>, db_column=<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    now = models.FloatField(db_column=<span class="string">&#x27;now&#x27;</span>)</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        db_table = <span class="string">&#x27;HKStockIndexinfo&#x27;</span></span><br><span class="line">        managed = <span class="literal">False</span></span><br></pre></td></tr></table></figure></li>
<li>迁移，将 model与 MySQL中的表映射<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations  <span class="comment"># IDE console</span></span><br></pre></td></tr></table></figure></li>
<li>编写html（datasite&#x2F;mainapp&#x2F;templates&#x2F;hkstockindexinfo.html）<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>代码<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>名称<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    &#123;% for info in infos %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">&quot;color: #1e8ecc;&quot;</span>&gt;</span>&#123;&#123; info.code &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">&quot;color: #1e8ecc;&quot;</span>&gt;</span>&#123;&#123; info.name &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>编写应用请求（datasite&#x2F;mainapp&#x2F;views.py）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hkstockindexinfo</span>(<span class="params">request</span>):</span><br><span class="line">    infos = HKStockIndexinfo.objects.<span class="built_in">all</span>()                    <span class="comment"># 从MySQL中获取对应表的数据</span></span><br><span class="line">    context = &#123;<span class="string">&#x27;infos&#x27;</span>: infos&#125;                                <span class="comment"># 创建上下文字典</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;hkstockindexinfo.html&#x27;</span>, context)  <span class="comment"># 渲染模板</span></span><br></pre></td></tr></table></figure></li>
<li>配置路由（datasite&#x2F;datasite&#x2F;urls.py）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;hkstockindexinfo&#x27;</span>, views.hkstockindexinfo),  <span class="comment"># 不需要配置项目-应用两级url</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li>启动Django项目<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS E:\Code\datasite&gt; python manage.py runserver</span><br></pre></td></tr></table></figure></li>
<li>发送请求 <a target="_blank" rel="noopener" href="http://127.0.0.1:8000/hkstockindexinfo%EF%BC%8C">http://127.0.0.1:8000/hkstockindexinfo，</a> 展示香港指数基本信息表</li>
</ol>
<h3 id="示例2：使用Echart展示港股主板历史数据k线图"><a href="#示例2：使用Echart展示港股主板历史数据k线图" class="headerlink" title="示例2：使用Echart展示港股主板历史数据k线图"></a><strong>示例2：使用Echart展示港股主板历史数据k线图</strong><img src="https://github.com/leo710aka/bk/blob/main/bishe4.png?raw=true" width="700" height="300" alt=""></h3><ol>
<li>编写model（datasite&#x2F;mainapp&#x2F;models.py）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HKEXMainBoardhistory</span>(models.Model):</span><br><span class="line">    code = models.CharField(max_length=<span class="number">12</span>, primary_key=<span class="literal">True</span>)  <span class="comment"># 假设code是主键</span></span><br><span class="line">    date = models.CharField(max_length=<span class="number">10</span>, db_column=<span class="string">&#x27;date&#x27;</span>)</span><br><span class="line">    <span class="built_in">open</span> = models.FloatField(db_column=<span class="string">&#x27;open&#x27;</span>)</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        db_table = <span class="string">&#x27;HKEXMainBoardhistory&#x27;</span></span><br><span class="line">        managed = <span class="literal">False</span></span><br></pre></td></tr></table></figure></li>
<li>迁移，将 model与 MySQL中的表映射<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations  <span class="comment"># IDE console</span></span><br></pre></td></tr></table></figure></li>
<li>编写html（datasite&#x2F;mainapp&#x2F;templates&#x2F;historyklines.html）<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;% load static %&#125;  <span class="comment">&lt;!-- 在项目setting.py配置：STATIC_URL = &#x27;/static/&#x27; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>港股主板历史数据k线图<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入已经下载到本地/static/assets/js下的Echarts文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;&#123;% static &#x27;assets/js/echarts.js&#x27; %&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 1600px;height:800px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 从Echarts官网上复制K线图示例代码</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> chartDom = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;main&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> myChart = echarts.<span class="title function_">init</span>(chartDom);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> option;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 使用模板语言获取传递的 JSON 数据</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> jsonData = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="string">&#x27;&#123;&#123; jsonData | escapejs &#125;&#125;&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">splitData</span>(<span class="params">rawData</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// ...</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">renderItem</span>(<span class="params">params, api</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// ...</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 使用后端查询的数据，代替模版代码中原本外部引入的json文件</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> data = <span class="title function_">splitData</span>(jsonData);</span></span><br><span class="line"><span class="language-javascript">        myChart.<span class="title function_">setOption</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// ...</span></span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>编写应用请求（datasite&#x2F;mainapp&#x2F;views.py）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">historyklines</span>(<span class="params">request</span>):</span><br><span class="line">    code = request.GET.get(<span class="string">&#x27;code&#x27;</span>)  <span class="comment"># 获取请求中携带的code参数值</span></span><br><span class="line">    queryset = HKEXMainBoardhistory.objects.<span class="built_in">filter</span>(code=code)  <span class="comment"># 查询所有代码为 code 的数据</span></span><br><span class="line">    jsonData = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> queryset:  <span class="comment"># 构造二维数组</span></span><br><span class="line">        data_row = [</span><br><span class="line">            item.date, item.<span class="built_in">open</span>, item.now, item.low, item.high, item.volume</span><br><span class="line">        ]</span><br><span class="line">        jsonData.append(data_row)</span><br><span class="line">    jsonData_str = json.dumps(jsonData)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;historyklines.html&#x27;</span>, &#123;<span class="string">&#x27;jsonData&#x27;</span>: jsonData_str&#125;)</span><br></pre></td></tr></table></figure></li>
<li>配置路由（datasite&#x2F;datasite&#x2F;urls.py）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;historyklines&#x27;</span>, views.historyklines),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li>启动Django项目<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS E:\Code\datasite&gt; python manage.py runserver</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="示例3：提供数据接口供其他模块调用，下载历史数据"><a href="#示例3：提供数据接口供其他模块调用，下载历史数据" class="headerlink" title="示例3：提供数据接口供其他模块调用，下载历史数据"></a><strong>示例3：提供数据接口供其他模块调用，下载历史数据</strong><img src="https://github.com/leo710aka/bk/blob/main/bishe3.png?raw=true" width="700" height="300" alt=""></h3><ol>
<li>指的是xx股历史数据</li>
<li>编写Model、View，配置urls<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hkexmainboarddata</span>(<span class="params">request</span>):</span><br><span class="line">    code = request.GET.get(<span class="string">&#x27;code&#x27;</span>)</span><br><span class="line">    data = HKEXMainBoardhistory.objects.<span class="built_in">filter</span>(code=code)</span><br><span class="line">    data_dict_list = [&#123;<span class="string">&quot;code&quot;</span>: item.code, <span class="string">&quot;date&quot;</span>: item.date, <span class="string">&quot;open&quot;</span>: item.<span class="built_in">open</span>, <span class="string">&quot;now&quot;</span>: item.now,</span><br><span class="line">                       <span class="string">&quot;high&quot;</span>: item.high, <span class="string">&quot;low&quot;</span>: item.low, <span class="string">&quot;volume&quot;</span>: item.volume, <span class="string">&quot;amount&quot;</span>: item.amount,</span><br><span class="line">                       <span class="string">&quot;rate&quot;</span>: item.rate, <span class="string">&quot;changerate&quot;</span>: item.changerate, <span class="string">&quot;per&quot;</span>: item.per, <span class="string">&quot;zero&quot;</span>: item.zero&#125;</span><br><span class="line">                      <span class="keyword">for</span> item <span class="keyword">in</span> data]</span><br><span class="line">    <span class="comment"># 转换为 JSON 格式</span></span><br><span class="line">    data_json = json.dumps(data_dict_list)</span><br><span class="line">    <span class="comment"># 返回 JSON 响应</span></span><br><span class="line">    <span class="keyword">return</span> JsonResponse(data_json, safe=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure></li>
<li>查询页面：输入港股代码，点击“生成K线图”按钮发送xxklines请求&#x2F;点击“下载历史数据”展示历史数据（右键“另存为”下载）<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card &quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card-header&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span> <span class="attr">class</span>=<span class="string">&quot;card-title&quot;</span>&gt;</span>港股历史数据<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;myForm&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;codeInput&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 150px;&quot;</span>&gt;</span>请输入港股主板代码：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;codeInput&quot;</span> <span class="attr">name</span>=<span class="string">&quot;codeInput&quot;</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">id</span>=<span class="string">&quot;submitButton&quot;</span>&gt;</span>生成K线图<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">id</span>=<span class="string">&quot;submitButton0&quot;</span>&gt;</span>下载历史数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myForm&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;submit&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  event.<span class="title function_">preventDefault</span>(); <span class="comment">// 阻止表单默认提交行为</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 获取输入框中的内容</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> code = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;codeInput&#x27;</span>).<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">if</span> (event.<span class="property">submitter</span>.<span class="property">id</span> === <span class="string">&#x27;submitButton&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 构造生成K线图的请求URL</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> url = <span class="string">`http://127.0.0.1:8000/hkexmainboardklines?code=<span class="subst">$&#123;code&#125;</span>`</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 在新标签页中打开链接</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="title function_">open</span>(url, <span class="string">&#x27;_blank&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.<span class="property">submitter</span>.<span class="property">id</span> === <span class="string">&#x27;submitButton0&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 构造下载历史数据的请求URL</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> url = <span class="string">`http://127.0.0.1:8000/hkexmainboarddata?code=<span class="subst">$&#123;code&#125;</span>`</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 在新标签页中打开链接</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="title function_">open</span>(url, <span class="string">&#x27;_blank&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>

<h1 id="毕业答辩"><a href="#毕业答辩" class="headerlink" title="毕业答辩"></a>毕业答辩</h1><p>毕业答辩的意义是，校方为了进一步的审查论文。<br>考查内容可归纳如下：①进一步考查和验证毕业论文作者对所着论文论题的认识程度及当场论证论题的能力 ②进一步考查毕业论文作者对专业知识掌握的深度与广度 ③审查毕业论文是否学员自己独立完成<br>答辩时提问依据：①汇报PPT的内容 ②毕业论文的内容 ③汇报者的言语</p>
<h3 id="答辩安排"><a href="#答辩安排" class="headerlink" title="答辩安排"></a>答辩安排</h3><p>答辩日期：5月24日（13周周五），上午1-4节，8：50开始，预计到中午左右结束；<br>答辩地点：A4206<br>需携带资料:<br>1.答辩ppt 电子版（u盘）；2.一式3份双面打印的论文（最新版，不需要装帧封面）。<br>注意事项：<br>1.请大家提前半小时（上午8：20）到现场，调试好设备（电脑、投影仪、麦克风，等），所有的ppt都拷贝到指定电脑上（可以用课室的电脑，但建议至少带一台笔记本做备用）。<br>2.提前打印好3份毕设论文（简单的双面打印即可，不需要特别装帧封面，因为不是最终稿），答辩前统一交给老师翻阅。如果在答辩前对论文有修改，和提交系统的版本不一致也没关系，只要打印最新版就可以了。<br>3.每人答辩陈述时间5分钟左右（可以利用powerpoint的排练功能提前排练好），然后留3分钟左右回答老师的提问。<br>4.回答问题时要认真记录下老师提出的修改意见，并在答辩结束后按要求修改论文，然后提交论文最终版到维普系统；<br>5.答辩结束后，老师们会在维普系统上给论文和答辩过程打分，大家把论文最终版提交维普系统之后，可以直接从系统上下载并打印带有老师电子签名的各类表格（一般不需要找老师们手签）。最终版论文一定要装帧好封面，和全套打印的表格一起，按照顺序放入档案袋并交给导师。</p>
<h2 id="答辩内容"><a href="#答辩内容" class="headerlink" title="答辩内容"></a>答辩内容</h2><p>各位评委老师，同学们：<br>大家上午好! 我是<em>网络工程</em>专业的<em>蔡枫</em>，我的论文题目是<em><strong>基于内地与香港金融平台的在线量化投资的数据原型系统的设计与开发</strong></em>。<br>&lt;翻页&gt;<br>今天我将从以下四个方面阐述我的毕业论文内容。<br>&lt;翻页&gt;</p>
<h3 id="第一部分-选题背景及意义"><a href="#第一部分-选题背景及意义" class="headerlink" title="第一部分 选题背景及意义"></a>第一部分 选题背景及意义</h3><p>随着在线量化投资的普及，如何有效地收集和整理海量的互联网金融数据，成为了一大挑战。<br>&lt;翻页&gt;<br>一方面，互联网数据具有实时性，导致用户和金融公司都难以检索过去特定时间的完整金融数据。<br>另一方面，人们需花费大量时间在门户网站浏览实时金融信息，但缺乏明确直观的数据分析结果。<br>&lt;翻页&gt;<br>为有效解决以上问题，本论文设计并开发了基于网络爬虫的数据原型系统，实时获取互联网上的金融数据，并提供数据下载的功能。<br>另外，系统提供了数据可视化和数据分析的功能，用户能够从中获取具有参考价值的信息。<br>以及，作为综合性金融系统中的底层数据平台，能够为其他模块的开发提供数据源。<br>&lt;翻页&gt;</p>
<h3 id="第二部分-开发环境与技术"><a href="#第二部分-开发环境与技术" class="headerlink" title="第二部分 开发环境与技术"></a>第二部分 开发环境与技术</h3><p>&lt;翻页&gt;<br>首先介绍一下网络爬虫，其通过模拟人类浏览网页的行为，获取并解析网络信息。<br>&lt;翻页&gt;<br>如果目标网站提供了 API 接口，我们可以通过浏览器的开发者工具进行抓包，并在Python项目中直接调用以获取数据。<br>&lt;翻页&gt;<br>系统的开发语言为 Python，采用 Django 框架结合前端技术进行 Web 应用的构建。通过编写 MTV 三层架构代码，开发子系统的各功能。<br>&lt;翻页&gt;<br>本系统中选择 MySQL 作为数据库，存储爬取到的网络金融数据，以及进行后续的功能开发。<br>&lt;翻页&gt;<br>本系统的数据库中主要有两种表，即各类港股基本信息表和港股历史数据表。<br>&lt;翻页&gt;<br>在港股基本信息表中，包括股票代码、股票名称、最新价、涨跌额等基本信息，另外还添加了 date_updated 字段，以便在更新历史数据表时计算出所需更新数据的时间段。<br>&lt;翻页&gt;<br>在港股历史数据表中，保存了表示K线数据的相关字段。<br>&lt;翻页&gt;</p>
<h3 id="第三部分-系统设计与实现"><a href="#第三部分-系统设计与实现" class="headerlink" title="第三部分 系统设计与实现"></a>第三部分 系统设计与实现</h3><p>&lt;翻页&gt;<br>本文的数据原型系统是作为综合性金融系统底层的数据平台模块进行开发的，其他的量化因子分析模块和量化投资策略模块由小组成员负责开发。<br>&lt;翻页&gt;<br>在底层的数据平台，即本文的数据原型系统中，保存了香港金融市场股票的交易数据，包括了数据库建设模块、数据可视化模块、数据接口模块、数据分析模块这四个模块。<br>&lt;翻页&gt;<br>在数据库建设模块中，主要有三个程序，分别用于创建数据库和表，初始化表数据，以及更新表数据。<br>其中更新程序是利用 schedule 库，设置定时任务16点实时更新数据到各类港股基本信息表中，根据基本信息表中的的股票代码和更新时间，获取其自更新时间至今的K线数据添加到对应的表中同时修改“更新时间”为当日，以及定期对表执行“转储SQL”操作进行数据备份，以便在需要时快速重构。<br>&lt;翻页&gt;<br>在数据可视化模块中，提供了基本信息表格功能。点击子系统导航栏，选择港股类型，在子系统界面上对应的基本信息数据。<br>&lt;翻页&gt;<br>实现的基本步骤为：编写模型与数据库表映射，编写视图接收请求和模版页面，并配置好请求访问路径，即可通过浏览器访问系统功能。<br>&lt;翻页&gt;<br>另外，提供了历史数据K线图展示功能，根据前端输入的各类港股股票代码，从数据库中获取数据，并利用 ECharts 生成历史数据K线图。<br>&lt;翻页&gt;<br>其实现步骤类似前面介绍的基本信息表格。<br>&lt;翻页&gt;<br>在数据接口模块中，复用了历史数据K线图功能的功能界面和业务代码，根据输入的各类港股股票代码，从数据库中对应的历史数据表中获取数据，以JSON形式返回到新标签页面上。<br>&lt;翻页&gt;<br>数据可以供综合性金融系统中的其他模块使用，用户也可以在页面上右键“另存为”下载数据文件。<br>&lt;翻页&gt;<br>最后是数据分析模块：对于采集的金融数据作进一步的分析，呈现更直观和更有价值的信息。我们另外爬取了内地市场沪深京A股的数据，对比分析凸显港陆市场的数据差别。<br>&lt;翻页&gt;<br>首先，对于港股与沪深京A股，计算基本统计描述。<br>&lt;翻页&gt;<br>可以简单分析看出，香港市场在股价波动性和交易量方面普遍较大，呈现出更高的市场活力和波动性；<br>内地市场的平均股价虽然较低，但交易量和交易金额却相对较高，显示出更为稳定的交易情况。<br>&lt;翻页&gt;<br>然后进一步进行各类数据的可视化分析。我们进行了收盘价分布统计，这是放大后。。<br>&lt;翻页&gt;<br>然后是涨跌幅分布比较。。<br>&lt;翻页&gt;</p>
<h3 id="第四部分-总结与展望"><a href="#第四部分-总结与展望" class="headerlink" title="第四部分 总结与展望"></a>第四部分 总结与展望</h3><p>&lt;翻页&gt;<br>本次毕业设计的工作涵盖了搭建数据原型系统的各个方面，包括金融数据库的设计、系统前端和后端的开发等。<br>（数据采集：直接从东方财富网接口获取金融数据，并通过数据清洗和整理存储到数据库中。在开发时使用了大模型进行数据含义的分析和编写数据清洗代码，极大地提高了开发效率。对于前端的编写，同组的同学提供了模板，为开发带来了很大的便利。只需开发子系统功能界面，将模板页面中空缺内容区块覆盖。在系统后端的开发过程中，我快速学习了Django的开发流程，进行需求分析和功能设计后，解决实际开发问题，同时总结经验完善系统。）<br>同时，对于这几个方面，未来还有需要改进的地方。<br>&lt;翻页&gt;<br>对于这几个方面，未来也有需要改进的地方，如加强数据采集时对异常情况的处理，优化系统前后端性能等。。<br>（在数据采集方面，引入多线程实现对数据的并行处理，另外还需加强对异常情况的处理，确保系统稳健运行。在系统前端方面，进一步完善用户界面的设计和用户体验，考虑引入前端框架如React、Vue.js等，以提升前端开发的效率和灵活性，提供更加直观和友好的数据展示方式。在系统后端方面，不断优化系统架构和性能，加强对系统的监控和管理，及时发现和解决潜在的问题，确保系统长期稳定运行。）<br>&lt;翻页&gt;<br>最后感谢各位老师的聆听及指导，我的汇报到此结束。</p>
<h3 id="问答环节"><a href="#问答环节" class="headerlink" title="问答环节"></a>问答环节</h3><ol>
<li>为什么会选择这个课题?<br>(自身原因+外部因素&#x3D;选择的原因，把选择的原因放大，从多角度回答)<br>我认为计算机金融有潜力，以及量化投资的研究在当下是非常有价值的，有很强的现实意义，其中数据平台的构建是基石。<br>本次毕业设计的工作涵盖了搭建数据原型系统的各个方面，包括金融数据库的设计、系统前端和后端的搭建等，提供一种快速构建的思路。</li>
<li>论文的创新点体现在哪里?<br>(通过和已有成果或内容相比较,从内容和研究方法上来讲创新。)<br>回答参考:本篇毕业论文的创新之处在于讨论 xxx 的问题时不仅在 xxx 方面列出xxx，也从实际的角度进行了举例论证。一是在方法上，本文将Xx方法与XX方法相结合,能够有效消除单一方法带来的误差,有效提高了数据的精度(结果的有效性)。二是在理论上，综合近十年的文献发现，目前还没有研究学者提出 xXX方面的内容，本文在理论的提出上是一种全新的尝试</li>
<li>本论文中你主要做了什么?<br>查找了大量的文献、书籍报刊，对这些资料进行了精谀，结合国内外的研究现状，对 xxx问题进行了归纳总结;在此基础上，提炼出本课题的核心，对xxx展开研究，并运用 xxx 方法进行研究;对xxx 研究结果进行分析，提出 solvexxx 问题的建议及措施。</li>
<li>本论文的意义和目的是什么?<br>(理论意义+实践意义)在理论方面，本文应用了 Xxx的专业方法，对于丰富果，并以具体的 xxx 例子展开应用得到较好的应用结果。</li>
<li>写论文的过程中有哪些困难，怎么克服的?<br>(如实叙即可，但一定要说问题是 solve 的!)<br>在撰写论文的过程中在xx方面(资料收集问卷发放实验开展)遇到有关 xxx(找不到相应主题的学术文献)困难，在与指导老师沟通后，查阅了老师推。荐的相关书籍、资料以及文献信息，也请教了直系的学长学姐们，最后 solve 了相关问题，在此也非常感谢给我提供帮助的他们。</li>
<li>论文哪些地方可以继续改进?<br>目前对于这个课题的认识确实还不够具体，所以在xxx 方萄的研究片法有一定限度，研究成果与前辈们的研究成果也确实相似，没有做到能够更加深入的研究。同时也受限于条件没能更多的试验方法</li>
<li>论文中的数据和资料从哪里来?<br>我的资料主要来自于知网等学术网站和导师提供的资料文献，数据是通过调查法以及些同类课题的数据参考,再统一分析计算得出</li>
<li>论文中相关定义的解释，理论解释?<br>要求你掌握本文研究中重点的一些概念及定义。有一些概率可以做一些生活中的举例来加深记忆。回答的时候也可以根据定义来加以拓展，比如:老师，这个问题我是这样理解的，以生活中的案例来举例 xxx 概念就好。比 XXX中的XXXX，对xxx是非常重要的。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/05/01/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/" data-id="cm3lnru65000qf0v51r6l29bt" data-title="毕 业 🎓 设 计" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-RabbitMQ" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/11/RabbitMQ/" class="article-date">
  <time class="dt-published" datetime="2024-01-11T02:58:11.000Z" itemprop="datePublished">2024-01-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/11/RabbitMQ/">RabbitMQ</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="一、初识MQ"><a href="#一、初识MQ" class="headerlink" title="一、初识MQ"></a>一、初识MQ</h1><h4 id="1-同步和异步通讯"><a href="#1-同步和异步通讯" class="headerlink" title="1. 同步和异步通讯"></a>1. 同步和异步通讯</h4><p>微服务间通讯有同步和异步两种方式：<br>1、同步通讯：就像打电话，需要实时响应；<br>2、异步通讯：就像发邮件，不需要马上回复。<br>两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发送邮件可以同时与多个人收发邮件，但是往往响应会有延迟。<img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717161939695.png?raw=true" width="700" height="200"> </p>
<ol>
<li><p><strong>同步通讯</strong><br> 我们之前学习的Feign调用就属于同步方式，虽然调用可以实时得到结果，但存在下面的问题：<img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717162004285.png?raw=true" width="700" height="200"><br> 同步调用的优点：</p>
<ul>
<li>时效性较强</li>
<li>可以立即得到结果</li>
</ul>
<p> 同步调用的问题：</p>
<ul>
<li>耦合度高</li>
<li>性能和吞吐能力下降</li>
<li>有额外的资源消耗</li>
<li>有级联失败问题</li>
</ul>
</li>
<li><p><strong>异步通讯</strong>：常见实现是事件驱动模式<br> 异步调用则可以避免上述问题：我们以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，调用物流服务，从仓库分配响应的库存并准备发货。<br> 在事件模式中，支付服务是事件发布者（publisher），在支付完成后只需要发布一个支付成功的事件（event），事件中带上订单id。订单服务和物流服务是事件订阅者（Consumer），订阅支付成功的事件，监听到事件后完成自己业务即可。为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个中间人（Broker）。发布者发布事件到Broker，不关心谁来订阅事件。订阅者从Broker订阅事件，不关心谁发来的消息。<img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210422095356088.png?raw=true"><br> Broker 是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。</p>
<p> <strong>好处：</strong></p>
<ul>
<li>吞吐量提升：无需等待订阅者处理完成，响应更快速</li>
<li>故障隔离：服务没有直接调用，不存在级联失败问题</li>
<li>调用间没有阻塞，不会造成无效的资源占用</li>
<li>耦合度极低，每个服务都可以灵活插拔，可替换</li>
<li>流量削峰：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件</li>
</ul>
<p> <strong>缺点：</strong></p>
<ul>
<li>架构复杂了，业务没有明显的流程线，不好管理；</li>
<li>需要依赖于Broker的可靠、安全、性能<br> 好在现在开源软件或云平台上 Broker 的软件是非常成熟的，比较常见的一种就是我们今天要学习的MQ技术。</li>
</ul>
</li>
</ol>
<h4 id="2-技术对比"><a href="#2-技术对比" class="headerlink" title="2. 技术对比"></a>2. 技术对比</h4><p>MQ，中文是消息队列（MessageQueue），字面来看就是存放消息的队列。也就是事件驱动架构中的Broker。<br>比较常见的MQ实现：ActiveMQ，RabbitMQ，RocketMQ，Kafka。几种常见MQ的对比：</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>RabbitMQ</strong></th>
<th><strong>ActiveMQ</strong></th>
<th><strong>RocketMQ</strong></th>
<th><strong>Kafka</strong></th>
</tr>
</thead>
<tbody><tr>
<td>公司&#x2F;社区</td>
<td>Rabbit</td>
<td>Apache</td>
<td>阿里</td>
<td>Apache</td>
</tr>
<tr>
<td>开发语言</td>
<td>Erlang</td>
<td>Java</td>
<td>Java</td>
<td>Scala&amp;Java</td>
</tr>
<tr>
<td>协议支持</td>
<td>AMQP，XMPP，SMTP，STOMP</td>
<td>OpenWire,STOMP，REST,XMPP,AMQP</td>
<td>自定义协议</td>
<td>自定义协议</td>
</tr>
<tr>
<td>可用性</td>
<td>高</td>
<td>一般</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>单机吞吐量</td>
<td>一般</td>
<td>差</td>
<td>高</td>
<td>非常高</td>
</tr>
<tr>
<td>消息延迟</td>
<td>微秒级</td>
<td>毫秒级</td>
<td>毫秒级</td>
<td>毫秒以内</td>
</tr>
<tr>
<td>消息可靠性</td>
<td>高</td>
<td>一般</td>
<td>高</td>
<td>一般</td>
</tr>
</tbody></table>
<p>追求可用性：Kafka、 RocketMQ 、RabbitMQ</p>
<p>追求可靠性：RabbitMQ、RocketMQ</p>
<p>追求吞吐能力：RocketMQ、Kafka</p>
<p>追求消息低延迟：RabbitMQ、Kafka</p>
<h1 id="二、快速入门"><a href="#二、快速入门" class="headerlink" title="二、快速入门"></a>二、快速入门</h1><h4 id="1-安装RabbitMQ"><a href="#1-安装RabbitMQ" class="headerlink" title="1. 安装RabbitMQ"></a>1. 安装RabbitMQ</h4><!-- 安装RabbitMQ，参考课前资料：![](https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717162628635.png?raw=true) -->
<p>MQ的基本结构：<img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717162752376.png?raw=true"><br>RabbitMQ中的一些角色：</p>
<ul>
<li>publisher：生产者</li>
<li>consumer：消费者</li>
<li>exchange：交换机，负责消息路由</li>
<li>queue：队列，存储消息</li>
<li>virtualHost：虚拟主机，隔离不同租户的exchange、queue、消息的隔离</li>
</ul>
<h4 id="2-RabbitMQ消息模型"><a href="#2-RabbitMQ消息模型" class="headerlink" title="2. RabbitMQ消息模型"></a>2. RabbitMQ消息模型</h4><!-- RabbitMQ官方提供了5个不同的Demo示例，对应了不同的消息模型： -->
<p><img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717163332646.png?raw=true"></p>
<h4 id="3-导入Demo工程"><a href="#3-导入Demo工程" class="headerlink" title="3. 导入Demo工程"></a>3. 导入Demo工程</h4><!-- 课前资料提供了一个Demo工程，mq-demo:![](https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717163253264.png?raw=true)
导入后可以看到结构如下： -->
<p><img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717163604330.png?raw=true"><br>包括三部分：</p>
<ul>
<li>mq-demo：父工程，管理项目依赖</li>
<li>publisher：消息的发送者</li>
<li>consumer：消息的消费者</li>
</ul>
<h4 id="4-入门案例"><a href="#4-入门案例" class="headerlink" title="4. 入门案例"></a>4. 入门案例</h4><p>简单队列模式的模型图：<img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717163434647.png?raw=true" width="700" height="200"><br>官方的HelloWorld是基于最基础的消息队列模型来实现的，只包括三个角色：</p>
<ul>
<li>publisher：消息发布者，将消息发送到队列queue</li>
<li>queue：消息队列，负责接受并缓存消息</li>
<li>consumer：订阅队列，处理队列中的消息</li>
</ul>
<ol>
<li>publisher实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PublisherTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMessage</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 1.1.设置连接参数，分别是：主机名（改成自己的ip）、端口号、vhost、用户名、密码</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.150.101&quot;</span>); </span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2.建立连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建通道Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.发送消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, rabbitmq!&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;发送消息成功：【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.关闭通道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>consumer实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.150.101&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2.建立连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建通道Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.订阅消息</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span><br><span class="line"><span class="params">                                       AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="comment">// 5.处理消息</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">                System.out.println(<span class="string">&quot;接收到消息：【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息。。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
消息被消费后，就消失（阅后即焚）</li>
</ol>
<hr>

<h1 id="三、SpringAMQP"><a href="#三、SpringAMQP" class="headerlink" title="三、SpringAMQP"></a>三、SpringAMQP</h1><p>SpringAMQP 是基于 RabbitMQ 封装的一套模板，并且还利用 SpringBoot 对其实现了自动装配，使用起来非常方便。<br>SpringAMQP提供了三个功能：</p>
<ul>
<li>自动声明队列、交换机及其绑定关系</li>
<li>基于注解的监听器模式，异步接收消息</li>
<li>封装了RabbitTemplate工具，用于发送消息 <img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717164024967.png?raw=true" width="400" height="200">
<img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717164038678.png?raw=true" width="400" height="200"></li>
</ul>
<h4 id="1-Basic-Queue-简单队列模型"><a href="#1-Basic-Queue-简单队列模型" class="headerlink" title="1. Basic Queue 简单队列模型"></a>1. Basic Queue 简单队列模型</h4><p>在父工程mq-demo中引入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>消息发送<br>首先配置MQ地址，在publisher服务的application.yml中添加配置：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">itcast</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure>
然后在publisher服务中编写测试类SpringAmqpTest，并利用RabbitTemplate实现消息发送：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAmqpTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSimpleQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 队列名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        <span class="comment">// 消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, spring amqp!&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>消息接收<br>首先配置MQ地址，在consumer服务的application.yml中添加配置：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">itcast</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure>
然后在consumer服务的<code>cn.itcast.mq.listener</code>包中新建一个类SpringRabbitListener，代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringRabbitListener</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;spring 消费者接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="2-WorkQueue"><a href="#2-WorkQueue" class="headerlink" title="2. WorkQueue"></a>2. WorkQueue</h4><p>Work queues，也被称为（Task queues），任务模型。简单来说就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。<br>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。此时就可以使用 work 模型，多个消费者共同处理消息处理，速度就能大大提高了。<img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717164238910.png?raw=true" width="400" height="200"></p>
<ol>
<li>消息发送：在publisher服务中的SpringAmqpTest类中添加一个测试方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * workQueue</span></span><br><span class="line"><span class="comment">     * 向队列中不停发送消息，模拟消息堆积。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWorkQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, message_&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message + i);</span><br><span class="line">        Thread.sleep(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>消息接收：要模拟多个消费者绑定同一个队列，我们在consumer服务的SpringRabbitListener中添加2个新的方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue1</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">20</span>);``</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue2</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;消费者2........接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">200</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>测试：启动ConsumerApplication后，在执行publisher服务中刚刚编写的发送测试方法testWorkQueue。<br>可以看到消费者1很快完成了自己的25条消息。消费者2却在缓慢的处理自己的25条消息。也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。这样显然是有问题的。<br>在spring中有一个简单的配置，可以解决这个问题。我们修改consumer服务的application.yml文件，添加配置：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="3-发布-订阅"><a href="#3-发布-订阅" class="headerlink" title="3. 发布&#x2F;订阅"></a>3. 发布&#x2F;订阅</h4><p>发布订阅的模型如图：<img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717165309625.png?raw=true" width="500" height="200"><br>可以看到，在订阅模型中，多了一个exchange角色，而且过程略有变化：</p>
<ul>
<li>Publisher：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）</li>
<li>Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有以下3种类型：<ul>
<li>Fanout：广播，将消息交给所有绑定到交换机的队列</li>
<li>Direct：定向，把消息交给符合指定routing key 的队列</li>
<li>Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</li>
</ul>
</li>
<li>Consumer：消费者，与以前一样，订阅队列，没有变化</li>
<li>Queue：消息队列也与以前一样，接收消息、缓存消息。</li>
</ul>
<p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！<br>这样，实现了一个消息发送给多个消费者。</p>
<h4 id="4-Fanout"><a href="#4-Fanout" class="headerlink" title="4. Fanout"></a>4. Fanout</h4><p>在广播模式下，消息发送流程是这样的：</p>
<ul>
<li>1）  可以有多个队列</li>
<li>2）  每个队列都要绑定到Exchange（交换机）</li>
<li>3）  生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定</li>
<li>4）  交换机把消息发送给绑定过的所有队列</li>
<li>5）  订阅队列的消费者都能拿到消息</li>
</ul>
<p>我们的计划是这样的：</p>
<ul>
<li>创建一个交换机 itcast.fanout，类型是Fanout</li>
<li>创建两个队列fanout.queue1和fanout.queue2，绑定到交换机itcast.fanout<img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717165509466.png?raw=true" width="500" height="200"></li>
</ul>
<ol>
<li>声明队列和交换机<br>Spring提供了一个接口Exchange，来表示所有不同类型的交换机：<img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717165552676.png?raw=true"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在consumer中创建一个类，声明队列和交换机</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Fanout类型交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span>&#123;    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;itcast.fanout&quot;</span>);    &#125;</span><br><span class="line">    <span class="comment">// 队列1，绑定交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue1</span><span class="params">()</span>&#123;    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue1&quot;</span>);    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1</span><span class="params">(Queue fanoutQueue1, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 队列2，绑定交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue2</span><span class="params">()</span>&#123;    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue2&quot;</span>);    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2</span><span class="params">(Queue fanoutQueue2, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>消息发送<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在publisher服务的SpringAmqpTest类中添加测试方法</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFanoutExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;itcast.fanout&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, everyone!&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送到交换机</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>消息接收<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在consumer服务的SpringRabbitListener中添加两个方法，作为消费者</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue1</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue2</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="5-Direct"><a href="#5-Direct" class="headerlink" title="5. Direct"></a>5. Direct</h4><p>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。<br>在Direct模型下：</p>
<ul>
<li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>BindingKey</code>（路由key）</li>
<li>消息的发送方在 向 Exchange发送消息时，必须指定消息的 <code>RoutingKey</code>。</li>
<li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>RoutingKey</code>进行判断，只有队列的<code>Bindingkey</code>与消息的 <code>Routingkey</code>完全一致，才会接收到消息</li>
<li>一个队列可以有多个BindingKey。如果多个队列具有相同的RoutingKey，则与Fanout功能类似(可以模拟广播)<br><img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717170223317.png?raw=true"></li>
</ul>
<ol>
<li>基于注解声明队列和交换机<br>基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。<br>在consumer的SpringRabbitListener中添加两个消费者，同时基于注解 <code>@RabbitListener</code> 来声明队列和交换机：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消费者1+队列+交换机+BindingKey</span></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到direct.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消费者2+队列+交换机+BindingKey</span></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到direct.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>消息发送<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendDirectExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;itcast.direct&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息，携带 RoutingKey</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;red&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="6-Topic"><a href="#6-Topic" class="headerlink" title="6.Topic"></a>6.Topic</h4><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候使用通配符！<br><code>Routingkey</code> 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code><br>通配符规则：<code>#</code>：匹配一个或多个词；<code>*</code>：匹配不多不少恰好1个词<br>举例：<code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code>；<code>item.*</code>：只能匹配<code>item.spu</code>  ​<br><img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717170705380.png?raw=true"><br>解释：</p>
<ul>
<li>Queue1：绑定的是<code>china.#</code> ，因此凡是以 <code>china.</code>开头的<code>routing key</code> 都会被匹配到。包括china.news和china.weather</li>
<li>Queue2：绑定的是<code>#.news</code> ，因此凡是以 <code>.news</code>结尾的 <code>routing key</code> 都会被匹配。包括china.news和japan.news</li>
</ul>
<ol>
<li>消息发送<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;china.news&quot;</span>, message);</span><br></pre></td></tr></table></figure></li>
<li>消息接收<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;china.#&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br></pre></td></tr></table></figure></li>
<li>总结<br> 描述下Direct交换机与Topic交换机的差异？<ul>
<li>Topic交换机接收的消息RoutingKey必须是多个单词，以 <code>.</code> 分割</li>
<li>Topic交换机与队列绑定时的bindingKey可以指定通配符</li>
<li><code>#</code>：代表0个或多个词</li>
<li><code>*</code>：代表1个词</li>
</ul>
</li>
</ol>
<h4 id="7-消息转换器"><a href="#7-消息转换器" class="headerlink" title="7.消息转换器"></a>7.消息转换器</h4><p>之前说过，Spring会把你发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。</p>
<p><img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20200525170410401.png?raw=true" alt="image-20200525170410401"></p>
<p>只不过，默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：</p>
<ul>
<li>数据体积过大</li>
<li>有安全漏洞</li>
<li>可读性差</li>
</ul>
<p>显然，JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。</p>
<p>在publisher和consumer两个服务中都引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置消息转换器。在启动类中添加一个Bean即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">jsonMessageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/11/RabbitMQ/" data-id="cm3lnru61000gf0v59ygq8ems" data-title="RabbitMQ" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-SpringCloud" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/07/SpringCloud/" class="article-date">
  <time class="dt-published" datetime="2024-01-07T02:58:11.000Z" itemprop="datePublished">2024-01-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/07/SpringCloud/">SpringCloud</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>单体架构</strong>：将业务的所有功能集中在一个项目中开发，打成一个包部署。优点：架构简单、部署成本低。缺点：耦合度高，扩展性差，适合小型项目。例如:学生管理系统<br><strong>分布式架构</strong>：根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务。松耦合，扩展性好，但架构复杂，难度大。适合大型互联网项目，例如:京东、淘宝<br>分布式架构的要考虑的问题有：服务拆分粒度如何？服务集群地址如何维护？服务之间如何实现远程调用？服务健康状态如何感知？<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/3.png?raw=true?raw=true" width="500" height="200"> </p>
<h2 id="微服务：一种良好的分布式架构方案。"><a href="#微服务：一种良好的分布式架构方案。" class="headerlink" title="微服务：一种良好的分布式架构方案。"></a>微服务：一种良好的分布式架构方案。</h2><ul>
<li>优点：拆分粒度更小、服务更独立、耦合度更低。缺点：架构非常复杂，运维、监控、部署难度提高</li>
<li>微服务特点：<ul>
<li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责，避免重复业务开发；每个服务单元都可以独立开发、部署、扩展和管理。这些服务单元相互协作，通过网络进行通信，通常使用轻量级的通信机制（如HTTP或消息队列）进行交互。使得应用程序更具弹性、可扩展性和灵活性，同时也有利于团队之间的独立开发和部署。</li>
<li>面向服务：微服务对外暴露业务接口，供其他微服务使用。</li>
<li>自治：团队独立、技术独立、数据独立、部署独立，不同微服务都应该有自己的数据库。</li>
<li>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题。<img src="https://github.com/leo710aka/bk/blob/main/springcloud/1.png?raw=true?raw=true" width="700" height="200"> 
再加上服务异常定位、节点状态监控、自动化部署
<img src="https://github.com/leo710aka/bk/blob/main/springcloud/2.png?raw=true?raw=true" width="700" height="200"></li>
</ul>
</li>
</ul>
<p>微服务这种方案需要技术框架来落地，全球的互联网公司都在积极尝试自己的微服务落地技术。在国内最知名的就是SpringCloud和阿里巴巴的Dubbo（升级SpringCloudAlibaba（实现了SpringCloud接口，是SpringCloud的一部分））微服务技术对比：<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/4.png?raw=true?raw=true" width="700" height="200"><br>企业中常见的四种需求：<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/5.png?raw=true?raw=true" width="700" height="200"> </p>
<hr>

<h2 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h2><p>SpringCloud 是一个基于 Spring Boot 的开源框架，旨在简化构建分布式系统中的微服务架构。它提供了一系列工具和库，用于实现微服务架构中常见的模式和功能，如服务发现、负载均衡、配置管理、断路器模式、消息总线等。<br>SpringCloud 集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验:<img src="https://github.com/leo710aka/bk/blob/main/springcloud/6.png?raw=true" width="600" height="200"><br>对于 SpringBoot 的版本要求 <img src="https://github.com/leo710aka/bk/blob/main/springcloud/8.png?raw=true" width="600" height="200">  </p>
<ul>
<li>服务拆分<ul>
<li>微服务需要根据业务模块拆分，做到单一职责，避免重复业务开发；</li>
<li>微服务可以将业务暴露为接口，供其他微服务使用。</li>
<li>不同微服务都应该有自己的数据库。</li>
</ul>
</li>
<li>项目结构<ul>
<li>两种工程结构<ul>
<li>独立 Project：？？</li>
<li>Maven 聚合：每个微服务作为 主Project 中的一个模块 Module，分别独立打包部署运行，只不过代码放在一个 Project</li>
</ul>
</li>
<li>cloud-demo：父工程，管理依赖<ul>
<li>order-service：订单微服务，负责订单相关业务</li>
<li>user-service：用户微服务，负责用户相关业务</li>
<li>在每个模块的 application.yaml 配置该微服务名字、端口号、数据库、日志位置、、</li>
<li>要求：订单微服务和用户微服务都必须有各自的数据库，相互独立；订单服务和用户服务都对外暴露Restful的接口；订单服务如果需要查询用户信息，只能调用用户服务的Restful接口，不能查询用户数据库  <img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210713211009593.png?raw=true" width="200" height="200"></li>
</ul>
</li>
</ul>
</li>
<li>远程调用<ul>
<li>物理上两个微服务隔离，无法查询各自数据库，但网络上微服务相通</li>
<li>在一个微服务中，通过java代码发送 http 请求，使用另一个微服务的接口以获取其数据库中的数据</li>
<li>在一个微服务的启动类（本身也是配置类）中注册 RestTemplate，配置成 Bean；</li>
<li>在 service 中注入 restTemplate（建议使用构造函数），通过 getForObject(“url”) 发送http请求，将返回的 json 数据转换为制定对象类型</li>
</ul>
</li>
</ul>
<h3 id="Eureka-服务注册中心（白雪）"><a href="#Eureka-服务注册中心（白雪）" class="headerlink" title="Eureka 服务注册中心（白雪）"></a>Eureka 服务注册中心（白雪）</h3><ul>
<li>在 Eureka 架构中，微服务角色有两类:<ul>
<li>EurekaServer:服务端，注册中心。记录服务信息、心跳监控</li>
<li>EurekaClient:客户端<ul>
<li>Provider:服务提供者，例如案例中的 user-service，注册自己的信息到 EurekaServer，每隔30秒向EurekaServer发送心跳</li>
<li>consumer:服务消费者，例如案例中的 order-service，根据服务名称从 EurekaServer 拉取服务列表，基于服务列表做负载均衡，选中一个微服务后发起远程调用</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://github.com/leo710aka/bk/blob/main/springcloud/7.png?raw=true?raw=true" width="500" height="200">  

<ul>
<li>Eureka的作用<ul>
<li>消费者该如何获取服务提供者具体信息? 服务提供者启动时向 eureka 注册自己的信息，eureka 保存这些信息，消费者根据服务名称向 eureka 拉取提供者信息</li>
<li>如果有多个服务提供者，消费者该如何选择? 服务消费者利用负载均衡算法，从服务列表中挑选一个</li>
<li>消费者如何感知服务提供者健康状态? 服务提供者会每隔30秒向 EurekaServer 发送心跳请求，报告健康状态 eureka 会更新记录服务列表信息，心跳不正常会被剔除，消费者就可以拉取到最新的信息</li>
</ul>
</li>
<li>Eureka 服务搭建：Eruka 自己就是一个微服务。新建项目，引入 eureka-server 依赖；编写启动类，添加 @EnableEurekaServer 注解；添加 application.yml，添加配置</li>
<li>Eureka 服务注册：把一个微服务注册到 EurekaServer。<ol>
<li>微服务项目引入 eureka-client 依赖，</li>
<li>在 application.yml 编写依赖：name、url…</li>
</ol>
</li>
<li>Eureka 服务发现：<br>  服务拉取是（服务A）基于（服务B）服务名称获取（服务B多个实例）服务列表，然后在对服务列表做负载均衡<ol>
<li>修改 orderService（服务B）的代码，修改访问的 userService 的url路径，用服务名代替ip、端口，消除硬编码:  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span><span class="string">&quot;http://userservice/user/&quot;</span> + order.getUserId();</span><br></pre></td></tr></table></figure></li>
<li>在 order-service 项目（服务B）的启动类 OrderApplication中 的 RestTemplate 添加负载均衡注解  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="Ribbon-负载均衡（白雪）"><a href="#Ribbon-负载均衡（白雪）" class="headerlink" title="Ribbon 负载均衡（白雪）"></a>Ribbon 负载均衡（白雪）</h2><ul>
<li>负载均衡原理<ul>
<li>加了 @LoadBalanced 注解的RestTemplate，发送的请求将会被 Ribbon 拦截（SpringCloudRibbon的底层采用了一个拦截器），对地址做了修改，处理后发送 HTTP 请求<br>  基本流程如下：<ul>
<li>拦截我们的RestTemplate请求<a target="_blank" rel="noopener" href="http://userservice/user/1">http://userservice/user/1</a></li>
<li>RibbonLoadBalancerClient会从请求url中获取服务名称，也就是user-service</li>
<li>DynamicServerListLoadBalancer根据user-service到eureka拉取服务列表</li>
<li>eureka返回列表，localhost:8081、localhost:8082</li>
<li>IRule利用内置负载均衡规则，从列表中选择一个，例如localhost:8081</li>
<li>RibbonLoadBalancerClient修改请求地址，用localhost:8081替代userservice，得到<a target="_blank" rel="noopener" href="http://localhost:8081/user/1%EF%BC%8C">http://localhost:8081/user/1，</a> 发起真实请求  <img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210713224724673.png?raw=true" width="500" height="200"></li>
</ul>
</li>
</ul>
</li>
<li>负载均衡策略IRule<ul>
<li>IRule 接口：决定了负载均衡的策略，每一个子接口都是一种规则，轮询、随机、、、 通过定义 IRule 实现可以修改负载均衡策略</li>
<li>负载均衡策略：负载均衡的规则都定义在IRule接口中，而IRule有很多不同的实现类：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210713225653000.png?raw=true" width="500" height="200"><table>
<thead>
<tr>
<th><strong>内置负载均衡规则类</strong></th>
<th><strong>规则描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>RoundRobinRule</td>
<td>简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td>
</tr>
<tr>
<td>AvailabilityFilteringRule</td>
<td>对以下两种服务器进行忽略：   （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。  （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的<clientName>.<clientConfigNameSpace>.ActiveConnectionsLimit属性进行配置。</td>
</tr>
<tr>
<td>WeightedResponseTimeRule</td>
<td>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td>
</tr>
<tr>
<td><strong>ZoneAvoidanceRule</strong>【默认】</td>
<td>以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做<strong>轮询</strong>。</td>
</tr>
<tr>
<td>BestAvailableRule</td>
<td>忽略那些短路的服务器，并选择并发数较低的服务器。</td>
</tr>
<tr>
<td>RandomRule</td>
<td>随机选择一个可用的服务器。</td>
</tr>
<tr>
<td>RetryRule</td>
<td>重试机制的选择逻辑</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li>自定义负载均衡策略<ol>
<li>代码方式：在order-service中的OrderApplication类中，定义一个新的IRule：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">randomRule</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则：  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">userservice:</span> <span class="comment"># 给某个微服务配置负载均衡规则，这里是userservice服务</span></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span> <span class="comment"># 负载均衡规则 </span></span><br></pre></td></tr></table></figure></li>
<li><strong>注意</strong>，一般用默认的负载均衡规则，不做修改。</li>
</ol>
</li>
<li>饥饿加载<ul>
<li>Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line"><span class="attr">eager-load:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">clients:</span> <span class="string">userservice</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>

<h2 id="Nacos注册中心【8848】"><a href="#Nacos注册中心【8848】" class="headerlink" title="Nacos注册中心【8848】"></a>Nacos注册中心【8848】</h2><ul>
<li><strong>Nacos</strong> 是阿里巴巴的产品，现在是 SpringCloud 中的一个组件。相比 Eureka 功能更加丰富，在国内受欢迎程度较高。</li>
<li><strong>Nacos服务搭建：</strong>下载安装包，解压，在 D:\nacos-server-1.4.1\bin 目录下cmd运行指令: <code>startup.cmd -m standalone</code><br>浏览器打开 <a target="_blank" rel="noopener" href="http://xxxx:8848/nacos/index.html#/login%EF%BC%8C%E8%BE%93%E5%85%A5%E8%B4%A6%E5%8F%B7/%E5%AF%86%E7%A0%81%EF%BC%9Anacos">http://xxxx:8848/nacos/index.html#/login，输入账号/密码：nacos</a></li>
</ul>
<h4 id="1-Nacos服务注册或发现"><a href="#1-Nacos服务注册或发现" class="headerlink" title="1. Nacos服务注册或发现"></a>1. Nacos服务注册或发现</h4><p>父工程添加 spring-cloud-alibaba 依赖；微服务项目引入 nacos.discovery 依赖，yml 配置 nacos 地址 spring.cloudnacos.server-addr<br>Nacos 是 SpringCloudAlibaba 的组件，而 SpringCloudAlibaba 也遵循 SpringCloud 中定义的服务注册、服务发现规范。因此使用 Nacos 和使用 Eureka 对于微服务来说，并没有太大区别。</p>
<ol>
<li>引入依赖：<br>在cloud-demo父工程的pom文件中的<code>&lt;dependencyManagement&gt;</code>中引入SpringCloudAlibaba的依赖；<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
然后在子微服务 user-service 和 order-service 中的pom文件中引入nacos-discovery依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>配置nacos地址：在子微服务 user-service 和 order-service 的 application.yml 中添加 nacos 地址：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">    <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br></pre></td></tr></table></figure></li>
<li>重启微服务后，登录nacos管理页面<a target="_blank" rel="noopener" href="http://10.195.138.48:8848/nacos/index.html#/">http://10.195.138.48:8848/nacos/index.html#/</a> ,可以看到微服务信息 <img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210713231439607.png?raw=true" width="600" height="200">  </li>
<li>服务发现：消费者需要连接nacos以拉取和订阅服务，因此服务发现的前两步与服务注册是一样（引入nacos-discovery依赖和配置nacos地址），后面再加上服务调用即可<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DiscoveryClient discoveryclient;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlecartItems</span><span class="params">(List&lt;CartVO&gt; vos)</span> &#123;</span><br><span class="line">  <span class="comment">// 1.根据服务名称，拉取服务的实例列表</span></span><br><span class="line">  List&lt;ServiceInstance&gt; instances = discoveryclient.getInstances(<span class="string">&quot;item-service&quot;</span>);</span><br><span class="line">  <span class="comment">// 2.负藏均衡，随机挑选一个实例</span></span><br><span class="line">  <span class="type">ServiceInstance</span> <span class="variable">instance</span> <span class="operator">=</span> instances.get(RandomUtil.randomInt(instances.size()));</span><br><span class="line">  <span class="comment">// 3.获取实例的TP和端口</span></span><br><span class="line">  URI uri= instance.getUri();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="2-Nacos服务分级存储"><a href="#2-Nacos服务分级存储" class="headerlink" title="2. Nacos服务分级存储"></a>2. <strong>Nacos服务分级存储</strong></h4><p>一个<strong>服务</strong>可以有多个<strong>实例</strong>，例如我们的user-service，可以有：127.0.0.1:8081，127.0.0.1:8082，127.0.0.1:8083<br>假如这些实例分布于全国各地的不同机房，例如：127.0.0.1:8081在上海机房，127.0.0.1:8082在上海机房，127.0.0.1:8083在杭州机房。    Nacos就将同一机房内的实例 划分为一个<strong>集群</strong>。</p>
<ul>
<li>也就是说，user-service是服务，一个服务可以包含多个集群，如杭州、上海，每个集群下可以有多个实例，形成分级模型：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210713232522531.png?raw=true" width="600" height="200"><br>微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210713232658928.png?raw=true" width="600" height="200">  </li>
<li>配置集群：修改user-service的application.yml文件，添加集群配置：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">    <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">    <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span> <span class="comment"># 集群名称</span></span><br></pre></td></tr></table></figure></li>
<li>同集群优先的负载均衡：默认的<code>ZoneAvoidanceRule</code>并不能实现根据同集群优先来实现负载均衡。因此Nacos中提供了一个<code>NacosRule</code>的实现，可以优先从同集群中挑选实例。<br>修改order-service的application.yml文件，修改负载均衡规则：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">userservice:</span></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class="comment"># 负载均衡规则 </span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-权重配置："><a href="#3-权重配置：" class="headerlink" title="3. 权重配置："></a>3. <strong>权重配置：</strong></h4><p>默认情况下NacosRule是同集群内随机挑选，不会考虑机器的性能问题。因此，Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高。<br>在nacos控制台，找到user-service的实例列表，点击编辑，在弹出的窗口修改权重：（<strong>注意</strong>：权重为0，则该实例永远不会被访问）<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210713235133225.png?raw=true"><br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210713235235219.png?raw=true" width="300" height="200"> </p>
<h4 id="4-环境隔离："><a href="#4-环境隔离：" class="headerlink" title="4. 环境隔离："></a>4. <strong>环境隔离</strong>：</h4><p>Nacos提供了namespace来实现环境隔离功能（比如把一些功能紧密的服务隔离在一起，不能被另一些服务访问）</p>
<ul>
<li>nacos中可以有多个namespace</li>
<li>namespace下可以有group、service等</li>
<li>不同namespace之间相互隔离，例如不同namespace的服务互相不可见<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210714000101516.png?raw=true" width="400" height="200"></li>
</ul>
<ol>
<li>创建namespace：默认情况下，所有service、data、group都在同一个namespace，名为public：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210714000414781.png?raw=true" width="300" height="200"> 
我们可以点击页面新增按钮，添加一个namespace；然后，填写表单，创建一个新的namespace：
<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210714000505928.png?raw=true" width="300" height="200"> </li>
<li>给微服务配置namespace：只能通过修改配置来实现。例如，修改order-service的application.yml文件：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">    <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">    <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">492a7d5d-237b-46a1-a99a-fa8e98e4b0f9</span> <span class="comment"># 命名空间，填ID</span></span><br></pre></td></tr></table></figure>
重启order-service后，访问控制台，可以看到下面的结果：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210714000830703.png?raw=true" width="600" height="200"> 
此时访问order-service，因为namespace不同，会导致找不到userservice，控制台会报错：
<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210714000941256.png?raw=true" width="600" height="200"></li>
</ol>
<h4 id="5-Nacos与Eureka的区别"><a href="#5-Nacos与Eureka的区别" class="headerlink" title="5. Nacos与Eureka的区别"></a>5. Nacos与Eureka的区别</h4><p>Nacos和Eureka整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异：<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210714001728017.png?raw=true" width="500" height="200"> </p>
<ul>
<li>Nacos与eureka的共同点<ul>
<li>都支持服务注册和服务拉取</li>
<li>都支持服务提供者心跳方式做健康检测</li>
</ul>
</li>
<li>Nacos与Eureka的区别<ul>
<li>Nacos的服务实例分为两种类型：<ul>
<li>临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。</li>
<li>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。<br>  配置一个服务实例为永久实例：  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">    <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">ephemeral:</span> <span class="literal">false</span> <span class="comment"># 设置为非临时实例</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li>
<li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li>
<li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li>
<li>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</li>
</ul>
</li>
</ul>
<h4 id="6-Nacos配置管理："><a href="#6-Nacos配置管理：" class="headerlink" title="6. Nacos配置管理："></a>6. <strong>Nacos配置管理</strong>：</h4><p>Nacos除了可以做注册中心，同样可以做配置管理来使用。</p>
<ul>
<li><strong>统一配置管理</strong><br>当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。我们需要一种统一配置管理方案，可以集中管理所有实例的配置。<br>Nacos一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新。(不用重启服务就能更新)  <img src="https://github.com/leo710aka/bk/blob/main/springcloud/9.png?raw=true" width="500" height="200"> <ol>
<li>在nacos中添加配置文件<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714164742924.png?raw=true" width="500" height="200">   <img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714164856664.png?raw=true" width="500" height="200"> <blockquote>
<p>注意：项目的核心配置，需要热更新的配置才有放到nacos管理的必要。基本不会变更的一些配置还是保存在微服务本地比较好。</p>
</blockquote>
</li>
<li>从微服务拉取配置：微服务要拉取nacos中管理的配置，并且与本地的application.yml配置合并，才能完成项目启动。 但如果尚未读取application.yml，又如何得知nacos地址呢？<br>因此spring引入了一种新的配置文件：bootstrap.yaml文件，会在application.yml之前被读取，流程如下：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/L0iFYNF.png?raw=true"><br>首先，在user-service服务中，引入nacos-config的客户端依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos配置管理依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
然后，在user-service中添加一个bootstrap.yaml文件，内容如下：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userservice</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment">#开发环境，这里是dev </span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># Nacos地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 文件后缀名</span></span><br></pre></td></tr></table></figure>
这里会根据spring.cloud.nacos.server-addr获取nacos地址，再根据<br><code>$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</code>作为文件id，来读取配置。本例中，就是去读取<code>userservice-dev.yaml</code>：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714170845901.png?raw=true" width="500" height="200"><br>读取nacos配置：在user-service中的UserController中添加业务逻辑，读取pattern.dateformat配置<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714170337448.png?raw=true" width="500" height="200"></li>
</ol>
</li>
<li><strong>配置热更新</strong><br>我们最终的目的，是修改nacos中的配置后，微服务中无需重启即可让配置生效，也就是<strong>配置热更新</strong>。可以使用两种方式：<ol>
<li>方式一：在 @Value 注入的变量所在类上添加注解 @RefreshScope：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714171036335.png?raw=true" width="500" height="200"> </li>
<li>方式二：使用 @ConfigurationProperties 注解代替 @Value 注解。<br>在 user-service 服务中，添加一个类，读取 patterrn.dateformat 属性：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.user.config;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;pattern&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PatternProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String dateformat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在 UserController 中使用这个类代替 @Value：<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714171316124.png?raw=true"></li>
</ol>
</li>
<li><strong>配置共享</strong><br>其实微服务启动时，会去nacos读取多个配置文件，例如：<ul>
<li><code>[spring.application.name]-[spring.profiles.active].yaml</code>，例如：userservice-dev.yaml</li>
<li><code>[spring.application.name].yaml</code>，例如：userservice.yaml<br>而<code>[spring.application.name].yaml</code>不包含环境，因此可以被多个环境共享。下面我们通过案例来测试配置共享：</li>
</ul>
<ol>
<li>添加一个环境共享配置：我们在nacos中添加一个userservice.yaml文件：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714173233650.png?raw=true" width="400" height="200"> </li>
<li>在user-service中读取共享配置<!-- 
在user-service服务中，修改PatternProperties类，读取新添加的属性：
![image-20210714173324231](https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714173324231.png?raw=true)
在user-service服务中，修改UserController，添加一个方法：
![image-20210714173721309](https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714173721309.png?raw=true)
 --></li>
<li>运行两个UserApplication，使用不同的profile<br>？？<!-- 
修改UserApplication2这个启动项，改变其profile值：
![image-20210714173538538](https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714173538538.png?raw=true)
![image-20210714173519963](https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714173519963.png?raw=true)
这样，UserApplication(8081)使用的profile是dev，UserApplication2(8082)使用的profile是test。
启动UserApplication和UserApplication2
访问http://localhost:8081/user/prop，结果：
![image-20210714174313344](https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714174313344.png?raw=true)
访问http://localhost:8082/user/prop，结果：
![image-20210714174424818](https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714174424818.png?raw=true)
可以看出来，不管是dev，还是test环境，都读取到了envSharedValue这个属性的值。 --></li>
<li>配置共享的优先级<br>当nacos、服务本地同时出现相同属性时，优先级有高低之分：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714174623557.png?raw=true" width="500" height="200"></li>
</ol>
</li>
<li><strong>搭建Nacos集群</strong><br>企业生产中强调“高可用”，Nacos 生产环境下一定要部署为集群状态，部署方式参考课前资料中的文档：nacos集群搭建.md</li>
</ul>
<hr>

<h2 id="Feign-远程调用"><a href="#Feign-远程调用" class="headerlink" title="Feign 远程调用"></a>Feign 远程调用</h2><p>Feign是一个声明式的http客户端，其作用就是帮助我们优雅的实现http请求的发送；<br>解决从前利用 RestTemplate 发起远程调用代码中的问题：1、代码可读性差，编程体验不统一；2、参数复杂URL难以维护<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714174814204.png?raw=true" width="600" height="200"><br><strong>OpenFeign</strong>是一个声明式的http客户端，是SpringCloud在Eureka公司开源的Feign基础上改造而来。其作用就是基于SpringMVC的常见注解，帮我们优雅的实现http请求的发送.</p>
<h4 id="1-Feign替代RestTemplate"><a href="#1-Feign替代RestTemplate" class="headerlink" title="1. Feign替代RestTemplate"></a>1. Feign替代RestTemplate</h4><ol>
<li>引入依赖：在order-service服务的pom文件中引入feign的依赖：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 负载均衡？？ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalance<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>添加注解：在order-service的启动类添加 <code>@EnableFeignClients</code>注解 开启Feign的功能：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714175102524.png?raw=true" width="500" height="200"> </li>
<li>编写Feign的客户端：在order-service中新建一个接口，添加 <code>@FeignClient</code>注解，内容如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;userservice&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这个客户端主要是基于SpringMVC的注解来声明远程调用的信息，比如：服务名称：userservice，请求方式：GET，请求路径：&#x2F;user&#x2F;{id}，请求参数：Long id，返回值类型：User。这样，当服务调用者需要调用服务提供者时，只需要通过Feign客户端调用接口方法即可，Feign会根据注解信息自动发起HTTP请求并处理响应，而无需使用 RestTemplate。<br><strong>Feign的client是写在服务调用者模块中，用于定义如何调用服务提供者的接口，而服务提供者模块则负责提供具体的业务逻辑和处理请求。</strong> </li>
<li>测试：修改order-service中的OrderService类中的queryOrderById方法，使用Feign客户端代替RestTemplate：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714175415087.png?raw=true" width="500" height="200"></li>
</ol>
<h4 id="2-日志？？"><a href="#2-日志？？" class="headerlink" title="2. 日志？？"></a>2. 日志？？</h4><p>Feign可以支持很多的自定义配置，如下表所示：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>feign.Logger.Level</strong></td>
<td>修改日志级别</td>
<td>包含四种不同的级别：NONE、BASIC、HEADERS、FULL</td>
</tr>
<tr>
<td>feign.codec.Decoder</td>
<td>响应结果的解析器</td>
<td>http远程调用的结果做解析，例如解析json字符串为java对象</td>
</tr>
<tr>
<td>feign.codec.Encoder</td>
<td>请求参数编码</td>
<td>将请求参数编码，便于通过http请求发送</td>
</tr>
<tr>
<td>feign. Contract</td>
<td>支持的注解格式</td>
<td>默认是SpringMVC的注？</td>
</tr>
<tr>
<td>feign. Retryer</td>
<td>失败重试机制</td>
<td>请求失败的重试机制，默认是没有，不过会使用Ribbon的重试</td>
</tr>
</tbody></table>
<p>一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的@Bean覆盖默认Bean即可。<br>自定义配置的两种方法：</p>
<ol>
<li>配置文件方式：基于配置文件修改feign的日志级别可以针对单个服务，也可以针对所有服务：</li>
<li>Java代码方式：也可以基于Java代码来修改日志级别，先声明一个类，然后声明一个Logger.Level的对象<br>如果要<strong>全局生效</strong>，将其放到启动类的@EnableFeignClients这个注解中；如果是<strong>局部生效</strong>，则把它放到对应的@FeignClient这个注解中</li>
</ol>
<h4 id="3-Feign使用优化"><a href="#3-Feign使用优化" class="headerlink" title="3. Feign使用优化"></a>3. Feign使用优化</h4><p>Feign 是一个声明式客户端，只是把声明变成 http 请求，底层还是发http请求，依赖于其它的框架。<br>其底层客户端实现包括 URLConnection：默认实现，不支持连接池；Apache HttpClient：支持连接池；OKHttp：支持连接池。因此提高Feign的性能主要手段就是使用<strong>连接池</strong>代替默认的URLConnection。用Apache的HttpClient来演示：</p>
<ul>
<li>引入依赖：在order-service的pom文件中引入Apache的HttpClient依赖：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--httpClient的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>配置连接池：在order-service的application.yml中添加配置：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span> <span class="comment"># default全局的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">BASIC</span> <span class="comment"># 日志级别，BASIC就是基本的请求和响应信息</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启feign对HttpClient的支持</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">200</span> <span class="comment"># 最大的连接数</span></span><br><span class="line">    <span class="attr">max-connections-per-route:</span> <span class="number">50</span> <span class="comment"># 每个路径的最大连接数</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-最佳实践"><a href="#4-最佳实践" class="headerlink" title="4. 最佳实践"></a>4. 最佳实践</h4><p>所谓最近实践，就是使用过程中总结的经验，最好的一种使用方式。<br>如果一个微服务需要重复被其他微服务调用(消费)，那么每个消费者都要重复编写一个 client。有没有办法简化这种重复的代码编写呢？</p>
<!-- 1. **继承方式：**一样的代码可以通过继承来共享：
  * 定义一个API接口，利用定义方法，并基于SpringMVC注解做声明。
  * Feign客户端和Controller都集成改接口
  ![](https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714190640857.png?raw=true)
  优点：简单，实现了代码共享
  缺点：服务提供方、服务消费方紧耦合，参数列表中的注解映射并不会继承，因此Controller中必须再次声明方法、参数列表、注解 -->
<ol>
<li>从一个微服务中拆出一个模块，将Feign的Client、接口有关的POJO、默认的Feign配置都放到这个模块中，供给所有消费者使用<br>例如，将UserClient、User、Feign的默认配置都抽取到一个feign-api包中，所有其他微服务需要消费该微服务时，引用该包的依赖，即可直接使用。<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714214041796.png?raw=true"></li>
<li>将所有的微服务中的 dto、client、config 统一放在一个模块中，供给所有消费者使用。<br>junbo-api也是如此？？！！</li>
</ol>
<hr>


<h2 id="Gateway-服务网关"><a href="#Gateway-服务网关" class="headerlink" title="Gateway 服务网关"></a>Gateway 服务网关</h2><p>Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。</p>
<h4 id="1-为什么需要网关"><a href="#1-为什么需要网关" class="headerlink" title="1. 为什么需要网关"></a>1. 为什么需要网关</h4><p>Gateway网关是我们服务的守门神，所有微服务的统一入口。前端只需要知道网关的端口，发送请求就行了。<br>架构图：<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714210131152.png?raw=true" width="600" height="200"> </p>
<p>网关的<strong>核心功能特性</strong>：</p>
<ul>
<li><strong>权限控制</strong>：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</li>
<li><strong>路由和负载均衡</strong>：一切请求都必须先经过gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。</li>
<li><strong>限流</strong>：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</li>
</ul>
<p>在SpringCloud中网关的实现包括两种：gateway、zuul</p>
<ul>
<li>Zuul是基于Servlet的实现，属于阻塞式编程。</li>
<li>SpringCloudGateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</li>
</ul>
<h4 id="2-gateway快速入门"><a href="#2-gateway快速入门" class="headerlink" title="2. gateway快速入门"></a>2. gateway快速入门</h4><ol>
<li>创建 SpringBoot 工程 gateway 服务，引入网关依赖<!-- 创建服务：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714210919458.png?raw=true" width="700" height="200"> 
引入依赖： -->
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--网关--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--nacos服务发现依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>编写启动类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GatewayApplication</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		SpringApplication.run(GatewayApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编写基础配置和路由规则：<br>创建application.yml文件，内容如下：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span> <span class="comment"># 网关端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span> <span class="comment"># 网关路由配置</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span>      <span class="comment"># 1. 路由id，自定义，只要唯一即可</span></span><br><span class="line">          <span class="comment"># uri: http://127.0.. # 2. 路由的目标地址 http 就是固定地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userservice</span> <span class="comment">#    lb(loadbalance) 就是负载均衡，后面跟服务名称</span></span><br><span class="line">          <span class="attr">predicates:</span>           <span class="comment"># 3. 路由断言(可多条)，判断请求是否符合路由规则的条件</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span>     <span class="comment">#    按照路径匹配，只要以/user/开头就符合要求</span></span><br><span class="line">          <span class="attr">filters:</span>              <span class="comment"># 4. 路由过滤器，，</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">order-service</span>     <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
我们将符合<code>Path</code>规则的一切请求，都代理到<code>uri</code>参数指定的地址。本例中，我们将 <code>/user/**</code>开头的请求，代理到<code>lb://userservice</code>，lb是负载均衡，根据服务名拉取服务列表，实现负载均衡。<!-- 4. 启动网关服务进行测试
重启网关，访问http://localhost:10010/user/1时， 符合`/user/**`规则，请求转发到uri：http://userservice/user/1， 得到了结果：
![](https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714211908341.png?raw=true) --></li>
<li>网关路由的流程图<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714211742956.png?raw=true"></li>
</ol>
<h4 id="3-断言工厂"><a href="#3-断言工厂" class="headerlink" title="3. 断言工厂"></a>3. 断言工厂</h4><p>我们在配置文件中写的断言规则只是字符串，这些字符串会被Predicate Factory读取并处理，转变为路由判断的条件<br>例如Path&#x3D;&#x2F;user&#x2F;**是按照路径匹配，这个规则是由 <code>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory</code>类来处理的，像这样的断言工厂在SpringCloudGateway还有十几个:</p>
<table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>说明</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td>After</td>
<td>是某个时间点后的请求</td>
<td>-  After&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver]</td>
</tr>
<tr>
<td>Before</td>
<td>是某个时间点之前的请求</td>
<td>-  Before&#x3D;2031-04-13T15:14:47.433+08:00[Asia&#x2F;Shanghai]</td>
</tr>
<tr>
<td>Between</td>
<td>是某两个时间点之前的请求</td>
<td>-  Between&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver],  2037-01-21T17:42:47.789-07:00[America&#x2F;Denver]</td>
</tr>
<tr>
<td>Cookie</td>
<td>请求必须包含某些cookie</td>
<td>- Cookie&#x3D;chocolate, ch.p</td>
</tr>
<tr>
<td>Header</td>
<td>请求必须包含某些header</td>
<td>- Header&#x3D;X-Request-Id, \d+</td>
</tr>
<tr>
<td>Host</td>
<td>请求必须是访问某个host（域名）</td>
<td>-  Host&#x3D;<strong>.somehost.org,</strong>.anotherhost.org</td>
</tr>
<tr>
<td>Method</td>
<td>请求方式必须是指定方式</td>
<td>- Method&#x3D;GET,POST</td>
</tr>
<tr>
<td>Path</td>
<td>请求路径必须符合指定规则</td>
<td>- Path&#x3D;&#x2F;red&#x2F;{segment},&#x2F;blue&#x2F;**</td>
</tr>
<tr>
<td>Query</td>
<td>请求参数必须包含指定参数</td>
<td>- Query&#x3D;name, Jack或者-  Query&#x3D;name</td>
</tr>
<tr>
<td>RemoteAddr</td>
<td>请求者的ip必须是指定范围</td>
<td>- RemoteAddr&#x3D;192.168.1.1&#x2F;24</td>
</tr>
<tr>
<td>Weight</td>
<td>权重处理</td>
<td></td>
</tr>
</tbody></table>
<h4 id="4-过滤器工厂"><a href="#4-过滤器工厂" class="headerlink" title="4. 过滤器工厂"></a>4. 过滤器工厂</h4><p>GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理：<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714212312871.png?raw=true" width="700" height="200"> </p>
<ul>
<li><strong>路由过滤器的种类</strong>：Spring提供了31种不同的路由过滤器工厂。例如：<table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>AddRequestHeader</td>
<td>给当前请求添加一个请求头</td>
</tr>
<tr>
<td>RemoveRequestHeader</td>
<td>移除请求中的一个请求头</td>
</tr>
<tr>
<td>AddResponseHeader</td>
<td>给响应结果中添加一个响应头</td>
</tr>
<tr>
<td>RemoveResponseHeader</td>
<td>从响应结果中移除有一个响应头</td>
</tr>
<tr>
<td>RequestRateLimiter</td>
<td>限制请求的流量</td>
</tr>
</tbody></table>
</li>
<li><strong>请求头过滤器</strong>：以AddRequestHeader 为例来讲解。<blockquote>
<p><strong>需求</strong>：给所有进入userservice的请求添加一个请求头：Truth&#x3D;itcast is freaking awesome!  </p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只需要修改gateway服务的application.yml文件，添加路由过滤即可</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> <span class="comment"># 当前过滤器写在userservice路由下，因此仅仅对访问userservice的请求有效</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://userservice</span> </span><br><span class="line">        <span class="attr">predicates:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/user/**</span> </span><br><span class="line">        <span class="attr">filters:</span> <span class="comment"># 过滤器</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=Truth,</span> <span class="string">Itcast</span> <span class="string">is</span> <span class="string">freaking</span> <span class="string">awesome!</span> <span class="comment"># 添加请求头</span></span><br></pre></td></tr></table></figure></li>
<li><strong>默认过滤器</strong>：如果要对所有的路由都生效，则可以将过滤器工厂写到default下。格式如下：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> </span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://userservice</span> </span><br><span class="line">        <span class="attr">predicates:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/user/**</span></span><br><span class="line">      <span class="attr">default-filters:</span> <span class="comment"># 默认过滤项</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">AddRequestHeader=Truth,</span> <span class="string">Itcast</span> <span class="string">is</span> <span class="string">freaking</span> <span class="string">awesome!</span> </span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="5-全局过滤器"><a href="#5-全局过滤器" class="headerlink" title="5. 全局过滤器"></a>5. 全局过滤器</h4><ol>
<li>全局过滤器作用<br>  上一节学习的过滤器，网关提供了31种，但每一种过滤器的作用都是固定的。如果我们希望拦截请求，做自己的业务逻辑则没办法实现。全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样。区别在于GatewayFilter通过配置定义，处理逻辑是固定的；而GlobalFilter的逻辑需要自己写代码实现。<br>  定义方式是实现GlobalFilter接口。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  处理当前请求，有必要的话通过&#123;<span class="doctag">@link</span> GatewayFilterChain&#125;将请求交给下一个过滤器处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange 请求上下文，里面可以获取Request、Response等信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chain 用来把请求委托给下一个过滤器 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> Mono&lt;Void&gt;&#125; 返回标示当前过滤器业务结束</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  在filter中编写自定义逻辑，可以实现下列功能：<strong>登录状态判断、权限校验、请求限流</strong>等</li>
<li>自定义全局过滤器<br>  <strong>需求：</strong>定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：（如果同时满足则放行，否则拦截）<br>  1、参数中是否有authorization，<br>  2、authorization参数值是否为admin<br>  <strong>实现：</strong>在gateway中定义一个过滤器：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order(-1)</span> <span class="comment">// 过滤器优先级</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizeFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取请求参数</span></span><br><span class="line">        MultiValueMap&lt;String, String&gt; params = exchange.getRequest().getQueryParams();</span><br><span class="line">        <span class="comment">// 2.获取authorization参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">auth</span> <span class="operator">=</span> params.getFirst(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.校验</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(auth)) &#123;</span><br><span class="line">            <span class="comment">// 放行</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.拦截</span></span><br><span class="line">        <span class="comment">// 4.1.禁止访问，设置状态码</span></span><br><span class="line">        exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);</span><br><span class="line">        <span class="comment">// 4.2.结束处理</span></span><br><span class="line">        <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>过滤器执行顺序<br>  请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter<br>  请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器： <img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714214228409.png?raw=true"></li>
</ol>
<ul>
<li>排序的规则是什么呢？<ul>
<li>每一个过滤器都必须指定一个int类型的order值，<strong>order值越小，优先级越高，执行顺序越靠前</strong>。</li>
<li>GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定</li>
<li>路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增。</li>
<li>当过滤器的order值一样时，会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行。<!-- 详细内容，可以查看源码：
`org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator#getFilters()`方法是先加载defaultFilters，然后再加载某个route的filters，然后合并。
`org.springframework.cloud.gateway.handler.FilteringWebHandler#handle()`方法会加载全局过滤器，与前面的过滤器合并后根据order排序，组织过滤器链 --></li>
</ul>
</li>
</ul>
<h4 id="6-跨域问题"><a href="#6-跨域问题" class="headerlink" title="6. 跨域问题"></a>6. 跨域问题</h4><ol>
<li><strong>什么是跨域问题</strong>：<br>域名不一致就是跨域，主要包括：域名不同： <a target="_blank" rel="noopener" href="http://www.taobao.com/">www.taobao.com</a> 和 <a target="_blank" rel="noopener" href="http://www.taobao.org/">www.taobao.org</a> 和 <a target="_blank" rel="noopener" href="http://www.jd.com;/">www.jd.com；</a> 域名相同，端口不同：localhost:8080 和 localhost:8081<br>跨域问题：浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题<br>解决方案：CORS <a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2016/04/cors.html">https://www.ruanyifeng.com/blog/2016/04/cors.html</a></li>
<li><strong>模拟跨域问题</strong><br>找到课前资料的页面文件：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714215713563.png?raw=true"><br>放入tomcat或者nginx这样的web服务器中，启动并访问。<br>可以在浏览器控制台看到下面的错误：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714215832675.png?raw=true"><br>从localhost:8090访问localhost:10010，端口不同，显然是跨域的请求。</li>
<li><strong>解决跨域问题</strong>：在gateway服务的application.yml文件中，添加下面的配置：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="comment"># ？？</span></span><br><span class="line">      <span class="attr">globalcors:</span> <span class="comment"># 全局的跨域处理</span></span><br><span class="line">        <span class="attr">add-to-simple-url-handler-mapping:</span> <span class="literal">true</span> <span class="comment"># 解决options请求被拦截问题</span></span><br><span class="line">        <span class="attr">corsConfigurations:</span></span><br><span class="line">          <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span></span><br><span class="line">            <span class="attr">allowedOrigins:</span> <span class="comment"># 允许哪些网站的跨域请求 </span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://localhost:8090&quot;</span></span><br><span class="line">            <span class="attr">allowedMethods:</span> <span class="comment"># 允许的跨域ajax的请求方式</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;GET&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;POST&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;DELETE&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;PUT&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;OPTIONS&quot;</span></span><br><span class="line">            <span class="attr">allowedHeaders:</span> <span class="string">&quot;*&quot;</span> <span class="comment"># 允许在请求中携带的头信息</span></span><br><span class="line">            <span class="attr">allowCredentials:</span> <span class="literal">true</span> <span class="comment"># 是否允许携带cookie</span></span><br><span class="line">            <span class="attr">maxAge:</span> <span class="number">360000</span> <span class="comment"># 这次跨域检测的有效期</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>

<h2 id="Sentinel-服务保护"><a href="#Sentinel-服务保护" class="headerlink" title="Sentinel 服务保护"></a>Sentinel 服务保护</h2><ul>
<li>雪崩：微服务调用链路中的某个服务故障，引起整个链路中的所有微服务都不可用，这就是雪崩。<ul>
<li>雪崩问题产生的原因是什么?<br>微服务相互调用，服务提供者出现故障或阻塞。<br>服务调用者没有做好异常处理，导致自身故障<br>调用链中的所有服务级联失败，导致整个集群故障<img src="https://github.com/leo710aka/bk/blob/main/springcloud/10.png?raw=true?raw=true" width="300" height="200"></li>
<li>解决问题的思路有哪些?<br>尽量避免服务出现故障或阻塞：保证代码的健壮性; 保证网络畅通; 能应对较高的并发请求;<br>服务调用者做好远程调用异常的后备方案，避免故障扩散</li>
<li>解决雪崩问题的常见方案有哪些?<br>请尔限流：限制流量在服务可以处理的范围，避免因突发流量丽故障<br>线程隔离：控制业务可用的线程数量，将故障隔离在一定范围<br>失败处理：（熔断的一部分）定义fallback逻辑，让业务失败时不再抛出异常，而是走fallback逻辑<br>服务熔断：将异常比例过高的接口断开，拒绝所有请求，直接走fallback</li>
<li>技术实现<br>现常用 Sentinel，功能更加强大；Hystrix 支持 SpringCloud 2020前的版本<img src="https://github.com/leo710aka/bk/blob/main/springcloud/11.png?raw=true?raw=true" width="700" height="200"></li>
</ul>
</li>
</ul>
<hr> 

<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/list/watchlater?oid=961238101&bvid=BV1kH4y1S7wz&spm_id_from=333.999.top_right_bar_window_view_later.content.click&p=46">https://www.bilibili.com/list/watchlater?oid=961238101&amp;bvid=BV1kH4y1S7wz&amp;spm_id_from=333.999.top_right_bar_window_view_later.content.click&amp;p=46</a></p>
<hr>

<h2 id="RabbitMQ-消息队列【5672】"><a href="#RabbitMQ-消息队列【5672】" class="headerlink" title="RabbitMQ 消息队列【5672】"></a>RabbitMQ 消息队列【5672】</h2><p><a target="_blank" rel="noopener" href="https://leo710aka.github.io/2024/01/11/RabbitMQ/">https://leo710aka.github.io/2024/01/11/RabbitMQ/</a></p>
<hr>

<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p><a target="_blank" rel="noopener" href="http://localhost:4000/2023/04/14/Docker/">http://localhost:4000/2023/04/14/Docker/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/07/SpringCloud/" data-id="cm3lnru62000mf0v542kqf8nh" data-title="SpringCloud" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-骏伯Junbo" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/04/%E9%AA%8F%E4%BC%AFJunbo/" class="article-date">
  <time class="dt-published" datetime="2024-01-04T02:58:11.000Z" itemprop="datePublished">2024-01-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/04/%E9%AA%8F%E4%BC%AFJunbo/">骏 伯 Junbo</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>使命</strong>：让移动互联网营销简单高效</p>
<p><strong>价值观</strong>：创造价值，分享价值</p>
<p><strong>愿景</strong>：做最受信赖的移动互联网营销服务商</p>
<!-- ## 学习 junbo-demo

开发工具：IDEA 2022.3.3
常用插件：阿里巴巴编码规约（Alibaba Java Coding Guidelines）, File->Settings->Plugins->Browse repositories->输入英文名称->install
开发环境：jdk1.8.0_202，Gradle 6.0 -->


<hr>

<h2 id="蔡枫-的2023年终总结"><a href="#蔡枫-的2023年终总结" class="headerlink" title="蔡枫 的2023年终总结"></a>蔡枫 的2023年终总结</h2><!-- * 回顾2023，你印象最深刻的2-3个 高光时刻 是什么？

    1. 愿意去了解，理解新事物的时候，从电影和音乐等感受乐趣，共情与哲思

    2. 准备一年拿到奖学金，重修两门课程高分通过

    3. 通过面试，进入骏伯，一定多向同事们学习

* 回顾2023，你印象最深刻的2-3个 艰难时刻 是什么？

    1. 放弃考研和出国，感觉是当下比较好的决定

    2. 想到家里情况是多么窘迫的时刻

    3. 发现脱发症状的时候

* 目标A：准备就业

    大概是八月份，打消了考研以及留学的念头后，由于有Java开发的经验，自然往这个方向准备就业。
    要学习的内容特别多，原以为有基础便能用三个月左右准备好，事实上即使每天都在尽力填充自己，如此半年后还剩下许多没准备好的，更别说要能够在面试时从容对答。但是并不焦虑，只要做好规划，继续学下去，有限的内容总是能够准备完成的，剩下就是准备和面对不喜欢的面试环节。
    2024年1月4日，我通过了骏伯的面试，岗位是Java开发实习生。面试中，我提到希望接触一些高并发、分布式这样的复杂场景中的“高大上”的问题。进入公司两周，我了解到在实际工作中更多的是在不断地解决需求，跟团队成员协作对接，真正重要的是要有解决实际问题的能力。
    每次向导师提问的时候，他的分享毫无保留，各位同事都是我学习的对象。未来的日子，我将尽全力完成每个安排到的任务，提升编码能力，为公司创造价值。 -->

<hr>

<h2 id="01-10"><a href="#01-10" class="headerlink" title="01.10"></a>01.10</h2><ul>
<li><p><strong>模块 服务</strong>？一个服务占用一个端口， 在 .gradle 配置<br>{<br>  demo-api: 服务化接口定义项目<br>  demo-service: 服务化实现项目<br>}<br>api 接口与实现 分离，<br>UserApi接口上加 @FeignClient， 请求均分发送到多台服务器上<br>spring注入 与 单例模式。。</p>
</li>
<li><p>敏捷开发：一种应对快速变化需求的一种软件开发能力。相对于”非敏捷”，更强调程序员团队与业务专家之间的紧密协作、面对面的沟通(认为比书面的文档更有效)、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好地适应需求变化的代码编写和团队组织方法，也更注重做为软件开发中人的作用。</p>
</li>
</ul>
<h2 id="01-18"><a href="#01-18" class="headerlink" title="01.18"></a>01.18</h2><ul>
<li><p>使用不同的窗口打开一个项目下的不同服务、、</p>
</li>
<li><p>使用 IDEA -&gt; Run&#x2F;Debug Configuration -&gt; Shorten command line 选项用于指定是否<strong>缩短命令行</strong>，以提高可读性或管理性，其中 None 表示不缩短，Classpath File 表示通过类路径文件缩短。<br>Java 源代码被编译成字节码文件（.class 文件）。字节码文件在 Java 虚拟机（JVM）上运行。运行时配置参数通过命令行或配置文件传递给 JVM 和应用程序。运行时参数包括类路径、系统属性、环境变量、应用程序参数等，用于影响应用程序在运行时的行为。</p>
</li>
<li><p>DevOps 懂技术的运维？ <a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%BE%8E/36%20DevOps%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%88%B0%E5%BA%95%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88%E4%BA%8B%E6%83%85%EF%BC%9F.md">https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%BE%8E/36%20DevOps%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%88%B0%E5%BA%95%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88%E4%BA%8B%E6%83%85%EF%BC%9F.md</a><br>DevOps 可以理解为一种开发和运维一起紧密协作的工作方式，从而可以更快更可靠地构建、测试和发布软件。DevOps 的主要原则就是自动化、信息透明可测量、构建协作文化。<br>DevOps 工程师，要做的事情就是帮助团队来实践 DevOps 的工作方式。具体可以帮助团队：建立基于持续集成和持续交付工作流程；建立基于日志的监控报警的系统，以及故障响应的流程；构建基于云计算和虚拟化技术的基础设施；形成 DevOps 的文化。DevOps 工程师做的事情，就是帮助团队基于 DevOps 原则来做事，让团队形成紧密协作的工作方式，更快更可靠的构建、测试和发布软件。</p>
</li>
</ul>
<h2 id="01-23"><a href="#01-23" class="headerlink" title="01.23"></a>01.23</h2><ul>
<li><p>Jedis 和 RedisTemplate有什么区别？<br>Jedis 是 Redis 的官方 Java 客户端，直接使用 Redis 的命令进行操作。它提供了比较底层的 API，需要手动管理连接、序列化等。RedisTemplate 是 Spring Data Redis 提供的 Redis 客户端，它在 Jedis 的基础上进行了封装，提供了更高层次的抽象和更多的功能。<br>如果你在使用 Spring 项目，并且希望更方便地集成 Redis，并提供更高层次的抽象和功能，那么推荐使用 RedisTemplate。如果你对 Redis 的命令较为了解，或者需要更底层的操作，那么 Jedis 可能更适合你。</p>
</li>
<li><p>SpringBoot实体类 DO 和 BO</p>
<ol>
<li><strong>DO（Data Object）：</strong>通常表示数据库中的数据实体，对应数据库表的结构。它主要用于数据存储和数据库操作，包含与数据库表字段一一对应的属性。DO 类的命名一般以 “DO” 为后缀，例如 <code>UserDO</code>，<code>OrderDO</code>。类中通常包含与数据库表字段对应的成员变量、getter 和 setter 方法。它不应包含业务逻辑，主要负责数据的持久化和映射。</li>
<li><strong>BO（Business Object）：</strong>通常表示业务层的业务实体，主要用于封装业务逻辑。BO 类一般包含与业务逻辑相关的属性和方法，与具体的数据存储形式无关。包含了一些业务逻辑的操作，比如计算、验证等。它不应直接与数据库进行交互，而是通过调用 Service 层或 DAO 层的方法实现数据的获取和存储。</li>
<li>在 Spring Boot 中，DO和 BO是一些常见的命名规范，用于表示在不同层次中使用的实体类。这些命名规范有助于代码的清晰性和可维护性。在业务逻辑层中，可以通过转换工具或框架进行 DO 和 BO 之间的转换，以完成数据的传递和处理。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用实例BO对象生成DO对象</span></span><br><span class="line"><span class="type">OrderDO</span> <span class="variable">orderDO</span> <span class="operator">=</span> BeanMapperUtil.map(orderBO, OrderDO.class);</span><br></pre></td></tr></table></figure>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">map</span><span class="params">(Object sourceObject, Class&lt;T&gt; destObjectclazz)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sourceObject == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">T</span> <span class="variable">destObject</span> <span class="operator">=</span> BeanUtils.instantiateClass(destObjectclazz);</span><br><span class="line">    <span class="comment">// 对象映射： 通过 copyProperties 方法，将源对象的属性值复制到目标对象中</span></span><br><span class="line">    copyProperties(sourceObject, destObject, <span class="literal">null</span>, (String[]) <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> destObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="01-30"><a href="#01-30" class="headerlink" title="01.30"></a>01.30</h2><p>App拉新业务，增加白名单功能</p>
<!-- - 业务：当新接入一个客户或者媒体时，需要对整条链路进行验证，确保数据是能够正常传递的。媒体广告投放后台有一个联调功能，通过联调功能，能够指定媒体给特定一台手机发送测试广告，用户再点击广告可以触发一条广告点击数据，并发送到我方拉新业务系统，我方可以通过页面功能查到该广告点击数据的状态。如果该点击数据成功发给客户，说明链路一（媒体到客户）是通的，则可以使用我方业务系统页面功能手动触发一条转化数据，发给媒体，如果能发送成功，则说明整条链路是通的，则验证通过。
- 问题：使用联调功能，媒体给我方发送的广告点击数据，我们会做一些拦截处理，有时候不会将它们发给客户，这就使得没法进行下一步转化回传的动作，从而无法完成媒体的联调。一个典型的拦截处理的案例是，对于某些客户，我方在发送点击数据给对方时，需要调用客户的接口进行确认，判断当前用户是否是客户的目标用户，如果不是，则不发送点击数据给客户，这样的拦截称之为RTA拦截。拦截率由客户决定的，并且可能会很高，业务方用来联调的手机基本都被拦截了，从而无法完成联调。
handle 拦截，其实就是修改某些字段的状态，以在之后判定为某种情况而进行某种行为
- 解决：添加白名单，如果业务方用来测试的手机设备号在白名单内，则不进行拦截。
- 代码介绍
仓库地址：http://git.gzjunbo.net/junbo/junbo-newenergy.git， 基于master分支创建一个自己的开发分支develop-caif
两个服务：newenergy-web-admin、newenergybg-service，前者提供了一个接收点击数据的接口，在收到点击数据以后，会将其通过feign转发给newenergybg-service服务进行处理（注册中心为eureka）。
接口对应的方法是：ConvTraceWebApi.send（newenergy-web-admin），它会调用newenergybg-service服务的ConvTraceApiImpl.upload方法，再通过MediaDataForwardProducer.produce方法，将其发送到Kafka消息队列，再由MediaDataForwardServiceImpl.consumeKafka方法进行消费，最终进入核心的业务处理逻辑方法，即MediaDataForwardServiceImpl.upload方法，我们需要修改的RTA拦截部分的代码就在这里面。
- upload方法的内部处理逻辑如下：
参数前置处理（initPreValidate）（一些通用逻辑，比如点击数据ID、时间字段的初始化）。
参数校验（isValid）（校验点击数据是否有效，如果无效则不发给客户，比如媒体可能会将用户曝光数据发过来，此时不需要发给客户）。
参数后置处理（initPostValidate）（一些带有复杂业务逻辑的处理，比如RTA拦截）。
将校验通过的点击数据发给客户（transferToCustomer）。
保存数据到数据库/缓存（save）。
我们需要修改的RTA拦截部分的代码在参数后置处理部分，具体方法是YoudaoMediaActionDataHandler.handle。
- YoudaoMediaActionDataHandler.handle类内部处理逻辑
媒体发给我方的数据可能不止用户点击数据，还包括了广告曝光数据（即用户只要看了广告，媒体就会通知我们），这类数据我们是不需要发给客户的，因此需要设置状态为NON_CLICK_NOT_TRANSFER_TO_CUSTOMER，后续代码流程识别出此状态后，不会将该数据发给客户。
走RTA拦截，有一些前置条件，包括①业务方指定了客户点击监测链接ID为RTA链接（客户的点击监测链接是客户提供过来用于接收我方点击数据的接口）（RTA链接是一个标记，标识当前点击数据发给客户前，要先调用客户的RTA接口过滤一道，最终只发送客户需要的用户）②如果当前数据类型为曝光，且曝光总数与点击总数的比例小于requestRate（默认为4:1）
对于满足前置条件的数据，则发起RTA请求，将结果记录下来（结果指的是客户是否接受当前用户，即是否参竞-isParticipated），用于业务方后续使用
如果客户不接受当前用户，则设置状态RTA_EXCLUDED，后续代码流程识别出此状态后，不会将该数据发给客户。（添加白名单后，如果客户不接受当前用户，不设置状态RTA_EXCLUDED，此时后续流程会正常将该数据发给客户） -->


<h2 id="02-20"><a href="#02-20" class="headerlink" title="02.20"></a>02.20</h2><p>需求：开发媒体上报规则报表的分页查询接口</p>
<!-- * 需求原型：https://axhub.im/pro/62d03dd7790d2dd4/#g=1&p=%E5%AA%92%E4%BD%93%E4%B8%8A%E6%8A%A5%E8%A7%84%E5%88%99%E6%8A%A5%E8%A1%A8
* 拉一个develop-caif分支，后续代码开发在此分支上进行，分支对应整个项目，其中包括了后面涉及到的所有微服务
* 数据库建表
* 使用junboGenerator插件生成表结构对应的MyBatis代码（DO, BO, Mapper文件），用于操作数据库。修改 /resources/generator/generatorConfig.xml 文件，运行插件： Gradle -> newenerge-soa -> Tasks -> junbo -> junboGenerater，配置新表（注意，此时需要将其他表的配置项注释掉），后续插件执行时会根据数据库表结构生成相应的Java代码（DO、Mapper等等），将代码文件放到特定的文件目录下。
config.xml 中有两类列属性需要特殊标记，一类是id，一类是枚举字段（在数据库里可能是int，而在java中是enum，此时插件默认无法将这两个类型对应，需要覆盖掉插件的默认行为，手动进行转换）
* 实现分页功能，大致步骤包括：
①【newenergy-api】定义XXXApi接口及page方法
②【newenergybg-service】定义XXXService接口及page方法
③【newenergybg-service】定义XXXApiImpl类（Controller），实现XXXApi接口及page方法，通过调用XXXService完成分页查询数据的操作
④【newenergybg-service】定义XXXServiceImpl类，实现XXXService接口及page方法，通过MyBatis分页插件及XXXMapper的查询方法，完成数据的分页查询。
⑤【newenergy-api】发布XXXApi：修改版本号（xx.snapshot），发布新的jar包（包含新的XXXApi接口）到 Maven 仓库；Gradle -> newenergy-api -> Tasks -> publishing -> publish 
⑥【newenergy-web-admin】引入最新的XXXApi：更新maven，依赖新版本jar包，以使用新的XXXApi接口
⑦【newenergy-web-admin】定义XXXWebApi类及page方法（Controller），通过XXXApi的page方法，完成数据的分页查询。
* 服务关系：
【newenergy-api】：定义接口信息，同时被【newenergybg-service】和【newenergy-web-admin】依赖
【newenergybg-service】是【newenergy-api】的实现，实际的服务端；
【newenergy-web-admin】接收前端请求（防止暴露实际服务端），从 maven 获取 jar 包反射获取接口和实体类信息。
* 参数信息：
Api方法中：XXXRequest、XXXResponse
业务层：XXXBO
持久层：直接与数据库交互 XXXDO
实际上，由于需要返回的数据是由多表查询而来，任一 BO 或 DO 都没法涵盖所有属性字段。所以新增一个 分页查询entity类 ConvCallbackRuleDailyReportPageItem，要在 mapper.xml 里修改 resultMap 中查询数据与返回值的对应关系，在后续数据转换的过程中主要前后类的字段的对应。
* 【集成测试】本地启动newenergybg-service服务和newenergy-web-admin服务，通过postman调用接口进行测试，期望结果是，查出来的结果与数据库中的数据一致。
实际请求发送流程为：前端客户端程序发起请求 ->【newenergy-web-admin】XXXWebApi.page -> 【newenergybg-service】XXXApiImpl.page -> 【newenergybg-service】XXXServiceImpl.page -> 【newenergybg-service】 XXXMapper.selectByExample
测试方法：打断点，观察获取和处理的数据从 mapper->serviceImpl->apiImpl 中的变化，注意数据转换过程
使用 postman 给本地服务发送请求，如 localhost:1087/service/conv-callback-rule-daily-report/page，在 Body 携带 raw 的 json 数据
* 提交代码到远程仓库develop-caif分支
* 在 Yapi 编写接口文档 -->

<h2 id="02-22"><a href="#02-22" class="headerlink" title="02.22"></a>02.22</h2><ul>
<li>YY yy &#x3D; BeanMapperUtil.map(xx, YY.class); 从xx复制属性值而来生成YY类型的实例yy</li>
<li>List<ConvCallbackRuleDailyReportResponse> list &#x3D; page.getList().stream().map(this::toResponse).collect(Collectors.toList());<br>  Java中的Stream API 是一种用于处理集合数据的强大工具，在 Java 8 中引入，它允许我们以声明性方式处理数据集合（即你可以描述你想要做什么，而不是描述如何去做）,它使得集合操作更加简洁、易读和高效。<ul>
<li>创建 Stream：你可以从集合（如 List、Set 等）创建 Stream，或者从数组创建。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>);  </span><br><span class="line">Stream&lt;String&gt; stream = list.stream();  </span><br><span class="line"><span class="comment">// 或者直接从数组创建  </span></span><br><span class="line">Stream&lt;String&gt; arrayStream = Arrays.stream(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>&#125;);</span><br></pre></td></tr></table></figure></li>
<li>中间操作：是返回新 Stream 的操作，它们可以链接起来形成一个处理链。常见的中间操作有 filter、map、sorted 等。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>);  </span><br><span class="line">    List&lt;String&gt; result = list.stream()  </span><br><span class="line">                        .filter(s -&gt; s.matches(<span class="string">&quot;[a-c]+&quot;</span>))  <span class="comment">// 过滤出以 a-c 开头的字符串  </span></span><br><span class="line">                        .map(String::toUpperCase)         <span class="comment">// 将字符串转换为大写  </span></span><br><span class="line">                        .sorted()                          <span class="comment">// 对字符串进行排序  </span></span><br><span class="line">                        .collect(Collectors.toList());     <span class="comment">// 收集到新的 List 中  </span></span><br></pre></td></tr></table></figure></li>
<li>终端操作：结束 Stream 处理并返回结果。常见的终端操作有 forEach、reduce、collect 等。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>);  </span><br><span class="line"><span class="comment">// 使用 forEach 遍历 Stream  </span></span><br><span class="line">list.stream().forEach(System.out::println);  </span><br><span class="line"><span class="comment">// 使用 reduce 对 Stream 中的元素进行归约操作，例如求和  </span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> list.stream().mapToInt(Integer::parseInt).sum();  </span><br><span class="line">System.out.println(sum);  <span class="comment">// 输出：6（&#x27;a&#x27;、&#x27;b&#x27;、&#x27;c&#x27;、&#x27;d&#x27; 的 ASCII 码之和）  </span></span><br><span class="line"><span class="comment">// 使用 collect 将 Stream 中的元素收集到新的集合中  </span></span><br><span class="line">List&lt;String&gt; collectedList = list.stream().collect(Collectors.toList());  </span><br><span class="line">System.out.println(collectedList);  <span class="comment">// 输出：[a, b, c, d]</span></span><br></pre></td></tr></table></figure></li>
<li>并行 Stream：Java Stream API 还支持并行处理，这可以充分利用多核处理器的优势，提高处理速度。要创建一个并行 Stream，你可以使用 parallelStream() 方法。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>);  </span><br><span class="line"><span class="comment">// 使用 parallelStream 创建并行 Stream  </span></span><br><span class="line">List&lt;String&gt; collectedList = list.parallelStream().collect(Collectors.toList());  </span><br><span class="line">System.out.println(collectedList);  <span class="comment">// 输出：[a, b, c, d]</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>在Java中，Stream流和序列化是两个不同的概念，但它们在某些场景下可以相互关联。<ul>
<li>Stream流是Java 8引入的一个新特性，它允许我们以声明性方式处理数据集合。Stream API提供了一种高效且简洁的方式来处理数据，例如过滤、映射、排序和聚合等操作。Stream流主要关注的是数据的处理和转换，而不是数据的存储或传输。</li>
<li>序列化（Serialization）则是将对象的状态转换为字节流的过程，以便可以将这些字节流持久化保存或通过网络传输到其他位置。序列化允许我们将对象的状态保存起来，然后在需要时恢复对象的状态。Java提供了ObjectOutputStream和ObjectInputStream类来进行对象的序列化和反序列化。</li>
<li>虽然Stream流和序列化是两个不同的概念，但它们在某些情况下可以相互结合使用。例如，当我们需要将一个对象的状态通过网络传输到另一个位置时，我们可以先将对象序列化为字节流，然后使用Stream流来处理和转换这些字节流。在接收端，我们可以使用Stream流来读取字节流，并使用反序列化来恢复对象的状态。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/04/%E9%AA%8F%E4%BC%AFJunbo/" data-id="cm3lnru6f000yf0v59yugbjbi" data-title="骏 伯 Junbo" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2046/12/">December 2046</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2046/08/">August 2046</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2046/12/30/nice-photo/">Nice Photo</a>
          </li>
        
          <li>
            <a href="/2046/08/27/Guitar/">Guitar 🎸</a>
          </li>
        
          <li>
            <a href="/2024/09/22/InfluxDB/">InfluxDB | DBAdvanced</a>
          </li>
        
          <li>
            <a href="/2024/09/22/Golang/">Golang</a>
          </li>
        
          <li>
            <a href="/2024/08/18/%E4%BF%9D%E9%99%A9/">保 险</a>
          </li>
        
          <li>
            <a href="/2024/07/07/%E7%BE%8E%E7%9A%84Midea/">美 的 Midea</a>
          </li>
        
          <li>
            <a href="/2024/05/01/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/">毕 业 🎓 设 计</a>
          </li>
        
          <li>
            <a href="/2024/01/11/RabbitMQ/">RabbitMQ</a>
          </li>
        
          <li>
            <a href="/2024/01/07/SpringCloud/">SpringCloud</a>
          </li>
        
          <li>
            <a href="/2024/01/04/%E9%AA%8F%E4%BC%AFJunbo/">骏 伯 Junbo</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 fengcai<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>