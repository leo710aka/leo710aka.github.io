<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Qué miras Bobo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Qué miras Bobo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Qué miras Bobo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="fengcai">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Qué miras Bobo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="https://github.com/leo710aka/bk/blob/main/DT1.jpg?raw=true">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Qué miras Bobo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-nice-photo" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2046/12/30/nice-photo/" class="article-date">
  <time class="dt-published" datetime="2046-12-30T03:11:00.000Z" itemprop="datePublished">2046-12-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2046/12/30/nice-photo/">Nice Photo</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <br>
<br>
<img src="https://leo710aka.github.io/bk/bk.jpg" width="550" height="300" alt="">
<!-- <div style="text-align:center;text-shadow: 2px 2px 2px #888888;">Old Master</div> -->
<br>
<img src="https://leo710aka.github.io/bk/zq.jpg" width="550" height="300" alt="">
<br>
<img src="https://leo710aka.github.io/bk/3.jpg" width="550" height="300" alt="">
<br>
<!-- <img src="https://leo710aka.github.io/bk/4.jpg" width="750" height="300" alt=""> -->
<!-- <img src="https://leo710aka.github.io/bk/zq2.jpg" width="550" height="200" alt="">
<br>
<br>
<img src="https://leo710aka.github.io/bk/zq3.jpg" width="550" height="200" alt="">
<br> -->
<!-- <div style="display: flex; justify-content: center;">
    <img src="https://leo710aka.github.io/bk/zq2.jpg" style="width: 100%; margin-right: 5px;">
    <img src="https://leo710aka.github.io/bk/zq3.jpg" style="width: 100%; margin-left: 5px;">
</div> -->
<img src="https://leo710aka.github.io/bk/zq2.jpg" width="550" height="300" alt="">
<br>
<img src="https://leo710aka.github.io/bk/zq3.jpg" width="550" height="300" alt="">
<br>
<br>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2046/12/30/nice-photo/" data-id="cmiae68a5000nl4v5gvrh7kka" data-title="Nice Photo" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Guitar" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2046/08/27/Guitar/" class="article-date">
  <time class="dt-published" datetime="2046-08-27T13:55:11.000Z" itemprop="datePublished">2046-08-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2046/08/27/Guitar/">Guitar 🎸</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="指板"><a href="#指板" class="headerlink" title="指板"></a>指板</h2><img src="https://picx.zhimg.com/80/v2-05339b6d9510209ea9ca02a75c325c4f_720w.webp" width="575" height="300" alt="chords">
<br>
在乐音体系中，七个具有独立名称的音级叫做基本音级（也叫自然音级）。
基本音级用“C、D、E、F、G、A、B”七个字母来表示，这就是基本音级的<b>音名</b>。
<b>唱名</b>是人们在演唱音乐的谱子时所使用的名称，即：“Do，Re，Mi，Fa，Sol，La，Si” 这七个唱名。
<br>
<img src="https://picx.zhimg.com/80/v2-5ef1b97ef6814aa577390b0f422f2735_720w.webp" width="475" height="300" alt="简谱上 唱名、音名的表示">
<br>
<b>十二平均律</b>，是将一个八度的音程等分成十二个半音的律制，各相邻两律之间的波长之比完全相等。一等份为一个半音(小二度)，对应吉他一品的距离。两等份为一个全音(大二度)。将一个八度分成12等份有着惊人的一些巧合，这是因为它的纯五度音程的两个音的波长比为(1/2)^(7/12)≈0.6674，与2/3≈0.6667非常接近。
<img src="https://pic2.zhimg.com/80/v2-288e079f27e141774b5ba1736da17af7_720w.webp" width="350" height="300" alt="一个八度内 全全半全全全半">

<p>C大调音阶在吉他指板上可以有不同的把位 <a target="_blank" rel="noopener" href="https://www.zhihu.com/tardis/zm/art/496745355?source_id=1005">https://www.zhihu.com/tardis/zm/art/496745355?source_id=1005</a><br><img src="https://pic1.zhimg.com/80/v2-c23f869bcd3573fe54cb71fb6507aebc_720w.webp" width="475" height="300" alt="C大调音阶图"></p>
<p>扫弦节奏型：1）下  下 下上 上下上下 下上<br>节拍</p>
<h2 id="乐理"><a href="#乐理" class="headerlink" title="乐理"></a>乐理</h2><p>HUB GUITAR: <a target="_blank" rel="noopener" href="https://hubguitar.com/zh_han/music-theory">https://hubguitar.com/zh_han/music-theory</a> 指板: <a target="_blank" rel="noopener" href="https://hubguitar.com/zh_han/fretboard">https://hubguitar.com/zh_han/fretboard</a></p>
<p>弹奏第一品位上的B弦，这就是 C音，一个以一定频率振动的音波。接下来你拨第十三品的同一根弦，同样地，它听上去好像是同一个音，但这个音高更高。这是因为声波的振动是原来的两倍之快，可以表达为1:2， 它们是有同一特性的音。如果两种不同的乐器同时弹奏C音，这个比例是1:1，这称为 同音。在下图中，第一品的音符将会是最左边的C，第十三品的音则是在最右边。所有在这两者之间的音符都是特定的音符，但一旦重新回到C音，就重新按照这个顺序继续下去。<br><img src="https://hubguitar.com//images/the-musical-alphabet.png"></p>
<p><strong>音程</strong>：就是两个音符之间的高低关系。在较低的一个 “C” 音和另一个较高的 “C” 音之间的音程就是 八度（八音音阶）。八度是音高的基本来源，其余的还包括将它分成更小的部分而得到的音高，称为 音数。半音就是移动一格，从 C 到 C♯。全音移动两格，从 C 到 D。 大多数现代音乐将八度分割为12级，如图所示，你可以按照这个音符的顺序来弹奏，从第一品的 B 弦开始，每次移动一个品位，直到第十三品，重新回到 C，一边弹奏一边大声说出这个音符的名字。所有这十二个音符一起组成了 半音音阶。音阶就是音符的顺序，并且没有重复的音符，所有的音符以升序，从低到高的顺序来弹奏。</p>
<p><strong>根音</strong>？它就是一首歌的主调音，它是一个单音，其余的东西全在它的基础上变化，想像它是重力中心，它是一种吸引力，吸引着一首歌曲里其余所有的音，不管什么情况下都会回到根音上来。</p>
<h2 id="TABS"><a href="#TABS" class="headerlink" title="TABS"></a>TABS</h2><br>

<div style="display: flex; justify-content: space-around;">
    <img src="https://pic4.zhimg.com/80/v2-24c56092ae6d3db3f549e43db567c641_720w.webp" width="550" height="300" alt="">
    <img src="https://pica.zhimg.com/80/v2-641a56efd1addd3d667a97c7e414952e_720w.webp" width="550" height="300" alt="">
    <img src="https://pic4.zhimg.com/80/v2-1b9c2fe17cff4da5c4c4c706f10f5efb_720w.webp" width="550" height="300" alt="">
</div>

<blockquote>
<p>晴天 - 周杰倫</p>
</blockquote>
<div style="display: flex; justify-content: space-around;">
    <img src="https://pic2.zhimg.com/80/v2-183d0eb2a71fbc33812e2f54460f7969_720w.webp" width="550" height="300" alt="">
    <img src="https://picx.zhimg.com/80/v2-22fce8698cf92f174ecf81820e74d2d9_720w.webp" width="550" height="300" alt="">
    <img src="https://pic1.zhimg.com/80/v2-7daea7e2b74b31031a70c230cdd30fc0_720w.webp" width="550" height="300" alt="">
</div>

<blockquote>
<p>Hey Jude - The Beatles</p>
</blockquote>
<div style="display: flex; justify-content: space-around;">
    <!-- <img src="https://picx.zhimg.com/80/v2-72b358faba023c900a22a5642e3a3115_720w.webp" width="550" height="300" alt="">
    <img src="https://picx.zhimg.com/80/v2-2457aa5d0465be0c3dbfd53e4f6ec85b_720w.webp" width="550" height="300" alt=""> -->
    <img src="https://www.helloimg.com/i/2024/11/18/673b50d5141e8.jpg" width="550" height="300" alt="">
    <img src="https://www.helloimg.com/i/2024/11/18/673b50d56467a.jpg" width="550" height="300" alt="">
</div> 

<blockquote>
<p>小情歌 - 蘇打綠 <a href="https://www.bilibili.com/video/BV1R64y1p7WB/?spm_id_from=333.337.search-card.all.click&vd_source=ff210768dfaee27c0d74f9c8c50d7274" target="_blank">https://www.bilibili.com/video/BV1R64y1p7WB/</a></p>
</blockquote>
<div style="display: flex; justify-content: space-around;">
    <!-- <img src="https://pic1.zhimg.com/80/v2-fbc32cea2510f17af26f01c8669c67c8_720w.webp" width="550" height="300" alt="">
    <img src="https://pic4.zhimg.com/80/v2-2bfb757b3f8b47a7b7774660db0b750d_720w.webp" width="550" height="300" alt="">
    <img src="https://picx.zhimg.com/80/v2-0445476bb9d9077872debb83d4cd8857_720w.webp" width="550" height="300" alt=""> -->
    <img src="https://www.helloimg.com/i/2024/11/18/673b53fad3fd8.jpg" width="550" height="300" alt="">
    <img src="https://www.helloimg.com/i/2024/11/18/673b53fae3339.jpg" width="550" height="300" alt="">
    <img src="https://www.helloimg.com/i/2024/11/18/673b53f9985d4.jpg" width="550" height="300" alt="">
</div>

<blockquote>
<p>紅豆 - 方大同</p>
</blockquote>
<div style="display: flex; justify-content: space-around;">
    <img src="https://www.helloimg.com/i/2024/12/05/6751ba9e71f6e.png" width="550" height="300" alt="">
    <img src="https://www.helloimg.com/i/2024/12/05/6751b9fe18946.png" width="550" height="300" alt="">
    <img src="https://www.helloimg.com/i/2024/12/05/6751b9fb8e729.png" width="550" height="300" alt="">
</div>

<blockquote>
<p>找自己 - 陶喆</p>
</blockquote>
<div style="display: flex; justify-content: space-around;">
    <img src="https://www.helloimg.com/i/2024/12/11/67597803294d6.png" width="550" height="300" alt="">
    <img src="https://www.helloimg.com/i/2024/12/11/6759780346ec7.png" width="550" height="300" alt="">
</div>

<blockquote>
<p>普通朋友 - 陶喆 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1zw4m1a7CU">https://www.bilibili.com/video/BV1zw4m1a7CU</a><br><br></p>
</blockquote>
<img src="https://www.helloimg.com/i/2024/12/07/67544d09dbe42.png" width="550" height="300" alt="">

<blockquote>
<p>Canon in C <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1if4y1A7SZ/">https://www.bilibili.com/video/BV1if4y1A7SZ/</a></p>
</blockquote>
<!-- <img src="https://www.jitabang.com/img/2022/03/2022031203241555.png" width="550" height="300" alt=""> -->

<!-- > 反方向的鐘 - 周杰倫 -->

<div style="display: flex; justify-content: space-around;">
    <img src="https://www.helloimg.com/i/2025/01/11/6782143fcf895.png" width="550" height="300" alt="">
    <img src="https://www.helloimg.com/i/2025/01/11/67821441562a1.png" width="550" height="300" alt="">
    <img src="https://www.helloimg.com/i/2025/01/11/6782143faf731.png" width="550" height="300" alt="">
</div>

<blockquote>
<p>揪心的玩笑與漫長的白日夢 - 萬能青年旅店<br> <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1cuHjetENY/?vd_source=ff210768dfaee27c0d74f9c8c50d7274">https://www.bilibili.com/video/BV1cuHjetENY/?vd_source=ff210768dfaee27c0d74f9c8c50d7274</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2046/08/27/Guitar/" data-id="cmiae689u0004l4v52t5ef5ij" data-title="Guitar 🎸" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-MongoDB" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/12/08/MongoDB/" class="article-date">
  <time class="dt-published" datetime="2025-12-08T05:34:33.000Z" itemprop="datePublished">2025-12-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/12/08/MongoDB/">MongoDB</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <br>
<div style="display: flex; align-items: center;">
  <div style="flex: 0 0 30%;">
    <img src="https://www.thehotskills.com/wp-content/uploads/2019/07/mongodb-logo-png.png" alt="" style="max-width: 100%;">
  </div>
  <div style="flex: 1; padding-left: 10px;">
    <p><em>MongoDB 是一个基于文档的开源 NoSQL 数据库，使用类似 JSON 的文档模型灵活存储数据，旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。<br>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。<br> https://www.mongodb.com/zh-cn/docs/manual/crud/</em></p>
  </div>
</div>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/12/08/MongoDB/" data-id="cmixawh5u0000yov54hde3zbb" data-title="MongoDB" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Docker_Kubernetes" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/22/Docker_Kubernetes/" class="article-date">
  <time class="dt-published" datetime="2024-10-22T02:25:07.000Z" itemprop="datePublished">2024-10-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/22/Docker_Kubernetes/">Kubernetes</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="2023-07-31-10-25-07-Docker"><a href="#2023-07-31-10-25-07-Docker" class="headerlink" title="2023-07-31 10:25:07 Docker &#x2F;"></a>2023-07-31 10:25:07 Docker &#x2F;</h2><p>Docker 是一种开源平台，一种快速构建、运行和管理应用的工具。它使用容器化技术，使得应用程序及其依赖性可以打包到一个容器中，并在任何支持 Docker 的环境中运行。<br>1 <a target="_blank" rel="noopener" href="https://leo710aka.github.io/2022/03/05/VMware_SSH/"><strong>MobarXterm 通过 SSH 连接 linux虚拟机，操作虚拟机上的 Docker。</strong></a><br>2 Windows本地：通过wsl安装Linux发行版本，安装docker desktop(将自动在WSL中配置Docker环境，借助linux内核运行)<br><img src="https://github.com/leo710aka/bk/blob/main/docker.png?raw=true"></p>
<h3 id="容器（Container）"><a href="#容器（Container）" class="headerlink" title="容器（Container）"></a><strong>容器（Container）</strong></h3><ul>
<li>容器是一个轻量级的、可移植的、自包含的单元，包括应用程序和其所有依赖项。</li>
<li>Docker 利用容器技术，将应用程序及其依赖项打包成一个容器，确保在不同环境中的一致性运行。</li>
<li><strong>Docker 位于容器 和 服务器-操作系统&#x2F;硬件 之间，是运行容器的引擎。</strong></li>
<li>隔离网络、文件、进程等环境。一个容器是一个沙盒隔离环境。</li>
<li>相对于虚拟机技术，docker 启动更快、更清量。但容器共用宿主机的内存、CPU物理资源，多容器可能存在互相抢占资源的情况。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \                  <span class="comment"># 创建并运行一个容器，-d 是让容器在后台运行；同一个镜像可创建多个容器</span></span><br><span class="line">   --name mysgl \                <span class="comment"># 给容器起名字，必须唯一</span></span><br><span class="line">   -p 3306:3306 \                <span class="comment"># 设置 宿主机端口：容器端口 映射</span></span><br><span class="line">   -e TZ=Asia/Shanghai \         <span class="comment"># 设置环境变量</span></span><br><span class="line">   -e MYSQL_ROOT_PASSWORD=123 \  <span class="comment"># 指定运行的镜像名，一般为 [镜像名]:[镜像版本]</span></span><br><span class="line">   mysql</span><br><span class="line">docker ps                        <span class="comment"># 查看本地容器（运行中的）</span></span><br><span class="line">docker ps a                      <span class="comment"># 查看所有容器 (包括未运行)</span></span><br><span class="line">docker start &lt;容器ID&gt;          <span class="comment"># 启动容器</span></span><br><span class="line">docker stop  &lt;容器ID&gt;          <span class="comment"># 停止容器中的进程，容器未删除</span></span><br><span class="line">docker <span class="built_in">rm</span> &lt;容器ID&gt;             <span class="comment"># 删除容器</span></span><br><span class="line">docker inspect &lt;容器ID&gt;        <span class="comment"># 查看容器配置信息 </span></span><br><span class="line">docker <span class="built_in">log</span> &lt;容器ID&gt;            <span class="comment"># 查看容器日志 </span></span><br><span class="line">docker <span class="built_in">exec</span> -it &lt;容器ID&gt; bash  <span class="comment"># 进入容器内部，命令行模式（容器内部模拟出一个操作系统）</span></span><br><span class="line">容器打包成镜像: docker commit -a <span class="string">&quot;作者信息&quot;</span> -m <span class="string">&quot;log信息&quot;</span> &lt;容器ID&gt;&lt;目标镜像名称:tag版本&gt; </span><br><span class="line">拷贝文件到容器: docker <span class="built_in">cp</span> &lt;文件目录&gt; &lt;容器ID&gt;:&lt;目标目录&gt;</span><br><span class="line">拷贝容器文件到宿主机:docker <span class="built_in">cp</span> &lt;容器ID&gt;:&lt;文件目录&gt;&lt;宿主机目标目录&gt;</span><br><span class="line">更新容器设置:docker update &lt;容器ID&gt;&lt;相关设置&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="镜像（Image）"><a href="#镜像（Image）" class="headerlink" title="镜像（Image）"></a><strong>镜像（Image）</strong></h3><ul>
<li>镜像是一个只读的模板，包含运行应用程序所需的所有信息，包括代码、运行时、库、环境变量和配置文件。</li>
<li><strong>容器是通过运行镜像创建的（像光盘），本地容器是真正运行的实例。镜像是容器的模板，是从容器打包来的，可以在不同操作系统，不同服务器之间传播。</strong></li>
<li>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker images                                <span class="comment"># 查看本地镜像</span></span><br><span class="line">docker search &lt;名称关键字&gt;                     <span class="comment"># 搜索镜像仓库</span></span><br><span class="line">docker pull &lt;镜像名:tag版本&gt;                   <span class="comment"># 下载镜像</span></span><br><span class="line">docker push &lt;镜像名:tag版本&gt;                   <span class="comment"># 上传镜像</span></span><br><span class="line">docker rmi &lt;镜像名:tag版本&gt;                    <span class="comment"># 删除镜像</span></span><br><span class="line">docker save -o &lt;输出文件路径&gt;&lt;镜像名:tag版本&gt;    <span class="comment"># 打包本地镜像文件</span></span><br><span class="line">docker load -i &lt;加载文件路径                   <span class="comment"># 导入本地镜像文件</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="仓库（Registry）"><a href="#仓库（Registry）" class="headerlink" title="仓库（Registry）"></a><strong>仓库（Registry）</strong></h3><ul>
<li>仓库是存储和组织 Docker 镜像的地方。Docker Hub 是一个常见的公共仓库，你也可以搭建私有仓库。</li>
<li>Docker 镜像可以从仓库中拉取，也可以推送到仓库。</li>
</ul>
<h3 id="沙箱"><a href="#沙箱" class="headerlink" title="沙箱"></a><strong>沙箱</strong></h3><ul>
<li>沙箱是一种安全机制，用于隔离和限制程序或应用程序的运行环境，以防止其对系统或其他程序产生潜在的危害。沙箱技术旨在创建一个受控制的环境，使得运行在其中的代码无法直接影响到系统的其他部分。这种隔离有助于确保安全性、防止恶意软件传播，同时提供一定程度的控制和监控。</li>
<li>容器化平台（如 Docker）使用沙箱技术来隔离容器中的应用程序，确保它们互相独立运行。</li>
</ul>
<h2 id="容器创建"><a href="#容器创建" class="headerlink" title="容器创建"></a><strong>容器创建</strong></h2><p>镜像结构：入口，层，基础镜像。分层的好处是可复用，，</p>
<ul>
<li>通过命令直接创建，需要完整镜像，几个G常有，稳定。</li>
<li>通过<strong>dockerfile</strong>创建，不需要完整镜像，更灵活。<br>Dockerfile 是一个包含构建镜像步骤的文本文件，包含一个个的指令。通过编写 Dockerfile，你可以定义如何构建镜像，包括基础镜像、安装依赖、复制文件等步骤。</li>
<li>使用 Docker 的基本步骤<ol>
<li><strong>安装 Docker：</strong> 根据操作系统的不同，安装适合的 Docker 版本。</li>
<li><strong>创建 Dockerfile：</strong> 编写包含应用程序构建步骤的 Dockerfile。</li>
<li><strong>构建镜像：</strong> 在包含 Dockerfile 的目录中运行 <code>docker build</code> 命令构建镜像。（如java项目还需要jar包）</li>
<li><strong>运行容器：</strong> 使用 <code>docker run</code> 命令基于构建的镜像创建和运行容器。</li>
<li><strong>发布镜像：</strong> 将构建的镜像推送到 Docker 仓库，以便其他人可以拉取使用。</li>
</ol>
</li>
</ul>
<h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><ul>
<li>数据卷(volume)是一个虚拟目录，是容器内目录与宿主机目录之间映射的桥梁（两边文件同时修改）。<br>（容器一般只包括支持运行的最少文件，一般无vi或其他编辑器，所以无法进入容器直接对容器中的文件进行修改）</li>
<li>如何挂载数据卷？在创建容器时，利用-v 数据卷名:容器内目录完成挂载。创建时如果发现挂载的数据卷不存在，会自动创建。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker volumels        <span class="comment"># 查看数据卷</span></span><br><span class="line">docker volume <span class="built_in">rm</span>       <span class="comment"># 删除数据卷</span></span><br><span class="line">docker volume inspect  <span class="comment"># 查看数据卷详情</span></span><br><span class="line">docker volume prune    <span class="comment"># 删除未使用的数据卷</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="容器编排-Orchestration-：运维人员"><a href="#容器编排-Orchestration-：运维人员" class="headerlink" title="容器编排(Orchestration)：运维人员"></a>容器编排(Orchestration)：运维人员</h3><p>容器编排是指在生产环境中管理和协调多个容器的过程。Docker 提供了 Docker Compose 工具，用于定义和运行多容器的应用。</p>
<hr>

<h1 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h1><h2 id="1-什么是Kubernetes"><a href="#1-什么是Kubernetes" class="headerlink" title="1. 什么是Kubernetes"></a>1. 什么是<a target="_blank" rel="noopener" href="https://kubernetes.io/">Kubernetes</a></h2><p><a target="_blank" rel="noopener" href="https://kubernetes.io/">Kubernetes</a>是一个开源的容器编排引擎，可以用来管理容器化的应用，包括容器的自动化的部署、扩容、缩容、升级、回滚等等；<br>它是Google在2014年开源的一个项目，它的前身是Google内部的Borg系统。</p>
<p>在<a target="_blank" rel="noopener" href="https://kubernetes.io/">Kubernetes</a>出现之前，我们一般都是使用Docker来管理容器化的应用，但是Docker只是一个单机的容器管理工具，它只能管理单个节点上的容器，当我们的应用程序需要运行在多个节点上的时候，就需要使用一些其他的工具来管理这些节点，比如Docker Swarm、Mesos、<a target="_blank" rel="noopener" href="https://kubernetes.io/">Kubernetes</a>等等；<br>这些工具都是容器编排引擎，它们可以用来管理多个节点上的容器，但是它们之间也有一些区别，比如Docker Swarm是Docker官方提供的一个容器编排引擎，它的功能比较简单，适合于一些小型的、简单的场景，而Mesos和<a target="_blank" rel="noopener" href="https://kubernetes.io/">Kubernetes</a>则是比较复杂的容器编排引擎；<br>Mesos是Apache基金会的一个开源项目，而<a target="_blank" rel="noopener" href="https://kubernetes.io/">Kubernetes</a>是Google在2014年开源的，目前已经成为了CNCF（Cloud Native Computing Foundation）的一个顶级项目，基本上已经成为了容器编排引擎的事实标准了。</p>
<h2 id="2-1-Kubernetes-资源对象"><a href="#2-1-Kubernetes-资源对象" class="headerlink" title="2.1 Kubernetes 资源对象"></a>2.1 Kubernetes 资源对象</h2><img src="https://pic1.zhimg.com/80/v2-ec15257b9a678f4ebe90217363e75d4a_720w.webp" width="450" height="300" alt="">

<p><strong>Node</strong>：k8s集群节点，可以是物理机&#x2F;虚拟机<br><strong>Pod</strong>：k8s最小调度单元，容器(运行app&#x2F;数据库&#x2F;..镜像)的抽象，可以是一&#x2F;多个容器的组合，但除非高度耦合，一个pod只运行一个容器<br><strong>Service</strong>：将一组pod封装成一个服务并且提供统一访问入口（解决了一组数据库pod中一个重建后ip变化的问题，类似于“服务发现”）<br>Ingress：为了对外提供服务，将外部请求路由转发到内部集群的service上</p>
<div style="display: flex; justify-content: space-around;">
  <img src="https://pica.zhimg.com/80/v2-8873f2af01c411f2c5f3ccac77d4c1fe_720w.webp" width="450" height="300" alt="">
  <img src="https://pica.zhimg.com/80/v2-8873f2af01c411f2c5f3ccac77d4c1fe_720w.webp" width="450" height="300" alt="">
</div>

<p>ConfigMap：封装配置信息<br>Secret：封装敏感信息<br>其他安全机制：网络安全，访问控制，身份认证<br>Volumn：将数据挂在到本地磁盘或远程存储上，实现持久化存储</p>
<div style="display: flex; justify-content: space-around;">
  <img src="https://pic2.zhimg.com/80/v2-f094c3d4626cee6e8ce4c3ada729b6dd_720w.webp" width="450" height="300" alt="">
  <img src="https://picx.zhimg.com/80/v2-97c6a4bf8b42a2fa3cf017d0c1392a53_720w.webp" width="450" height="300" alt="">
</div>

<p><strong>Deployment</strong>：部署无状态应用程序，将一&#x2F;多个Pod组合到一起；冗余备份，相当于对Pod的抽象；具有副本控制、滚动更新、自动扩缩容等功能，实现应用程序的高可用<br><strong>Statefulset</strong>：部署有状态应用程序，如DB、MQ、缓存以及保留会话状态的应用程序</p>
<h2 id="2-2-Kubernetes-架构"><a href="#2-2-Kubernetes-架构" class="headerlink" title="2.2 Kubernetes 架构"></a>2.2 Kubernetes 架构</h2><img src="https://pic4.zhimg.com/80/v2-1168bb8f95b88b76ef8678c25f27a007_720w.webp" width="750" height="300" alt="">

<p>分为Master和Worker节点<br>apiserver：位于master节点上，是k8s集群的API接口；交互方式包括 <code>kubectl</code> 命令行、Dashboard界面或API接口</p>
<h2 id="3-使用minikube搭建kubernetes集群环境"><a href="#3-使用minikube搭建kubernetes集群环境" class="headerlink" title="3. 使用minikube搭建kubernetes集群环境"></a>3. 使用<a target="_blank" rel="noopener" href="https://minikube.sigs.k8s.io/">minikube</a>搭建kubernetes集群环境</h2><p><a target="_blank" rel="noopener" href="https://minikube.sigs.k8s.io/">minikube</a>是一个轻量级的kubernetes集群环境，可以用来在本地快速搭建一个单节点的kubernetes集群；<br><a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/tutorials/hello-minikube/">https://kubernetes.io/zh-cn/docs/tutorials/hello-minikube/</a> 你好，Minikube</p>
<h2 id="4-使用Multipass和k3s搭建kubernetes集群环境"><a href="#4-使用Multipass和k3s搭建kubernetes集群环境" class="headerlink" title="4. 使用Multipass和k3s搭建kubernetes集群环境"></a>4. 使用<a target="_blank" rel="noopener" href="https://multipass.run/">Multipass</a>和<a target="_blank" rel="noopener" href="https://k3s.io/">k3s</a>搭建kubernetes集群环境</h2><p><a target="_blank" rel="noopener" href="https://minikube.sigs.k8s.io/">minikube</a>只能用来在本地搭建一个单节点的kubernetes集群环境，<br>下面介绍如何使用<a target="_blank" rel="noopener" href="https://multipass.run/">Multipass</a>和<a target="_blank" rel="noopener" href="https://k3s.io/">k3s</a>来搭建一个多节点的kubernetes集群环境，</p>
<h2 id="5-在线实验环境"><a href="#5-在线实验环境" class="headerlink" title="5. 在线实验环境"></a>5. 在线实验环境</h2><p><a target="_blank" rel="noopener" href="https://killercoda.com/">Killercoda</a> <a target="_blank" rel="noopener" href="https://labs.play-with-k8s.com/">Play-With-K8s</a></p>
<h2 id="6-kubectl常用命令"><a href="#6-kubectl常用命令" class="headerlink" title="6. kubectl常用命令"></a>6. kubectl常用命令</h2><h3 id="6-1-基础使用"><a href="#6-1-基础使用" class="headerlink" title="6.1 基础使用"></a>6.1 基础使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看帮助</span></span><br><span class="line">kubectl --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看API版本</span></span><br><span class="line">kubectl api-versions</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看集群信息</span></span><br><span class="line">kubectl cluster-info</span><br></pre></td></tr></table></figure>

<h3 id="6-2-资源的创建和运行"><a href="#6-2-资源的创建和运行" class="headerlink" title="6.2 资源的创建和运行"></a>6.2 资源的创建和运行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建并运行一个指定的镜像</span></span><br><span class="line">kubectl run NAME --image=image [params...]</span><br><span class="line"><span class="comment"># e.g. 创建并运行一个名字为nginx的Pod</span></span><br><span class="line">kubectl run nginx --image=nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据YAML配置文件或者标准输入创建资源</span></span><br><span class="line">kubectl create RESOURCE</span><br><span class="line"><span class="comment"># e.g.</span></span><br><span class="line"><span class="comment"># 根据nginx.yaml配置文件创建资源</span></span><br><span class="line">kubectl create -f nginx.yaml</span><br><span class="line"><span class="comment"># 根据URL创建资源</span></span><br><span class="line">kubectl create -f https://k8s.io/examples/application/deployment.yaml</span><br><span class="line"><span class="comment"># 根据目录下的所有配置文件创建资源</span></span><br><span class="line">kubectl create -f ./dir</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过文件名或标准输入配置资源</span></span><br><span class="line">kubectl apply -f (-k DIRECTORY | -f FILENAME | stdin)</span><br><span class="line"><span class="comment"># e.g.</span></span><br><span class="line"><span class="comment"># 根据nginx.yaml配置文件创建资源</span></span><br><span class="line">kubectl apply -f nginx.yaml</span><br></pre></td></tr></table></figure>

<h3 id="6-3-查看资源信息"><a href="#6-3-查看资源信息" class="headerlink" title="6.3 查看资源信息"></a>6.3 查看资源信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看集群中某一类型的资源</span></span><br><span class="line">kubectl get RESOURCE</span><br><span class="line"><span class="comment"># 其中，RESOURCE可以是以下类型：</span></span><br><span class="line">kubectl get pods / po         <span class="comment"># 查看Pod</span></span><br><span class="line">kubectl get svc               <span class="comment"># 查看Service</span></span><br><span class="line">kubectl get deploy            <span class="comment"># 查看Deployment</span></span><br><span class="line">kubectl get rs                <span class="comment"># 查看ReplicaSet</span></span><br><span class="line">kubectl get cm                <span class="comment"># 查看ConfigMap</span></span><br><span class="line">kubectl get secret            <span class="comment"># 查看Secret</span></span><br><span class="line">kubectl get ing               <span class="comment"># 查看Ingress</span></span><br><span class="line">kubectl get pv                <span class="comment"># 查看PersistentVolume</span></span><br><span class="line">kubectl get pvc               <span class="comment"># 查看PersistentVolumeClaim</span></span><br><span class="line">kubectl get ns                <span class="comment"># 查看Namespace</span></span><br><span class="line">kubectl get node              <span class="comment"># 查看Node</span></span><br><span class="line">kubectl get all               <span class="comment"># 查看所有资源</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 后面还可以加上 -o wide 参数来查看更多信息</span></span><br><span class="line">kubectl get pods -o wide</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某一类型资源的详细信息</span></span><br><span class="line">kubectl describe RESOURCE NAME</span><br><span class="line"><span class="comment"># e.g. 查看名字为nginx的Pod的详细信息</span></span><br><span class="line">kubectl describe pod nginx</span><br></pre></td></tr></table></figure>

<h3 id="6-4-资源的修改、删除和清理"><a href="#6-4-资源的修改、删除和清理" class="headerlink" title="6.4 资源的修改、删除和清理"></a>6.4 资源的修改、删除和清理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新某个资源的标签</span></span><br><span class="line">kubectl label RESOURCE NAME KEY_1=VALUE_1 ... KEY_N=VALUE_N</span><br><span class="line"><span class="comment"># e.g. 更新名字为nginx的Pod的标签</span></span><br><span class="line">kubectl label pod nginx app=nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除某个资源</span></span><br><span class="line">kubectl delete RESOURCE NAME</span><br><span class="line"><span class="comment"># e.g. 删除名字为nginx的Pod</span></span><br><span class="line">kubectl delete pod nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除某个资源的所有实例</span></span><br><span class="line">kubectl delete RESOURCE --all</span><br><span class="line"><span class="comment"># e.g. 删除所有Pod</span></span><br><span class="line">kubectl delete pod --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据YAML配置文件删除资源</span></span><br><span class="line">kubectl delete -f FILENAME</span><br><span class="line"><span class="comment"># e.g. 根据nginx.yaml配置文件删除资源</span></span><br><span class="line">kubectl delete -f nginx.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置某个资源的副本数</span></span><br><span class="line">kubectl scale --replicas=COUNT RESOURCE NAME</span><br><span class="line"><span class="comment"># e.g. 设置名字为nginx的Deployment的副本数为3</span></span><br><span class="line">kubectl scale --replicas=3 deployment/nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据配置文件或者标准输入替换某个资源</span></span><br><span class="line">kubectl replace -f FILENAME</span><br><span class="line"><span class="comment"># e.g. 根据nginx.yaml配置文件替换名字为nginx的Deployment</span></span><br><span class="line">kubectl replace -f nginx.yaml</span><br></pre></td></tr></table></figure>

<h3 id="6-5-调试和交互"><a href="#6-5-调试和交互" class="headerlink" title="6.5 调试和交互"></a>6.5 调试和交互</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入某个Pod的容器中</span></span><br><span class="line">kubectl <span class="built_in">exec</span> [-it] POD [-c CONTAINER] -- COMMAND [args...]</span><br><span class="line"><span class="comment"># e.g. 进入名字为nginx的Pod的容器中，并执行/bin/bash命令</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it nginx -- /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个Pod的日志</span></span><br><span class="line">kubectl logs [-f] [-p] [-c CONTAINER] POD [-n NAMESPACE]</span><br><span class="line"><span class="comment"># e.g. 查看名字为nginx的Pod的日志</span></span><br><span class="line">kubectl logs nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将某个Pod的端口转发到本地</span></span><br><span class="line">kubectl port-forward POD [LOCAL_PORT:]REMOTE_PORT [...[LOCAL_PORT_N:]REMOTE_PORT_N]</span><br><span class="line"><span class="comment"># e.g. 将名字为nginx的Pod的80端口转发到本地的8080端口</span></span><br><span class="line">kubectl port-forward nginx 8080:80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接到现有的某个Pod（将某个Pod的标准输入输出转发到本地）</span></span><br><span class="line">kubectl attach POD -c CONTAINER</span><br><span class="line"><span class="comment"># e.g. 将名字为nginx的Pod的标准输入输出转发到本地</span></span><br><span class="line">kubectl attach nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行某个Pod的命令</span></span><br><span class="line">kubectl run NAME --image=image -- COMMAND [args...]</span><br><span class="line"><span class="comment"># e.g. 运行名字为nginx的Pod</span></span><br><span class="line">kubectl run nginx --image=nginx -- /bin/bash</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="7-Portainer的安装和使用"><a href="#7-Portainer的安装和使用" class="headerlink" title="7. Portainer的安装和使用"></a>7. Portainer的安装和使用</h2><p><a target="_blank" rel="noopener" href="https://www.portainer.io/">Portainer</a> 是一个轻量级的容器管理工具，可以用来管理Docker和Kubernetes，它提供了一个Web界面来方便我们管理容器<br>官方网址: <a target="_blank" rel="noopener" href="https://www.portainer.io/">https://www.portainer.io/</a></p>
<h2 id="8-Helm的安装和使用"><a href="#8-Helm的安装和使用" class="headerlink" title="8. Helm的安装和使用"></a>8. Helm的安装和使用</h2><p><a target="_blank" rel="noopener" href="https://helm.sh/">Helm</a> 是一个Kubernetes的包管理工具，可以用来管理Kubernetes的应用，它提供了一个命令行工具来方便我们管理Kubernetes的应用<br>官方网址: <a target="_blank" rel="noopener" href="https://helm.sh/">https://helm.sh/</a></p>
<h2 id="集群存储"><a href="#集群存储" class="headerlink" title="集群存储"></a>集群存储</h2><p><a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/">https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/22/Docker_Kubernetes/" data-id="cmiae689s0001l4v5e7i60plq" data-title="Kubernetes" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-InfluxDB" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/22/InfluxDB/" class="article-date">
  <time class="dt-published" datetime="2024-09-22T05:34:33.000Z" itemprop="datePublished">2024-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/22/InfluxDB/">InfluxDB</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <!-- # InfluxDB | DBAdvanced -->

<p><strong>InfluxDB</strong> 是一个由InfluxData开发的开源时序型数据库，专注于海量时序数据的高性能读、高性能写、高效存储与实时分析等；<br>在DB-Engines Ranking时序型数据库排行榜上排名第一，广泛应用于DevOps监控、IoT监控、实时分析等场景。<br><a target="_blank" rel="noopener" href="https://jasper-zhang1.gitbooks.io/influxdb/content/Introduction/getting_start.html">https://jasper-zhang1.gitbooks.io/influxdb/content/Introduction/getting_start.html</a></p>
<p><em><strong>influxdb-cluster</strong></em> 是InfluxDB的集群版本，InfluxDB Enterprise 的开源替代方案，设计用于大规模数据存储和高可用性需求。<br>可以实现数据的分片和复制，从而提高系统的可用性和扩展性。数据安全。operator缺失<br><a target="_blank" rel="noopener" href="https://github.com/chengshiwen/influxdb-cluster/wiki">https://github.com/chengshiwen/influxdb-cluster/wiki</a></p>
<h3 id="集群体系结构"><a href="#集群体系结构" class="headerlink" title="集群体系结构"></a>集群体系结构</h3><p>InfluxDB Enterprise由两组软件进程组成： Data 数据节点 和 Meta 元节点。集群内的通信是这样的：</p>
<div style="display: flex; justify-content: space-around;">
  <img src="https://pic3.zhimg.com/80/v2-6685cdf3df810ad3e5ae44d4e1a9df22_720w.webp" width="450" height="300" alt="">
  <img src="https://pic4.zhimg.com/80/v2-abb99833337f84b3850e0f6484f013ef_720w.webp" width="450" height="300" alt="">
</div>

<p>influxdb使用的默认端口号为分别为用于meta集群内部服务的8091端口，meta节点通信的8089端口，data集群内部服务的8088端口，以及data节点对外提供http服务的8086端</p>
<ul>
<li>Meta 节点通过 TCP 协议和 Raft 共识协议相互通信，默认都使用端口 8089，此端口必须在 Meta 节点之间是可访问的。默认 Meta 节点还将公开绑定到端口 8091 的 HTTP API，influxd-ctl 命令使用该 API。</li>
<li>Data 节点通过绑定到端口 8088 的 TCP 协议相互通信。Data 节点通过绑定到 8091 的 HTTP API 与 Meta 节点通信。这些端口必须在 Meta 节点和 Data 节点之间是可访问的。</li>
<li>在集群内，所有 Meta 节点都必须与所有其它 Meta 节点通信。所有 Data 节点必须与所有其它 Data 节点和所有 Meta 节点通信。</li>
</ul>
<h2 id="Where-data-lives"><a href="#Where-data-lives" class="headerlink" title="Where data lives"></a>Where data lives</h2><p>InfluxDB 集群中，一个节点要么是专门用于存储和查询时间序列数据的数据节点，要么是专门用于存储集群元数据的元节点。数据节点负责存储实际的数据和处理查询请求，而元节点则负责管理集群的元数据，包括节点信息、数据库和保留策略等。</p>
<h3 id="Meta"><a href="#Meta" class="headerlink" title="Meta"></a>Meta</h3><p>元节点保存以下所有元数据：</p>
<ul>
<li>集群中的所有节点及其角色</li>
<li>集群中存在的所有数据库和保留策略</li>
<li>所有分片和分片组，以及它们存在于哪些节点上</li>
<li>集群用户及其权限</li>
<li>所有连续查询</li>
</ul>
<p>元节点将这些数据保存在磁盘上的Raft数据库中，由BoltDB提供支持。默认情况下，Raft数据库是&#x2F;var&#x2F;lib&#x2F;influxdb&#x2F;meta&#x2F;raft.db。<br>注意：Meta节点需要&#x2F; Meta目录。</p>
<ul>
<li><strong><code>influxd-meta</code> 元数据服务</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置文件示例（meta节点）</span></span><br><span class="line">[<span class="string">meta</span>]</span><br><span class="line">  <span class="string">dir</span> <span class="string">=</span> <span class="string">&quot;/var/lib/influxdb/meta&quot;</span>  <span class="comment"># 元数据存储路径 </span></span><br><span class="line">  <span class="string">bind-address</span> <span class="string">=</span> <span class="string">&quot;:8089&quot;</span>          <span class="comment"># Raft协议通信端口</span></span><br><span class="line">  <span class="string">http-bind-address</span> <span class="string">=</span> <span class="string">&quot;:8091&quot;</span>     <span class="comment"># 管理API端口 </span></span><br></pre></td></tr></table></figure></li>
<li><strong><code>influxd-ctl</code> 集群管理</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看分片分布</span></span><br><span class="line">kubectl <span class="built_in">exec</span> influxdb-meta-0 -- influxd-ctl show-shards </span><br><span class="line"><span class="comment"># 强制同步分片到新节点</span></span><br><span class="line">kubectl <span class="built_in">exec</span> influxdb-meta-0 -- influxd-ctl copy-shard 3 influxdb-data-0:8088 </span><br><span class="line"><span class="comment"># 节点维护操作</span></span><br><span class="line">influxd-ctl remove-data influxdb-data-0:8088  <span class="comment"># 下线节点 </span></span><br><span class="line"><span class="comment"># 检查Meta节点Raft状态</span></span><br><span class="line">kubectl <span class="built_in">exec</span> influxdb-meta-0 -- influxd-ctl raft-state </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h3><p>数据节点保存所有原始时间序列数据和元数据，包括：</p>
<ul>
<li>measurements</li>
<li>tag keys and values</li>
<li>field keys and values</li>
</ul>
<p>在磁盘上，数据总是按照<database>&#x2F;<retention_policy>&#x2F;<shard_id>组织。默认父目录为&#x2F;var&#x2F;lib&#x2F;influxdb&#x2F;data。注意：数据节点需要&#x2F;var&#x2F;lib&#x2F;influxdb&#x2F;的所有四个子目录，包括&#x2F;meta(specifically, the clients.json file)、&#x2F;data、&#x2F;wal和&#x2F;hh。</p>
<ul>
<li><strong><code>influx</code> CLI工具</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入容器执行CLI</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it influxdb-data-0 -n influxdb -- influx -username admin -password <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 常用命令</span></span><br><span class="line">SHOW DATABASES;        <span class="comment"># 显示所有数据库 </span></span><br><span class="line">SELECT * FROM cpu;     <span class="comment"># 查询数据</span></span><br><span class="line">CREATE RETENTION POLICY <span class="string">&quot;1d&quot;</span> ON db3 DURATION 1d REPLICATION 2;  <span class="comment"># 创建保留策略 </span></span><br></pre></td></tr></table></figure></li>
<li><strong><code>influxd</code> 数据节点服务</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看运行状态</span></span><br><span class="line">kubectl <span class="built_in">exec</span> influxdb-data-0 -- ps aux | grep influxd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键参数</span></span><br><span class="line">-data-dir /var/lib/influxdb/data   <span class="comment"># 数据存储目录 </span></span><br><span class="line">-wal-dir /var/lib/influxdb/wal     <span class="comment"># WAL日志目录</span></span><br></pre></td></tr></table></figure></li>
<li><strong><code>influx_inspect</code> 数据工具</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导出TSM文件（需进入容器）</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it influxdb-data-0 -- influx_inspect <span class="built_in">export</span> \</span><br><span class="line">  -datadir /var/lib/influxdb/data \</span><br><span class="line">  -waldir /var/lib/influxdb/wal \</span><br><span class="line">  -out backup.gz -compress </span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证数据完整性</span></span><br><span class="line">influx_inspect verify -<span class="built_in">dir</span> /var/lib/influxdb/data/db3 </span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Data-与-Meta节点交互机制"><a href="#Data-与-Meta节点交互机制" class="headerlink" title="Data 与 Meta节点交互机制"></a>Data 与 Meta节点交互机制</h4><ol>
<li><p>通信协议</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>端口</th>
<th>用途</th>
<th>协议</th>
</tr>
</thead>
<tbody><tr>
<td>Meta节点间</td>
<td>8089</td>
<td>Raft协议同步元数据</td>
<td>TCP</td>
</tr>
<tr>
<td>Data节点间</td>
<td>8088</td>
<td>分片数据复制</td>
<td>TCP</td>
</tr>
<tr>
<td>Data→Meta节点</td>
<td>8091</td>
<td>注册节点&#x2F;获取分片元信息</td>
<td>HTTP</td>
</tr>
</tbody></table>
</li>
<li><p>核心交互场景<br><strong>节点注册</strong>  ：   Data节点启动时通过HTTP API向Meta节点注册（<code>POST /data</code>）<br><strong>分片分配</strong>  ：   Meta节点根据<code>replication-factor</code>策略分配分片到Data节点<br><strong>写入协调</strong>  ：   客户端写入数据时，由Meta节点确定目标分片所在Data节点<br><strong>故障转移</strong>  ：   Meta节点检测Data节点离线后，自动通过Hinted Handoff机制转移副本</p>
</li>
</ol>
<p>一个集群至少要有三个独立的元节点才能允许一个节点的丢失，如果要容忍n个节点的丢失则需要2n+1个元节点。集群的元节点的数目应该为奇数。不要是偶数元节点，因为这样在特定的配置下会导致故障。<br>一个集群运行只有一个数据节点，但这样数据就没有冗余了。这里的冗余通过写数据的RP中的副本个数来设置。一个集群在丢失n-1个数据节点后仍然能返回完整的数据，其中n是副本个数。为了在集群内实现最佳数据分配，我们建议数据节点的个数为偶数。</p>
<h3 id="术语-Glossary"><a href="#术语-Glossary" class="headerlink" title="术语 &#x2F; Glossary"></a>术语 &#x2F; Glossary</h3><ul>
<li>measurement：描述了存在关联field中的数据的意义，measurement是字符串。作为tag，fields和time列的容器。相当于MySQL的table，关系&#x2F;表的意思。单个measurement可以有不同的retention policy（即 一个measurement 中的不同 tag set 可以有不同的 retention policy，构成多组 series）</li>
<li>Continuous Query (CQ)是在数据库内部自动周期性跑着的一个InfluxQL的查询，CQs需要在SELECT语句中使用一个函数，并且一定包括一个GROUP BY time()语句。</li>
<li>Retention Policy (RP)是InfluxDB数据结构的一部分，描述了InfluxDB保存数据的长短，数据存在集群里面的副本数，以及shard group的时间范围。RPs在每个database里面是唯一的，？连同measurement和tag set定义一个series。当创建一个database时，InfluxDB会自动创建一个叫做autogen的retention policy，其duration为永远，replication factor为1，shard group的duration设为七天。<ul>
<li>duration：决定InfluxDB中数据保留多长时间。在duration之前的数据会自动从database中删除掉。</li>
<li>replication factor：决定在集群模式下数据的副本的个数。InfluxDB在N个数据节点上复制数据，其中N就是replication factor。</li>
<li>shard group duration决定了每个shard group跨越多少时间。具体间隔由retention policy中的SHARD DURATION决定。例如，如果retention policy的SHARD DURATION设置为1w，则每个shard group将跨越一周，并包含时间戳在该周内的所有点。</li>
</ul>
</li>
<li>series：InfluxDB数据结构的集合，一个特定的series由measurement，tag set和retention policy组成。！field set不是series的一部分</li>
<li>schema：数据在InfluxDB里面怎么组织。InfluxDB的schema的基础是database，retention policy，series，measurement，tag key，tag value以及field keys。</li>
<li>shard：包含实际的编码和压缩数据，并由磁盘上的TSM文件表示。 每个shard都属于唯一的一个shard group。多个shard可能存在于单个shard group中。每个shard包含一组特定的series。给定shard group中的给定series上的所有点将存储在磁盘上的相同shard（TSM文件）中。</li>
<li>shard group：是shard的逻辑组合。shard group由时间和retention policy组织。包含数据的每个retention policy至少包含一个关联的shard group。给定的shard group包含其覆盖的间隔的数据的所有shard。每个shard group跨越的间隔是shard的持续时间。</li>
</ul>
<h2 id="InfluxDB读写"><a href="#InfluxDB读写" class="headerlink" title="InfluxDB读写"></a>InfluxDB读写</h2><ol>
<li>命令行工具<ul>
<li>influx命令行连接本地InfluxDB：直接通过InfluxDB的HTTP接口(如果没有修改，默认是8086)来和InfluxDB通信。（说明：也可以直接发送裸的HTTP请求来操作数据库，例如curl）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ influx -precision rfc3339</span><br><span class="line">Connected to http://localhost:8086 version 1.2.x // </span><br><span class="line">InfluxDB shell 1.2.x</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
InfluxDB的HTTP接口默认起在8086上，所以influx默认也是连的本地的8086端口。-precision参数表明了任何返回的时间戳的格式和精度，如 rfc3339是让InfluxDB返回RFC339格式(YYYY-MM-DDTHH:MM:SS.nnnnnnnnnZ)的时间戳。</li>
<li>数据格式：将数据点写入InfluxDB，只需要遵守如下的行协议：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;measurement&gt;[,&lt;tag-key&gt;=&lt;tag-value&gt;...] &lt;field-key&gt;=&lt;field-value&gt;[,&lt;field2-key&gt;=&lt;field2-value&gt;...] [unix-nano-timestamp]</span><br></pre></td></tr></table></figure>
InfluxDB里存储的数据被称为时间序列数据，其包含一个数值。时序数据有零个或多个数据点，每一个都是一个指标值。数据点包括time(一个时间戳)，measurement(例如cpu_load)，至少一个k-v格式的field(也即指标的数值例如 “value&#x3D;0.64”或者“temperature&#x3D;21.2”)，零个或多个tag，其一般是对于这个指标值的元数据(例如“host&#x3D;server01”, “region&#x3D;EMEA”)。<br>可以将measurement类比于SQL里的table，其主键索引总是时间戳。tag和field是在table里的其他列，tag是被索引起来的，field没有。不同之处在于InfluxDB里，你可以有几百万的measurements，不用事先定义数据的scheme，且null值不会被存储。</li>
<li><strong>使用CLI插入单条的时间序列数据到InfluxDB中，用INSERT后跟数据点：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; use testdb</span><br><span class="line">Using database testdb</span><br><span class="line">&gt; INSERT cpu,host=serverA,region=us_west value=0.64</span><br></pre></td></tr></table></figure>
这样一个measurement为cpu，tag是host和region，value值为0.64的数据点被写入了InfluxDB中。</li>
<li>现在我们查出写入的这笔数据：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT <span class="string">&quot;host&quot;</span>, <span class="string">&quot;region&quot;</span>, <span class="string">&quot;value&quot;</span> FROM <span class="string">&quot;cpu&quot;</span></span><br><span class="line">name: cpu</span><br><span class="line">---------</span><br><span class="line">time                                     host         region   value</span><br><span class="line">2015-10-21T19:28:07.580664347Z  serverA      us_west     0.64</span><br><span class="line"></span><br><span class="line">&gt; delete FROM <span class="string">&quot;cpu&quot;</span> WHERE <span class="string">&quot;host&quot;</span> = <span class="string">&#x27;serverA&#x27;</span> <span class="comment"># 不带where将删除measurement所有数据</span></span><br></pre></td></tr></table></figure>
我们在写入的时候没有包含时间戳，当没有带时间戳的时候，InfluxDB会自动添加本地的当前时间作为它的时间戳。</li>
</ul>
</li>
<li>HTTP 请求<ul>
<li>写数据 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -XPOST <span class="string">&#x27;http://localhost:8086/write?db=mydb&#x27;</span> --data-binary <span class="string">&#x27;cpu_load_short,host=server01,region=us-west value=0.64 1434055562000000000&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>读数据 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -G <span class="string">&#x27;http://localhost:8086/query?pretty=true&#x27;</span> --data-urlencode <span class="string">&quot;db=mydb&quot;</span> --data-urlencode <span class="string">&quot;q=SELECT \&quot;value\&quot; FROM \&quot;cpu_load_short\&quot; WHERE \&quot;region\&quot;=&#x27;us-west&#x27;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>客户端库，InfluxDB 提供了多种编程语言的客户端库，如Python、Go、Java等，可以方便地在应用程序中读写数据。</li>
<li>采样和数据保留 <a target="_blank" rel="noopener" href="https://jasper-zhang1.gitbooks.io/influxdb/content/Guide/downsampling_and_retention.html">https://jasper-zhang1.gitbooks.io/influxdb/content/Guide/downsampling_and_retention.html</a></li>
</ol>
<h2 id="集群读写"><a href="#集群读写" class="headerlink" title="集群读写"></a>集群读写</h2><ul>
<li>分片Shard：<strong>InfluxDB集群读写的基本单位分片是时间序列数据的物理存储单位</strong>，每个分片包含一段时间范围内的数据。<br>复制因子为X，则在每个分片的数据同步到X个节点（部署influxdb的主机）上。<br>分片的划分依据是时间范围和数据的存储策略（Retention Policy）。在集群环境中，分片可以分布在不同的节点上，以实现数据的分布式存储和负载均衡。这样可以提高数据的读写性能和系统的可扩展性。<br>确定数据属于哪个分片的过程主要涉及以下几个步骤：数据写入时，首先根据时间戳确定属于哪个Shard Group（分片组）。然后，基于Measurement和Tag的值计算哈希值。最后，根据哈希值将数据分配到具体的分片。<blockquote>
<p>shard :&#x3D; shardGroup.shards[fnv.New64a(key) % len(shardGroup.Shards)]</p>
</blockquote>
</li>
<li>分片组Shard groups：集群在一个分片组内创建分片，以最大限度地利用数据节点的数量。<br>分片数计算：当集群有 N 个数据节点且副本因子为 X 时，每个分片组中会创建 floor(N&#x2F;X) 个分片（向下取整）<br>示例：若集群有 4 个数据节点，副本因子为 2，则每个分片组包含 4&#x2F;2&#x3D;2 个分片（每个分片在 2 个节点上复制）<!-- 这意味着每天都会为写入的数据创建一个新的shard组。？在每个shard组中创建2个shard。由于复制因子为2，这两个分片中的每一个都在2个服务器上复制。例如，我们有一个2016年09月19日的shard组，它有两个shard 1和2。将Shard 1复制到服务器A和B，将Shard 2复制到服务器C和D。写入值时，集群必须首先确定shard组中的哪个shard应该接收写入，通过对测量+排序标记集（元序列）进行散列并将桶存储到正确的分片中来完成。 --></li>
<li>集群写入：<br>假设一个HTTP写操作被发送到服务器D，数据属于分片1。写操作需要被复制到分片1的所有者：数据节点A和B。当写操作进入D时，该节点从其亚转移的本地缓存中确定需要将写操作复制到A和B，并立即尝试对两者进行写操作。<br>每个对HTTP API的请求都可以通过一致性查询参数指定一致性级别。 <a target="_blank" rel="noopener" href="https://docs.influxdata.com/enterprise_influxdb/v1/concepts/clustering/#write-consistency">https://docs.influxdata.com/enterprise_influxdb/v1/concepts/clustering/#write-consistency</a></li>
<li>集群查询：<br>根据查询的时间段和数据的复制因子进行分布的。例如，如果保留策略的复制因子为4，则接收查询的协调数据节点将随机选择存储该分片副本的4个数据节点中的任何一个来接收查询。如果我们假设系统的分片持续时间为一天，那么对于查询覆盖的每一天，协调节点都会选择一个数据节点来接收当天的查询。<br>协调节点尽可能在本地执行和完成查询。如果一个查询必须扫描多个shard组（在上面的例子中是多个天），协调节点将查询转发给其他节点，以查找本地没有的shard。查询与扫描自己的本地数据并行转发。查询被分发到尽可能多的节点，以查询每个分片组一次。当结果从每个数据节点返回时，协调数据节点将它们组合成返回给用户的最终结果。</li>
<li><strong>Shard Group 与 Shard 的实战示例：</strong><ol>
<li>场景描述，假设有以下配置：<br>Retention Policy:  Duration: 30d  | Replication Factor: 2  | Shard Group Duration: 1d，<br>集群数据节点: 4 个（A&#x2F;B&#x2F;C&#x2F;D）</li>
<li><strong>分片组创建</strong><br>时间划分：每天 00:00 自动创建新的分片组（如 2025-04-02 ~ 2025-04-03）<br>分片数：<code>4/2=2</code> 个分片（Shard 1 &amp; 2）</li>
<li><strong>分片分布</strong><br>分片 1    | 副本节点 A, B          | 存储内容  所有哈希值模2&#x3D;0的 Series Key 数据<br>分片 2    | 副本节点 C, D          | 存储内容  所有哈希值模2&#x3D;1的 Series Key 数据   </li>
<li>数据写入示例<br>当写入 <code>cpu,host=svr1 usage=80</code>：Series Key &#x3D; <code>cpu,host=svr1</code>，哈希值模2&#x3D;1 ⇒ 分片2，数据同时写入节点 C 和 D</li>
<li>数据查询流程<br>查询 <code>SELECT * FROM cpu WHERE time &gt; &#39;2025-04-02&#39;</code>：定位到 2025-04-02 分片组，  协调节点同时向 A&#x2F;B（分片1）和 C&#x2F;D（分片2）发起查询， 合并结果后返回</li>
</ol>
</li>
</ul>
<h2 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h2><p>Docker安装操作单例InfluxDB <a target="_blank" rel="noopener" href="https://www.cnblogs.com/nhdlb/p/16409849.html">https://www.cnblogs.com/nhdlb/p/16409849.html</a><br>Docker快速开始集群InfluxDB <a target="_blank" rel="noopener" href="https://github.com/chengshiwen/influxdb-cluster/wiki#docker-%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B">https://github.com/chengshiwen/influxdb-cluster/wiki#docker-%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B</a></p>
<p>在使用容器多节点部署InfluxDB时，数据库、容器、Docker、主机和Kubernetes（k8s）之间的关系可以理解如下：</p>
<ul>
<li>数据库（InfluxDB）：InfluxDB是一个时序数据库，用于存储和查询时间序列数据。在多节点部署中，InfluxDB可以运行在多个容器中，以实现高可用性和负载均衡。</li>
<li>容器：容器是一个轻量级、独立的运行环境，用于打包和运行应用程序及其依赖项。InfluxDB可以被打包成一个容器镜像，并在多个容器实例中运行。</li>
<li>Docker：Docker是一个容器化平台，用于创建、部署和管理容器。Docker负责启动和管理运行InfluxDB的容器。</li>
<li>主机：主机是运行Docker和容器的物理或虚拟机器。在多节点部署中，可能有多个主机，每个主机上运行一个或多个InfluxDB容器。</li>
<li>Kubernetes（k8s）：一个开源的容器编排平台，用于自动化部署、扩展和管理容器化应用程序。Kubernetes可以管理多个主机上的容器，提供服务发现、负载均衡、自动扩展和自愈能力。在多节点部署中，Kubernetes可以管理InfluxDB容器的部署，确保它们在多个节点上运行，并提供高可用性和扩展性。</li>
<li>关系总结：InfluxDB 作为数据库运行在 容器 中。容器 由 Docker 创建和管理。Docker 运行在 主机 上。Kubernetes 管理多个 主机 上的 Docker 容器，提供编排和管理功能。通过这种方式，InfluxDB可以在一个分布式环境中高效运行，利用Kubernetes的编排能力实现自动化管理和扩展。</li>
</ul>
<p>Kubernetes 存储与 InfluxDB Shard 的关系解析</p>
<ol>
<li><strong>PV&#x2F;PVC</strong>：是 Kubernetes 管理存储资源的抽象层。PV 描述物理存储资源（如 NFS、云盘等），PVC 是 Pod 对存储资源的请求声明。PVC 绑定到 PV 后，Pod 通过挂载 PVC 使用持久化存储。</li>
<li><strong>Shard</strong>：是 InfluxDB 存储引擎的物理存储单元，表现为磁盘上的 TSM 文件（Time-Structured Merge Tree），每个 Shard 对应一个时间范围内的时序数据块。Shard 的存储路径通常位于 PVC 挂载的 <code>/var/lib/influxdb/data</code> 目录下。<br>每个 Shard 包含：时间序列索引（.tsi 文件），压缩后的时序数据块（.tsm 文件），WAL（Write-Ahead Log）日志文件（.wal） 其路径结构为：<code>/var/lib/influxdb/data/&lt;database&gt;/&lt;retention_policy&gt;/&lt;shard_id&gt;</code>。</li>
<li>重建 PVC 导致数据丢失的本质问题<br>• <strong>PVC 删除与 PV 回收策略</strong>：若 PVC 的回收策略为 <code>Delete</code>（默认），删除 PVC 会导致 Kubernetes 清理其绑定的 PV 及底层存储数据（如 NFS 目录、云盘等）。此时 <code>/var/lib/influxdb</code> 下的 <code>data</code>、<code>meta</code> 目录被清空，导致 Shard 文件丢失。<br>• Shard 文件丢失会导致对应时间范围的时序数据不可查询，触发 <code>ERR: shard not found</code> 错误。<br>• Meta 文件丢失会破坏集群元数据一致性，导致用户权限、分片策略等配置失效。</li>
</ol>
<h2 id="InfluxDB-备份与恢复"><a href="#InfluxDB-备份与恢复" class="headerlink" title="InfluxDB 备份与恢复"></a>InfluxDB 备份与恢复</h2><p><a target="_blank" rel="noopener" href="https://docs.influxdata.com/enterprise_influxdb/v1/administration/backup-and-restore/">https://docs.influxdata.com/enterprise_influxdb/v1/administration/backup-and-restore/</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46560589/article/details/127748939">https://blog.csdn.net/weixin_46560589/article/details/127748939</a></p>
<p>InfluxDB Enterprise支持在集群实例、单个数据库和保留策略以及单个分片中备份和恢复数据。</p>
<ol>
<li>备份整个实例，即所有数据库（全量备份）。命令如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">influxd backup -portable /path/to/backup</span><br></pre></td></tr></table></figure></li>
<li>备份单个数据库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">influxd backup -portable -database &lt;database_name&gt; /path/to/backup</span><br></pre></td></tr></table></figure></li>
<li>增量备份：对于较大的数据集，可以进行增量备份，只备份自上次全量或增量备份以来的数据<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">influxd backup -portable -start &lt;timestamp&gt; /path/to/backup</span><br></pre></td></tr></table></figure></li>
</ol>
<p>备份的数据可以恢复到新实例或现有实例中。</p>
<ol>
<li>恢复整个实例，包括所有的数据库。命令如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">influxd restore -portable /path/to/backup</span><br></pre></td></tr></table></figure></li>
<li>恢复单个数据库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">influxd restore -portable -db &lt;database_name&gt; /path/to/backup</span><br></pre></td></tr></table></figure></li>
<li>有时你可能希望将备份的数据恢复到另一个数据库，可以使用 <code>-newdb</code> 选项来实现：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">influxd restore -portable -db &lt;old_database_name&gt; -newdb &lt;new_database_name&gt; /path/to/backup</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="导出和导入数据"><a href="#导出和导入数据" class="headerlink" title="导出和导入数据"></a>导出和导入数据</h2><p>对于大多数InfluxDB Enterprise应用程序，备份和恢复实用程序提供了备份和恢复策略所需的工具。但是，在某些情况下，标准备份和恢复实用程序可能无法充分处理应用程序中的大量数据。作为标准备份和恢复实用程序的替代方案，可以使用InfluxDB influx_inspect export和涌入-import命令为灾难恢复和备份策略创建备份和恢复过程。</p>
<ol>
<li>数据库导出：容器层面命令，指定 数据文件和 写前日志(WAL)文件的存储目录，将指定数据库中指定时间的数据导出到指定文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@influxdb-e2cb6c913a191e56c134e-data-0:/<span class="comment"># influx_inspect export -datadir &quot;/var/lib/influxdb/data&quot; -waldir &quot;/var/lib/influxdb/wal&quot; -out &quot;influxdb_test01_dump_out&quot; -database &quot;test01&quot; -start &quot;2024-10-22T00:00:00Z&quot;</span></span><br><span class="line">writing out tsm file data <span class="keyword">for</span> test01/autogen...complete.</span><br><span class="line">writing out wal file data <span class="keyword">for</span> test01/autogen...complete.</span><br><span class="line">root@influxdb-e2cb6c913a191e56c134e-data-0:/<span class="comment"># cat influxdb_test01_dump_out</span></span><br><span class="line"><span class="comment"># INFLUXDB EXPORT: 2024-10-22T00:00:00Z - 2262-04-11T23:47:16Z</span></span><br><span class="line"><span class="comment"># DDL</span></span><br><span class="line">CREATE DATABASE test01 WITH NAME autogen</span><br><span class="line"><span class="comment"># DML</span></span><br><span class="line"><span class="comment"># CONTEXT-DATABASE:test01</span></span><br><span class="line"><span class="comment"># CONTEXT-RETENTION-POLICY:autogen</span></span><br><span class="line"><span class="comment"># writing tsm data</span></span><br><span class="line">temp,location=room1 value=24.5 1729589246099070937</span><br><span class="line">temp,location=room2 value=22.5 1729589253425715740</span><br><span class="line">temp,location=room3 value=22 1729649010554978701</span><br><span class="line"><span class="comment"># writing wal data</span></span><br></pre></td></tr></table></figure></li>
<li>数据库导入：容器层面执行命令，使用admin账号，指定文件、数据库、时间戳精度<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@influxdb-e73f149ff7192bd87d190-data-1:/<span class="comment"># influx -import -path=&#x27;influxdb_test01_dump_out&#x27; -precision=ns -username=&#x27;&#x27; -password=&#x27;&#x27;</span></span><br><span class="line">2024/10/25 03:21:47 Processed 1 commands</span><br><span class="line">2024/10/25 03:21:47 Processed 2 inserts</span><br><span class="line">2024/10/25 03:21:47 Failed 0 inserts</span><br></pre></td></tr></table></figure></li>
<li>实例导出：把influxdb集群实例中所有数据库的数据导出，不加 <code>-database</code>，加 <code>-compress</code></li>
<li>实例导入：加<code>-compressed</code> 导入压缩文件，本质上是先解压后倒入</li>
</ol>
<h2 id="InfluxDB节点迁移"><a href="#InfluxDB节点迁移" class="headerlink" title="InfluxDB节点迁移"></a>InfluxDB节点迁移</h2><p>Data节点迁移方案评审：先迁移后逐个恢复分片数据。已验证在分片副本大小70M、写入数据达2000point&#x2F;s的情况下直接copy-shard会导致增量数据丢失，考虑在copy-shard前先执行truncate-shards截断热分片（集群中所有写入最新数据的分片，截断后关闭写入，变成冷分片），并在所有Data节点上创建该分片的新热分片副本，也就是在迁移节点上恢复了全部原有分片的新热分片副本，最新数据写入这个副本，然后再逐个从健康节点上的冷分片副本copy-shard恢复出分片的历史数据（迁移前分片副本原有的数据&amp;迁移过程中未能写入的数据），该分片数据完全恢复；自测符合预期</p>
<ol>
<li>在做迁移操作前，先记录迁移节点拥有的分片副本，后续从健康节点的相同副本中恢复出来；<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -i influxdb-xx-meta-0 -n influxdb -- influxd-ctl show-shards <span class="comment"># 或influx命令行执行show shards</span></span><br></pre></td></tr></table></figure></li>
<li>迁移后更新节点&#x2F;分片元信息，新data-0节点丢失db1的shard3，另外_internal的db1转移到健康节点data-1上了<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -i influxdb-xx-meta-0 -n influxdb -- influxd-ctl remove-data influxdb-xx-data-0.influxdb-xx-data:8088</span><br><span class="line">kubectl <span class="built_in">exec</span> -i influxdb-xx-meta-0 -n influxdb -- influxd-ctl add-data influxdb-xx-data-0.influxdb-xx-data:8088</span><br></pre></td></tr></table></figure></li>
<li>持续写入数据到db1(只能写入健康节点上的db1分片副本)，某一时刻执行truncate-shards，db1的shard3切断，新热分片shard4的分片副本分配到data-1以及迁移后的data-0中，此刻开始写入db1的新数据在data-0和data-1上的分片中一致（一个数据库的分片可能有多个，但只有一个正在写入，其他都是冷分片）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -i influxdb-xx-meta-0 -n influxdb -- influxd-ctl truncate-shards</span><br></pre></td></tr></table></figure></li>
<li>最后再恢复历史数据，也就是执行迁移前的data-0节点拥有的分片副本数据，以及迁移完成前应该写入但没有写入data-0的数据。从健康的data-1上的分片副本copy-shard而来，导出文件可见data-0和data-1上的db1数据完全一致<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于_internal分片的转移 先copy后remove</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -i influxdb-xx-meta-0 -n influxdb -- influxd-ctl copy-shard influxdb-xx-data-1.influxdb-xx-data:8088 influxdb-xx-data-0.influxdb-xx-data:8088 1</span><br><span class="line">kubectl <span class="built_in">exec</span> -i influxdb-xx-meta-0 -n influxdb -- influxd-ctl remove-shard influxdb-xx-data-1.influxdb-xx-data:8088 1</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分片的物理文件 wal&amp;tsm</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -i influxdb-xx-data-0 -n influxdb -- <span class="built_in">ls</span> /var/lib/influxdb/data</span><br><span class="line">kubectl <span class="built_in">exec</span> -i influxdb-xx-data-0 -n influxdb -- <span class="built_in">ls</span> /var/lib/influxdb/wal</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可能要等wal落tsm</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -i influxdb-xx-data-0 -n influxdb -- influx_inspect <span class="built_in">export</span> -datadir <span class="string">&quot;/var/lib/influxdb/data&quot;</span> -waldir <span class="string">&quot;/var/lib/influxdb/wal&quot;</span> -out <span class="string">&quot;influxdb_dump_out&quot;</span> -database <span class="string">&quot;db1&quot;</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -i influxdb-xx-data-0 -n influxdb -- <span class="built_in">md5sum</span> influxdb_dump_out</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/22/InfluxDB/" data-id="cmiae689v0005l4v5e4s5057x" data-title="InfluxDB" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Golang" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/22/Golang/" class="article-date">
  <time class="dt-published" datetime="2024-09-22T05:17:33.000Z" itemprop="datePublished">2024-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/22/Golang/">Golang</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <br>
<div style="display: flex; align-items: center;">
  <div style="flex: 0 0 30%;">
    <img src="https://www.runoob.com/wp-content/uploads/2015/06/go128.png" alt="" style="max-width: 100%;">
  </div>
  <div style="flex: 1; padding-left: 10px;">
    <p><em>Go 是一个开源的编程语言，它能让构造简单、可靠且高效的软件变得容易。<br>Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。 对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。</em></p>
  </div>
</div>


<p>除了OOP外，近年出现了一些小众的编程哲学，Go语言对这些思想亦有所吸收。例如，Go语言接受了函数式编程的一些想法，支持匿名函数与闭包。再如，Go语言接受了以Erlang语言为代表的面向消息编程思想，支持goroutine和通道，并推荐使用消息而不是共享内存来进行并发编程。总体来说，Go语言是一个非常现代化的语言，精小但非常强大。</p>
<h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><ul>
<li>Go 语言最主要的特性<br>自动垃圾回收 更丰富的内置类型 函数多返回值 错误处理 匿名函数和闭包 类型和接口 并发编程 反射 语言交互性<br><a target="_blank" rel="noopener" href="https://www.runoob.com/go/go-tutorial.html">https://www.runoob.com/go/go-tutorial.html</a></li>
<li>Go 和 Java 有很多共同之处<br>C 系列 (强类型，括号) 静态类型 垃圾收集 内存安全 (nil 引用，运行时边界检查) 变量总是初始化 (zero&#x2F;nil&#x2F;false)<br>方法 接口 类型断言 (实例) 反射</li>
<li>Go 与 Java 的不同之处<br>代码程序直接编译成机器码，没有 VM<br>静态链接二进制 内存布局控制 函数值和词法闭包 内置字符串 (UTF-8) 内置泛型映射和数组&#x2F;片段 内置并发 </li>
<li>Go 特意去掉了大量的特性<br>没有类 没有构造器 没有继承 没有 final 没有异常 没有注解 没有自定义泛型</li>
<li>为 Java 程序员准备的 Go 语言入门 PPT <a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/go-for-java-programmers.html">https://www.runoob.com/w3cnote/go-for-java-programmers.html</a></li>
</ul>
<h3 id="Go-项目构建"><a href="#Go-项目构建" class="headerlink" title="Go 项目构建"></a>Go 项目构建</h3><ul>
<li>Module：是 Go 语言用于管理项目依赖和版本的一种机制。go.mod 文件定义了模块的元数据和依赖关系。<br><code>go.mod</code> 文件是声明依赖的地方，记录了项目的依赖关系。如果项目中没有 go.mod，需要先运行 <code>go mod init</code> 来初始化模块。然后使用 <code>go get</code>（或其他命令）来引入依赖，下载到本地缓存（<code>~/go/pkg/mod</code>），并更新 go.mod，添加对应的模块路径和版本要求。</li>
<li>Makefile：是一个用于自动化构建、测试和其他任务的工具。它允许你定义复杂的构建流程和依赖关系。<br>Makefile 可以包含多个targets，例如 build、test、clean 等。make 命令会查找当前目录下的 Makefile 并执行指定的目标。<br>构建过程本身不负责引入依赖，它假定所有必要的依赖已经通过 <code>go.mod</code> 文件声明并被解析（否则报错），将编译代码并链接所有必要的依赖来生成最终的可执行文件或库文件。如果 go.mod 中声明的依赖尚未下载，Go 工具链会自动为你下载这些依赖。如果你的项目中没有 go.mod，go build 将无法正确识别和下载依赖（除非是 Go 1.11 前的版本）</li>
<li>项目构建…<ul>
<li>对于一个带有 <code>go.mod</code> 文件的 Go 项目，项目所需的依赖<strong>不会</strong>自动下载到本地环境中。需要手动运行 <code>go mod download</code> 或 <code>go mod tidy</code> 来下载依赖，或者直接运行 <code>go build</code> 以触发依赖的下载。</li>
<li>如果本地已有的依赖版本与 <code>go.mod</code> 文件中声明的版本不同，Go 工具链会优先使用 <code>go.mod</code> 文件中指定的版本。Go 会从远程仓库下载与 <code>go.mod</code> 兼容的依赖版本，并将其存储在本地缓存目录（通常是 <code>~/go/pkg/mod</code>）中。</li>
<li>Go 项目使用的依赖是项目特定的，存储在项目的本地缓存中，而不是全局的 GOPATH 或者 GOROOT 目录。这意味着不同的项目可以依赖同一库的不同版本，而不会发生冲突。其实际工作目录<code>go env</code>中的配置（看上去是如果配置全局 PATH&#x3D;%GOPATH%\bin 就使用 GOPATH 中的go.exe和pkg）</li>
<li>对于复杂的构建流程和依赖关系，有时还需要根据 <code>Makefile</code> 文件，执行 build来构建项目。</li>
</ul>
</li>
<li><strong>VSCode</strong> 连接 WSL的Linux环境 开发 Go 项目（先用ubuntu开发，后再centos验证）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">D:\Users\caifeng7&gt;wsl -l -v</span><br><span class="line">  NAME                   STATE           VERSION</span><br><span class="line">* Ubuntu                 Running         2</span><br><span class="line">  CentOS7                Running         2</span><br><span class="line"></span><br><span class="line">D:\Users\caifeng7&gt;wsl  <span class="comment"># 管理员cmd进入wsl的默认linux发行版</span></span><br><span class="line">root@caifeng7138:/mnt/d/Users/caifeng7<span class="comment"># </span></span><br></pre></td></tr></table></figure>
安装go到linux，配置ubuntu上的golang开发环境（centos使用yum管理包）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install golang-go</span><br></pre></td></tr></table></figure>
将GOPATH&#x2F;bin添加到的PATH环境变量中<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$PATH:/root/go/bin&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">root@caifeng7138:/mnt/c/Windows/system32<span class="comment"># go env</span></span><br><span class="line">GO111MODULE=<span class="string">&#x27;&#x27;</span></span><br><span class="line">GOARCH=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">GOBIN=<span class="string">&#x27;&#x27;</span>  <span class="comment"># 编译后的二进制文件的存放位置</span></span><br><span class="line">GOCACHE=<span class="string">&#x27;/root/.cache/go-build&#x27;</span>  <span class="comment"># Go编译缓存的路径</span></span><br><span class="line">GOENV=<span class="string">&#x27;/root/.config/go/env&#x27;</span></span><br><span class="line">GOEXE=<span class="string">&#x27;&#x27;</span></span><br><span class="line">GOEXPERIMENT=<span class="string">&#x27;&#x27;</span></span><br><span class="line">GOFLAGS=<span class="string">&#x27;&#x27;</span></span><br><span class="line">GOHOSTARCH=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">GOHOSTOS=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line">GOINSECURE=<span class="string">&#x27;&#x27;</span></span><br><span class="line">GOMODCACHE=<span class="string">&#x27;/root/go/pkg/mod&#x27;</span></span><br><span class="line">GONOPROXY=<span class="string">&#x27;&#x27;</span></span><br><span class="line">GONOSUMDB=<span class="string">&#x27;&#x27;</span></span><br><span class="line">GOOS=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line">GOPATH=<span class="string">&#x27;/root/go&#x27;</span>  <span class="comment"># Go工作空间的根目录，用于存放你的Go项目和依赖。</span></span><br><span class="line">GOPRIVATE=<span class="string">&#x27;&#x27;</span></span><br><span class="line">GOPROXY=<span class="string">&#x27;https://proxy.golang.org,direct&#x27;</span>  <span class="comment"># 修改代理 export GOPROXY=https://goproxy.cn,direct</span></span><br><span class="line">GOROOT=<span class="string">&#x27;/usr/lib/go-1.22&#x27;</span>  <span class="comment"># Go语言的安装目录，包含了Go的编译器、标准库和工具。</span></span><br><span class="line">GOSUMDB=<span class="string">&#x27;sum.golang.org&#x27;</span></span><br><span class="line">GOTMPDIR=<span class="string">&#x27;&#x27;</span></span><br><span class="line">GOTOOLCHAIN=<span class="string">&#x27;auto&#x27;</span></span><br><span class="line">GOTOOLDIR=<span class="string">&#x27;/usr/lib/go-1.22/pkg/tool/linux_amd64&#x27;</span></span><br><span class="line">GOVCS=<span class="string">&#x27;&#x27;</span></span><br><span class="line">GOVERSION=<span class="string">&#x27;go1.22.2&#x27;</span></span><br><span class="line">GCCGO=<span class="string">&#x27;gccgo&#x27;</span></span><br><span class="line">GOAMD64=<span class="string">&#x27;v1&#x27;</span></span><br><span class="line">AR=<span class="string">&#x27;ar&#x27;</span></span><br><span class="line">CC=<span class="string">&#x27;gcc&#x27;</span></span><br><span class="line">CXX=<span class="string">&#x27;g++&#x27;</span></span><br><span class="line">CGO_ENABLED=<span class="string">&#x27;1&#x27;</span></span><br><span class="line">GOMOD=<span class="string">&#x27;/dev/null&#x27;</span></span><br><span class="line">GOWORK=<span class="string">&#x27;&#x27;</span></span><br><span class="line">CGO_CFLAGS=<span class="string">&#x27;-O2 -g&#x27;</span></span><br><span class="line">CGO_CPPFLAGS=<span class="string">&#x27;&#x27;</span></span><br><span class="line">CGO_CXXFLAGS=<span class="string">&#x27;-O2 -g&#x27;</span></span><br><span class="line">CGO_FFLAGS=<span class="string">&#x27;-O2 -g&#x27;</span></span><br><span class="line">CGO_LDFLAGS=<span class="string">&#x27;-O2 -g&#x27;</span></span><br><span class="line">PKG_CONFIG=<span class="string">&#x27;pkg-config&#x27;</span></span><br><span class="line">GOGCCFLAGS=<span class="string">&#x27;-fPIC -m64 -pthread -Wl,--no-gc-sections -fmessage-length=0 -ffil...&#x27;</span></span><br></pre></td></tr></table></figure>
VSCode使用WSL：Remote Explorer选择linux发行版，使用Ubuntu环境打开Go项目目录： <code>/mnt/d/code/datamars-agent/</code><br>此时自动下载了项目go.mod要求的go版本? 项目中的环境变量发生变化 ↓<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@caifeng7138:/mnt/d/code/datamars-agent<span class="comment"># go env</span></span><br><span class="line"><span class="comment"># 个人用户的Go工作空间。用于存放Go项目和依赖</span></span><br><span class="line">GOPATH=<span class="string">&#x27;/root/go&#x27;</span>  </span><br><span class="line"><span class="comment"># Go的安装目录，指向通过模块系统安装的一个特定版本（1.22.4），而不是 /usr/lib/go(全局路径)</span></span><br><span class="line">GOROOT=<span class="string">&#x27;/root/go/pkg/mod/golang.org/toolchain@v0.0.1-go1.22.4.linux-amd64&#x27;</span></span><br><span class="line"><span class="comment"># Go工具链的安装目录</span></span><br><span class="line">GOTOOLDIR=<span class="string">&#x27;/root/go/pkg/mod/golang.org/toolchain@v0.0.1-go1.22.4.linux-amd64/pkg/tool/linux_amd64&#x27;</span>  </span><br><span class="line">GOVERSION=<span class="string">&#x27;go1.22.4&#x27;</span></span><br><span class="line"><span class="comment"># Go模块缓存的路径</span></span><br><span class="line">GOMOD=<span class="string">&#x27;/mnt/d/code/datamars-agent/go.mod&#x27;</span>  </span><br></pre></td></tr></table></figure>
在WSL中，安装protoc，添加到PATH；<br>执行make，通过makefile中的配置构建项目，编译proto文件，生成Go，grpc程序<br><strong>Protobuf</strong> 是一种由 Google 开发的用于序列化结构化数据的语言中立、平台中立的可扩展机制，Protoc 可以将 定义了数据结构和序列化规则的 .proto 文件编译生成包括 Go，Java的多种语言。用于grpc请求的数据同步。。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/22/Golang/" data-id="cmiae689p0000l4v511x68co6" data-title="Golang" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-理财" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/18/%E7%90%86%E8%B4%A2/" class="article-date">
  <time class="dt-published" datetime="2024-08-18T08:55:11.000Z" itemprop="datePublished">2024-08-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/18/%E7%90%86%E8%B4%A2/">Lic Ai</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="保-险"><a href="#保-险" class="headerlink" title="保 险"></a>保 险</h1><h2 id="社会保障"><a href="#社会保障" class="headerlink" title="社会保障"></a>社会保障</h2><p>通过对国民收入的再分配，使公民在遇到特定风险或困难时能够获得基本生活保障。本质是追求一种公平。</p>
<h2 id="社会保险"><a href="#社会保险" class="headerlink" title="社会保险"></a><strong>社会保险</strong></h2><ol>
<li><strong>养老保险</strong>：为了保障老年人退休后的基本生活，通过个人和单位的缴费，在退休后按月领取养老金。个人在达到法定退休年龄时，如果满足缴费年限等条件，就可以领取养老金。</li>
<li><strong>医疗保险</strong>：旨在为参保人员提供医疗费用的报销或补偿，以减轻医疗费用的负担。参保人员在生病住院或接受治疗时，可以通过医保报销一部分或全部的医疗费用。</li>
<li>失业保险：为因非个人原因失去工作的参保人员提供一定时间内的生活保障金，帮助他们在失业期间维持基本生活。</li>
<li>工伤保险：用于保障因工作原因遭受意外伤害或职业病的劳动者，提供医疗费用和伤残补助，甚至提供生活保障金等。</li>
<li>生育保险：主要为参保女性在生育期间提供一定的经济补助和医疗费用报销。</li>
</ol>
<h3 id="社保卡"><a href="#社保卡" class="headerlink" title="社保卡"></a>社保卡</h3><p>佛山社保卡如何申领？“一人一卡”清理又是个啥？ <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/9uQ5qGOYv35BGRgs4OvzvA">https://mp.weixin.qq.com/s/9uQ5qGOYv35BGRgs4OvzvA</a><br>没领佛山社保卡可以使用医保报销吗？可以，微信支付时会显示报销数额。<br>如何使用医保余额？办理实体医保卡，可以查到余额。</p>
<h3 id="医保"><a href="#医保" class="headerlink" title="医保"></a>医保</h3><ul>
<li>医疗保险是一种社会保障制度。通常由个人和单位共同缴纳，参保人员在医疗机构就诊时可以通过医保报销部分或全部的医疗费用。<br>通过医保报销的费用是由医保基金支付的，而这个基金是由全体参保人员（包括你和你的单位）共同缴纳的资金组成的。<strong>个人缴纳的那部分医保费用只是整个基金的一部分，而报销的金额往往远超过个人单独缴纳的部分，这正是医保体系的优势所在</strong>。</li>
<li><em>佛山医疗保险享受指引</em><ol>
<li>门诊选点：公众号-粤医保</li>
<li>异地就医备案<br>  办理条件：异地安置退休人员、异地长期居住人员、常驻异地工作人员、临时外出就医人员<br>  办理途径：公众号-粤医保-线上办理-异地就医备案</li>
<li>医保报销方式<br>  定点联网机构住院(?)费用：凭社保卡&#x2F;医保电子凭证&#x2F;身份证现场结算；未能即使结算的，先挂账后结算；无法补记账结算的，垫付费用后申请零星保险。（医保里的钱可以用吗？怎么用？<br>  零星报销：提供资料到参保所属医保经办机构办理<br>  <a target="_blank" rel="noopener" href="https://ihr.midea.com/selfhelp/ihr/selfhelp/pdf?businessId=8a928ead90719d3201907b3b580d00b7&mc_widget_identifier=com.midea.msd.ihrcommonmx&scene=selfhelp_sdc&page=showPdf&type=1">https://ihr.midea.com/selfhelp/ihr/selfhelp/pdf?businessId=8a928ead90719d3201907b3b580d00b7&amp;mc_widget_identifier=com.midea.msd.ihrcommonmx&amp;scene=selfhelp_sdc&amp;page=showPdf&amp;type=1</a></li>
</ol>
</li>
</ul>
<h3 id="住房公积金"><a href="#住房公积金" class="headerlink" title="住房公积金"></a>住房公积金</h3><ul>
<li>住房公积金是一种社会福利制度，而不是严格意义上的社会保障。住房公积金是国家为帮助职工解决住房问题而设立的一项长期住房储金。它由职工个人和单位共同缴纳，归职工个人所有，并在一定条件下用于购房、建房、房屋维修或者租房等住房相关支出。</li>
<li>职工可以在以下情况下提取住房公积金：购买、建造、翻建、大修自住住房。偿还住房贷款本息（利率低）。支付房租。离职或退休后可以提取全部住房公积金。</li>
<li>住房公积金可以断缴。如果有购房计划或其他需要公积金支持的需求，最好避免长时间断缴。<ul>
<li>可以断缴：如果你换工作、辞职、或者暂时没有固定工作，住房公积金可以暂时断缴。没有法律强制要求必须连续缴纳。一旦找到新工作或稳定下来，你可以恢复缴纳住房公积金。新单位会重新为你开设账户或继续使用之前的账户。</li>
<li>断缴的影响<br>  <strong>贷款购房影响</strong>：<strong>影响贷款资格</strong>，在申请住房公积金贷款时，很多地方要求申请人在最近的6个月或12个月内连续缴纳公积金。如果公积金断缴，可能会影响你申请住房公积金贷款的资格。<strong>贷款额度影响</strong>，公积金贷款额度通常与公积金的缴纳时间和余额挂钩。如果断缴时间较长，贷款额度可能会受到影响。<br>  <strong>影响提取条件</strong>：如果计划通过提取公积金支付房租或购房时，断缴可能会影响提取公积金的条件，因为很多地方要求提取前必须有一定的连续缴纳记录。</li>
<li>如何减少断缴的影响：1、补缴：在新单位入职后，你可以尝试与单位协商，进行断缴期间的补缴。以恢复在断缴期间的公积金记录。2、灵活就业人员公积金：有些城市允许灵活就业人员或个体工商户自行缴纳公积金，以避免断缴。</li>
</ul>
</li>
<li>住房公积金在中国是可以随着工作地点的变更而进行转移的。通常的步骤是：在新城市的新工作单位会为你开设一个新的住房公积金账户。向新单位的公积金管理中心申请将旧账户的公积金余额转入新账户。新单位所在的公积金管理中心会联系原城市的公积金管理中心，办理资金转移。公积金转移通常需要一定时间，一旦转移完成，你的住房公积金余额将会合并到新城市的账户中。</li>
<li><em>佛山公积金提取</em>：wx公众号办理租房提取业务，选择按年&#x2F;月提取，隔日到账。</li>
</ul>
<h2 id="个人所得税"><a href="#个人所得税" class="headerlink" title="个人所得税"></a>个人所得税</h2><h4 id="工资条计算步骤"><a href="#工资条计算步骤" class="headerlink" title="工资条计算步骤"></a>工资条计算步骤</h4><ol>
<li><strong>应发合计 &#x3D; 基本工资 + 考评绩效 + 其他发放 + 福利</strong><br>2月说明：12330&#x3D;3555+8445+0+330(餐补)</li>
<li><strong>实发工资 &#x3D; 应发合计 - 代扣代缴</strong><br>代扣代缴项：包括五险一金（专项扣除）、本月预扣个人所得税。<br>2月说明：：9612.2&#x3D;12330-2717.8</li>
<li><strong>累计预扣预缴应纳税所得额 &#x3D; 累计收入 - 累计减除费用 - 累计专项扣除 - 累计专项附加扣除</strong><br>累计减除费用：每月5,000元起征点，年度累计为60,000元（如工作满12个月）。<br>专项附加扣除：包括子女教育（每月2,000元&#x2F;孩）、房贷利息（每月1,000元）、赡养老人（每月2,000元）等，需在个税APP填报。<br>2月说明：11101.74&#x3D;35710(2024.12起重新计算?) - 15000 - 6308.26(累计个人缴纳社保&amp;公积金) - 3300， 公式逻辑：逐月累计收入及扣除项，动态计算全年税基。</li>
<li><strong>扣税 &#x3D; 累计预扣预缴应纳税所得额 × 税率 - 速算扣除数 - 累计已预扣预缴税额</strong><br>税率表：采用七级超额累进税率（3%-45%），按月累计收入匹配税率档位。若某月税额突增，可能是累计收入进入更高税率区间，属正常现象。<br>示例：若累计应纳税所得额36,000元，对应税率10%，速算扣除数2,520元，则当月预扣税额 &#x3D; 36,000×10% - 2,520 - 已缴税额。</li>
</ol>
<h4 id="退税条件与计算"><a href="#退税条件与计算" class="headerlink" title="退税条件与计算"></a>退税条件与计算</h4><p>个人所得税丨2024年个人综合所得年度汇算操作指引 <a target="_blank" rel="noopener" href="https://mapmpm5.midea.com/newservicenopages/#/content/preview?id=1896853229331374081">https://mapmpm5.midea.com/newservicenopages/#/content/preview?id=1896853229331374081</a><br>个人的汇算清缴，就是把您2024年一整年取得的劳动收入（税法中叫“综合所得”，具体指工资薪金、劳务报酬、稿酬、特许权使用费共4项）合并计算个税，得出应纳个人所得税，与2024年实际预扣预缴的个税比较，税款多退少补。预缴税款与实际应缴税款产生差异的核心原因在于<strong>预扣预缴机制与全年综合计算的逻辑差异</strong>。<br>预扣预缴是<strong>基于局部数据和固定规则的估算</strong>，而汇算清缴是<strong>基于完整数据和真实扣除的精准计算</strong>，<br><strong>建议</strong>：通过“个人所得税APP”提前核对收入明细和扣除项，利用汇算规则合法降低税负（如优化年终奖计税方式）。以下是具体原因分析：</p>
<ol>
<li>收入结构与预扣方式的差异<br>  • <strong>预扣预缴的“分段计算”特性</strong> ： 工资薪金采用<strong>累计预扣法</strong>，按月计算税款（逐月累加收入并匹配税率），而劳务报酬、稿酬等按<strong>固定比例预扣</strong>（如劳务报酬预扣率20%）。若全年收入波动大（如年终奖集中发放）或存在多处收入，可能导致：1. <strong>前期预缴税率低，后期税率跳档</strong>：例如前半年收入低按3%预扣，后半年累计收入超过36,000元后按10%计税，全年汇算需补差额。 2. <strong>劳务报酬预扣率高于综合税率</strong>：劳务报酬预扣时按20%扣税，但全年综合所得实际税率可能仅为3%或10%，汇算时可退税。<br>  • <strong>年终奖计税方式选择的影响</strong> ： 年终奖可选择<strong>单独计税</strong>（按“年终奖&#x2F;12”匹配月度税率）或<strong>合并计税</strong>（并入综合所得）。若预缴时选择单独计税，但汇算时合并后适用更高税率，则需补税。</li>
<li>扣除项目的动态调整<br>  • <strong>专项附加扣除的补充申报</strong>  ：预缴时未填报的专项附加扣除（如租房、赡养老人等），可在汇算时补充扣除，直接减少应纳税额。例如：<strong>租房扣除（1,500元&#x2F;月）</strong>：若全年未申报，汇算时补充可减少18,000元应税所得额，按10%税率计算可退1,800元。<strong>大病医疗扣除</strong>：只能在次年汇算时申报，直接影响退税额度。<br>  • 其他扣除项的汇算调整：如公益捐赠（需在汇算时提供凭证）、职业资格继续教育等扣除，预缴时未计入的，汇算时可补充抵扣。</li>
<li>收入合并的税负效应<br>  • <strong>综合所得合并计算的税率跃升</strong>  ：工资、劳务报酬等四项收入合并后，可能使全年应纳税所得额跨越税率档位。例如：<strong>单独计算时未超档</strong>：工资10万元（适用10%税率）+ 劳务报酬5万元（预扣20%但实际税率10%），合并后15万元应纳税所得额适用20%税率，需补税。<strong>多处收入叠加</strong>：从两家单位取得工资，每家均按5,000元起征点预扣，但全年合并收入超过6万元的部分需补税。<br>  • 稿酬的特殊计算规则：按“（稿酬收入×80%）×70%”计入综合所得，若预缴时未按此规则计算（如企业误操作）汇算时需调整。</li>
<li>政策与实操的特殊情形<br>  • <strong>免税收入的误计入</strong>  ： 部分免税补贴（如差旅津贴、误餐补助）若被错误计入工资，预缴时多缴税款，汇算时可申请剔除并退税。<br>  • <strong>预缴申报的误差</strong>  ：  企业可能因操作失误导致预缴税款错误（如漏报专项扣除），需通过汇算修正。</li>
</ol>
<h3 id="劳动合同"><a href="#劳动合同" class="headerlink" title="劳动合同"></a>劳动合同</h3><ol>
<li><strong>N+1补偿的适用场景与条件</strong><br>  • <strong>触发条件</strong>：  <strong>企业合法解除劳动合同但未提前30日通知</strong>，需支付“N+1”（经济补偿金+代通知金）。<br>  • 具体情形包括：<br>  ◦ 劳动者医疗期满后无法返岗且无法调岗；<br>  ◦ 劳动者经培训或调岗仍不胜任工作；<br>  ◦ 客观情况重大变化（如部门撤销、搬迁）导致合同无法履行。  </li>
<li><strong>计算规则</strong>：<br>  • <strong>N</strong>：按工作年限计算（每满1年支付1个月工资，不满半年按0.5个月计算）。  N按离职前12个月平均工资计算，包含奖金、津贴等。<br>  • <strong>+1</strong>：额外支付1个月工资（按解除合同前12个月平均工资或上月工资计算）。<br>  • ​月工资上限：若月工资高于当地上年度职工月平均工资3倍，按3倍标准支付且年限最高12年</li>
<li><strong>员工主动离职的经济补偿可能性</strong><br>  • <strong>一般情况</strong>：员工主动离职无补偿。<br>  • <strong>例外情形</strong>（企业存在过错，员工被迫离职）：<br> • 企业未足额支付工资、未缴社保、未提供劳动保护等（依据《劳动合同法》第38条）；<br> • 此时员工可主张<strong>N倍经济补偿金</strong>（无“+1”），但需书面通知并保留证据（如工资流水、社保记录）。  </li>
<li><strong>违法解除劳动合同的赔偿标准（2N）</strong> ：若企业无合法依据解除合同（如无故辞退、程序违法、裁撤孕期员工等），需支付<strong>2N赔偿金</strong>（经济补偿金的双倍）。    </li>
<li><strong>实务对比与维权建议</strong>  <table>
<thead>
<tr>
<th><strong>情形</strong></th>
<th><strong>补偿标准</strong></th>
<th><strong>法律依据</strong></th>
<th><strong>维权路径</strong></th>
</tr>
</thead>
<tbody><tr>
<td>企业合法解除未提前通知</td>
<td>N+1</td>
<td>《劳动合同法》第40条</td>
<td>协商或仲裁主张代通知金</td>
</tr>
<tr>
<td>企业违法解除</td>
<td>2N</td>
<td>《劳动合同法》第87条</td>
<td>劳动仲裁或诉讼索赔双倍赔偿</td>
</tr>
<tr>
<td>员工被迫离职（企业过错）</td>
<td>N</td>
<td>《劳动合同法》第38条</td>
<td>提交证据申请仲裁</td>
</tr>
</tbody></table>
</li>
</ol>
<hr>
<h1 id="商业保险"><a href="#商业保险" class="headerlink" title="商业保险"></a>商业保险</h1><p>【当代年轻人没了铁饭碗，还能负重奔跑多久？北京二胎家庭如何转移风险？】 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV16F4m1V7wv/?share_source=copy_web&vd_source=2cbe8cdd54a75d0c43fcdefa624d3fbe">https://www.bilibili.com/video/BV16F4m1V7wv/?share_source=copy_web&amp;vd_source=2cbe8cdd54a75d0c43fcdefa624d3fbe</a></p>
<p>“年纪轻的一定要买百万医疗险和意外险，还有抗癌险，关键时候真的能救命的，有余裕买个重疾险，如果生病了确证了就能拿到几十万的保额，可以作为治疗和康复期的生活费开销，医疗费有医保和百万医疗险，到时候真生比较严重的病百分之九十能报销，年纪轻买了便宜加起来一年千把块，父母没生病可以给他们买众民保和中银全名保，还有当地的惠民保三个加起来六百块不到，不看健康告知年龄大可以报销，配合医保大概能报销八十花的多甚至能报销到九十，给家里老人多套保障，不会出现得了病只能放弃的人间惨剧，如果老人没医保可以买城乡医保一年几百块”</p>
<p>mom：东莞农村？居民社保医保，莞家福，莞家福居民保？，midea家属保险</p>
<p>2025年度商业保险开始投保了~ 员工（统一投保无需美福下单）本人及任选两名家属的免费&#x2F;自付费升级方案 <a target="_blank" rel="noopener" href="https://mapnew5.midea.com/newservicenopages/#/content/detail?id=1902351310562877442&type=2">https://mapnew5.midea.com/newservicenopages/#/content/detail?id=1902351310562877442&amp;type=2</a></p>
<h4 id="快速了解一个保险的7个核心要素"><a href="#快速了解一个保险的7个核心要素" class="headerlink" title="快速了解一个保险的7个核心要素"></a>快速了解一个保险的7个核心要素</h4><ol>
<li><strong>保障范围</strong>（核心）<br>• 保什么：疾病类型（如60种重疾）、门诊&#x2F;住院&#x2F;手术等报销范围。<br>• 特别关注：是否包含社保外费用（如进口药、质子重离子）、癌症特药清单。<br>• 图片信息提示：图中“重大疾病列表”需核对乳腺癌是否被列为赔付疾病。  </li>
<li><strong>购买条件</strong><br>• 年龄：是否限制60岁以上？续保是否允许超龄？<br>• 健康告知：是否询问癌症病史？如有，如何核保？（图片中未提及健康告知，可能宽松）<br>• 等待期：生效前等待期（通常30-90天，重疾险可能180天）。  </li>
<li><strong>免赔额与报销比例</strong><br>• <strong>免赔额</strong>：如“意外住院补贴限额100元&#x2F;天”可能指单日免赔额。<br>• <strong>报销比例</strong>：社保内是否100%？社保外是否有比例限制？（图中“社保范围内7.5万&#x2F;位”需进一步解读）。  </li>
<li><strong>既往症条款</strong><br>• 关键问题：乳腺癌术后治疗是否被定义为“既往症”？若属于，报销比例是多少？（图中“免检责任”可能指部分疾病免检，需核实）</li>
<li><strong>保额与限额</strong><br>• 单项限额：如“意外住院补贴7.5万&#x2F;位”是否够用？<br>• 年度总限额：重大疾病总保额是否充足（至少100万以上）。  </li>
<li><strong>增值服务</strong><br>• 实用性：医疗垫付、重疾绿通、二次诊疗意见（图中未提及，需向HR确认）。  </li>
<li><strong>免责条款</strong><br>• 雷区排查：如“不覆盖胎液”（图片底部注释）可能指免责先天性疾病，需明确免责清单。</li>
</ol>
<h4 id="从报销顺序理解"><a href="#从报销顺序理解" class="headerlink" title="从报销顺序理解"></a>从报销顺序理解</h4><ol>
<li>“社保医保”“惠民保”：基本保障，看病报销“社保范围”内的如60%</li>
<li>团保商业保险：企业与保险公司合作提供，一方面能够报销“社保范围”内剩余40%中的部分，一方面能保重疾住院等</li>
<li>百万医疗险：看病报销“社保范围”外的部分，？有患癌史无法购买，可选择众民保</li>
<li>重疾保：以上“医疗险”报销看病本身的费用，而“重疾险”为支付单笔保费，用于后续正常生活；需要安全告知</li>
<li>意外险：负责意外事故以及某些“医疗险”不涵盖的病</li>
<li>可以按照“医疗险”，“重疾险”，“意外险”来搭配购买，但也存在商业保险覆盖其中多种的能力<img src="https://www.helloimg.com/i/2025/03/26/67e2eafe59c4a.jpg" width="350" height="300" alt=""></li>
</ol>
<p>根据您母亲的情况（47岁、乳腺癌病史、已参保东莞社保及莞家福），结合健康限制和保障需求，以下是商业保险的配置建议及具体产品的分析：</p>
<h4 id="一、基础保障优先级（必选）"><a href="#一、基础保障优先级（必选）" class="headerlink" title="一、基础保障优先级（必选）"></a><strong>一、基础保障优先级（必选）</strong></h4><ol>
<li><strong>普惠型医疗险（补充社保和莞家福）</strong><br>• <strong>推荐产品</strong>：全国版惠民保（如众民保）、东莞本地惠民保（如已参保莞家福需确认既往症规则）<br>• <strong>适用性</strong>：<br>  ◦ 无健康告知，覆盖乳腺癌术后治疗费用（报销比例通常为30%-50%，需查看具体条款）。<br>  ◦ 年保费约100-200元，保额高达300万，覆盖医保内外费用（部分产品含特药）。<br>• <strong>注意事项</strong>：<br>  ◦ 优先选择支持“乳腺癌复发治疗”的产品，如众民保对复发医疗费按比例报销。  </li>
<li><strong>乳腺癌复发险（专项核心保障）</strong><br>• <strong>推荐产品</strong>：<br>  ◦ <strong>泰康粉红卫士</strong>：0-2期患者可投保，复发或转移一次性赔付最高50万，报销型最高100万（含41种特药）。<br>  ◦ <strong>太平洋粉红守护</strong>：支持0-2期患者，可选对侧乳腺癌保障，含48种特药报销，续保稳定性较好。<br>• <strong>适用性</strong>：<br>  ◦ 覆盖乳腺癌复发、转移、对侧新发，报销比例100%（含社保外费用）。<br>  ◦ 年保费约1400-3000元（根据保额选择），等待期90天。</li>
</ol>
<h4 id="二、补充保障（根据预算可选）"><a href="#二、补充保障（根据预算可选）" class="headerlink" title="二、补充保障（根据预算可选）"></a><strong>二、补充保障（根据预算可选）</strong></h4><ol>
<li><strong>意外险</strong><br>• <strong>推荐产品</strong>：众安高危职业意外险、平安综合意外险<br>• <strong>适用性</strong>：<br>  ◦ 无健康告知，保意外身故&#x2F;伤残（50-100万）、意外医疗（不限社保）。<br>  ◦ 年保费约200-500元，杠杆率高。  </li>
<li><strong>团体医疗险（企业合作产品）</strong><br>• <strong>适用性</strong>：<br>  ◦ 您提到的太平洋人寿企业合作套餐，若无健康告知或宽松告知，可作为基础住院医疗补充（覆盖门诊住院费用）。<br>  ◦ 需确认是否覆盖社保外费用及乳腺癌复发相关治疗。</li>
</ol>
<h4 id="三、不推荐或限制类产品"><a href="#三、不推荐或限制类产品" class="headerlink" title="三、不推荐或限制类产品"></a><strong>三、不推荐或限制类产品</strong></h4><ol>
<li><strong>常规重疾险&#x2F;百万医疗险</strong>：<br>• 因乳腺癌病史，99%产品拒保或除外责任。  </li>
<li><strong>防癌医疗险</strong>：<br>• 仅少数产品允许投保（如支付宝终身防癌险），但通常除外乳腺癌责任。</li>
</ol>
<p><strong>具体产品对比分析</strong></p>
<table>
<thead>
<tr>
<th><strong>产品类型</strong></th>
<th><strong>推荐产品</strong></th>
<th><strong>核心优势</strong></th>
<th><strong>局限性</strong></th>
<th><strong>年保费参考</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>乳腺癌复发险</strong></td>
<td>泰康粉红卫士</td>
<td>保费最低（1400元起），特药覆盖最全（41种）</td>
<td>仅限0-2期患者，续保需审核</td>
<td>1400-5000元</td>
</tr>
<tr>
<td><strong>乳腺癌复发险</strong></td>
<td>太平洋粉红守护</td>
<td>含对侧乳腺癌保障，特药清单更新快（48种）</td>
<td>仅限0-2期患者，保费较高</td>
<td>2000-8000元</td>
</tr>
<tr>
<td><strong>惠民保</strong></td>
<td>众民保（全国版）</td>
<td>覆盖复发治疗，含CAR-T疗法和质子重离子</td>
<td>免赔额高（2万），报销比例50%-80%</td>
<td>150-300元</td>
</tr>
<tr>
<td><strong>团体医疗险</strong></td>
<td>太平洋企业合作套餐</td>
<td>无健康告知，可能覆盖既往症</td>
<td>需确认保额和报销范围（可能仅限社保内）</td>
<td>企业合作价（待确认）</td>
</tr>
</tbody></table>
<h4 id="四、配置方案建议"><a href="#四、配置方案建议" class="headerlink" title="四、配置方案建议"></a><strong>四、配置方案建议</strong></h4><ol>
<li><strong>预算有限方案（年保费约1600元）</strong>：<br>• <strong>必选</strong>：泰康粉红卫士（基础型1400元）+ 众民保（200元）。<br>• <strong>作用</strong>：覆盖乳腺癌复发高额医疗费，补充普惠报销。  </li>
<li><strong>全面保障方案（年保费约5000元）</strong>：<br>• <strong>必选</strong>：太平洋粉红守护（含特药责任3000元）+ 众民保（200元）+ 团体医疗险（企业合作）。<br>• <strong>可选</strong>：叠加意外险（300元），覆盖意外风险。  </li>
<li>区分保险类型，明确赔付规则</li>
</ol>
<ul>
<li><strong>可叠加赔付的保险类型（给付型）</strong><br>• <strong>重疾险</strong>：若确诊合同约定的疾病（如癌症、心梗等），不同保司的重疾险可同时赔付，互不影响。例如：投保两份50万保额的重疾险，确诊后可获100万赔付。<br>• <strong>寿险&#x2F;意外险身故&#x2F;伤残保障</strong>：身故或伤残保额可叠加赔付，但未成年人受保额限制（如10岁以下身故保额最高20万）。<br>• <strong>年金险</strong>：按合同约定固定给付生存金，多份保单可同时领取。  </li>
<li><strong>不可叠加赔付的保险类型（报销补偿型）</strong><br>• <strong>医疗险（含意外医疗）</strong>：以实际医疗费用为上限，发票原件仅能用于一次报销。若A公司已全额赔付，B公司不再赔付；若A公司仅报销80%，剩余20%可向B公司申请（需提供分割单）。<br>• <strong>财产险（车险、家财险）</strong>：遵循损失补偿原则，赔付总和不超过实际损失。例如：车辆全损价值50万，即使投保两份车险，最高仅赔50万。</li>
</ul>
<ol start="4">
<li>保障范围叠加策略</li>
</ol>
<ul>
<li><strong>优先覆盖不同风险场景</strong><br>• <strong>疾病+意外+身故组合</strong>：例如「重疾险+医疗险+意外险」，覆盖疾病治疗、意外伤害和身故风险。<br>• <strong>高低保额搭配</strong>：小额医疗险（覆盖1万内费用） + 百万医疗险（覆盖大额住院费用），减少免赔额影响。  </li>
<li><strong>避免重复投保同类报销型保险</strong><br>• 同时购买多份百万医疗险无意义（均需扣除1万免赔额），但可搭配无免赔额的小额医疗险。  </li>
<li><strong>注意隐性条款冲突</strong><br>• 部分医疗险限制“仅报销社保目录内费用”，若另一份医疗险覆盖社保外费用，可互补。</li>
</ul>
<ol start="5">
<li>总结建议<br>• <strong>合理搭配类型</strong>：给付型（重疾、寿险） + 报销型（医疗险） + 财产险，避免同类报销险重复。<br>• <strong>重点核查条款</strong>：健康告知、免责范围、赔付优先级（如医疗险报销顺序）。<br>• <strong>动态调整保障</strong>：定期检视保单，根据家庭阶段（如生子、购房）增减保额或险种。</li>
</ol>
<h4 id="五、注意事项"><a href="#五、注意事项" class="headerlink" title="五、注意事项"></a>五、注意事项</h4><ol>
<li><strong>健康告知</strong>：购买前务必确认条款中的“既往症定义”，乳腺癌相关治疗可能被除外。  </li>
<li><strong>报销材料</strong>：需保存医疗发票、诊断证明、用药清单等，多数产品需先经医保报销。  </li>
<li><strong>续保稳定性</strong>：众民保为1年期产品，不保证续保，但众安产品历史稳定性较好。</li>
</ol>
<p>建议优先投保乳腺癌复发险（专项保障），再补充惠民保和意外险，最后根据企业团体险条款决定是否叠加。<br>建议通过保险顾问协助核保（如众安、慧择平台），确保理赔无争议。</p>
<hr>

<h1 id="投资"><a href="#投资" class="headerlink" title="投资"></a>投资</h1><h3 id="三、个性化投资策略建议"><a href="#三、个性化投资策略建议" class="headerlink" title="三、个性化投资策略建议"></a>三、个性化投资策略建议</h3><h4 id="1-资金配置方案（月均5000元）："><a href="#1-资金配置方案（月均5000元）：" class="headerlink" title="1. 资金配置方案（月均5000元）："></a>1. <strong>资金配置方案（月均5000元）</strong>：</h4><table>
<thead>
<tr>
<th>类别</th>
<th>比例</th>
<th>工具示例</th>
<th>目的</th>
</tr>
</thead>
<tbody><tr>
<td>学习投入</td>
<td>10%</td>
<td>付费研报、专业课程</td>
<td>知识体系构建</td>
</tr>
<tr>
<td>模拟交易</td>
<td>0%</td>
<td>同花顺模拟盘、Backtrader</td>
<td>策略验证</td>
</tr>
<tr>
<td>指数定投</td>
<td>40%</td>
<td>沪深300ETF（A股）</td>
<td>强制储蓄+市场β收益</td>
</tr>
<tr>
<td>行业ETF</td>
<td>30%</td>
<td>半导体ETF（512480）</td>
<td>把握结构性机会</td>
</tr>
<tr>
<td>现金储备</td>
<td>20%</td>
<td>货币基金</td>
<td>应对黑天鹅事件</td>
</tr>
</tbody></table>
<h4 id="2-技术赋能投资的具体路径："><a href="#2-技术赋能投资的具体路径：" class="headerlink" title="2. 技术赋能投资的具体路径："></a>2. <strong>技术赋能投资的具体路径</strong>：</h4><ul>
<li><strong>量化入门</strong>：<ol>
<li>用Python复现经典策略（如双均线策略）</li>
<li>开发舆情监控爬虫（抓取雪球、股吧热词）</li>
<li>构建多因子选股模型（参考WorldQuant Alpha库）</li>
</ol>
</li>
<li><strong>工具推荐</strong>：<ul>
<li>数据平台：AKShare（开源替代Tushare）</li>
<li>回测框架：QLib（阿里开源）</li>
<li>可视化：Plotly+Dash构建交互式看板</li>
</ul>
</li>
</ul>
<h4 id="3-阶段目标管理："><a href="#3-阶段目标管理：" class="headerlink" title="3. 阶段目标管理："></a>3. <strong>阶段目标管理</strong>：</h4><ul>
<li><strong>新手期（0-1年）</strong>：<ul>
<li>目标：年化收益率跑赢货币基金（2%-3%）</li>
<li>关键动作：完成10个策略回测、建立投资checklist</li>
</ul>
</li>
<li><strong>进阶期（1-3年）</strong>：<ul>
<li>目标：年化收益率8%-10%（同期沪深300水平）</li>
<li>关键动作：开发自动化交易信号系统</li>
</ul>
</li>
</ul>
<h3 id="四、风险控制工具箱"><a href="#四、风险控制工具箱" class="headerlink" title="四、风险控制工具箱"></a>四、风险控制工具箱</h3><ol>
<li><strong>极端情况应对预案</strong>：<ul>
<li>设置动态止损线（如回撤超15%强制减仓）</li>
<li>保留3-6个月生活费的现金储备</li>
<li>建立黑天鹅事件清单（如中美脱钩、疫情反复）</li>
</ul>
</li>
<li><strong>认知偏差矫正方法</strong>：<ul>
<li>交易日志模板：<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| 日期 | 操作 | 决策依据 | 情绪状态 | 事后评估 |</span><br><span class="line">|------|------|----------|----------|----------|</span><br><span class="line">| 2023-08-01 | 买入XX股 | MACD金叉 | 焦虑追涨 | 错误：未考虑成交量萎缩 |</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>推荐监控指标</strong>：<ul>
<li>十年期美债收益率（全球资产定价锚）</li>
<li>人民币汇率波动区间</li>
<li>融资融券余额变化率</li>
</ul>
</li>
</ol>
<h3 id="六、推荐资源清单"><a href="#六、推荐资源清单" class="headerlink" title="六、推荐资源清单"></a>六、推荐资源清单</h3><ol>
<li><strong>数据源</strong>：<ul>
<li>国家统计局宏观数据库</li>
<li>FRED（美联储经济数据）</li>
</ul>
</li>
<li><strong>工具链</strong>：<ul>
<li>Jupyter Notebook + Pandas（数据分析）</li>
<li>TensorFlow&#x2F;PyTorch（预测模型）</li>
</ul>
</li>
<li><strong>深度阅读</strong>：<ul>
<li>《主动型指数投资》（王延巍）</li>
<li>《量化投资：以Python为工具》（蔡立耑）</li>
</ul>
</li>
</ol>
<p><strong>下一步行动建议</strong>：</p>
<ol>
<li>本周内注册模拟交易账户</li>
<li>用Matplotlib复现近5年行业轮动图谱</li>
<li>加入量化投资开源社区（如JoinQuant）</li>
</ol>
<p>你的技术背景是独特优势，建议从**”工程师型投资者”<strong>路径切入，将编程能力转化为投资生产力。记住：在认知不充分时，</strong>不亏损<strong>比</strong>追求收益**更重要。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/18/%E7%90%86%E8%B4%A2/" data-id="cmiae68a6000tl4v57p0hea2m" data-title="Lic Ai" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-美的Midea" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/07/%E7%BE%8E%E7%9A%84Midea/" class="article-date">
  <time class="dt-published" datetime="2024-07-07T02:58:11.000Z" itemprop="datePublished">2024-07-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/07/%E7%BE%8E%E7%9A%84Midea/">美 的 Midea</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="08-07-24"><a href="#08-07-24" class="headerlink" title="08&#x2F;07&#x2F;24"></a>08&#x2F;07&#x2F;24</h1><p><img src="https://leo710aka.github.io/bk/midea.jpg"></p>
<p>入职第一天，熟悉运维平台，目标实现其自动化，后续参与到美的云,?<br>熟悉新旧平台的功能和调用关系，拆分业务需求开发步骤，编写文档，每日汇报进展，熟悉开发流程、、<br>软工院作为非互联网公司的非核心业务的底层平台建设部门，结果导向，组员多一年社招；)无校招培养。？</p>
<h2 id="7-17-7-29"><a href="#7-17-7-29" class="headerlink" title="7.17 ~ 7.29"></a>7.17 ~ 7.29</h2><p>EDP培训 ＋ MGC（头脑风暴&#x2F;产品调研&#x2F;拉通对齐&gt;&gt;技术）<br>T型人才(广度＋深度)，开发技术+产品思维-&gt;架构师<br>不设限，主动承担任务，机会莫名来：) take other people’s jobs and become indispensable to the team..</p>
<p>复杂的事情简单化(思考简化)，简单的事情复杂化(做到极致)<br>工作就是生活，生活就是工作，不需要平衡（找到热爱的工作）<br>成功的百分比 &#x3D; 做事 &#x2F; (个人 + 做事)；做事的比例越大，成功的概率越大</p>
<p>Allen: 向上管理?× 向上反馈，同步进展<br>MGC结营<br>融入团队？主动承担？谈论未知？如何选择自己在团队中的角色，人设？？<br>圈子</p>
<h2 id="8-17"><a href="#8-17" class="headerlink" title="8.17"></a>8.17</h2><p>佛山校友会迎新<br>“努力会发光，先有为后有位”，“头三年不要动，把这一套学会”<br>程序员的本质核心竞争力是什么？1.开发都是那一套 2.专精一个领域 3.meet新公司的需求 4.解决问题的能力</p>
<h2 id="8-22-需求一："><a href="#8-22-需求一：" class="headerlink" title="8.22 需求一："></a>8.22 <strong>需求一</strong>：</h2><p><em>华为云主机开&#x2F;关机&#x2F;重启自动化</em> : mq、定时任务、公有云api、crud、、<br>完成第一版8.14，自测8.15，，merge request，code review，sit，测试，uat，发版8.22、、<br>反思、、在开发同事的指导下完成了开发，不具备独立调研和开发能力，，<br>缺少对产品的思考？？没有对需求进行120%的思考和完成。。</p>
<h2 id="8-24"><a href="#8-24" class="headerlink" title="8.24"></a>8.24</h2><p>顺德校友会迎新<br>why Midea？1.生活成本低（特别是住宿好通勤方便）2.相比下工作轻松（能够有自己的时间学习业务以外的东西）<br>思考自己在..年后会到什么层次（本科毕业+6y ?&#x3D; 博士毕业起步）。。阶段性目标</p>
<h2 id="8-27-Steven"><a href="#8-27-Steven" class="headerlink" title="8.27 Steven:"></a>8.27 Steven:</h2><p>深入一个领域，，<br>先做一点功能点，然后负责一个模块，到不同系统的交互、、<br>多学基础，与外包的区别。。与人沟通的能力<br>幂等，整体设计，微服务治理，看项目源码，，<br>干半年就不是应届生了。社会很残酷，前两年要快速成长；思考两&#x2F;五年后的情况、、<br>开发整个过一遍，打包，发版，，<br>多讨论，多问，code review<br><strong>失败邮件发送</strong>：设计一个功能，，关注点，逻辑路径，通用性，，如何表述。。?！ –&gt;</p>
<h2 id="9-9-并发先查后改"><a href="#9-9-并发先查后改" class="headerlink" title="9.9 并发先查后改"></a>9.9 并发先查后改</h2><p>方法：事务+行锁【悲观锁】，避免在高并发场景下<strong>先读后写</strong>导致多个线程同时读取相同的值然后同时写入引发数据不一致的问题<br>测试：线程池多线程访问，打印数据，排查重复值；考虑数据库连接池配置<br>思考：项目部署到多节点下，则是多进程的多线程环境，需要用Redis分布式锁，或者唯一的全局数据库节点加锁；<br>单节点的多线程才能用synchronized？、</p>
<ul>
<li>优化：事实上，update方法会加行锁，所以直接先update后select即可，无需select…for update<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumberService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> NumberMapper numberMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span> <span class="comment">// 在业务逻辑层开启事务，确保整个操作是原子的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incrementNumber</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 查询并锁定行</span></span><br><span class="line">        <span class="type">NumberEntity</span> <span class="variable">numberEntity</span> <span class="operator">=</span> numberMapper.selectForUpdate(id);</span><br><span class="line">        <span class="comment">// 读取后进行计算并更新，保证只有当前事务可以操作该行</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">currentNumber</span> <span class="operator">=</span> numberEntity.getNumber();</span><br><span class="line">        numberEntity.setNumber(currentNumber + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 更新数据库</span></span><br><span class="line">        numberMapper.updateById(numberEntity);</span><br><span class="line">        <span class="comment">// 更新完成后提交事务，释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NumberMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;NumberEntity&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 FOR UPDATE 读取并锁定行，防止其他事务并发读取该行</span></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM number_table WHERE id = #&#123;id&#125; FOR UPDATE&quot;)</span></span><br><span class="line">    NumberEntity <span class="title function_">selectForUpdate</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="9-12-需求二："><a href="#9-12-需求二：" class="headerlink" title="9.12 需求二："></a>9.12 <strong>需求二</strong>：</h2><p><em>Azure公有云主机申请</em> :根据云管界面配置配齐参数发送报文到作业平台，完成自动化主机创建和标准化<br>对其参数，连续加班，9.9完成第一版，9.10上sit前端联调，9.11开发部分发邮件，9.12上uat，6.同步DDL&amp;DML，7.发版，验收成功<br>接触运维协同，，code review，联调，，集成，部署，流水线，，</p>
<h2 id="9-14"><a href="#9-14" class="headerlink" title="9.14"></a><strong>9.14</strong></h2><p>窝囊费:）120</p>
<!-- 00+440(补贴)-2674.81(代扣代缴:898.9+1151+480补充公积金+144.91扣税)-762.1(房租水电)(+2302公积金) = 9003.09(+2302)
| 个人住房公积金 | 个人补充公积金 | 公司缴纳金额 | 月缴纳金额合计 |
| ------- | ------- | ------- | ------- |
| 1151 | 480 | 671 | 2302 |

| 五险 | 个人缴纳金额 | 公司缴纳金额 | 总计 |
| ------- | ------- | ------- | ------- |
| 养老保险 | 767.2 | 1438.5 | 2205.7 |
| 医疗保险 | 115.2 | 281.3 | 393.82 |
| 失业保险 | 19.18 | 76.72 | 95.9 |
| 工伤保险 | 0 | 38.36 | 38.36 |
| 生育保险 | 0 | 0 | 0 |
| 总计    | 898.9 | 1834.88 | 2733.78 | -->


<h2 id="9-26-需求三："><a href="#9-26-需求三：" class="headerlink" title="9.26 需求三："></a>9.26 需求三：</h2><p><em>Azure公有云主机回收&#x2F;开&#x2F;关机&#x2F;重启</em> : 调研AzureApi和测试方法，开发，，<br>9.23回收上sit，9.24开关机重启代码重构(原华为云方法过于通用)，9.25bug毁了我的足球梦，9.26配置ngix上uat，验收<br>思考：自测可以 1.全流程验证 2.单独功能验证 3.考虑开发与测试环境的区别（ping的包装方法&#x2F;命令行执行在开发&#x2F;测试环境的区别）<br>后续：完善公有云开发（Azure回收配额，ip，失败邮件），后续由<em>运维平台MOPS</em> -&gt; 参与到数据库开发</p>
<h2 id="10-12-需求四："><a href="#10-12-需求四：" class="headerlink" title="10.12 需求四："></a>10.12 需求四：</h2><p>任务触发式失败邮件完成，改造为工单定时任务扫描式，10.17上线<br>邮件通用性？？工单+定时任务层面的通用，，</p>
<h2 id="10-14"><a href="#10-14" class="headerlink" title="10.14"></a>10.14</h2><p><strong>数据管控平台DataMars:</strong> 云管cmcloud开发功能，先提供内部服务，后到SAAS，，<br>InfluxDB备份恢复 1 调研 2 手工实现 3 详细文档<br>2-3月时间，不要求11月上线，整体设计，转正答辩<br>api，数据库内核？，容器，k8s<br>容器，登录主机，查看docker实例，操作数据库实例</p>
<h2 id="10-22-K8S验证InfluxDB-Cluster实例导入导出"><a href="#10-22-K8S验证InfluxDB-Cluster实例导入导出" class="headerlink" title="10.22 K8S验证InfluxDB Cluster实例导入导出"></a>10.22 K8S验证InfluxDB Cluster实例导入导出</h2><ol>
<li>FinalShell客户端：主要用于服务器管理和运维。支持 SSH、SFTP 等多种协议，方便用户通过图形界面进行远程连接和操作。</li>
<li>跳板机&#x2F;堡垒机： SSH连接，登录堡垒机opsec.midea.com，mip账密 + OTP验证</li>
<li>资产列表中选择指定环境下的主机，InfluxDB多节点部署在对应环境的几台主机上</li>
<li>切换用户：rouser，apps，root<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rouser20@(datamars)mhpl74337-10.20.248.65 ~$ sudo su - apps</span><br></pre></td></tr></table></figure></li>
<li>K8S入门 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/32618563">https://zhuanlan.zhihu.com/p/32618563</a><ul>
<li>Namespace(命名空间,是一个逻辑隔离的环境,用于资源分组和隔离) -&gt; InfluxDB集群(可以有多个)，Pod(Kubernetes的基本计算单元) -&gt; InfluxDB集群节点(逻辑上)，容器 -&gt; InfluxDB单例(物理上) </li>
<li>Namespace：作为最顶层的资源，实现了资源的逻辑隔离。</li>
<li>StatefulSet：对于有状态的服务如数据库，K8s 推荐使用 StatefulSet 进行管理，确保每个 Pod 都有一个持久的唯一标识并提供稳定的网络标识和存储。 InfluxDB 集群中，StatefulSet 用于管理数据节点和元节点。</li>
<li>Pod 是最基本的部署单元，它是可以被创建和管理的最小部署对象。当创建一个 InfluxDB 集群实例时，StatefulSet 会用来管理 Pod 的生命周期(而不是直接创建Pod)。</li>
<li>InfluxDB 集群部署：对于一个 Namespace下的几个  Pod，这些节点会通过 StatefulSet或者 Deployment来进行管理和部署。在实际操作中，创建 InfluxDB 集群实例的 Helm Chart 或者 Operator 通常会自动化这些资源的创建过程。</li>
<li>通信调度：K8s 中，Pod 之间的通信通常通过 Service 来进行。Service 会为一组 Pod 提供一个稳定的 IP 地址和 DNS 名称。对于 InfluxDB 集群，可能会有一个或多个 Service 来管理数据节点和元数据节点之间的通信。</li>
<li>查看实例root密码<br> kubectl get secrets -n influxdb<br> kubectl get secrets -n influxdb influxdb-e73f149ff7192bd87d190-influxdb -o yaml</li>
</ul>
</li>
<li>连接主机mhpl74337（datamars-uat的三台服务器之一），查看 <code>influxdb</code> 命名空间下的所有 Stateful、Pod 的状态和节点信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apps@(datamars)mhpl74337-10.20.248.65 ~$ kubectl get sts -n influxdb</span><br><span class="line">NAME                                  READY   AGE</span><br><span class="line">influxdb-e2cb6c913a191e56c134e-data   2/2     47d</span><br><span class="line">influxdb-e2cb6c913a191e56c134e-meta   3/3     47d</span><br><span class="line">apps@(datamars)mhpl74337-10.20.248.65 ~$ kubectl get pod -n influxdb -o wide</span><br><span class="line">influxdb-e2cb6c913a191e56c134e-data-0   1/1     Running   0              20d     10.20.205.88    mhpl74338   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">influxdb-e2cb6c913a191e56c134e-data-1   1/1     Running   52 (44h ago)   20d     10.20.206.129   mhpl74344   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">meta-0/1/2...</span><br></pre></td></tr></table></figure>
可以看到，<strong>在 Kubernetes上创建了 InfluxDB集群实例，它们共用一个 Namespace：influxdb</strong>，使用 StatefulSet 来创建和管理 Pod。这些 Pod 负责运行 InfluxDB 服务，并由 StatefulSet 确保它们的高可用性和数据持久化。<br>对于每个集群实例，<strong>有 2个 sts为 meta和 data，分别有2和3个复制，即2个元节点和3个数据节点 Pod，部署在3台服务器上</strong>；pod内部共用数据卷，pod之间数据不互通，部署在同一主机上的pod之间可以通过本地机器为中介复制文件。</li>
<li>查看 <code>influxdb</code> 命名空间下的 service 信息。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apps@(datamars)mhpl74337-10.20.248.65 ~$ kubectl get svc -n influxdb</span><br><span class="line">NAME                                  TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)                                                  AGE</span><br><span class="line">influxdb-e2cb6c913a191e56c134e-data   ClusterIP   None         &lt;none&gt;        8086/TCP,8088/TCP,2003/TCP,4242/TCP,25826/UDP,8089/UDP   39d</span><br><span class="line">influxdb-e2cb6c913a191e56c134e-meta   ClusterIP   None         &lt;none&gt;        8089/TCP,8091/TCP                                        39d</span><br></pre></td></tr></table></figure>
有 2 个Service，用来定义一组Pod的访问策略的抽象。它提供了一种方式，使得外部客户端可以通过一个固定的IP地址和端口访问这些Pod，而不需要关心Pod的实际IP地址和端口。Service会通过选择器（selector）将这些端口映射到后端的Pod上。</li>
<li><code>kubectl exec</code> 进入指定的 Pod(默认进入其中的第一个容器)，并启动一个 bash shell；可以看到当前 InfluxDB 版本是v1.8.10-c1.1.2<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apps@(datamars)mhpl74337-10.20.248.65 ~$ kubectl <span class="built_in">exec</span> -it influxdb-e2cb6c913a191e56c134e-data-0 -n influxdb -- bash</span><br><span class="line">root@influxdb-e2cb6c913a191e56c134e-data-0:/<span class="comment"># influxd version</span></span><br><span class="line">InfluxDB v1.8.10-c1.1.2 (git: master 529251fda5d776cf47bb0c247cf81075f2980fed, build: go1.16.15 linux/amd64)</span><br></pre></td></tr></table></figure>
在使用InfluxDB进行备份和恢复操作时，通常需要在数据节点上执行相关命令（元节点上都没有influx指令。。）</li>
<li>进入influx命令行界面，验证身份信息；事实上，进入到influxdb实例中，便无需考虑节点，部署，，，了，直接操作数据库和数据<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@influxdb-e2cb6c913a191e56c134e-data-0:/<span class="comment"># influx</span></span><br><span class="line">Connected to http://localhost:8086 version 1.8.10-c1.1.2</span><br><span class="line">InfluxDB shell version: 1.8.10-c1.1.2</span><br><span class="line">&gt; auth</span><br><span class="line">username: </span><br><span class="line">password: </span><br></pre></td></tr></table></figure></li>
<li>数据库导出：容器层面命令，指定 数据文件和 写前日志(WAL)文件的存储目录，将指定数据库中指定时间的数据导出到指定文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@influxdb-e2cb6c913a191e56c134e-data-0:/<span class="comment"># influx_inspect export -datadir &quot;/var/lib/influxdb/data&quot; -waldir &quot;/var/lib/influxdb/wal&quot; -out &quot;influxdb_test01_dump_out&quot; -database &quot;test01&quot; -start &quot;2024-10-22T00:00:00Z&quot;</span></span><br></pre></td></tr></table></figure>
数据文件复制：1、从pod1复制到本地机器 2、从本地机器复制到部署在同一服务器上的pod2（NODE: mhpl74344）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo kubectl <span class="built_in">cp</span> influxdb/influxdb-e2cb6c913a191e56c134e-data-1:/influxdb_test01_dump_out data/influxdb_test01_dump_out</span><br><span class="line">sudo kubectl <span class="built_in">cp</span> data/influxdb_test01_dump_out influxdb/influxdb-e73f149ff7192bd87d190-data-1:/influxdb_test01_dump_out </span><br></pre></td></tr></table></figure>
获取密码：查看对应实例的admin账密，解密data<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl get secrets -n influxdb <span class="comment"># 看命名空间</span></span><br><span class="line">kubectl get secrets -n influxdb influxdb-e73f149ff7192bd87d190-influxdb -o yaml <span class="comment"># 看选定实例</span></span><br></pre></td></tr></table></figure>
数据库导入：容器层面执行命令，使用admin账号，指定文件、数据库、时间戳精度<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@influxdb-e73f149ff7192bd87d190-data-1:/<span class="comment"># influx -import -path=&#x27;influxdb_test01_dump_out&#x27; -precision=ns -username=&#x27;admin&#x27; -password=&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
实例导出：不加 <code>-database</code>，把influxdb集群实例中所有数据库的数据导出，加 <code>-compress</code> 导出压缩文件<br>实例导入：加<code>-compressed</code> 导入压缩文件，本质上是先解压后倒入</li>
</ol>
<h2 id="11-4-Pod添加datamars-agent-Container"><a href="#11-4-Pod添加datamars-agent-Container" class="headerlink" title="11.4 Pod添加datamars-agent Container"></a>11.4 Pod添加datamars-agent Container</h2><ol>
<li>从已有的MongoDB实例中的statefulset配置文件中，找到datamars-agent容器修改配置<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导出配置文件</span></span><br><span class="line">apps@(datamars)mhpl74337-10.20.248.65 ~$ kubectl get sts influxdb-xxxx-xxx -n influxdb -o yaml &gt; influxdb-sts.yaml</span><br><span class="line"><span class="comment"># 文件下载本地</span></span><br><span class="line">apps@(datamars)mhpl74337-10.20.248.65 ~$ sz influxdb-sts.yaml </span><br></pre></td></tr></table></figure></li>
<li>本地编辑器打开（for convenience）<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span>     </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">command:</span>  <span class="comment"># 找到datamars-agent容器</span></span><br><span class="line">        <span class="comment"># 配置</span></span><br><span class="line">        <span class="attr">image:</span> </span><br><span class="line">        <span class="attr">name:</span> </span><br><span class="line">        <span class="attr">volumeMounts:</span>  <span class="comment"># volumeMounts 是在容器层面配置的，定义了容器内的挂载点</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/etc/localtime</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">host-local-time</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/etc/mongodb-config</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/log</span>  <span class="comment"># /log 挂载了名为 log 的卷。</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">log</span></span><br><span class="line">      <span class="attr">volumes:</span>  <span class="comment"># volumes 是在 Pod 层面配置的，定义了 Pod 中可以使用的卷</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">configMap:</span></span><br><span class="line">          <span class="attr">defaultMode:</span> <span class="number">420</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">influxdb-e73f149ff7192bd87d190-data</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">config</span>  <span class="comment"># config 卷是一个 configMap，实际路径在物理机上并不固定，由 Kubernetes 动态管理</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/etc/localtime</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">File</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">host-local-time</span>  <span class="comment"># host-local-time 卷是一个 hostPath，路径为 /etc/localtime，类型为 File</span></span><br><span class="line">  <span class="attr">volumeClaimTemplates:</span>  <span class="comment"># volumeClaimTemplates 是在 StatefulSet 层面配置的，定义了持久化存储卷的声明</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">annotations:</span></span><br><span class="line">        <span class="attr">ext.datamars.org/blkio.throttle.read_iops_device:</span> <span class="string">&quot;8000&quot;</span></span><br><span class="line">        <span class="attr">ext.datamars.org/blkio.throttle.write_iops_device:</span> <span class="string">&quot;8000&quot;</span></span><br><span class="line">      <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">log</span>  <span class="comment"># log 卷声明了一个 PersistentVolumeClaim，请求 50Gi 的存储，实际路径在物理机上由存储类 datamars-default-lvm 管理，具体路径取决于存储类的实现</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">mongodb</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">accessModes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">storage:</span> <span class="string">50Gi</span></span><br><span class="line">      <span class="attr">storageClassName:</span> <span class="string">datamars-default-lvm</span></span><br><span class="line">      <span class="attr">volumeMode:</span> <span class="string">Filesystem</span></span><br><span class="line">    <span class="attr">status:</span></span><br><span class="line">      <span class="attr">phase:</span> <span class="string">Pending</span></span><br></pre></td></tr></table></figure>
查看pv（集群层面的存储），pvc（pv的使用规则）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apps@(datamars)mhpl74337-10.20.248.65 ~$ kubectl get pv -n influxdb</span><br><span class="line">apps@(datamars)mhpl74337-10.20.248.65 ~$ kubectl get pvc -n influxdb</span><br></pre></td></tr></table></figure></li>
<li>添加到influxdb-data Statefulset的配置中，手动更新sts配置（导出influxdb-sts.yaml，sz到本地，修改后rz传到服务器）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f influxdb-sts.yaml</span><br></pre></td></tr></table></figure>
或者，直接修改influxdb-data Statefulset的配置中，:wq 保存，成功后自动更新到Pod<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apps@(datamars)mhpl74337-10.20.248.65 ~$ kubectl edit sts -n influxdb influxdb-e73f149ff7192bd87d190-data</span><br><span class="line">statefulset.apps/influxdb-e73f149ff7192bd87d190-data edited</span><br><span class="line">apps@(datamars)mhpl74337-10.20.248.65 ~$ kubectl describe sts -n influxdb influxdb-e73f149ff7192bd87d190-data</span><br><span class="line"><span class="comment"># 最下面可以看到事件信息</span></span><br><span class="line">Events:</span><br><span class="line">  Type     Reason            Age                 From                    Message</span><br><span class="line">  ----     ------            ----                ----                    -------</span><br><span class="line">  Warning  FailedCreate      50m                 statefulset-controller  create Pod influxdb-e73f149ff7192bd87d190-data-0 <span class="keyword">in</span> StatefulSet influxdb-e73f149ff7192bd87d190-data failed error: Pod <span class="string">&quot;influxdb-e73f149ff7192bd87d190-data-0&quot;</span> is invalid: spec.containers[1].volumeMounts[0].name: Not found: <span class="string">&quot;conf&quot;</span></span><br><span class="line">  Normal   SuccessfulCreate  48m (x2 over 12d)   statefulset-controller  create Pod influxdb-e73f149ff7192bd87d190-data-0 <span class="keyword">in</span> StatefulSet influxdb-e73f149ff7192bd87d190-data successful</span><br><span class="line"><span class="comment"># 或者看日志</span></span><br><span class="line">apps@(datamars)mhpl74337-10.20.248.65 ~$ kubectl logs influxdb-e73f149ff7192bd87d190-data-0 -n influxdb -c datamars-agent</span><br></pre></td></tr></table></figure></li>
<li>注意以上操作只是手动修改一个Pod，要想新建Pod中的配置更新，需要通过helm chart配置__</li>
</ol>
<h2 id="11-11-InfluxDB服务化-：实例备份-调研-开发"><a href="#11-11-InfluxDB服务化-：实例备份-调研-开发" class="headerlink" title="11.11 InfluxDB服务化 ：实例备份(调研&amp;开发)"></a>11.11 <em>InfluxDB服务化</em> ：实例备份(调研&amp;开发)</h2><p>10.14-10.18：看文档，建立InfluxDB集群概念(前期已经也在看了..)，建立整体框架概念（apiserver–bakserver–agent）<br>10.21-10.25：本地容器搭建influxdb集群×，连接服务器测试实例验证功能，了解K8S概念，手动验证实例(库级)导入导出即逻辑备份<br>10.28-11.01：对其需求(能做但没用户??)，完成技术文档框架，开始将功能接入datamars-bakserver，了解golang开发<br>11.04-11.08：搭建go开发和agent项目环境，，无法理解go项目结构，尝试从bakserver侧理解task下发-接收-执行全流程<br>11.11：理解所有业务代码(after2weeks)发现task下发无需改动，只需适配influxdb(修改配置类和表)，接着打包至sit环境打印log调试<br>11.12-11.15：研究pod添加container(改sts后delete pod重建)，go项目构建(windows尝试配齐开发工具但有些包依赖linux环境)》。<br>11.18-11.27：本机wsl的ubuntu成功构建起datamars-agent，边抄边做，不用理解其框架?.. 及时请教专家<br>11.28-12.03：kun手改agent代码：）打包image push到dockerhub，宿主机拉取镜像后本地grpcurl调试 pod ip:port 验证功能<br>12.04-12.09：bakserver打日志流水线部署到uat(集群实例所在环境)，通过apiserver-bakserver-agent中的日志验证全流程功能<br>12.10：验证通过<br>技术文档先行，将需求拆分成一步步，重要的是要有<strong>产出</strong>，，能汇报<strong>进度</strong>。。buffer。。好心态😇不怕叼<br>关注重要的事情（功能接入已有框架&#x2F;理解业务逻辑×，功能验证和对齐需求√，开发卡点及时请教）<br>1&#x2F;2时间幻想(串联已知信息且验证,对齐上下游并重复验证,本质是开发环境,业务不熟悉)，1&#x2F;4等回复(线上下请教+准备)，1&#x2F;4开发(快乐短暂)<br>与人沟通是重要的能力。。拉群问。。软件开发还是很残酷的。。</p>
<p>2025.04：重新考虑… 1 influx_inspect export只是把该pod指定数据库(或所有库)的指定时间段的分片数据(tsm&amp;wal)导出line protocol文件，各Data-Pod数据不一致时不能代表整个实例；2 influx -import本质是将数据重新写入，前提要先恢复好shard元数据，，</p>
<h2 id="12-12-年终述职"><a href="#12-12-年终述职" class="headerlink" title="12.12 年终述职"></a>12.12 年终述职</h2><ul>
<li>大家好，那我现在开始~<br>七月份入职后，我先是接触了MOPS自动化运维的开发任务:）<!-- 1 第一个需求是“华为云主机开/关机/重启自动化”，主要进行了华为云api的验证并接入代码；基本上每天就是面对zhib开发，通过这个需求，我建立了对开发环境和流程的认识，学会了将需求拆分开来开发和逐步验证
2 然后是“Azure公有云主机申请自动化”，我在看不懂的文档和听不懂的会议中陷入了迷失，才理解到其实我的工作就是配齐参数构造报文发送至作业平台，经过前端、运维的协作，主要是不停地对齐需求对参数，最终在发版前一小时极限提交变更，上线，五人
3 对于“Azure公有云主机回收/开/关机/重启”，开发起来比较轻车熟路了，区别于华为云api会返回job状态，azure需要设计新的验证方式如开机成功是ping通，重启是先ping不通后ping通，为了适配原业务逻辑也进行了很多思考，当然代码是zhib重构的
4 “公有云主机邮件发送”，指的是进行了主机“开/关机/申请/回收”操作后，发送邮件提醒执行状态，对此我前后憋出四五版方案，之所以复杂是做触发式方案“触发时”需要考虑因素较多且互相影响，最后做的定时任务扫描工单表，简化了发送条件并且更好理解
国庆后，我开始了influxdb的备份与恢复的开发:<
我先是进行了influxdb本身功能的简单验证，尝试去理解这个跨多系统的工作流程以及每个系统里的业务逻辑，非常艰难地搭起开发环境，开发的同时补上了k8s、linux等能力，目前备份部分已经验证通过；
这个过程中，我深刻的理解到要把时间要花在关键的事情上，比如做好调研和理清需求是重要的，全面对齐上下游验证自己的猜想是耗时痛苦的，而写代码本身应该是快乐而短暂的:> 
特别要感谢zhup老师对我的赋能，他提供了从技术文档编写、需求本身分析和开发技能补齐的全套帮助 --></li>
<li>总的来说，这五个月以来，我作为团队和开发领域的新人，得到了循序渐进的挑战和成长。了解到如何作为团队中的一个成员进行开发，能够理清一些比较复杂的业务逻辑，能够尝试进行调研和方案设计 ~<br>相比于<strong>赋能团队</strong>，我觉得更多的是还我自身需要补齐能力；也许目前开发效率低，本质是对业务的不熟悉和开发技能的缺失，但是除了我觉得提升开发能力，还应该具备产品思考的能力，<strong>服务客户</strong>。我的汇报就到这里。<!-- <img src="https://leo710aka.github.io/bk/md.jpg" width="450" height="300" alt=""> --></li>
</ul>
<h2 id="12-27-成长对话"><a href="#12-27-成长对话" class="headerlink" title="12.27 成长对话"></a>12.27 成长对话</h2><ol>
<li>本年度关键战役及成果产出<!-- **MOPS开发任务**：
1 华为云主机开/关机/重启自动化：进行了华为云api的验证并接入代码，对开发环境和流程有了基本认识，学会将需求拆分进行开发和逐步验证。
2 Azure公有云主机申请自动化：开发初期遇到文档和会议理解上的困难，沟通后明确需要配置参数构造Azure主机申请报文，发送至作业平台完成自动化主机创建和标准化，经过与前端、运维同事协同开发上线，申请数达20+。
3 Azure公有云主机回收/开/关机/重启自动化：区别于华为云api会返回job状态，为Azure任务设计了新的验证方式，如开机成功是能够ping通主机，重启是先ping不通后ping通，并为适配原业务逻辑进行了代码重构。
4 公有云主机邮件发送：为公有云消息通知功能设计了多版方案，最终采用定时任务扫描工单表的方式，以工单执行状态和执行时间作为邮件发送条件，简化了发送条件且便于理解和维护，发送邮件数达40＋。
**DBEngine开发任务**：
1 InfluxDB备份与恢复：先进行了InfluxDB Cluster实例导入导出功能的验证，确定了先导出物理备份文件后上传OSS的技术方案，功能分别接入 apiserver，bakserver，agent 各系统，在配置开发环境及开发验证的过程中补齐了K8s、Linux等能力；目前备份功能进入联调阶段，同步开发备份集恢复功能。 --></li>
<li>面对未来1-2年的职业规划<br>作为团队和开发新人，在这个阶段希望能锻炼自己的专业能力，补齐开发所需地各项能力，积累实战经验，能够快速开发需求和输出文档；而从需求开发和解决问题的经验中抽象出能力，无非就是在沟通时抓住重点，开发时做到极致，这也许就是院长所说的“复杂的事情简单化，简单的事情复杂化”；<br>除了专业能力的提升，还应该具备产品侧思考的能力，对一个系统有深入的认知，能够独当一面，做到专精一个领域。</li>
<li>希望提升的1-3项核心能力项，计划如何提升<br>1 快速学习的能力。通过自主学习&#x2F;经验复用，辨别需求开发中问题的关键，快速掌握解决问题所需能力，不企图全面构建知识体系<br>2 时间管理的能力。目前，需求开发中实际用于写代码的时间很少，大部分的时间用于串联和验证已知或猜测的信息，对齐上下游，这也许是因为对开发环境、业务的不熟悉和开发技能的缺失。另外，由于当前需求开发很依赖他人的讲解，做到高效提问，不耽误他人时间也是很重要的。以及要学会在开发中预留buffer，在实际开发中提高效率。<br>3 精确表达的能力。描述调研方案或解释曾做过的功能时，往往没法在当时呈现所有的思考结果。在对齐需求和协同开发中，有时会抓不住重点，重复提问，效率不高。需要向同事请教如何提升这项能力。</li>
<li>上级总结<br>24年成果：<br>1）mops完成2个公有云的主机开&#x2F;关机&#x2F;重启自动化的能力研发<br>2）完成数据库influxdb的备份和恢复任务开发<br>做的好的：<br>1）作为应届生有一定的主动性，对于不懂的积极学习<br>2）能够在同学指导下完成工作<br>待改进：<br>1）技术能力需要加强和提升，需要快速学习新技能<br>明确员工亟待提升的核心能力，并为其制定成长计划：需要提升代码开发基本技能，加强基础学习</li>
<li>more thinking<br>无法独立开发，效率低，代码量少；问人很正常，在群里问，卡点，同步领导；值班，锻炼解决问题的能力；长期发展，先补齐技能，有好奇心，，提高工作日效率，边工作边学习成长，，<strong>用心，真诚</strong> ：_<br>阶段目标、、开发效率，高级开发，项目管理<br>2024：校招，旅行，吉他<br>2025：职场，矫正，足球<br>【程序员如何快速成长，这几点值得重点参考，我只教一遍！】 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1bK4y1B7rj">https://www.bilibili.com/video/BV1bK4y1B7rj</a><br>【【社区分享】程序员宝藏推荐！提升天花板！覆盖学生到架构师！】 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Ta411s7ij/">https://www.bilibili.com/video/BV1Ta411s7ij/</a><br>【建议收藏，高级开发如何提升产品能力！我常用的5个网站！】 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1y2C3YpEaL/">https://www.bilibili.com/video/BV1y2C3YpEaL/</a></li>
</ol>
<h2 id="2025-01-16-试用期转正答辩汇报"><a href="#2025-01-16-试用期转正答辩汇报" class="headerlink" title="2025.01.16 试用期转正答辩汇报"></a>2025.01.16 试用期转正答辩汇报</h2><ul>
<li><strong>尊敬的领导、各位同事：</strong></li>
<li>大家好！我是蔡枫，今天非常荣幸能在这里与大家分享我在试用期的工作成果和心得。【翻页】我将从试用期工作内容、工作改进点、下季度工作计划以及问题与建议，四个方面进行汇报。【翻页】</li>
<li><strong>试用期工作内容</strong><br>这段时间，我主要参与到两个项目中：分别是MOPS公有云自动化和InfluxDB服务化。<br>我首先接触到Mops华为云和Azure两个云厂商公有云主机的 “开&#x2F;关机&#x2F;重启&#x2F;申请&#x2F;回收自动化” 的需求，在业务熟悉的同时，进行了云主机运维功能的完善。以及，我参与到influxdb服务化开发，目前实例备份与恢复功能已开发完成，并将逐步支持其他功能。【翻】</li>
<li>；）<!-- 1 华为云主机开/关机/重启自动化：七月份入职后，第一个需求做的是 “华为云主机开/关机/重启自动化”，我在同事的指导下开展了工作，先是进行了华为云主机相关api的验证，在理解了现有 “云管-MOPS_backend-云厂商API” 流程后接入代码业务逻辑，并学习了技术文档的撰写。这个过程中，我对开发环境和流程有了基本认识，学会将需求拆分进行开发和逐步验证。
2 Azure公有云主机申请自动化：然后是 “Azure公有云主机申请自动化”，开发初期遇到文档和会议理解上的困难，跟不上进度，沟通后明确需要配置参数构造Azure主机申请报文，发送至作业平台完成自动化主机创建和标准化，这个过程中接触到与运维同事的协同开发，与前端同事的联调验证，azure主机申请数达30+。
3 Azure公有云主机回收/开/关机/重启自动化：区别于华为云api会返回任务执行状态，为 “Azure主机开/关机/重启/回收自动化” 任务设计了新的验证方式，如开机成功是能够ping通主机，重启是先ping不通后ping通，并为适配原业务逻辑进行了代码重构。【翻】
4 公有云主机邮件发送：随着对公有云主机业务的逐渐熟悉，发现存在着问题是公有云主机在执行自动化任务后，无法自动通知用户或运维人员进行后续处理。为了解决这一问题，我为公有云消息通知功能设计了多版方案。触发式方案指是在获得任务状态的同时判断工单执行状况，成功需要通知用户，失败则通知运维人员进行检查；但存在着触发条件复杂，且互相影响的问题？？。。定时任务方案则是直接以工单状态为判断条件，简化了发送条件且便于理解和维护。发送邮件数达60＋。【翻】
5 InfluxDB备份与恢复：十月份后，我参与到influxdb数据库的服务化开发。面对influxdb备份恢复能力欠缺，无法保障高可用的问题背景，我首先在测试环境实例上验证了开源InfluxDB Cluster的读写/备份/恢复功能，设计了技术方案。具体来说，InfluxDB Cluster实例支持导入导出功能，选择一个数据节点导出备份文件，再将其上传至OSS，实现实例备份；而实例恢复功能需要在创建的新实例中，从OSS下载并导入所选备份集的数据，并恢复相关元数据。在开发实例备份功能时，我花费大量时间在agent代理、bakserver中控服务代码业务逻辑的理解上，以及k8s运维工作的熟悉中，了解了工作流和Helm Chart的配置和使用，进行了分步验证和联调测试。有了前期调研经验和开发技能的熟悉后，后续我快速开发了备份集恢复功能：将工作拆分为restore工作流开发、agent开发和bakserver接入三部分。首先，参考create工作流，我完善了restore工作流，即在创建新实例的同时从备份集恢复数据；然后在agent框架式代码中实现了备份集导入实例逻辑；而对于bakserver我在有经验后明白通用业务逻辑中的接入往往变动不大，开发速度也比一开始快乐很多。这段时间里，我主动和团队成员对齐进度，主动讨论需求实现中的问题，给出自己的方案见解，最后的功能上线环节对我来说，也是不小的挑战，更加深入的理解了开发工作。。这个过程中，我深刻的理解到要把时间要花在关键的事情上，比如做好调研和理清需求是重要的，全面对齐上下游验证自己的猜想是耗时痛苦的。我由此对整个服务化工作有了进一步了解，为后续开发工作打好基础。【翻】 --></li>
<li><strong>试用期工作改进点</strong><br>在试用期间，我意识到需要首先要提高代码能力。在需求开发的过程中，我逐渐熟悉开发环境和流程，初步掌握验证和联调方法。作为团队和开发新人，在这个阶段希望能锻炼自己的专业能力，积累实战经验，能够快速开发需求和输出文档；<br>同时，我补充了运维相关的能力，学习并通过实践掌握了K8s，Linux相关知识和基本操作，为后续工作打下坚实基础。<br>以及在做需求，协同开发的过程中，我增强了沟通理解的能力，学会从需求开发和解决问题的经验中抽象出能力，要能在沟通时抓住重点，开发时做到极致。【翻】</li>
<li><strong>下季度工作计划</strong><br>接下来，我计划完善和支持InfluxDB实例集恢复、扩容、重搭等功能，以进一步提升系统的高可用性。<br>总的来说，通过Kubernetes集群和Helm Chart等实现了对InfluxDB集群的高效管理。用户可以通过DataMars控制台方便地进行实例的备份恢复和配置变更，同时支持扩容重搭以应对业务需求的变化。工作流引擎负责处理用户请求并调用相应的Helm Chart模板、通用或专有的apiserver接口等，确保操作的自动化和一致性。相信有了前期开发经验，我能够更快的进行后续的开发产出。【翻】</li>
<li><strong>问题及建议</strong><br>最后，希望提出一些建议。首先，在新人指引方面，我认为前期培训缺少技术方面的指引，可能导致新员工在后续开发中理解比较费劲，上手难度大。建议组织开展包括开发流程、开发环境搭建、代码规范等内容的培训，确保新员工能够快速融入。其次，关于文档落实，我发现一些技术文档内容不够详尽，导致无法自行定位问题，需要频繁联系文档编写者。对此首先我应该提高自己的文档撰写水平，确保能够让人快速理解整体流程，找到问题所在，并及时更新文档内容。</li>
<li><strong>总结</strong>(的)来说，在各位同事的帮助下，我在试用期间得到了快速成长，收获颇丰。【翻页】以上就是我的汇报内容。感谢各位领导和同事的聆听和支持。我相信，在大家的共同努力下，我们的工作会取得更大的进步。谢谢大家！</li>
</ul>
<h2 id="1-16-InfluxDB服务化-：备份集恢复"><a href="#1-16-InfluxDB服务化-：备份集恢复" class="headerlink" title="1.16 InfluxDB服务化 ：备份集恢复"></a>1.16 <em>InfluxDB服务化</em> ：备份集恢复</h2><p>1.02：不上心<br>1.14：开发uat自测(sit没测)完成，开发分支合dev提测，最后合main上线<br>1.16：SD&#x2F;GA测试发版失败，恢复工作流需要人工介入验证，存在问题 1地址没有<strong>动态配置！！</strong> 2漏配接口&#x2F;审批流变更<br>1.21：发布修复版本，生产延后</p>
<h2 id="2-7"><a href="#2-7" class="headerlink" title="2.7"></a>2.7</h2><p><em><strong>复工</strong></em><br>当前阶段的关键，，交付能力，，工程能力是练出来的<br>熬夜是没有对明天的期待、、-》培养兴趣转移注意力、，books<br>程序员。技术。不要只看自己的一亩三分地。。开源项目<br>工作以外；：给自己创造需求，根据需求解决问题，在解决问题上配合看书，，从而在某一细分领域有知识图谱，有一技之长，用系统性的看书代替cdsn查找零散的解决方案<br>“下班的时间放在哪哪里就有提升”<br>副业？；web3；licai</p>
<p>dataMars服务架构理解</p>
<ol>
<li>apiserver：1 datamars管控接口 2 mcloud回调接口 3 properties获取apiserver服务自身暴露的域名端口+controller接口拼接url</li>
<li>apiserver-{engine}：引擎专有服务，工作流(其实是workflowclient处理)中调用不同服务暴露的接口(common,,influxdb,,apiserver)</li>
<li>bakserver&#x2F;metaservice&#x2F;xx-agent：其他服务，由rpc&#x2F;grpc暴露服务</li>
<li>调用架构：api、v1、v2<!-- <img src="https://www.helloimg.com/i/2025/03/01/67c1e151bda80.jpg" width="450" height="300" alt=""> --></li>
<li>服务架构：通过Kubernetes集群和Helm Chart等实现了对InfluxDB集群的高效管理。用户可以通过DataMars控制台方便地进行实例的备份恢复和配置变更，同时支持扩容重搭以应对业务需求的变化。工作流引擎负责处理用户请求并调用相应的Helm Chart模板、通用或专有的apiserver&#x2F;k8srepository接口等，确保操作的自动化和一致性。<!-- <img src="https://www.helloimg.com/i/2025/03/01/67c1e14b13f0e.jpg" width="450" height="300" alt=""> --></li>
</ol>
<p>todo 手画图</p>
<h2 id="2-18-InfluxDB服务化-：本地变配"><a href="#2-18-InfluxDB服务化-：本地变配" class="headerlink" title="2.18 InfluxDB服务化 ：本地变配"></a>2.18 <em>InfluxDB服务化</em> ：本地变配</h2><p>2.6-2.16：现有InfluxDB集群实例（只考虑data节点）的CPU、内存和存储资源已无法满足需求，需对资源配置进行扩展，以提升性能和稳定性。通过修改StatefulSet中cpu、memory配置并删除Pod触发StatefulSet控制器重建data节点Pod以应用新配置，通过修改data节点Pod对应的pvc中storage配置以触发pv的存储扩容（只能增加），实现资源变配（本地变配）<br>2.17：前端对齐开发，准备进入sit联调<br>2.18：插入需求“meta节点自定义创建”<br>2.28：整合已知信息已读代码-&gt;无法理解多节点类型实例如何发起变配，应该果断求助<br>3.3-3.10：改造influxdb集群为父子实例模式，改配置，传参调试，适配已有功能，考虑存量实例的影响<br>3.11-3.13：data变配基础上开发meta变配，云管订单遇到配额不匹配问题，上线延期下周<br>3.14：跨团队求助无果，请求协助，，新需求着手开发<br>3.17：搁置，开发新需求<br>3.18：实操tidb复现该“问题”，考虑转向与云管沟通。。<br>3.27：发版 &#x3D;》InfluxDB父子实例改造&#x2F;本地变配&#x2F;节点&#x2F;实例重启</p>
<h2 id="2-22"><a href="#2-22" class="headerlink" title="2.22"></a>2.22</h2><p><em><strong>正畸, 启动</strong></em><br>读书时无所事事的日子，今天拔完牙和妈妈一起冰敷等待的日子，还有多少<br>刚开始普遍很难，易的是背八股，难的是落实和推进<br>如何跳出这个困境？如何跳出程序员行业？30岁，35岁<br>熬夜是因为没有对明天的渴望。但是在晚上的当下，有很多事情想做😿<br>喜欢一个人独处，是因为不想自己长期以来形成的情绪稳定被打破。害怕形成亲密关系，有时无法融入团体😿</p>
<h2 id="2-27-InfluxDB服务化-：实例创建自定义Meta节点规格"><a href="#2-27-InfluxDB服务化-：实例创建自定义Meta节点规格" class="headerlink" title="2.27 InfluxDB服务化 ：实例创建自定义Meta节点规格"></a>2.27 <em>InfluxDB服务化</em> ：实例创建自定义Meta节点规格</h2><p>2.18：本需求作为其他需求开发的前置条件<br>2.19：apisever打log上uat调试创建流程，从已部署分支git branch新分支以免影响正在使用者<br>2.21：提sql变更 1 dataspace提工单 2 直接进入各环境metadb(其本身为容器部署的mariadb服务) 3 某些配置项可通过datamars控制台修改<br>2.25：云管运营端商品信息变更，考虑是否影响<strong>存量实例</strong>；；1 云管释放旧实例将计价报错-&gt;调datamars管控接口释放&#x2F;发版前释放旧实例 2 可以发起工单但无法下单-&gt;手动修改配额发起工单后过云管审批<br>2.27：发版流程、、代码合master，流水线打包使用（<strong>发版版本</strong>）部署，<strong>sql变更</strong>（定时，增加条件避免误订正），<strong>云运营变更</strong>（改一次console-cloud即各环境共用）<br>Steven👨‍🦲：裁员，残酷，危机感，，工作就是生活的很大一部分</p>
<ol>
<li>meta规格，配置到instance_spec，engine &#x3D; “InfluxDBMeta”<br>| 场景 | 规格代码 | CPU 核数 | 内存 (GB) | 存储 (GB) | 网络带宽 |<br>|————–|———————–|———-|———–|———–|————|<br>| 小型集群 | influx-meta-small | 2 | 4 | 50 | 中等 |<br>| 中型集群 | influx-meta-medium | 4 | 8 | 50 | 高 |<br>| 大型集群 | influx-meta-large | 8+ | 16 | 50 | 超高 |<br>| 特大型集群 | influx-meta-xlarge | 16+ | 32 | 50 | 超高 |</li>
<li>apiserver实例创建逻辑<br>meta信息通过request.getExtraJson()传入，ClusterInstanceService#initClusterInstanceExtend保存在cluster_instance_extend；initClusterInstanceParams能适配保存meta节点的param吗（iops，连接数，influxdb不考虑？）<br>不考虑在cluster_instance要新增字段体现meta规格信息</li>
<li>apiserver-influxdb工作流完成实例创建，pv，sts，helm，install，node，instance<br>获取meta规格信息，构造临时value文件，生成用于安装InfluxDB集群的Helm命令并执行</li>
<li>以上只是在k8s环境中实现了自定义meta规格创建，事实上应该参考tidb，将influxdb集群改造为父子实例模式，逻辑上把data&#x2F;meta节点区分开，进行变配&#x2F;更新meta信息..</li>
<li><strong>more to concern?</strong> param创建，变更？extend父子实例数量不一致？实例创建流程，sts，副本，顺序。。</li>
</ol>
<h2 id="3-3-阶段目标-：入职半年"><a href="#3-3-阶段目标-：入职半年" class="headerlink" title="3.3 阶段目标 ：入职半年 .."></a>3.3 阶段目标 ：<em>入职半年 ..</em></h2><p>deepseek：数据库方向是一个值得长期投入的领域，尤其适合对系统底层感兴趣的程序员。你的现有经验（运维+K8s）可成为切入云数据库或分布式数据库的跳板。建议以<strong>​“运维需求驱动内核学习”​</strong>为短期目标，逐步掌握分布式一致性、存储引擎等核心技术，同时通过开源贡献和项目实践构建技术影响力。&#x3D;&gt; <a target="_blank" rel="noopener" href="https://yuanbao.tencent.com/bot/app/share/chat/c6b48985efa0c1101e5c6ae18c867724">https://yuanbao.tencent.com/bot/app/share/chat/c6b48985efa0c1101e5c6ae18c867724</a><br>rong teng：在midea得到的成长是显著的；（身兼开发运维多职，具体求职情况如何？）数据库方向有些窄；（作为senior求职需要专精时显得窄？作为基础能力学习可行？）应届生可以提转方向，转团队；以招聘市场心仪岗位的需求作为努力发展的方向！？</p>
<ul>
<li>快速了解MySQL<br>1.MySQL45讲 <a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100020801">https://time.geekbang.org/column/intro/100020801</a>  特点中文、有音频、快速了解相关背景<br>2.高性能MySQL <a target="_blank" rel="noopener" href="https://book.douban.com/subject/23008813/">https://book.douban.com/subject/23008813/</a><br>3.MySQL技术内幕（InnoDB存储引擎）<a target="_blank" rel="noopener" href="https://book.douban.com/subject/24708143/">https://book.douban.com/subject/24708143/</a><br>4.官方MySQL Internals Manual： <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/internals/en/guided-tour.html">https://dev.mysql.com/doc/internals/en/guided-tour.html</a><br>5.阿里云mysql内核月报：<a target="_blank" rel="noopener" href="http://mysql.taobao.org/monthly/">http://mysql.taobao.org/monthly/</a><br>6.Polardb-X知乎专栏：<a target="_blank" rel="noopener" href="https://www.zhihu.com/org/polardb-x">https://www.zhihu.com/org/polardb-x</a></li>
<li>数据库架构<br>1.Architecture of a Database System 网上有中文翻译： <a target="_blank" rel="noopener" href="http://dblab.xmu.edu.cn/sites/default/files/files/linziyu-Architecture%20of%20a%20Database%20System%28Chinese%20Version%29-ALL.pdf">http://dblab.xmu.edu.cn/sites/default/files/files/linziyu-Architecture%20of%20a%20Database%20System%28Chinese%20Version%29-ALL.pdf</a><br>2.红宝书：<a target="_blank" rel="noopener" href="http://www.redbook.io/">http://www.redbook.io/</a><br>3.数据库系统实现：<a target="_blank" rel="noopener" href="https://book.douban.com/subject/4838430/">https://book.douban.com/subject/4838430/</a><br>4.Database Internals 有中文书籍：<a target="_blank" rel="noopener" href="https://book.douban.com/subject/35078474/">https://book.douban.com/subject/35078474/</a></li>
<li>通过以上书籍可以了解整体架构，数据库整体可以分为共识算法、存储引擎、事务处理（单机、分布式事务）、数据分析（执行引擎、分析引擎）<br>共识算法：<br>1)Paxos协议(basic paxos、multi paxos等） 蚂蚁金服Oceanbase实现了Paxos<br>paxos-simple.pdf  <a target="_blank" rel="noopener" href="https://lamport.azurewebsites.net/pubs/paxos-simple.pdf">https://lamport.azurewebsites.net/pubs/paxos-simple.pdf</a><br>paxos made live.pdf <a target="_blank" rel="noopener" href="https://www.cs.utexas.edu/users/lorenzo/corsi/cs380d/papers/paper2-1.pdf">https://www.cs.utexas.edu/users/lorenzo/corsi/cs380d/papers/paper2-1.pdf</a><br>2)Raft协议，本质上是Paxos的简化   开源版本ETCD使用的是raft共识算法、TiKV使用的复制算法最开始是改写的etcd的raft库<br>raft.pdf <a target="_blank" rel="noopener" href="https://raft.github.io/raft.pdf">https://raft.github.io/raft.pdf</a><br>存储引擎：<br>LSM Tree（LevelDB、RocksDB)<br>InnoDB引擎<br>单机事务（MySQL InnoDB事务可见性实现原理）<br>分布式事务<br>Percolator.pdf <a target="_blank" rel="noopener" href="https://www.usenix.org/legacy/event/osdi10/tech/full_papers/Peng.pdf">https://www.usenix.org/legacy/event/osdi10/tech/full_papers/Peng.pdf</a></li>
<li>实战<br>1.从0到1数据库内核实战教程 <a target="_blank" rel="noopener" href="https://open.oceanbase.com/activities/4921877">https://open.oceanbase.com/activities/4921877</a><br>2.MariaDB原理与实现  <a target="_blank" rel="noopener" href="https://book.douban.com/subject/26340413/">https://book.douban.com/subject/26340413/</a><br>3.字节云数据库架构设计与实战 <a target="_blank" rel="noopener" href="https://ke.segmentfault.com/course/1650000041697934/section/1500000041697942">https://ke.segmentfault.com/course/1650000041697934/section/1500000041697942</a><br>4.MySQL 原理与实践 <a target="_blank" rel="noopener" href="https://ke.segmentfault.com/course/1650000023669742/section/1500000023669752">https://ke.segmentfault.com/course/1650000023669742/section/1500000023669752</a></li>
<li>论文<br>Polardb计算存储分离论文<br>TiDB: a Raft-based HTAP database： TiDB 2020 VLDB上的文章，介绍TiDB的架构<br>Polardb-X分布式数据库论文<br>Spanner: Google’s Globally-Distributed Database: Google的tp数据库<a target="_blank" rel="noopener" href="https://www.usenix.org/system/files/conference/osdi12/osdi12-final-16.pdf%E2%80%8Bwww.usenix.org/system/files/conference/osdi12/osdi12-final-16.pdf">https://www.usenix.org/system/files/conference/osdi12/osdi12-final-16.pdf​www.usenix.org/system/files/conference/osdi12/osdi12-final-16.pdf</a><br>F1: A Distributed SQL Database That Scales 大G的F1系列<a target="_blank" rel="noopener" href="http://www.vldb.org/pvldb/vol6/p1068-shute.pdf%E2%80%8Bwww.vldb.org/pvldb/vol6/p1068-shute.pdf">http://www.vldb.org/pvldb/vol6/p1068-shute.pdf​www.vldb.org/pvldb/vol6/p1068-shute.pdf</a><br>Amazon Aurora: Design Considerations for High Throughput Cloud-Native Relational Databases; 亚马逊的Aurora</li>
<li>快速了解kubernetes<ol>
<li>深入剖析kubernetes(geek)：<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100015201?tab=catalog">https://time.geekbang.org/column/intro/100015201?tab=catalog</a></li>
<li>kubernetes operator：<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/extend-kubernetes/operator/">https://kubernetes.io/docs/concepts/extend-kubernetes/operator/</a></li>
<li>kubernetes 入门资料：kubernetes概述、kubernetes-operator机制、k8s scheduler framework</li>
<li>容器网络插件：kube-ovn 、calico、Flannel、Weave、CNI</li>
<li>社区开源经典容器管理项目：tidb-operator、flink-operator</li>
<li>社区开源多k8s集群管理项目：kamada、clusternet</li>
<li>kubernetes 集群管理平台：kubesphere</li>
</ol>
</li>
<li>快速了解中间件、基础技术<ul>
<li>Spring cloud技术<ol>
<li>spring-cloud 中文文档：<a target="_blank" rel="noopener" href="https://www.springcloud.cc/spring-cloud-greenwich.html">https://www.springcloud.cc/spring-cloud-greenwich.html</a></li>
<li>spring-cloud API网关（gateway）：<a target="_blank" rel="noopener" href="http://c.biancheng.net/springcloud/gateway.html">http://c.biancheng.net/springcloud/gateway.html</a></li>
<li>spring-cloud 配置中心（Consul）：<a target="_blank" rel="noopener" href="https://www.springcloud.cc/spring-cloud-consul.html">https://www.springcloud.cc/spring-cloud-consul.html</a></li>
<li>spring-cloud 统一配置、服务注册和发现（Nacos）：社区git、what is nacos</li>
</ol>
</li>
<li>API网关<ol>
<li>APISIX：社区git、快速指南、插件开发</li>
<li>Kong：社区git、入门blog</li>
<li>nginx-ingress：nginx官网 ingress手册</li>
</ol>
</li>
<li>Spring <ol>
<li>官方手册</li>
<li>spring framework手册 <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-api">https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-api</a></li>
</ol>
</li>
<li>Springboot <a target="_blank" rel="noopener" href="https://www.springcloud.cc/spring-boot.html">https://www.springcloud.cc/spring-boot.html</a></li>
<li>Reids 推荐书籍：《Redis入门指南 （第2版）》、《Redis设计与实现》</li>
<li>Nginx <a target="_blank" rel="noopener" href="https://www.cnblogs.com/54chensongxia/p/12938929.html">https://www.cnblogs.com/54chensongxia/p/12938929.html</a></li>
</ul>
</li>
</ul>
<h2 id="3-13-AI编程助手：codetip"><a href="#3-13-AI编程助手：codetip" class="headerlink" title="3.13 AI编程助手：codetip"></a>3.13 AI编程助手：codetip</h2><p>代码可以看作是一种特殊的prompt，用于引导AI生成高质量的代码提示；开发者有目的地编写代码，实是为AI提供清晰的意图上下文。<br>代码补全 需要让AI理解意图；技巧 提供具体示例，遵循规范和语义化，规范注释；“内联对话”<br>代码对话 本地工程理解@workspace，RAG增强<br>最佳实践 </p>
<p>todo 体验cursor</p>
<h2 id="3-17-InfluxDB服务化-：实例-节点重启"><a href="#3-17-InfluxDB服务化-：实例-节点重启" class="headerlink" title="3.17 InfluxDB服务化 ：实例&#x2F;节点重启"></a>3.17 <em>InfluxDB服务化</em> ：实例&#x2F;节点重启</h2><p>3.17：简单需求，父子workflow + k8s资源控制器<br>3.18：接口配置：接口信息查看mariadb已有的相同接口，其他信息参考influxdb自身的其他接口；前端联调完成<br>3.19：提测，发版：发版分支一周内进行 1 代码扫描-安全扫描 2 安全-软件成分-Web漏洞-灰盒，解决漏洞；代码仓库设置发版分支，史诗中关联所涉及仓库，检索其发版分支的扫描报告，手动关联web漏洞测试报告，质量门禁达标以通过安全卡点</p>
<h2 id="3-24-从零实现Kubernetes环境下的InfluxDB自动化登录工具：Bash与Java的跨语言实践"><a href="#3-24-从零实现Kubernetes环境下的InfluxDB自动化登录工具：Bash与Java的跨语言实践" class="headerlink" title="3.24 从零实现Kubernetes环境下的InfluxDB自动化登录工具：Bash与Java的跨语言实践"></a>3.24 从零实现Kubernetes环境下的InfluxDB自动化登录工具：Bash与Java的跨语言实践</h2><ul>
<li>背景与需求分析<br>在云原生环境中，InfluxDB集群常以StatefulSet形式部署于Kubernetes。运维人员需要频繁执行以下操作：<br>动态选择特定Data Pod；解密存储在Secret；通过交互式命令登录数据库。<br>手工操作存在效率低下、易出错等问题。本工具通过Bash脚本整合Kubernetes CLI、Java加解密等能力，实现全流程自动化。</li>
<li>技术方案设计亮点<ol>
<li>混合编程模式（Bash+Java）<br><strong>核心难点</strong>：GCM解密在纯Bash环境难以实现（openssl版本低(不会升级…) 没有aes-256-gcm工具）<br><strong>创新方案</strong>：编写Java脚本，动态生成Java解密类（图1），通过Java标准加密库实现AES-GCM解密<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成随机类名避免冲突</span></span><br><span class="line">CLASS_NAME=<span class="string">&quot;InfluxDecryptor_<span class="subst">$(mktemp -u XXXXXXXXXX | tr -dc &#x27;a-zA-Z0-9&#x27;)</span>&quot;</span></span><br><span class="line"><span class="comment"># 编译并执行Java代码</span></span><br><span class="line"><span class="keyword">if</span> javac <span class="string">&quot;<span class="variable">$TEMP_JAVA</span>&quot;</span>; <span class="keyword">then</span></span><br><span class="line">    auth_output=$(java -<span class="built_in">cp</span> /tmp <span class="variable">$&#123;CLASS_NAME&#125;</span>) </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$auth_output</span>&quot;</span>  </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Java编译失败&quot;</span></span><br><span class="line">    <span class="built_in">return</span> 1</span><br><span class="line">  <span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
凭证安全处理机制：<br>• 使用临时文件存储解密代码（<code>TEMP_JAVA=&quot;/tmp/$&#123;CLASS_NAME&#125;.java&quot;</code>）<br>• 执行后立即清理编译产物（<code>rm -f &quot;$TEMP_JAVA&quot;</code>）<br>• 避免敏感信息持久化</li>
<li>跨语言参数传递<br>动态生成的Java脚本中，选择标准输出+格式控制方案：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;USERNAME:&quot;</span> + username.trim()); </span><br><span class="line">System.out.println(<span class="string">&quot;PASSWORD:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(decrypted).trim());</span><br></pre></td></tr></table></figure>
多行输出解析难题<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误示例：初始方案采用`IFS`分割导致变量截断</span></span><br><span class="line">IFS=: <span class="built_in">read</span> username password &lt;&lt;&lt; <span class="string">&quot;<span class="variable">$credentials</span>&quot;</span> </span><br></pre></td></tr></table></figure>
<strong>优化方案</strong>：bash脚本中，使用sed精确提取java脚本输出，通过正则表达式过滤前后空格，避免不可见字符影响<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">credentials=$(get_auth <span class="variable">$1</span>) <span class="comment"># get_auth()动态生成java解密脚本并多行输出</span></span><br><span class="line"><span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;解密失败，无法登录&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 提取用户名和密码（处理多行输出）</span></span><br><span class="line">username=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$credentials</span>&quot;</span> | sed -n <span class="string">&#x27;s/^USERNAME://p&#x27;</span> | sed <span class="string">&#x27;s/^[[:space:]]*//;s/[[:space:]]*$//&#x27;</span>)</span><br><span class="line">password=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$credentials</span>&quot;</span> | sed -n <span class="string">&#x27;s/^PASSWORD://p&#x27;</span> | sed <span class="string">&#x27;s/^[[:space:]]*//;s/[[:space:]]*$//&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>交互式Pod选择器<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">select_data_pod</span></span>() &#123;</span><br><span class="line">    <span class="comment"># 过滤带data标签的Pod</span></span><br><span class="line">    PODS=$(kubectl get pod -n <span class="variable">$NAMESPACE</span> | grep <span class="string">&quot;data&quot;</span> | awk <span class="string">&#x27;&#123;print $1, $6&#125;&#x27;</span>)</span><br><span class="line">    <span class="comment"># 构建交互式菜单</span></span><br><span class="line">    <span class="keyword">select</span> pod_option <span class="keyword">in</span> <span class="variable">$PODS</span>; <span class="keyword">do</span></span><br><span class="line">        SELECTED_POD=$(<span class="built_in">echo</span> <span class="variable">$pod_option</span> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>传递方案对比：<table>
<thead>
<tr>
<th>方案</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>文件存储</td>
<td>实现简单</td>
<td>存在安全风险</td>
</tr>
<tr>
<td>环境变量</td>
<td>进程内可见</td>
<td>长度受限</td>
</tr>
<tr>
<td><strong>标准输出</strong></td>
<td>无持久化风险</td>
<td>需严格格式控制</td>
</tr>
<tr>
<td>网络传输</td>
<td>适合分布式</td>
<td>增加复杂度</td>
</tr>
</tbody></table>
<blockquote>
<p>本项目完整代码已开源，读者可通过<a target="_blank" rel="noopener" href="https://github.com/example/influxdb-helper">GitHub仓库</a>获取最新版本。在Kubernetes运维领域，通过灵活组合各类工具实现自动化，是提升效率的关键路径。</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h2 id="3-28-InfluxDB服务化-：节点迁移-重搭"><a href="#3-28-InfluxDB服务化-：节点迁移-重搭" class="headerlink" title="3.28 InfluxDB服务化 ：节点迁移 &#x2F; 重搭"></a>3.28 <em>InfluxDB服务化</em> ：节点迁移 &#x2F; 重搭</h2><p>3.28：需求分析-&gt;将pod迁移到集群的另一个资源充足的node上，并且恢复数据以及集群功能(元数据)<br>3.31-4.1：存量实例问题处理,, 建议客户使用改造后的influxdb实例，存量实例释放&#x2F;启停&#x2F;重启等功能遇到问题 &#x3D;》未考虑好适配<br>4.2-4.7：出方案 1 sts指定亲合度规则以在指定node重建pod和pvc 2 开源influxdb-cluster功能不完全支持，考虑从分片副本层面恢复数据<br>4.8-4.10：数据恢复的主要思路&#x3D;》从健康节点的分片副本copy-shard恢复出迁移节点原有的所有分片副本，?质疑-&gt;恢复过程中健康节点的分片副本持续写入的增量数据能否恢复??<br>4.11：考虑创建第3个Data-Pod替代迁移节点(从仍健康的迁移节点上迁移数据)× -&gt;应该认为原节点完全不可用（相当于节点重搭了）设计方案参考其他数据库产品；；<br>4.14：推方案不动..自验证copy-shard达到预期效果，但无法解答原理，，自测方式还需模拟实际场景，多线程写入。。<br>4.15：写bash脚本批量写，开多终端模拟多线程，分片副本达70M+大流量2000point&#x2F;s写 &#x3D;》copy-shard恢复出分片副本与健康节点持续写的副本md5值不一致，恢复副本export文件小，猜测丢失数据<br>4.17：InfluxDB Data节点迁移方案评审：先迁移后逐个恢复分片数据。已验证在分片副本大小70M、写入数据达2000point&#x2F;s的情况下直接copy-shard会导致增量数据丢失，考虑在copy-shard前先执行truncate-shards截断热分片（集群中所有写入最新数据的分片，截断后关闭写入，变成冷分片），并在所有Data节点上创建该分片的新热分片副本，也就是在迁移节点上恢复了全部原有分片的新热分片副本，最新数据写入这个副本，然后再逐个从健康节点上的冷分片副本copy-shard恢复出分片的历史数据（迁移前分片副本原有的数据&amp;迁移过程中未能写入的数据），该分片数据完全恢复；自测符合预期<br>4.18-4.21：开发。发现原checkPodRebuildReady接口有时不符合预期，执行influxd-ctl指令(硬写成String在代码中)有时失效(meta no leader..)，经常需要手工介入。。<br>4.22：提测<br>4.23：InfluxDB开源版可靠性不确定，，社区版，单节点，，开发，值班暂停<br>官方文档 <a target="_blank" rel="noopener" href="https://influxdb-v1-docs-cn.cnosdb.com/influxdb/v1.8/introduction/install/">https://influxdb-v1-docs-cn.cnosdb.com/influxdb/v1.8/introduction/install/</a><br>开源influxdb-cluster源码 <a target="_blank" rel="noopener" href="https://github.com/chengshiwen/influxdb-cluster">https://github.com/chengshiwen/influxdb-cluster</a></p>
<!-- <img src="https://www.helloimg.com/i/2025/04/23/6808e34c40fe2.png" width="450" height="300" alt=""> -->
<p><strong>Data节点迁移方案</strong></p>
<ol start="0">
<li>重启所有meta节点，避免后续执行influxd-clt指令时报错“no leader”</li>
<li>记录待迁移Data节点上的分片副本信息</li>
<li>迁移节点，sts加affinity节点调度规则，重建pod和pvc，完成后恢复sts</li>
<li>分片数据和元数据完全丢失，backup工具缺失，考虑逐个恢复分片副本</li>
<li>迁移节点重新加入集群 influxd-ctl remove&#x2F;add-data</li>
<li>截断热分片truncate-shards（集群中所有写入最新数据的分片），在所有Data节点上创建该分片的新热分片副本，也就是在迁移节点上恢复了原有分片的热分片副本，新数据写入这个副本</li>
<li>再从健康节点上的冷分片副本copy-shard恢复出分片的历史数据（迁移前分片副本原有的数据&amp;迁移过程中未能写入的数据），该分片数据完全恢复</li>
<li>检查分片恢复情况</li>
</ol>
<p><strong>故障矩阵：</strong> 架构 &#x3D;&gt; 2 data 3 meta 副本因子为2</p>
<ol>
<li>挂1个data -&gt; 节点迁移、重搭</li>
<li>挂2个data -&gt; 备份恢复</li>
<li>挂1个meta -&gt; 未知</li>
<li>挂两个meta -&gt; 未知</li>
<li>挂三个meta -&gt; 未知</li>
</ol>
<h2 id="4-14-DB值班开始"><a href="#4-14-DB值班开始" class="headerlink" title="4.14 DB值班开始 ; )"></a>4.14 DB值班开始 ; )</h2><p>DBCLOUD开源DB报警群（实例），DBEngine告警群（机器），致命告警-&gt;数据库值班告警处理群，MariaDB&#x2F;MySQL&#x2F;MongoDB&#x2F;PostgreSQL 常见问题,,</p>
<ul>
<li>MariaDB容器数据盘使用率过大<br>1.异常内容:容器数据盘占用率超过90%<br>2.问题定位：<br>1）&#x2F;var&#x2F;lib&#x2F;mysql 目录下存在大量临时文件（如 #sql_1_44.MAD，大小达185G）<br>2）show process 查看未提交的长事务（WITH RECURSIVE 查询和 Sending data 状态，确认这些递归查询正在生成大临时表）持有临时表资源，导致文件无法自动清理。<br>3.处理方案<br>1）KILL 15443008, 15443009, 15443010; &#x2F;&#x2F; 终止进程（替换为实际ID）临时kill了超长事务连接，临时文件自动清理了（&#x2F;var&#x2F;lib&#x2F;mysql挂载点空间得到释放）<br>2）联系用户优化sql</li>
<li>MariaDB实例备库IO线程停止<br>1.告警内容<br>实例 IO 线程停止.通常由于无法连接到主库.<br>2.问题定位：<br>1）服务可用性-&gt;观察到发生主从切换，发生时间符合告警情况<br>2）kubectl get pod -n mariadb -Lrole -Lhealthy-&gt;从库（原主库切换而来）健康为no<br>3）kubectl descirbe 从库pod，观察到mysql container发生terminated，OOMKill，，<br>4）监控指标：内存缓慢提升-&gt;考虑扩容，暴增-&gt;dataspace诊断看慢sql<br>3.处理方案<br>1）备库重搭<br>2）联系用户扩容&#x2F;优化慢sql</li>
</ul>
<h2 id="4-22-2025成长对话"><a href="#4-22-2025成长对话" class="headerlink" title="4.22 2025成长对话"></a>4.22 2025成长对话</h2><ul>
<li><p>制定2025年度重点工作计划。<br>快速开发InfluxDB服务化需求，持续优化已有功能；深度熟悉开源数据库，确保提供稳定服务。对齐其他数据库产品，了解用户实际需求，多方面考虑设计方案。做好值班任务。</p>
</li>
<li><p>希望提升的1-3项核心能力项，计划如何提升。<br>1 深入技术栈学习。阅读InfluxDB源码，学习数据库架构设计，K8s应用课程等，掌握高频业务场景的原理和运维技巧。<br>2 高效合作开发的能力。在全面思考，明确需求后开始开发，遇到卡点快速解决。</p>
</li>
<li><p>面向未来1年的职业规划。<br>本岗位沉淀<br>在这个阶段希望提高自己的工程能力，能比较全面地思考设计方案，快速开发和交付需求；还应该具备产品侧思考的能力，对一个系统有深入的认知，能够独当一面，做到专精一个领域。</p>
</li>
</ul>
<h2 id="4-23-Mops需求：NBU备份自动化"><a href="#4-23-Mops需求：NBU备份自动化" class="headerlink" title="4.23 Mops需求：NBU备份自动化"></a>4.23 Mops需求：NBU备份自动化</h2><p>4.25-5.8：手动验证全流程+调通API，分阶段做，卡点及时同步到群聊.. 官网找接口文档&#x2F;厂家提供，postPolicies接口参数调不好，就先手动设好用get查出来构造requestBody..<br>5.9-5.13：理清自动化接入和改造方案（先看一期代码，考虑接口和表能否复用），主动拉评审会议<br>5.14-5.16：开发及时理清需求原型和改造点，开发备份域配置管理界面<br>5.19-5.23：重难点&#x3D;》作业平台下发备份客户端安装ansible脚本改造，根据传参when指定不同task，实现在target主机安装指定平台的client，expect实现交互式流程<br>5.26-5.29：NBU备份申请自动化开发，实现BackupNbuService（备份平台NBU涉及代码，构造RestTemplate调API）；备份域配置“增删改查”，分页，模糊查询，@Transation处理先删后插&#x2F;先改后改&#x2F;先删后删。。延期-&gt;0605<br>6.3：自测&#x3D;》页面上发起请求获得requestBody&#x2F;通过postman调用本地起的后端服务，调试&#x3D;》注释排查法&#x2F;计算器debug<br>6.4：发sit，延期-&gt;0612；完善todo<br>6.5：自测，业务验收，ddl&amp;dml(注意StringEncryptor加密的密钥随env变化!!) 发版，存在问题待完善<br>11.13：<code>ToB</code>客户验收（产品化环境开发、、接入客户环境、、）</p>
<ol start="0">
<li><em>统一运维平台：</em>就是接各种需求，把主机创建、备份等操作自动化</li>
<li>Ansible入门：脚本在特权机上，指定targetIp执行，，playbook为入口，roles&#x2F;tasks实现具体逻辑，，安装client注意预检查，常量写在var文件，脚本写在flie&#x2F;script.py通过scp传到target机器执行</li>
<li><strong>CRUD</strong>基本功：1. 分页，baseMapper.selectPage(new Page&lt;&gt;(page, size), getQueryWrapper(req))  2. 模糊查询，queryWrapper.eqIfNotNull(BackupConfigPO::isDeleted, 0).likeIfNotNull(BackupConfigPO::getConfigKey, condition.getBackupRegion())  3. 模糊查询条件涉及表中text类型字段的内容为json，本质还是处理wrapper，queryWrapper.apply(“JSON_SEARCH(config_desc, ‘one’, ‘%” + req + “%’, NULL, ‘$.req’) IS NOT NULL”);</li>
</ol>
<h2 id="6-9-2025年中总结"><a href="#6-9-2025年中总结" class="headerlink" title="6.9 2025年中总结"></a>6.9 2025年中总结</h2><ul>
<li>工作成果<br>1.InfluxDB服务化体系构建<br>完成父子实例模式改造，新增InfluxDBMeta规格体系，实现节点级独立变配能力，为后续节点重启、迁移奠定基础；<br>针对Data节点迁移提出 “热分片截断-冷副本恢复”双阶段法，通过多线程大流量写入压力验证（2000 points&#x2F;s），解决开源工具增量数据丢失问题；<br>参与数据库运维工作。<br>2.NBU备份自动化开发<br>支持备份平台自动化运维需求，开发基于Ansible的客户端安装脚本，整合NBU API，实现备份申请自动化；<br>开发备份域配置管理界面（增删改查+JSON字段模糊查询）</li>
<li>能力提升<br>在InfluxDB服务化需求开发中锻炼了“场景抽象-方案验证”的能力，从寻找开源社区方案到定制化能力开发（如备份集恢复、节点迁移及数据一致性保障），梳理故障矩阵（如单Data宕机、多Meta宕机的应对策略）；在NBU备份自动化需求开发中能够快速上手Ansible脚本，复用已有能力，与用户及时沟通并完成开发。</li>
<li>存在不足<br>数据库开发方面需要积累技术深度，全面考虑方案并推动评审；自动化运维需求开发可以积累解决方案，缩短交付周期。</li>
</ul>
<h2 id="6-12-智能体人才认证（一级）"><a href="#6-12-智能体人才认证（一级）" class="headerlink" title="6.12 智能体人才认证（一级）"></a>6.12 智能体人才认证（一级）</h2><h5 id="0-ChatGPT的基本原理及应用实践分享"><a href="#0-ChatGPT的基本原理及应用实践分享" class="headerlink" title="0. ChatGPT的基本原理及应用实践分享"></a>0. ChatGPT的基本原理及应用实践分享</h5><ul>
<li>what is 大语言模型<br>流式输出（逐字计算概率），基于Transformer神经网络（本质上一个Encoder+Decoder结构，自然语言 ⇄ 机器理解）</li>
<li>why ChatGPT<br>除了卷大模型（参数量）&amp;大数据量，有着更好的交互原因：1 指令微调？ 2 基于人类反馈的强化学习</li>
<li>提示工程 Prompt Engineering<br>提示词尽量简单、明确，最好完整描述以下关键要素：1 指令 2 上下文 3 输入数据 4 输出指示<br>提示词使用技巧：1 明确提出（不）应该做什么  2 提供输出的格式提示 3 使用特殊符号指令将需要处理的文本分开 4 增加示例，少样本提示 5 增加任务角色（Role）或场景</li>
<li>应用场景实践<br>本地知识库问答：从本地知识库构成的文本向量库中搜索相关知识+用户问题 &#x3D;》一个提问（增强Prompt 如：“基于以下知识：{text1}…{textN}，回答：{question}”）&#x3D;》 LLM(如 ChatGLM2、GPT-3.5)读取该 Prompt结合自身语言能力生成最终回答；模型参数提供语言能力，但不存储动态知识。语言模型的“理解能力”本质是参数化的统计规律，通过海量通用文本训练获得。专业领域适配需针对性选择微调或 RAG 策略，二者互补而非互斥。当前技术趋势是：通用大模型作“引擎”，领域知识库作“燃料”，Prompt 工程作“方向盘”，三者协同实现高效、低成本的专业化智能问答。</li>
</ul>
<h5 id="1-学习-LLM"><a href="#1-学习-LLM" class="headerlink" title="1. 学习 LLM"></a>1. 学习 LLM</h5><ul>
<li>大语言模型 LLM 的“理解能力”来源：参数、训练与概率生成<ol>
<li>60亿参数的本质<br>参数是什么？神经网络中神经元连接的权重值（浮点数矩阵），例如 ChatGLM2-6B 的 60 亿参数即其网络权重总量。<br>参数如何产生？通过海量无监督预训练：模型从数万亿 token 的通用文本（网页、书籍、百科等）中学习语言统计规律。例如：GPT-3 训练数据：45TB 原始文本 → 过滤后 570GB，包含近万亿 token；训练目标：预测文本中遮蔽词（如 “猫喜欢抓__” → “老鼠”）或续写句子。  </li>
<li>参数如何实现“理解”？<br>概率建模：LLM 本质是概率生成器。给定输入文本，模型计算下一个词的概率分布（如 “天空是___” → “蓝色”概率 80%，“绿色”概率 0.1%）；<br>上下文编码：通过 Transformer 的自注意力机制，模型捕捉长距离依赖（如代词指代、逻辑关联）；<br>知识内化：训练中高频出现的知识（如 “水的沸点是 100°C”）被编码到参数中，形成“通用知识库”。  </li>
<li>训练成果与参数的关系<br>训练完成后的参数 &#x3D; 固化后的语言规律与知识表示；<br>生成过程：根据输入 Prompt 的语义，激活相关参数路径，按概率生成符合语言习惯的文本。</li>
</ol>
</li>
<li>专业领域模型训练：微调 vs. 知识库增强<ol>
<li>全参数微调（Full Fine-tuning）<br>方法：在领域数据上继续训练模型，更新全部参数（如用医疗文献训练 ChatGLM2）；<br>效果：模型深度内化领域知识，生成更专业、连贯的文本；<br>成本：需大量领域数据（GB 级）和 GPU 算力（如 8×A100 训练数天）。  </li>
<li>高效参数微调（PEFT）<br>方法：仅训练少量新增参数（如 LoRA、Adapter），冻结原模型参数；<br>优势：节省 90% 算力，适合中小机构；<br>适用场景：领域术语适应（如法律条文格式），但无法新增未训练过的知识。  </li>
<li>知识库增强（RAG）的定位<br>核心价值：无需训练模型，直接注入动态更新的领域知识（如企业最新产品文档）；<br>局限：依赖检索质量，复杂推理能力受限于 LLM 本身。</li>
</ol>
</li>
<li>DeepSeek 之所以能广泛回答各领域问题，并非因为对所有领域都做过“专门训练”，而是通过大规模通用预训练 + 领域增强技术 + 智能调度机制实现的；<ol>
<li>基础：海量通用预训练（广度覆盖）<br>DeepSeek 的底层模型（如 DeepSeek-R1）在训练初期使用数万亿 token 的互联网公开文本，覆盖科技、教育、历史、文化、生活、基础学术等广泛领域。<br>效果：模型能对大多数常识性问题生成合理回答，类似一个“受过通识教育的聪明助手”。</li>
<li>增强：垂直领域优化策略（深度强化）为提升专业领域表现，DeepSeek 采用以下技术实现“泛中求精”：<br>混合专家模型（MoE）：模型内部划分多个“专家子网络”（如医疗、法律、编程等），根据问题自动激活相关专家；<br>领域微调（Fine-tuning）：对金融、法律、医学等专业领域，用高质量数据二次训练模型，优化参数<br>检索增强生成（RAG）：对动态知识（如实时政策、企业数据库），通过外部知识库检索最新信息，再生成答案；  </li>
<li>调度：智能路由与知识管理<br>动态路由机制：用户提问时，模型自动判断问题类型，分配至：  通用知识层（如“水的沸点是多少”）；专业模块（如“心肌梗死的最新诊疗指南”）；  外部检索（如“2025 年光伏产业新政策”）。<br>知识更新与纠偏：用户反馈可修正错误答案（如律师指出法律条文解读偏差）；  结合知识图谱持续更新事实库，减少“知识过期”问题。</li>
<li>用户建议：如何获得更专业回答？<br>明确领域身份：     提问时声明“以金融分析师身份，分析光伏产业趋势”，引导模型调用专业模块。<br>开启深度思考模式：     对逻辑问题（如数学、编程），勾选“深度思考（R1）”提升推理质量。<br>补充专业资料：     上传领域文档（如论文、手册），用 RAG 增强答案准确性。<br>微调定制专家：     企业用户可通过 LoRA 微调，训练专属领域模型（如“医疗问诊助手”）。</li>
</ol>
</li>
</ul>
<h5 id="2-大模型提示词工程基础"><a href="#2-大模型提示词工程基础" class="headerlink" title="2. 大模型提示词工程基础"></a>2. 大模型提示词工程基础</h5><ul>
<li>提示词基本要素<ol>
<li>指令：想要模型执行的特定任务或指令</li>
<li>上下文：包含上下文信息，引导模型更好地响应</li>
<li>输入数据：用户输入的内容或问题</li>
<li>输出指示：指定输出的类型或格式</li>
</ol>
</li>
<li>提示词工程进阶技术<ol>
<li>少样本提示：可以作为一种提示词，以启用上下文学习，我们在提示中提供演示以引导模型实现更好的性能。</li>
<li>链式思考（CoT）提示：提出问题的同时提供自己的推理方法，供LLM学习参考</li>
<li>检索增强生成（RAG）：如本地知识库问答。从本质上讲，RAG包括一个检索组件、一个外部知识数据库和一个生成组件。整体流程：RAG需要从外部知识数据库中获取文档，然后将这些文档与用户的查询一起被传输到LLM，用于生成响应</li>
<li>自动推理并使用工具 (ART)：？接到一个新任务的时候，从任务库中选择多步推理和使用工具的案例。在测试中，调用外部工具时，先暂停生成，将工具输出整合后继续接着生成。</li>
<li>自我反思（Reflexion）：？自我反思是一个通过语言反馈来强化基于语言的智能体的机制。<br>• 在高层次上，自我反思将来自环境的反馈（自由形式的语言或者标量）转换为语言反馈，也被称作 self-reflection，为下一轮中 LLM 智能体提供上下文。<br>• 这有助于智能体快速有效地从之前的错误中学习，进而提升许多高级任务的性能。</li>
</ol>
</li>
</ul>
<h5 id="3-如何从0-1开展Prompt工程项目"><a href="#3-如何从0-1开展Prompt工程项目" class="headerlink" title="3. 如何从0-1开展Prompt工程项目"></a>3. 如何从0-1开展Prompt工程项目</h5><ul>
<li>Prompt就是给AI的指令，引导大模型生成响应回答。<br>进阶例子：“现在你是一名xx专家，以下是xx内容，你的任务是对内容进行xxx，让我们一步一步做：1. 做&#x2F;不做xx 2. 以json格式输出… 3. …”</li>
<li>什么是Prompt工程？<br>是业务服务应用大语言模型的中枢，用于释放LLM的能力，包括 1）单个任务的Prompt撰写调试 2）多个任务Prompt的设计组合<br>如：撰写短视频文案 &#x3D;》 1. 分析热门文案 2. 结合商品信息生成文案</li>
<li>Prompt工程开展方式<br>根据生成的可行性与效果，明确对模型的输入、输出目标，经设计&#x2F;调试后，生成效果达成业务目标后，固化为应用服务。</li>
</ul>
<h2 id="6-20-一个尝试：生成编程指令Prompt"><a href="#6-20-一个尝试：生成编程指令Prompt" class="headerlink" title="6.20 一个尝试：生成编程指令Prompt"></a>6.20 一个尝试：生成编程指令Prompt</h2><ul>
<li>你是一个资深编程助手，擅长根据用户诉求生成可执行的编程指令。让我们一步步做：<ol>
<li>将用户诉求拆解为清晰、可执行的原子化步骤。</li>
<li>注意环境适配（例如 Linux&#x2F;macOS 环境优先使用 Bash&#x2F;Python，Windows 环境优先使用 PowerShell）以及进行包依赖的检测。</li>
<li>考虑错误处理，如网络请求需设置超时（例如 ‘timeout 3’）</li>
<li>输出规范，代码必须包含完整可执行结构和注释（每20行至少1个注释）  </li>
<li>按照以下格式返回：{步骤拆解：””，生成程序：””}</li>
<li>不受示例语言的限制，选择最适合的语言实现。</li>
</ol>
</li>
<li>这是一个示例AI问答<br>输入：写一个能够在Linux环境使用的脚本，检测对指定IP和端口是否连通。<br>输出：<br>{<br>步骤拆解：<br>1.参数检查：验证输入参数格式（IP 端口 或 -f 文件）<br>2.端口测试：依次尝试 nc → telnet → &#x2F;dev&#x2F;tcp 三种方式（3秒超时）<br>3.批量处理：支持从文件逐行读取 IP 端口（跳过空行和注释）<br>4.结果输出：直接显示开放&#x2F;关闭状态<br>生成程序：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash -e</span></span><br><span class="line"><span class="comment"># 端口检测工具v2 | 支持: Linux/macOS/Windows(WSL)</span></span><br><span class="line"><span class="comment"># 基础依赖: nc &gt; telnet &gt; /dev/tcp</span></span><br><span class="line"></span><br><span class="line">config_timeout=3  <span class="comment"># 全局超时可配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数: 环境预检</span></span><br><span class="line"><span class="function"><span class="title">check_dependencies</span></span>() &#123;</span><br><span class="line">  <span class="comment"># 检测网络工具链</span></span><br><span class="line">  <span class="built_in">local</span> tools=(nc telnet)</span><br><span class="line">  <span class="keyword">for</span> tool <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;tools[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> ! <span class="built_in">command</span> -v <span class="string">&quot;<span class="variable">$tool</span>&quot;</span> &amp;&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;! 缺少 <span class="variable">$tool</span>, 启用降级模式&quot;</span> &gt;&amp;2</span><br><span class="line">      <span class="built_in">return</span> 1</span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">  <span class="built_in">return</span> 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数: 端口检测 (带双超时)</span></span><br><span class="line"><span class="function"><span class="title">test_port</span></span>() &#123;</span><br><span class="line">  <span class="built_in">local</span> ip=<span class="variable">$1</span> port=<span class="variable">$2</span></span><br><span class="line">  <span class="comment"># 方案1: nc (Linux/macOS)</span></span><br><span class="line">  <span class="keyword">if</span> nc -z -w <span class="string">&quot;<span class="variable">$&#123;config_timeout&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$ip</span>&quot;</span> <span class="string">&quot;<span class="variable">$port</span>&quot;</span> 2&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">return</span> 0</span><br><span class="line">  <span class="comment"># 方案2: /dev/tcp (跨平台)</span></span><br><span class="line">  <span class="keyword">elif</span> <span class="built_in">timeout</span> <span class="string">&quot;<span class="variable">$&#123;config_timeout&#125;</span>&quot;</span> bash -c <span class="string">&quot;cat &lt; /dev/null &gt; /dev/tcp/<span class="variable">$&#123;ip&#125;</span>/<span class="variable">$&#123;port&#125;</span>&quot;</span>2&gt;/dev/null;<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">return</span> 0</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">return</span> 1</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 主流程</span></span><br><span class="line">[ <span class="variable">$#</span> -lt 2 ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;用法: <span class="variable">$0</span> IP 端口&quot;</span> &amp;&amp; <span class="built_in">exit</span> 1</span><br><span class="line">check_dependencies || <span class="built_in">echo</span> <span class="string">&quot;! 使用基础检测模式&quot;</span> &gt;&amp;2</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> test_port <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="string">&quot;<span class="variable">$2</span>&quot;</span>; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;✅ <span class="variable">$1</span>:<span class="variable">$2</span> 开放&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;❌ <span class="variable">$1</span>:<span class="variable">$2</span> 关闭&quot;</span> &amp;&amp; <span class="built_in">exit</span> 3</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
}</li>
<li>这是用户的正式诉求<br>(输入用户诉求。)</li>
</ul>
<h2 id="6-27-Mops需求：负载均衡变更自动化"><a href="#6-27-Mops需求：负载均衡变更自动化" class="headerlink" title="6.27 Mops需求：负载均衡变更自动化"></a>6.27 Mops需求：负载均衡变更自动化</h2><p>6.27：页面流程理解+看“申请”自动化代码-&gt;考虑改造点，找api，输出文档<br>6.30-7.4：需求对齐，减少开发量的机会，，对于依赖项的变更（healthCheck-&gt;ResourcePool-VirtualServer）采用“蓝绿发布”&#x3D;》先增后删<br>7.5-7.9：开发完成<br>7.10-7.11：自测，前端发起一次请求F12取payload &#x2F; 后端接口处打印入参 + 按需修改 &#x3D;》构造入参，走通流程，只需关注新加的代码（无关逻辑如校验&#x2F;审批代码可以先注释掉。。）<br>7.14：变更成功后回滚。。手动修改+提sql同步配置；思考&#x3D;》是不是可以直接另提一次变更，或者另外提供回滚接口，，总之此时回滚和前一次变更已经没有关联<br>7.17：上线。修复 1 管理员节点自动带出尽可能多参数 2 支持定时执行 3 思考：checkChangeSuccess()方法期望同步response，但方法里调API返回fail会隔10s重复十次，就是一直fail的话接口会隔100s才返回数据，假如加了一个定时任务扫描出待变更工单列表，用for循环执行change()并且各调用了checkChangeSuccess()，会发生什么，for循环卡住？”springboot项目，写了一个变更c…”点击查看元宝的回答<br><a target="_blank" rel="noopener" href="https://yuanbao.tencent.com/bot/app/share/chat/qqYiHTHYRWDv">https://yuanbao.tencent.com/bot/app/share/chat/qqYiHTHYRWDv</a><br>7.29：支持定时执行，注意避免同一个工单被多次扫除(未完成变更后状态-&gt;EXECUTED)，注意调度任务下发到本地节点，可能由于代码版本不同造成“灵异事件”<br>10.16：支持变更页面上的所有参数<br>10.30：支持回收自动化<br>11.13：优化提交工单时校验逻辑，避免重复补工单（按需增加存表字段&amp;管理端加编辑后门）</p>
<ol>
<li>f5理解：F5 BIG-IP 是业界主流的硬件&#x2F;软件负载均衡解决方案。配置好负载均衡后，一个请求从客户端到后端服务器的生效流程涉及多个关键环节，其核心是​<strong>​客户端访问域名 → DNS解析至F5的VIP → F5转发请求至Pool Members → 后端处理并返回响应</strong></li>
<li>Mops服务架构。。用户提交工单-&gt; iflow审批流-&gt; 回调&#x2F;前端调接口-&gt; 传入xxTicketVo-&gt; convert成Dto&#x2F;Po处理业务逻辑</li>
<li>蓝鲸。。统一运维平台竞品</li>
<li>自动化运维开发总结：工单，，提效，，用户，，，</li>
</ol>
<h2 id="6-28-Alibaba-Java开发手册学习"><a href="#6-28-Alibaba-Java开发手册学习" class="headerlink" title="6.28 Alibaba Java开发手册学习"></a>6.28 Alibaba Java开发手册学习</h2><h4 id="1-计算机基础"><a href="#1-计算机基础" class="headerlink" title="1. 计算机基础"></a>1. 计算机基础</h4><h4 id="2-面向对象"><a href="#2-面向对象" class="headerlink" title="2. 面向对象"></a>2. 面向对象</h4><p>解析值。。序列反序列parse，，JSONNode，，</p>
<h4 id="3-代码风格"><a href="#3-代码风格" class="headerlink" title="3. 代码风格"></a>3. 代码风格</h4><ol>
<li>魔法值 &#x3D;&gt; enum</li>
<li>变量一般以小驼峰格式命名，但有一种特殊情况：定义类成员变量时，特别是POJO类中，针对布尔值类型的变量不要以“is”开头，而是将数据表中的“is_xxx”字段映射到POJO类中的属性“Xxx”（如is_deleted &#x3D;》Deleted）</li>
<li>文档注释 &#x2F;** *&#x2F; 加上创建和修改时间，写在代码上方,, Idea怎么配置??</li>
</ol>
<h4 id="4-走进-JVM"><a href="#4-走进-JVM" class="headerlink" title="4. 走进 JVM"></a>4. 走进 JVM</h4><h4 id="5-异常与日志"><a href="#5-异常与日志" class="headerlink" title="5. 异常与日志"></a>5. 异常与日志</h4><ol>
<li>where to throw Exception？who to solve？how solve？<br>如果异常在在当前方法的处理能力范围内且无需透出，就直接捕获异常并处理；否则向上抛出，由上层方法或框架来处理。<br>如果在方法内部处理异常，需根据业务场景定制处理，如重试、回滚（还有 <em>ticketDetail.setExecutionStatus(xxEnum.FAIL)</em> 返回）等操作；如果向上抛出异常，需要在异常对象中添加上下文参数、局部变量、运行环境等消息，便于排查问题。<br>考虑设计业务逻辑，无论在哪一步终止业务，都能让外界感知此时的状态，并保留错误信息（ststus，log）</li>
<li>异常分类<ul>
<li>Error（致命异常），不可控错误，如StackOverFlowError、OutOFMemoryError</li>
<li>Exception（非致命异常）<ul>
<li>checked异常（受检异常）例如：IOException, SQLException。<ul>
<li>无能为力型，如SQLException，只好保存现场人工介入</li>
<li>力所能及型，如发生非授权异常可跳转权限申请页面</li>
</ul>
</li>
<li>unchecked异常（非受检异常）是运行时异常，继承自 RuntimeException，更像是由 <em><strong>业务逻辑</strong></em>可能导致的异常<ul>
<li>可预测异常，如IndexOutOfBoundsException, NullPointerException，应该提前做好边界检查而不是抛出</li>
<li>需捕获异常，如Dubno框架进行RFC调用时产生的超时异常DubboTimeoutException，客户端不能因服务端异常导致不可用，可以重试或降级处理</li>
<li>可透出异常，如Spring框架中抛出的NoSuchRequestHandingMethodException，框架会自行将异常映射到合适的状态码如404</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>throws</strong>关键字用于声明一个方法可能抛出的受检异常（checked）。BusinessException 通常是一个运行时异常，也就是非受检异常，不需要在方法签名中用 throws 声明（显式捕捉和处理），因为它通常表示业务逻辑错误，而不是程序错误。非受检异常的设计目的是让开发者在编写代码时不必显式地捕获或声明它们。<br>但是，仍然需要确保在适当的地方捕获和处理，特别是在应用程序的边界层（如控制器层）进行统一的异常处理。？？</li>
<li>​​防御式编程，可以让方法返回null，，防止空指针异常（NPE）上调用方的责任，需要事先判断</li>
<li>需定位报错行数 → 必须打印 e​​（传入异常对象）会输出完整的堆栈(e.printStackTrace())跟踪，包括类名、方法名、文件名和行号。<br>​​仅需错误描述 → 使用 e.getMessage()​​（适用于前端提示或自定义消息）。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log.error(<span class="string">&quot;查询VirtualServer信息异常：&quot;</span>+e.getMessage(), e);</span><br><span class="line">throw new BusinessException(<span class="string">&quot;查询VirtualServer信息异常：&quot;</span> + e.getMessage());</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="6-数据结构与集合"><a href="#6-数据结构与集合" class="headerlink" title="6. 数据结构与集合"></a>6. 数据结构与集合</h4><h4 id="7-并发与多线程"><a href="#7-并发与多线程" class="headerlink" title="7. 并发与多线程"></a>7. 并发与多线程</h4><h4 id="8-单元测试"><a href="#8-单元测试" class="headerlink" title="8. 单元测试"></a>8. 单元测试</h4><h4 id="9-代码规约"><a href="#9-代码规约" class="headerlink" title="9. 代码规约"></a>9. 代码规约</h4><p>。。</p>
<hr>


<h2 id="7-16-Mops-深度学习———暨Java开发体系构建"><a href="#7-16-Mops-深度学习———暨Java开发体系构建" class="headerlink" title="7.16 Mops 深度学习———暨Java开发体系构建"></a>7.16 Mops 深度学习———暨Java开发体系构建</h2><p>Java如何处理一个请求  <a target="_blank" rel="noopener" href="https://yuanbao.tencent.com/bot/app/share/chat/crOguvwf38jw">https://yuanbao.tencent.com/bot/app/share/chat/crOguvwf38jw</a><br>mops架构熟悉 “如何深入了解当前负责的java项目，在i…”  <a target="_blank" rel="noopener" href="https://yuanbao.tencent.com/bot/app/share/chat/bsqucYK8K9bJ">https://yuanbao.tencent.com/bot/app/share/chat/bsqucYK8K9bJ</a></p>
<h4 id="MOPS-统一运维平台"><a href="#MOPS-统一运维平台" class="headerlink" title="MOPS 统一运维平台"></a>MOPS 统一运维平台</h4><p>打造主机、网络、存储等运维一键操作，支持申请、变更、回收等常见场景，实现工单下发、流程审批、策略下发的逻辑，集成平台API、脚本下发、定时调度、CMDB能力，保证流程清晰、节点可控、异常告警。。<br>负责。。网络管理模块开发，发版小组，值班<br>竞品。。蓝鲸研发运维技术PaaS体系<br>产品化。。定制化功能</p>
<h5 id="Mops"><a href="#Mops" class="headerlink" title="Mops"></a>Mops</h5><p>网络管理模块。。增删改查。。AI code<br>技术实现：多平台用策略模式，加注解实现定时任务调度？<br>解决问题：并发。。</p>
<h5 id="CMDB"><a href="#CMDB" class="headerlink" title="CMDB"></a>CMDB</h5><p>配置数据库<br>mongodb、Elasticsearch<br>运维事实库，，与mops数据同步，订阅。。<br>数据重复。。问题排查</p>
<h5 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h5><p>作业平台，特权机+脚本下发<br>运维入口</p>
<h5 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h5><p>自动化运维&#x3D;》LLM作为“大脑”负责思考和规划，MCP等框架提供标准化的“工具库”，而强大的权限与安全体系则扮演着“交通警察”和“紧箍咒”的角色。这三者的有机结合，使得Agent既能智能地帮我们一步步完成复杂任务，又能被有效地约束在安全、可控的边界之内，从而真正成为一位可靠的数字助手。<br>Serval raises $52M in funding. Learn More <a target="_blank" rel="noopener" href="https://www.serval.com/updates/series-a">https://www.serval.com/updates/series-a</a><br>Spring AI Alibaba 1.0 GA 正式发布，Java智能体开发进入新时代 <a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/1666891">https://developer.aliyun.com/article/1666891</a></p>
<h2 id="7-17-Mops-CMDB发版"><a href="#7-17-Mops-CMDB发版" class="headerlink" title="7.17 Mops &amp; CMDB发版"></a>7.17 Mops &amp; CMDB发版</h2><p>“一个Java系统开发完了，是怎么跑起来…”  <a target="_blank" rel="noopener" href="https://yb.tencent.com/s/jj0KGxxEGgzU">https://yb.tencent.com/s/jj0KGxxEGgzU</a><br>“IDEA调试、线上运行，Maven、SpringCloud…”  <a target="_blank" rel="noopener" href="https://yb.tencent.com/s/GB2sYz5WPHbB">https://yb.tencent.com/s/GB2sYz5WPHbB</a><br>集成，部署 “所谓的微服务实际上是怎么部署的呢…”  <a target="_blank" rel="noopener" href="https://yuanbao.tencent.com/bot/app/share/chat/gt96bRkSxuos">https://yuanbao.tencent.com/bot/app/share/chat/gt96bRkSxuos</a><br>K8S&amp;微服务部署方案 “k8s和springcloud是如何关联…”  <a target="_blank" rel="noopener" href="https://yuanbao.tencent.com/bot/app/share/chat/H2FtlSdK24y1">https://yuanbao.tencent.com/bot/app/share/chat/H2FtlSdK24y1</a></p>
<h4 id="MOPS-开发，测试，发版流程"><a href="#MOPS-开发，测试，发版流程" class="headerlink" title="MOPS 开发，测试，发版流程"></a>MOPS 开发，测试，发版流程</h4><ol>
<li>开发阶段<ul>
<li>main：生产环境稳定分支，仅用于发布，禁止直接修改。</li>
<li>develop：开发&#x2F;测试&#x2F;发版分支，功能合并主干。前一个<code>feature/v1.1.0</code>发版完成后，拉出最多下两个版本的开发分支，如 bugfix&#x2F;v1.1.0和 feature&#x2F;v1.2.0，发版完成后合入线上分支和下一个版本分支。</li>
<li>feature&#x2F;xxx：团队开发各自从develop切出的功能分支，开发完成后合并回去，发sit联调，uat验收，发版。</li>
<li>bugfix：main切出的紧急修复分支，修复后合并至main和当前develop。</li>
</ul>
</li>
<li>测试阶段<ul>
<li>SIT（系统集成测试）：前后端联调测试环境，验证功能集成与基础流程。</li>
<li>UAT（用户验收测试）：预生产环境，业务方验证业务逻辑。关键点：数据与生产环境隔离但配置一致，避免环境差异问题。</li>
</ul>
</li>
<li>发版准备<ul>
<li>发版材料：包含需求清单，DDL&amp;DML，配置变更清单。提交变更实施文档、代码质量报告、版本号（从最新git记录的Copy Revision Number）</li>
<li>SQL变更：提变更单，先DDL后DML，设置发版窗口执行，记录到<code>db文件</code>上传git。</li>
<li>针对本次变更的配置备份、数据备份，确保有完整的回滚步骤。</li>
</ul>
</li>
<li>上线验证<ul>
<li>发版分支打Tag（如feature-v1.33.0，相当于是一个快照，后续再合代码要打新tag）</li>
<li>持续集成（指定tag，发版前提前集成）</li>
<li>检查提的sql是否变更成功（提醒先到uat执行一遍）</li>
<li>持续部署，可分批部署到多节点，减小用户影响（提前到uat部署一遍）<ul>
<li>灰度发布：先切10%流量验证，逐步全量。</li>
<li>蓝绿部署：并行两套环境，切换流量实现零宕机。</li>
</ul>
</li>
<li>流水线：集成＋部署</li>
<li>发版验证：避免业务高峰期发版，异常&#x3D;》监控平台搜“error”排查，以及先回退旧版本（集成旧tag部署）</li>
<li>发版成功：发版分支合到main和下一个版本分支，SQL变更提交到MOPS_SQL</li>
</ul>
</li>
<li>事件管理<ul>
<li>事件指导致或可能导致服务中断或服务质量下降的任一事态</li>
<li>以恢复业务为第一要务，72h内进行根因查找与5C闭环</li>
</ul>
</li>
</ol>
<h4 id="CMDB-部署指令"><a href="#CMDB-部署指令" class="headerlink" title="CMDB 部署指令"></a>CMDB 部署指令</h4><ol>
<li>下发介质（jar包）<br>将服务的可执行文件（通常是一个 .jar ）下发目标服务器。这个 .jar 文件是通过构建工具（如 Maven 或 Gradle）打包生成，包含了应用程序的所有代码、依赖库和资源文件。</li>
<li>停止旧服务<br><code>ps aux | grep $&#123;package_name&#125; | grep java | grep -v grep | awk &#39;&#123;print $2&#125;&#39; | xargs kill -15</code><br>停止正在运行的旧版本服务，释放端口和资源。ps aux：列出所有进程。grep ${package_name}：过滤出与服务相关的进程。kill -15：优雅地终止进程，避免强制终止（kill -9）可能导致数据丢失或资源未释放。</li>
<li>检查进程<br>确认服务进程是否已经成功停止。ps -ef：列出所有进程及其详细信息。grep ${package_name}：过滤出与服务相关的进程。</li>
<li>备份文件<br>在部署新版本之前，备份旧版本的 .jar 文件和相关配置文件，以便在新版本出现问题时可以快速回滚。</li>
<li>下发 OneAgent（监控工具）</li>
<li>配置服务（生成配置文件）<br>通过 Shell 脚本动态生成服务的配置文件（如 application.yml），用于定义服务的端口、文件路径、Redis 配置等。可以根据环境（如开发、测试、生产）动态调整配置。</li>
<li>启动服务<br><code>nohup /usr/bin/java $&#123;C_CMDB_XXL_JOB_EXECUTOR_ONEAGENT_OPTS&#125; -Xms8g -Xmx8g -jar -Dspring.config.location=$&#123;package_path&#125;/application.yml -Djasypt.encryptor.password=abcdefg $&#123;package_path&#125;/$&#123;package_name&#125;.jar &gt; $&#123;package_path&#125;/$&#123;package_name&#125;.log 2&gt;&amp;1 &amp;</code><br>启动 Java 服务，并将日志输出到指定文件。<br>nohup：允许服务在后台运行，即使关闭终端，服务也不会停止。<br>-Xms8g：设置 JVM 的初始堆内存为 8GB。<br>-Xmx8g：设置 JVM 的最大堆内存为 8GB。<br>-Dspring.config.location：指定 Spring Boot 的配置文件路径。<br>-Djasypt.encryptor.password：指定加密配置的解密密码。<br>${package_path}&#x2F;${package_name}.jar：指定要运行的 .jar 文件。<br>日志输出：&gt; ${package_path}&#x2F;${package_name}.log：将标准输出重定向到日志文件。2&gt;&amp;1：将标准错误输出重定向到标准输出。</li>
<li>ps检查服务是否启动成功</li>
</ol>
<h4 id="新增微服务"><a href="#新增微服务" class="headerlink" title="新增微服务"></a>新增微服务</h4><p>“springcloud微服务架构里，每个微服务是单独开发，部署的吗，如何互相发现、调用？如果要新增一个微服务，要做什么工作？有没有“主服务”的概念，所有微服务都要记在主服务的配置文件中？”<a target="_blank" rel="noopener" href="https://yb.tencent.com/s/oL2XPesIhuCx">https://yb.tencent.com/s/oL2XPesIhuCx</a></p>
<h2 id="7-18-MOPS-CMDB运维日志"><a href="#7-18-MOPS-CMDB运维日志" class="headerlink" title="7.18 MOPS &amp; CMDB运维日志"></a>7.18 MOPS &amp; CMDB运维日志</h2><h4 id="Helloworld"><a href="#Helloworld" class="headerlink" title="Helloworld"></a>Helloworld</h4><p>运维人员 -&gt; 办公电脑 -&gt; 访问入口 -&gt; 堡垒机(安全审计核心) &#x2F; 跳板机(简易通道) -&gt; 内网 -&gt; 物理机 &#x2F; Linux后台(应用载体) </p>
<p>Linux基本命令：<br>netstat ; top;  awk ; dstat;  iostat; lsof; free, df；uptime；dmesg ；dig ； nslookup</p>
<p>vim&#x2F;vi的基本快捷命令（gg, shift + g, :n ; dd, :%d ; yy, p ,u等）</p>
<p>终端的一些快捷命令（ctrl + a; ctrl + e）</p>
<h4 id="Zookeeper磁盘占用过高的SOP"><a href="#Zookeeper磁盘占用过高的SOP" class="headerlink" title="Zookeeper磁盘占用过高的SOP"></a>Zookeeper磁盘占用过高的SOP</h4><ol>
<li>告警确认<br>• 监控告警内容：磁盘使用率&gt;80%<br>• 初步排查：通过跳板机连接CMDB主机（FinalShell + SSH）逐层定位，确认Zookeeper目录为占用源头（如&#x2F;apps&#x2F;zookeeper&#x2F;v2）</li>
<li>清理旧日志，并且再次运行 df -h 确认使用率下降。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 确认分区使用率</span></span><br><span class="line"> 98    2025-07-18 17:38:17   <span class="built_in">df</span> -h</span><br><span class="line"> <span class="comment"># 逐步排查子目录 tab自动补齐路径</span></span><br><span class="line"> 99    2025-07-18 17:38:29   <span class="built_in">du</span> sh /apps/svr/*</span><br><span class="line">100    2025-07-18 17:38:38   <span class="built_in">du</span> sh /apps/svr/zookeeper-3.4.6/*</span><br><span class="line">101    2025-07-18 17:38:44   <span class="built_in">cd</span> /apps/svr/zookeeper-3.4.6/data</span><br><span class="line">106    2025-07-18 17:39:16   <span class="built_in">du</span> -sh *</span><br><span class="line">107    2025-07-18 17:39:22   <span class="built_in">cd</span> version-2/</span><br><span class="line"><span class="comment"># 分析日志文件（发现日均61MB未清理）</span></span><br><span class="line">108    2025-07-18 17:39:26   ll</span><br><span class="line"><span class="comment"># 删除两个月前的日志 检查效果</span></span><br><span class="line">109    2025-07-18 17:39:52   find . -<span class="built_in">type</span> f -name <span class="string">&quot;snapshot.*&quot;</span> -mtime +60 -<span class="built_in">exec</span> <span class="built_in">rm</span> -f &#123;&#125; \;</span><br><span class="line">110    2025-07-18 17:39:57   ll</span><br><span class="line">112    2025-07-18 17:40:03   <span class="built_in">df</span> -h</span><br><span class="line">123    2025-07-20 21:50:41   <span class="built_in">history</span></span><br></pre></td></tr></table></figure></li>
<li>告警解除  </li>
<li>Zookeeper日志管理优化<br>配置自动清理：zoo.cfg中启用参数 autopurge.purgeInterval&#x3D;24（每24h清理），autopurge.snapRetainCount&#x3D;7（保留7个快照）<br>日志轮转，集成Logrotate：配置日志按大小&#x2F;时间切割并压缩：<code>/etc/logrotate.d/zookeeper</code> 中设置 daily, rotate 30, compress<br>自动化清理脚本：编写定时任务，每月清理旧日志（保留30天）  &#x3D;&gt;  0 3 * * * find &#x2F;apps&#x2F;zookeeper&#x2F;version-2 -mtime +30 -delete</li>
</ol>
<h4 id="ops-subscribe微服务磁盘占用过高"><a href="#ops-subscribe微服务磁盘占用过高" class="headerlink" title="ops-subscribe微服务磁盘占用过高"></a>ops-subscribe微服务磁盘占用过高</h4><ol>
<li>Java服务（devops部署）堆积日志的情况与中间件（zookeeper是eops部署&#x2F;apps&#x2F;svr目录）有所差异</li>
<li>清理多余日志<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">987    2025-12-04 17:13:46   <span class="built_in">df</span> -h</span><br><span class="line">991    2025-12-04 17:15:44   <span class="built_in">du</span> -sh /apps/devops/*</span><br><span class="line">992    2025-12-04 17:16:04   <span class="built_in">cd</span> /apps/devops/ops-cmdb-subscribe/</span><br><span class="line">993    2025-12-04 17:16:12   <span class="built_in">du</span> -sh *</span><br><span class="line"><span class="comment"># nohup部署命令中指定的服务日志清空掉（但其实还有一份备份）</span></span><br><span class="line">994    2025-12-04 17:17:10   <span class="built_in">echo</span> <span class="string">&quot;&quot;</span> &gt; ops-cmdb-subscribe-1.0.log</span><br><span class="line"><span class="comment"># Java服务本身输出日志（application配置）</span></span><br><span class="line">996    2025-12-04 17:24:27   <span class="built_in">cd</span> /apps/devops/log/ops-subscribe/2025-12-04/</span><br><span class="line">998    2025-12-04 17:24:39   <span class="built_in">ls</span> -alh</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="CMDB回调并发量大导致MOPS飙升CPU"><a href="#CMDB回调并发量大导致MOPS飙升CPU" class="headerlink" title="CMDB回调并发量大导致MOPS飙升CPU"></a>CMDB回调并发量大导致MOPS飙升CPU</h4><ol>
<li>根本原因：回调任务包含查询接口，请求返回慢，并发大导致？？cpu飙升，后续请求直接卡住，服务挂？？不是io型任务开多线程没用</li>
<li>临时方案：1）关闭回调任务，积存任务消化完即可 2）重启mops服务</li>
<li>优化：1）优化cmdb查询接口，加索引 2）避免并发大？。缓存，，</li>
<li>研究。。。</li>
</ol>
<h4 id="CPU高："><a href="#CPU高：" class="headerlink" title="CPU高："></a>CPU高：</h4><ol>
<li>内存fgc导致 —针对进程 oom?<br>先dump，下载heap文件<br>jmap -dump:live,format&#x3D;b,file&#x3D;heap.hprof 1651260<br>通过Eclipse Memory Analyzer (MAT)工具分析heap文件</li>
<li>线程导致<br>找出排查cpu高的线程对应的方法：<br>1）top。找出对应的高cpu的pid<br>2）top -Hp pid。打印出pid里的线程，找出对应的cpu高的线程tid<br>3）jstack -l pid &gt; jstack.txt。打印对应的进程堆栈信息<br>4）printf “%x\n” <TID>。找出对应16进制的线程id<br>5）vi jstack.txt。搜索第4步的线程id，看其方法</li>
<li>机器资源不足。。</li>
</ol>
<h2 id="8-1-Mops需求：DNS变更自动化"><a href="#8-1-Mops需求：DNS变更自动化" class="headerlink" title="8.1 Mops需求：DNS变更自动化"></a>8.1 Mops需求：DNS变更自动化</h2><p>8.1：梳理变更场景，4种记录+2种平台，拆解为每种记录只有增删改三种操作，一步步实现即可<br>8.2-8.10：大假，昆明-大理-贵阳-深圳<br>8.11-8.15：收集＋验证现状，还需拉会议评审<br>8.17：后续每天定 <em><strong>每日计划</strong></em>…<br>0818：DNS变更，确定所有api&#x2F;script（√），方案评审（×）<br>0819：DNS变更主流程（80%）<br>0820：DNS变更主流程（90%）<br>0821：管理端加失败工单入库按钮，当日上线<br>0822-0824：DNS变更开发<br>0825：DNS变更自测(√)，CMDB安全组件安装流程确定(×)<br>0826：DNS变更sit(√)，CMDB安全组件安装(×)<br>0827：DNS变更全流程报错机制完善，1.流程节点失败就报错 2.ticket.setExecutionLog(+&#x3D;新日志) 那么可以全程操作溯源、、成功就直接加，失败throwE在catch里加e.getMessage()<br>0828：涉及定时任务调度&#x2F;异步的要考虑UserContext空指针；上线<br>0908：一键回退主流程开发<br>0916：一键回退上线<br>1016：全面支持mx+txt申请变更回收，通过workspace让AI“模仿”cname自动化来实现<br>1030：支持智能解析，todo-&gt;cmdb字段回写+移动审批带出<br>11.18：产品化需求-&gt;Windows DNS自动化下发，适配进常规DNS下发流程（midea生产和产品化环境通过前端开放不同入口，实现执行不同部分代码，下发不同platform的DNS配置）<br>1202：变更一键回退优化（直接挂回原pool），支持申请回退（即回收掉）</p>
<ol>
<li>当F5设备被配置为该域名的权威DNS服务器时，nslookup查询才会最终指向它。<br>一个域名的权威DNS服务器信息（NS记录）是由其上一级域名注册商管理的（比如.com域名的注册商）。当你在注册商处将域名的NS记录指向你的F5设备（或其管理的DNS服务）后，一个完整的解析流程如下：<br>本地输入 nslookup <a target="_blank" rel="noopener" href="http://www.yourdomain.com/">www.yourdomain.com</a> &#x3D;》本地DNS服务器会从根域名服务器开始，一路查询到.com服务器，最终获知你的域名的权威DNS服务器是你的F5设备 &#x3D;》本地DNS服务器随后向你的F5设备发起查询，并获得F5上配置的IP地址（VIP）返回给用户。</li>
<li>如果不指定记录类型（直接 nslookup example.com），默认查询的是A记录。要查询特定类型，需使用 -qt&#x3D;类型参数</li>
<li>DNS与负载均衡（F5）的配合<br>用户访问 app.example.com-&gt; DNS解析返回F5的VIP（如 203.0.113.10） -&gt; 用户请求到达F5 -&gt; F5根据预设的负载均衡算法（如轮询、最小连接数等）将请求转发给后台的Web服务器池（如 10.1.1.101, 10.1.1.102）</li>
</ol>
<h2 id="8-31-use-Workspace"><a href="#8-31-use-Workspace" class="headerlink" title="8.31 use Workspace"></a>8.31 use Workspace</h2><ol>
<li>基本介绍<br>Workspace是一个基于云端的代码编辑环境，由Cursor提供支持。Cursor是一个AI驱动的代码编辑器，集成了Claude等先进的AI模型，为开发者提供智能编程辅助。在这个环境中，您可以编写代码、获取AI辅助、管理项目并执行基本的开发任务。<br>与IntelliJ IDEA等传统IDE相比，Workspace&#x2F;Cursor有以下主要区别：<br>• <strong>运行环境</strong>：Workspace运行在云端服务器上，而非本地机器<br>• <strong>资源位置</strong>：代码、依赖包和运行环境都位于远程服务器<br>• <strong>功能界面</strong>：相比完整IDE功能较为精简，但集成了强大的AI辅助能力；更简洁，专注于代码编辑和AI交互，类vscode</li>
<li>问答模式<br>• <strong>edit</strong>：结合本地rag，针对代码结构和业务逻辑，返回与工程相关且与上下文相关的答案<br>• <strong>chat</strong>：纯AI对话，回答仅针对上下文相关内容，不涉及对工程的理解<br>• <strong>agent</strong>：智能体的“大脑”与“手脚”，AI Agent的核心目标是​​将自然语言指令转化为一系列具体的、可执行的操作​​，直到任务完成。它不再是简单的聊天或代码补全，而是一个具备自主性的系统。实现从​​任务规划与分解，​​工具调用与执行，​​到自我验证与迭代。适合用来完成相对复杂的任务如：代码重构，错误修复（单文件用edit模式即可），自动化任务（实现文件批量操作、脚本生产）</li>
<li>规则&amp;交互<br>• AI规则：设置个人、工程规则，使AI输出遵循个性化要求；优先级：系统规则&gt;用户规则&gt;工程规则<br>• MCP：连接的“通用协议”，可以理解为AI世界的​​“USB-C标准接口”​​。在MCP出现之前，每个Agent想要连接一个新工具（如数据库、GitHub API），都需要进行大量的定制化开发，而MCP定义了一套统一的通信规范，工具开发者只需按照此标准将工具封装成独立的​​MCP Server​​，任何支持MCP协议的Agent都可以“即插即用”这些工具，极大地降低了开发难度并促进了工具生态的繁荣。<br>• “&#x2F;”加run，fix，explain，&#x2F;CR审查；“@”加devops中的需求、缺陷、任务至chat，、；“#”设置引用知识库</li>
<li>开发流程<br>• 版本管理：图形化操作，或直接用git指令——git branch -a查看所有本地&#x2F;远程origin分支，git checkout -b feature&#x2F;xx origin&#x2F;feature&#x2F;xx从远程分支拉出本地分支，git branch -vv查看本地&amp;远程分支关联情况<br>• 配置Maven：ctrl+shift+p-&gt;打开setting（ui）-&gt;配置path to settings.xml 、依赖包会被下载到远程服务器的Maven本地仓库<br>• 安装Extensions（最接近IntellijIdea2022.3.2的主题-&gt;Darcula Theme_v1.18.1_Rafael Renan Pacheco）<br>• 设置启动参数和环境变量：在.vscode&#x2F;launch.json加配置”configurations”: [{“xx”:”yy”}]，相当于idea里edit Run&#x2F;Debug Configuration<br>• 运行&#x2F;Debug：1）终端输入运行命令 2）chat输入&#x2F;run，回答中返回可执行命令。点击执行<br>• 本地调试：Postman发请求到<a target="_blank" rel="noopener" href="https://caifeng7-31579-.devops.midea.com/xx">https://caifeng7-31579-.devops.midea.com/xx</a></li>
<li>AI coding实践<br>• 从单纯的Programmer转为AI的协作伙伴，提供足够清晰的开发方案，让AI在充分理解后生成代码<br>• 让AI参考现有资源：已有代码、API文档，以及建立和使用知识库；也可以通过MCP读外部文档<br>• 拆解任务，逐个完成，分而治之，，<br>• 尝试约束AI行为，明确输出要求，，配置工程规则，让AI了解项目（chat-&gt;setting-&gt;配置rules.md）<br>• 复用交互模式，优化开发流程</li>
<li>快捷键<br>Ctrl+F: 在当前文件中查找<br>Ctrl+Shift+F: 全局搜索<br>Ctrl+P&#x2F;shift*2（安装idea快捷键插件）: 查找文件<br>Ctrl+Shift+P: 打开Command Palette<br>Ctrl+I：生成代码建议<br>Ctrl+B&#x2F;Ctrl+左键：跳转类<br>Ctrl+alt+B：跳转实现类<br>Ctrl+J&#x2F;Ctrl+&#96;（反引号在tab键上面）：打开终端窗口<br>Ctrl+alt+J：打开chat框</li>
</ol>
<h2 id="10-20-OBCA准备"><a href="#10-20-OBCA准备" class="headerlink" title="10.20 OBCA准备"></a>10.20 OBCA准备</h2><h4 id="MySQL-实战-45-讲-https-time-geekbang-org-column-intro-100020801"><a href="#MySQL-实战-45-讲-https-time-geekbang-org-column-intro-100020801" class="headerlink" title="MySQL 实战 45 讲 (https://time.geekbang.org/column/intro/100020801)"></a>MySQL 实战 45 讲 (<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100020801">https://time.geekbang.org/column/intro/100020801</a>)</h4><ol start="0">
<li>不是要背下所有东西，而是在构建体系后，能快速回忆起来</li>
<li>一条sql查询如何执行？<strong>客户端</strong>-&gt; <strong>Server层</strong>: 连接器-（-查询缓存命中则直接返回）词法&#x2F;语法分析-优化器（执行计划生成,索引选择）-执行器（操作引擎,返回结果）-&gt; <strong>存储引擎</strong>（存储数据,提供读写接口）<!-- <img src="https://www.helloimg.com/i/2025/10/21/68f7a97f73ce3.png" width="450" height="300" alt="一条SQL查询语句是如何执行的？"> --></li>
<li>一条sql更新如何执行？把原数据行从硬盘读到内存（或者在缓存命中）-&gt; 写新数据到新行 -&gt; 引擎将新数据更新到内存并且把这个update操作记录到 <strong>redo log</strong>（InnoDB独有物理日志-&gt;“在某个数据页上做了什么修改”,保证事务的​​持久性 Durability,提供 ​​crash-safe​​ 能力）此时redolog处于 <em>prepare</em> 状态随时可以提交事务 -&gt; 执行器生成这个操作的 <strong>binlog</strong>（Mysql Server层实现的逻辑日志-&gt;“给 ID&#x3D;2 这一行的 c 字段加 1 ”,用于​​主从复制​​和​​数据恢复​,如时间点恢复）并且写入磁盘 -&gt; 执行器调用引擎的提交事务接口，引擎把刚刚写入的redolog改成提交<em>commit</em>状态，更新完成（<code>二阶段提交</code>以保证两份日志保持逻辑一致）-&gt; 两份日志都成功写入磁盘后，被修改的数据页（脏页）并不会立即写入磁盘，而是由 MySQL 在“后台”选择一个合适的时机异步刷盘。<br>​”redolog是如何配合binlog工作的？”<a target="_blank" rel="noopener" href="https://yuanbao.tencent.com/bot/app/share/chat/vVRlFaO0o3sg">https://yuanbao.tencent.com/bot/app/share/chat/vVRlFaO0o3sg</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/68963">https://time.geekbang.org/column/article/68963</a> 事务隔离。事务就是要保证一组数据库操作，要么全部成功，要么全部失败，InnoDB在引擎层支持事务。</li>
<li>索引。MySQL中索引是在存储引擎层实现的。InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树的数据模型中的。每一个索引在 InnoDB 里面对应一棵 B+ 树，N叉树的N以整数字段为例差不多是 1200，树高等于4的情况下就能够存储很多数据，以减少单次查询的磁盘访问次数。根据建立索引的字段不同，索引类型分为（1）主键索引，叶子节点存的是整行数据（2）非主键索引，叶子节点内容是主键的值，还需要回表到主键的B+树二次查询。</li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/69636">https://time.geekbang.org/column/article/69636</a> 根据业务需求建索引，包括了覆盖索引、前缀索引、索引下推，，在满足语句需求的情况下， 尽量少地访问资源是数据库设计的重要原则之一</li>
</ol>
<h4 id="OBCA-认证-https-www-oceanbase-com-training-obca"><a href="#OBCA-认证-https-www-oceanbase-com-training-obca" class="headerlink" title="OBCA 认证 (https://www.oceanbase.com/training/obca)"></a>OBCA 认证 (<a target="_blank" rel="noopener" href="https://www.oceanbase.com/training/obca">https://www.oceanbase.com/training/obca</a>)</h4><p>^^</p>
<h2 id="11-20"><a href="#11-20" class="headerlink" title="11.20"></a>11.20</h2><img src="https://www.helloimg.com/i/2025/11/21/692089497f66d.jpg" width="450" height="300" alt="冬藏春生.团队对话-职业生涯教练.孙小红">
刚刚好找出这张照片，刚好这一天的头发服帖，刚好朋友拍出了不错的构图，脸上也满是生气，好像有勇气冲到一个新的level
但最近我都在跑医院，想着每个周末只是在修复自己的身体和精神，到了工作日又要回去摧残自己..这有什么意义吗
为了回归到这张照片，想了半天得出一个结论是，不断地修复自己到一个刚刚好的状态就是生活的意义，吗
有点虚无，说了但像什么也没说，什么又是一个刚刚好的状态呢
也许是我刚好能够面对相机，刚好拍下了这张照片
也许人置身生活的洪流，只能不断修复自己
也许可以找到互相修复的人


<h2 id="11-30-CMDB-项目运营"><a href="#11-30-CMDB-项目运营" class="headerlink" title="11.30 CMDB 项目运营"></a>11.30 CMDB 项目运营</h2><h4 id="深度参与策略"><a href="#深度参与策略" class="headerlink" title="深度参与策略"></a>深度参与策略</h4><p>接手CMDB,,从做需求-&gt;做系统 <a target="_blank" rel="noopener" href="https://yuanbao.tencent.com/bot/app/share/chat/920NVAbsqwtm">https://yuanbao.tencent.com/bot/app/share/chat/920NVAbsqwtm</a><br>最大化CMDB项目的学习价值,, <a target="_blank" rel="noopener" href="https://yuanbao.tencent.com/bot/app/share/chat/SzQrsGlsuz88">https://yuanbao.tencent.com/bot/app/share/chat/SzQrsGlsuz88</a></p>
<ul>
<li>理解CMDB系统本质与行业实践<ul>
<li>核心价值：CMDB（配置管理数据库）是IT服务的“中枢神经”，存储所有配置项（CI）及其关系，唯一事实库，支撑运维自动化、变更管理等场景。</li>
<li>主流竞品参考：ServiceNow CMDB，企业级SaaS方案，强在ITSM流程集成。腾讯Blue King。开源方案：iTop、CMDBuild。</li>
<li>自研系统关键模块：数据采集 –&gt; 数据建模 –&gt; 关系拓扑 –&gt; API服务–&gt; 可视化平台</li>
</ul>
</li>
<li>通过CMDB项目深挖技术栈，Java底层实践场景：？<ul>
<li>高并发设计：自动发现引擎需处理海量设备扫描（学习Netty异步IO、Disruptor队列）。</li>
<li>JVM调优实战：配置项关系计算需避免Full GC（分析G1日志，调整Eden&#x2F;Survivor比例）。</li>
<li>分布式事务：CI数据跨服务同步（基于Seata AT模式或消息最终一致性）。</li>
</ul>
</li>
<li><strong>云原生技术落地</strong>：<ul>
<li>微服务架构：Apache(SSO登录)-NGINX(反向代理+静态资源)-eruka(服务发现)-zuul(网关分发请求)-各微服务-mongodb主数据库-es(同步数据用于检索)</li>
<li>容器化部署：将CMDB模块拆分为微服务，用Docker打包，K8s调度（学习Pod滚动升级、HPA弹性伸缩）。</li>
<li>可观测性建设：集成Prometheus监控API延迟，Grafana展示拓扑关系健康度。</li>
</ul>
</li>
<li><strong>以CMDB为杠杆撬动技术纵深</strong>：CMDB是运维体系的“核心数据枢纽”，其复杂场景（数据一致性、分布式调度）是修炼Java底层和云原生的绝佳沙盒。</li>
<li>📊 <strong>项目经验如何写入简历</strong><table>
<thead>
<tr>
<th><strong>简历模块</strong></th>
<th>平庸写法</th>
<th><strong>高价值写法（量化+技术关键词）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>项目经验</strong></td>
<td>参与CMDB需求开发</td>
<td>主导CMDB数据模型重构，设计弹性CI架构，支持200+动态属性扩展，模型变更效率提升40%</td>
</tr>
<tr>
<td><strong>技术亮点</strong></td>
<td>使用Spring Cloud开发API</td>
<td>基于Quartz+Netty开发高并发自动发现引擎，单节点支持5000+设备&#x2F;秒采集</td>
</tr>
<tr>
<td><strong>业务价值</strong></td>
<td>提升系统稳定性</td>
<td>通过拓扑影响分析模块，故障定位时效从30min缩短至5min，年止损运维成本200万+</td>
</tr>
</tbody></table>
</li>
</ul>
<blockquote>
<p>💡 简历筛选口诀：<strong>“技术深度×业务影响”双突出</strong>——避免写“增删改查”，聚焦架构设计、性能优化、跨系统集成。</p>
</blockquote>
<h4 id="CMDB-交接分享"><a href="#CMDB-交接分享" class="headerlink" title="CMDB 交接分享"></a>CMDB 交接分享</h4><ul>
<li>整体理解<br>CMDB（配置管理数据库）是IT基础设施与应用配置项的集中存储库，为运维、自动化、各业务系统提供数据支撑。<br>数据组织：以配置项（模型就是配置项相当于表）的形式组织各类数据，支持通过模型管理灵活变更字段，通过关系拓扑进一步展开数据间的关系。<br>数据使用：支持白屏化检索、维护数据，导入导出，支持查看历史版本，涉及”管理员”字段（管理员信息维护数据字典）自动发起变更流程；对外提供数据连接器（配置项增删改查）、消费视图能力，通过API读写数据；数据订阅服务通过监控oplog触发回调任务；数据审计（数据传入传出、消费视图审计，数据归档）<br>数据更新：通过定时任务+采集脚本实现配置项信息的自动发现。<br>数据治理：数据质量（自动校验异常数据），IP治理，EAM对账（定时任务拉取数据获取差异并展示）<br>系统管理：支持配置用户角色以获得不同权限，对界面上的用户操作有审计记录。</li>
<li>服务运维<br>内部部署：devops主机部署微服务，数据库mongo、es由DBA运维<br>日常运维：看监控数据；从监控查到服务部署的主机，登陆，查看java服务，重启？<br>私有化部署：微服务组件、数据库都以镜像打包，服务化部署，k8s运维</li>
<li>系统架构与组件<ol>
<li>用户通过访问CMDB域名解析到F5资源，经过F5跳转后进入系统。Apache主要负责单点登录功能，配置文件中可以设置跳过认证的URL。</li>
<li>Nginx作为反向代理，将请求转发到网关。网关通过注册中心获取服务IP，并根据负载均衡策略选择微服务节点。前端资源部署通过流水线将打包文件放到指定文件夹，静态资源无需进程管理。</li>
<li>CMDB主服务（OPS_CMDB）处理大部分页面请求，代码结构复杂，接口查询逻辑需通过页面查找。MongoDB ：主数据库，集群模式，一主一从一隐藏，读写分离。</li>
<li>数据连接器服务提供外部API，用户通过登录获取token后访问。查询和写入数据需经过参数验证和限流控制（默认1000条）。数据入库前会经过多层级校验（如选项值、关联字段等），采用责任链模式实现。高频接口涉及大量衍生查询，需谨慎修改。消费视图提供(多)配置项数据关联+指定字段查询能力。</li>
<li>全文检索服务对接开放搜索，查询时通过缓存获取用户可访问的索引列表，支持高亮和加权排序。mongodb数据通过monscache同步es，根据模型字段值检索。</li>
<li>数据订阅服务通过MongoDB的OP Log捕获数据变更，发送到Kafka后由订阅服务消费并触发后续逻辑（如离职资产交接）。数据质量服务通过配置告警任务，筛出异常数据</li>
<li>定时任务服务通过注解开发新任务，采集代理服务通过Kafka下发脚本并分批处理返回数据。自动采集：xxljob-&gt;ops-syn-task-&gt;kafka-&gt;ansible-&gt;执行消息回调-&gt;kafka-&gt;syn-task入库</li>
<li>用户中心服务处理登录初始化，表头配置服务管理页面表格显示字段，均为低改动频率服务。</li>
<li>组件包版本管理：测试环境用snapshot可随意修改，生产环境需更新release版本号并重新打包部署。</li>
<li>远程Debug需在启动项添加参数，连接UAT环境IP和端口，适用于本地无法模拟的场景（如采集任务）。</li>
</ol>
</li>
</ul>
<h4 id="CMDB-智能助手"><a href="#CMDB-智能助手" class="headerlink" title="CMDB 智能助手"></a>CMDB 智能助手</h4><p><a target="_blank" rel="noopener" href="https://www.vertice.cn/solution-details/26737.html">https://www.vertice.cn/solution-details/26737.html</a><br>llm+rag+mcp</p>
<h2 id="12-11-2025年度总结-成长对话"><a href="#12-11-2025年度总结-成长对话" class="headerlink" title="12.11 2025年度总结&amp;成长对话"></a>12.11 2025年度总结&amp;成长对话</h2><ul>
<li><p>工作成果</p>
</li>
<li><p>能力提升</p>
</li>
<li><p>存在不足</p>
</li>
</ul>
<hr>

<h1 id="02-2027"><a href="#02-2027" class="headerlink" title="02&#x2F;2027"></a>02&#x2F;2027</h1><h3 id="CV"><a href="#CV" class="headerlink" title="CV"></a>CV</h3><ul>
<li><strong>工作经历</strong><br>后端开发工程师-Java <sup>2024.7~</sup></li>
<li><strong>教育经历</strong><ul>
<li>在校经历：曾获学校与企业奖学金, “三好学生”等荣誉，发表 EI 会议论文一篇。曾加入学院青马工程班学习，担任华工青年志愿者指导中心宣传部副部长，有丰富的志愿活动和学生组织经历。</li>
<li>荣誉奖项：五粮液优秀学生奖学金(2023.10)，华南理工大学三等奖学金(2022.09)，广东省第十一届大运会“优秀志愿者”(22.06)<br>2022—2023学年度 “三好学生”×，校级“优秀公益组织骨干”，”青马工程”班优秀学员<br>2021—2022学年度 “三好学生”，“两优两红优秀共青团员”</li>
</ul>
</li>
<li><strong>项目经验</strong><ol>
<li>运维平台（MOPS）自动化开发 &amp; CMDB<br>  • 华为云&#x2F;Azure 主机生命周期管理：实现云主机的创建、开关机、重启自动化，通过调 API 和作业平台接口，减少70%人工<br>  • NBU 备份自动化：通过 Ansible 脚本部署备份客户端，集成备份平台 API，提升备份任务效率 50%。<br>  • 负载均衡（F5）配置自动化：设计蓝绿发布流程，支持参数动态变更和回滚，处理并发场景下的数据一致性。海内外 全集团使用，自动化20%-&gt;80%<br>  • DNS 解析管理：支持 A、CNAME、MX 等记录类型的增删改，集成多平台（Windows DNS产品化），实现一键申请和回退。<br>  • 了解整个系统架构，springboot，，mq，java回收器，，<br>  • 参与 CMDB 数据同步和回调优化，解决高并发场景下的性能瓶颈。</li>
<li>InfluxDB 服务化开发<br>  • 调研开发基于开源influxdb的服务化功能，对齐mariadb，支持创建回收、备份恢复、重启、节点迁移等功能<br>  • 备份恢复功能：集成 OSS 存储和 K8s 运维能力，实现实例级备份恢复，保障高可用性。<br>  • 集群管理：完成 InfluxDB 父子实例改造，支持 Data&#x2F;Meta 节点独立变配和迁移。<br>  • 数据迁移与恢复：设计“热分片截断-冷副本恢复”方案，解决开源工具在增量数据场景下的丢失问题（通过 2000 points&#x2F;s 压力测试验证）。<br>  • 了解k8s云原生环境运维开发？具备常见数据库运维能力，，oom，慢sql，主从切换异常，，</li>
</ol>
</li>
<li><strong>专业技能</strong><br>• 后端开发：熟练掌握 Java、Spring Boot、Spring Cloud、MyBatis，熟悉微服务架构和设计模式。<br>• 数据库与中间件：<br>  • 关系数据库：MySQL、Oracle（事务、索引优化、SQL调优）。<br>  • NoSQL：InfluxDB（集群部署、备份恢复、数据迁移）。<br>  • 消息队列：RabbitMQ（异步任务解耦）。<br>• 运维与云原生：<br>  • 熟练使用 Kubernetes（Pod、StatefulSet、Service）、Docker 部署和管理应用。<br>  • 熟悉自动化运维工具：Ansible（脚本编写）、Jenkins（CI&#x2F;CD流水线）。<br>  • 云平台：华为云、Azure（API集成与资源管理）。<br>• 学习<br>  • 读《马斯克传》后感：.. 读《阿里巴巴Java开发手册》..<br>  • 学《mysql45讲》，通过OBCA？？</li>
</ul>
<h3 id="0"><a href="#0" class="headerlink" title="0"></a>0</h3><ul>
<li><p>自我介绍。<br>面试官您好，我是蔡枫，本科毕业于华南理工大学计算机学院，一年多以来在美的集团从事Java后端开发的工作。<br>我主要接触两方面的工作，目前正在做的是自动化运维平台的开发，面向整个集团的用户提供主机、网络管理相关的服务，类似的竞品有嘉为蓝鲸，我们的工作就是把以往通过管理员手动下发的工作实现流程化、自动化，保证可追溯和甚至可逆。另外，还做了半年的数据库服务化开发，建设InfluxDB的“数据库即服务”（DBaaS）能力，基于开源Influxdb Cluster支持了备份恢复、变配、迁移等功能，但是后期随着对开源数据库的可靠性存在顾虑中断了。</p>
</li>
<li><p>💻 项目一：自动化运维平台开发与产品化</p>
<ul>
<li>我主要负责MOPS开发，面向全集团提供主机、网络运维、备份管理等运维功能，目标是实现运维操作的自动化、流程化和可逆化。本身也是可对外输出的ToB产品，也接触到产品化定制需求的开发和环境部署。独立负责基于F5的负载均衡和域名解析两大模块的自动化功能全生命周期建设，主要是申请、变更、回收和一键回退的场景，基本实现了全自动化。</li>
<li>具体工作与关键技术细节<ol>
<li>自动化流水线设计：我设计了基于 “工单驱动” 的自动化流水线。将用户申请转化为标准化工单，支持 “立即、定时、两阶段” 等多种执行策略，将F5平台的参数与表字段一一对应，调用API、脚本实现策略下发。（特别的，负载均衡变更为创建新pool挂到原vs&#x3D;》蓝绿发布，，记录变更前状态以保证回滚完全。。）</li>
<li>多系统集成与可靠性保障：深度集成CMDB（作为资源事实库）、作业平台（用于脚本下发）等系统。为确保流程可靠，我着重处理了异常控制和回滚机制。所有操作步骤都有明确的状态和日志记录，每一环节的操作都详细记录上下文到日志供排查；下发成功后，支持一定时效内和指定权限人发起一键回退。。</li>
<li>产品化与高可用设计：为支持产品化输出，我对功能进行了抽象和封装，使其能通过配置适配不同客户的环境。通过Powershell脚本另外支持了Windows平台的DNS自动化下发。</li>
</ol>
</li>
<li>市场竞品对比与成果衡量<ul>
<li>对标产品：这项工作在市场上类似嘉为蓝鲸的自动化运维平台或腾讯蓝鲸的相关模块。它们核心价值也在于将复杂的手动操作标准化、自动化，并确保过程可控。</li>
<li>我的成果：<br>效率提升：将F5配置和DNS解析这类操作的平均交付时间从天级缩短到分钟级，全年支持变更超千次。<br>可靠性：通过完善的异常处理和回滚，将因配置失误导致的业务中断事件降低了90%以上。<br>产品价值：直接支撑了该平台作为ToB产品成功落地，获得了客户验收。</li>
</ul>
</li>
</ul>
</li>
<li><p>💾 项目二：InfluxDB数据库服务化能力建设</p>
<ul>
<li>我主导了InfluxDB数据库的服务化改造，在数据库管控平台（DataMars）中，建设InfluxDB的“数据库即服务”（DBaaS）能力，解决手动运维数据库效率低、易出错的问题。基于开源Influxdb Cluster，从0到1负责InfluxDB实例的备份恢复、在线变配、节点迁移&#x2F;重搭等核心功能的调研、设计和开发。</li>
<li>具体工作与关键技术细节<ol>
<li>核心场景实现：<br>备份恢复：调研并采用 influx_inspect export 逻辑备份与OSS对象存储结合方案，实现了数据库级和实例级的备份恢复，并集成到平台的工作流引擎中。<br>在线变配：通过修改Kubernetes StatefulSet配置，实现了CPU、内存的原地变配，以及通过PVC（持久化存储声明）扩容实现存储空间的在线扩展。<br>节点迁移与数据一致性保障：这是项目最大挑战。我设计并实现了 “热分片截断-冷副本恢复”双阶段迁移方案。在数据持续高速写入（2000 points&#x2F;s）的场景下，通过先截断热分片引导新数据写入新节点，再从健康节点同步历史数据，有效解决了开源工具在迁移过程中可能丢失增量数据的问题，确保了数据一致性。</li>
<li>技术架构：功能深度集成到平台的apiserver、bakserver和agent组件中，通过K8S Operator模式对InfluxDB集群的生命周期进行管理。</li>
</ol>
</li>
<li>市场竞品对比与成果衡量<ul>
<li>对标产品：这类数据库服务化平台在业界类似云和恩墨zCloud、腾讯云DBbridge等数据库管理平台，核心是实现数据库资源的池化、按需供给和全生命周期智能化管理。</li>
<li>我的成果：事实上基本没有用户，随着发现开源数据库的功能不完善，开发也中断了。</li>
</ul>
</li>
<li>在面试中介绍时，你可以遵循“背景-行动-结果-对比”的结构：<br>•   开头总结：用一句话点明项目核心价值。<br>•   具体阐述：重点突出你如何解决关键问题，特别是高可用、数据一致性、自动化闭环方面的设计。<br>•   量化成果：用数据（如效率提升百分比、可靠性指标）证明你的贡献。<br>•   展现视野：通过提及竞品，表明你不仅埋头编码，更抬头看路，了解行业最佳实践。</li>
</ul>
</li>
<li><p><strong>技术亮点与难点</strong></p>
<ol>
<li>InfluxDB 节点迁移（2025年4月）<br>  • 难点：开源工具在数据同步时可能丢失增量数据，需自定义解决方案。<br>  • 解决：设计“热分片截断+冷副本恢复”双阶段方案，通过多线程压测验证数据一致性。<br>  • 价值：为分布式数据库的容灾提供了可复用的方法论。</li>
<li>负载均衡&#x2F;F5 配置自动化（2025年7月）<br>  • 难点：并发变更时资源竞争导致配置异常。<br>  • 解决：引入状态机管理工单流程，通过校验机制和回滚逻辑保证安全性。<br>  • 价值：支持每年 1000+ 次变更需求，错误率下降至 1% 以下。<br>  • ？！工程化思维：注重文档、自动化、可维护性（如制定 SOP、设计回滚方案）。</li>
</ol>
</li>
<li><p>为什么要跳槽？<br>？</p>
</li>
<li><p>工作一年以来对Java开发的理解。<br>整体比较符合预期，就是解决实际问题的根据，利用算法&amp;数据结构，实现具体的需求。目前不可避免的陷入在很小的领域（很具体的功能）编写杂七杂八的业务逻辑，但这是总来有执行者来做的工作，我觉得关键是前期方案设计时保证整体的可靠性和通用性（自动化场景1 2 3，平台1 2 3），做需求时总结出sop，或者直接交给AI来做</p>
</li>
<li><p>一个挑战。</p>
<ol>
<li>自动化运维，负载均衡vs&lt;-pool&lt;-server三层结构，改造为支持并发。。立即，定时，同时都有，怎么考虑，，</li>
<li>influxdb服务化，做迁移的时候，把指令全试了一遍</li>
</ol>
</li>
<li><p>一次排查问题。<br>cpu飙升，发现是一个接口有io操作，并发大了就卡住了。。<br>首先，停掉回写接口，把cpu降下来，恢复服务<br>分析，不是计算型的，所以多线程没用，要考虑优化io查询，cmdb加索引。。<br>其次，如何降低并发，加缓存？异步？？</p>
</li>
<li><p>处理线上问题，处理偶现问题<br>。。</p>
</li>
<li><p><strong>为什么tob，为什么2c？中台？</strong><br>不局限tob&#x2F;c，但是要持续学习，保持好奇。做中台就像一个螺丝钉，不断修修补补，比较无趣（运维场景深度待挖掘）</p>
</li>
<li><p>对AI的使用<br>AI Coding使用的主要场景有 1、有过往代码可参考的新需求 2、有API文档的需求<br>运维Agent</p>
</li>
</ul>
<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><ul>
<li>字节跳动·巨量广告<ul>
<li>面试辅导<br>  为什么捞出一年经验的校招生，有什么期待？</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/07/%E7%BE%8E%E7%9A%84Midea/" data-id="cmiae68a6000ul4v55u5sffpz" data-title="美 的 Midea" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-毕业设计" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/05/01/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/" class="article-date">
  <time class="dt-published" datetime="2024-05-01T03:11:00.000Z" itemprop="datePublished">2024-05-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/05/01/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/">毕 业 设 计</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <!-- 毕 业 🎓 设 计 -->

<h2 id="选-题"><a href="#选-题" class="headerlink" title="选 题"></a><strong>选 题</strong></h2><p><em>基于内地与香港金融平台的在线量化投资的数据原型系统的设计与开发_</em>_</p>
<h3 id="论文结构"><a href="#论文结构" class="headerlink" title="论文结构"></a>论文结构</h3><p>摘 要 II<br>Abstract III<br>目 录 V<br>第一章 绪论<br>1.1 引言<br>1.2 研究背景<br>1.3 研究现状<br>1.4 课题来源及意义<br>1.5 论文结构<br>第二章 数据原型系统开发环境和工具<br>2.1 Python爬虫<br>2.2 Django框架<br>2.3 设计模式<br>2.4 前端开发框架<br>2.5 开源图形库 ECharts<br>2.6 本章小结<br>第三章 数据原型系统架构设计<br>3.1 综合性金融系统架构设计<br>3.2 数据原型系统架构设计<br>3.3 功能接口设计<br>3.4 数据库设计<br>第四章 数据原型系统的实现<br>4.1从金融平台获取数据实现<br>4.2 数据库查询实现<br>4.3 数据可视化实现<br>4.4 Echarts 图形库渲染生成统计图表<br>4.5 数据下载接口实现<br>4.6 数据维护接口实现<br>第五章 数据原型系统的测试及结果<br>5.1 数据更新模块测试<br>5.2 数据下载模块测试<br>5.3 数据分析模块测试<br>5.4 数据维护模块测试<br>5.5 本章小结<br>第六章 结论<br>1.论文工作总结<br>2.工作展望<br>参考文献<br>致谢</p>
<h3 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h3><ul>
<li>香港市场股票数据库的构建<ul>
<li>MySql数据库：股票、基金、期货</li>
<li>数据库表结构：参考旧论文&#x2F;直接用东方财富网表头</li>
<li>用python爬虫爬取数据, 数据清洗, 爬取历史数据</li>
</ul>
</li>
<li>获取香港期货代码 \spider\Get_Future_Info.py<ul>
<li>数据库创建  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CreateDatabase</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, new_database</span>):</span><br><span class="line">        self.new_database = new_database</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_new_database</span>(<span class="params">self</span>):</span><br><span class="line">        connection = pymysql.connect(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, user=<span class="string">&#x27;root&#x27;</span>, password=<span class="string">&#x27;078114&#x27;</span>, cursorclass=pymysql.cursors.DictCursor)</span><br><span class="line">        new_database_name = self.new_database</span><br><span class="line">        cursor = connection.cursor()</span><br><span class="line">        cursor.execute(<span class="string">f&quot;CREATE DATABASE <span class="subst">&#123;new_database_name&#125;</span>&quot;</span>)</span><br><span class="line">        cursor.close()</span><br><span class="line">        connection.close()</span><br></pre></td></tr></table></figure></li>
<li>数据库操作  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Database</span>:          </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">InsertFutureInfo</span>(<span class="params">self, item</span>):  <span class="comment"># 插入数据</span></span><br><span class="line">        mydb = pymysql.connect(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">3306</span>, user=<span class="string">&#x27;root&#x27;</span>, password=<span class="string">&#x27;078114&#x27;</span>, database=<span class="string">&#x27;finance&#x27;</span>, charset=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">        cursor = mydb.cursor()</span><br><span class="line">        sql = <span class="string">&quot;insert into futureinfo values(%s, %s)&quot;</span></span><br><span class="line">        cursor.executemany(sql, item) <span class="comment"># 要传入一个二维列表或元组的列表作为参数 item，每个子列表或元组应包含两个元素，对应着 SQL 语句中的两个 %s，用于插入数据库表中的两个字段的值</span></span><br><span class="line">        mydb.commit()</span><br><span class="line">        cursor.close()</span><br><span class="line">        mydb.close()</span><br></pre></td></tr></table></figure></li>
<li>爬虫操作  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取期货列表：东方财富网今天期货市场中港交所的期货列表信息（??不确定是不是完整期货信息）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getInfo</span>(<span class="params">self</span>): </span><br><span class="line">    url_base = <span class="string">&#x27;https://futsseapi.eastmoney.com/list/HKSTOCKF?callback=aaa_callback&amp;xx&#x27;</span></span><br><span class="line">    all_data = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>): <span class="comment"># 默认30页？</span></span><br><span class="line">        url = url_base.<span class="built_in">format</span>(size=<span class="number">20</span>, page=i)</span><br><span class="line">        data_str = requests.get(url).text</span><br><span class="line">        json_str = data_str[data_str.index(<span class="string">&#x27;(&#x27;</span>) + <span class="number">1</span>:-<span class="number">1</span>] <span class="comment"># 去除 JSON 数据中的回调函数</span></span><br><span class="line">        data_list = json.loads(json_str)[<span class="string">&quot;list&quot;</span>]</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> data_list:</span><br><span class="line">            tmp = [item[<span class="string">&#x27;dm&#x27;</span>], item[<span class="string">&#x27;name&#x27;</span>]] <span class="comment"># 期货代码，期货名称</span></span><br><span class="line">            all_data.append(tmp)</span><br><span class="line">    Database().InsertFutureInfo(all_data) </span><br></pre></td></tr></table></figure>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取历史期货数据：通过之前获取的期货列表信息，根据期货代码获取其历史（日线）数据（??不确定完整）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getHistory</span>(<span class="params">self</span>): </span><br><span class="line">    url_base = <span class="string">&#x27;https://push2his.eastmoney.com/api/qt/stock/kline/get?secid=130.&#123;secid&#125;&amp;xx&#x27;</span></span><br><span class="line">    all_data = <span class="built_in">list</span>()</span><br><span class="line">    code_list = Database().GetCodeList() <span class="comment"># 获取期货列表信息</span></span><br><span class="line">    <span class="keyword">for</span> dm <span class="keyword">in</span> tqdm(code_list):</span><br><span class="line">        url = url_base.<span class="built_in">format</span>(secid=dm) <span class="comment"># 日线数据</span></span><br><span class="line">        response = requests.get(url=url, timeout=<span class="number">15</span>)</span><br><span class="line">        klines_data = json.loads(response.text)[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;klines&#x27;</span>]</span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> klines_data:</span><br><span class="line">            res_data = data.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">            res_data = [dm] + res_data <span class="comment"># 元组首位加上期货代码</span></span><br><span class="line">            all_data.append(res_data)</span><br><span class="line">    Database().InsertFutureHistory(all_data)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="系统开发"><a href="#系统开发" class="headerlink" title="系统开发"></a>系统开发</h2><ul>
<li>系统架构<ul>
<li>前端：Django+Template，Echarts</li>
<li>后端：Django，MySQL，定时任务</li>
</ul>
</li>
<li>主要工作（原）<ul>
<li>四大模块：数据更新、数据下载、数据分析、数据维护<ul>
<li>一、香港数据<ol>
<li>数据实时更新 （1.1 数据列表(香港股票，香港基金，香港指数，香港期货，香港交易所),1.2 基本信息数据（股票、基金、期货），1.3 基本信息， 1.4 财务报表， 1.5 香港历史交易数据（香港股票，香港基金，香港指数，香港期货）， 1.6 当日交易数据（香港股票，香港基金，香港指数，香港期货）） </li>
<li>数据下载 （2.1 列表数据下载(香港股票，香港基金，香港指数，香港期货，香港交易所)，2.2 基本信息数据下载（股票、基金、期货），2.3 基本信息下载， 2.4 财务报表数据下载， 2.5 香港历史交易数据下载（大陆股票，大陆基金，大陆指数，大陆期货）， 2.6 当日交易数据下载（香港股票，香港基金，香港指数，香港期货））</li>
<li>数据分析 （3.1 列表数据分析(香港股票，香港基金，香港指数，香港期货，香港交易所)，3.2 基本信息数据分析（股票、基金、期货），3.3 基本信息分析， 3.4 财务报表数据分析， 3.5 大陆历史交易数据分析（大陆股票，大陆基金，大陆指数，大陆期货）， 3.6 当日交易数据分析（大陆股票，大陆基金，大陆指数，大陆期货））</li>
<li>数据维护 （4.1 数据导出 4.1.1 数据列表导出(香港股票，香港基金，香港指数，香港期货，香港交易所),4.1.2 基本信息数据导出（股票、基金、期货），4.1.3 基本信息数据导出， 4.1.4 财务报表导出， 4.1.5 香港历史交易数据导出（香港陆股票，香港基金，香港指数，香港期货）， 4.1.6 当日交易数据导出（香港股票，香港基金，香港指数，香港期货）， 4.2 数据导入 4.2.1 数据列表导入(香港股票，香港基金，香港指数，香港期货，香港交易所),4.2.2 基本信息数据导入（股票、基金、期货），4.2.3 基本信息数据导入， 4.2.4 财务报表导入， 4.2.5 香港历史交易数据导入（香港股票，香港基金，香港指数，香港期货）， 4.2.6 当日交易数据导入（香港股票，香港基金，香港指数，香港期货））】</li>
</ol>
</li>
<li>二、香港相关数据还要包括 【1 深港通、沪港通数据；2. 在港上市的大陆股票；3. 在港国企股；4. 港股的科创板】</li>
</ul>
</li>
</ul>
</li>
<li><strong>主要工作（真）</strong><ul>
<li><strong>主要是要多完成港股中相关数据内容：</strong><a target="_blank" rel="noopener" href="https://quote.eastmoney.com/center/ggsc.html">港股主板、港股创业板、知名港股、蓝筹股、红筹股、红筹成分股、国企股、国企成分股、港股通成份股、人民币交易港股、AH股比价、香港指数</a> </li>
<li><strong>突出两地股市的差别：对这几个港股数据，提供数据展示（调用其他同学的接口同时展现大陆数据），数据更新、维护、下载的功能；最好论文还要有一些分析的结果，需要自己做一些结果和图表出来，系统上时间不够可以不加</strong></li>
</ul>
</li>
<li>开发流程<ul>
<li>港股数据爬取（spider）：<br>  创建各类港股基本信息表：获取“港股市场xx股”（在今日）的信息列表，将“股票代码”、“股票名称”等保存在数据库对应的基本信息表中，同时保存“更新时间”为今日<br>  创建各类港股历史数据表：根据“港股市场xx股”的基本信息表中的股票代码，获取该股至今的历史数据，将“股票代码, 名称, k线数据, 时间”存入对应的历史数据表中</li>
<li>港股数据更新（spider）：<br>  更新各类港股基本信息表：获取“港股市场xx股”（在今日）的信息列表，将对应表中不存在的“股票代码”的数据存入并且保存“更新时间”为今日，将原本存在的股票信息和“更新时间”更新<br>  更新各类港股历史数据表：根据“港股市场xx股”的基本信息表中的“股票代码”和“更新时间”，获取从“更新时间”至今的历史数据，存入对应的历史数据表中（无序）</li>
<li>港股基本数据展示（Django）：展示各类港股基本信息表</li>
<li>港股K线图展示（Django）：根据股票代码，结合Echarts展示各类港股历史数据的K线图</li>
<li>提供数据接口供其他的模块使用（Django）：以JSON形式返回各类港股历史数据到页面上</li>
<li>数据下载（Django）：以JSON形式返回各类港股历史数据到页面上，右键“另存为”下载</li>
<li>数据维护：导入，导出</li>
</ul>
</li>
</ul>
<h3 id="数据库建设"><a href="#数据库建设" class="headerlink" title="数据库建设"></a>数据库建设</h3><ol>
<li>创建数据库和表（\spider\DB_Fund.py）<ul>
<li>xx股基本信息表 xxinfo<table>
<thead>
<tr>
<th>股票代码</th>
<th>股票名称</th>
<th>最新价</th>
<th>涨跌额</th>
<th>涨跌幅</th>
<th>今开</th>
<th>最高</th>
<th>最低</th>
<th>昨收</th>
<th>成交量(股)</th>
<th>成交额</th>
<th>更新日期</th>
</tr>
</thead>
<tbody><tr>
<td>code</td>
<td>name</td>
<td>now</td>
<td>change</td>
<td>changerate</td>
<td>open</td>
<td>high</td>
<td>low</td>
<td>yesterday_close</td>
<td>volume</td>
<td>amount</td>
<td>date_updated</td>
</tr>
</tbody></table>
</li>
<li>xx股历史数据表 xxhistory<table>
<thead>
<tr>
<th>code</th>
<th>date</th>
<th>open</th>
<th>now</th>
<th>high</th>
<th>low</th>
<th>volume</th>
<th>amount</th>
<th>rate</th>
<th>changerate</th>
<th>per</th>
<th>zero</th>
</tr>
</thead>
</table>
</li>
<li>A-H股基本信息表 AHStockComparisoninfo<table>
<thead>
<tr>
<th>名称</th>
<th>H股代码</th>
<th>最新价(HKD)</th>
<th>涨跌幅</th>
<th>A股代码</th>
<th>最新价(RMB)</th>
<th>涨跌幅</th>
<th>比价（A&#x2F;H）</th>
<th>溢价（A&#x2F;H）%</th>
<th>更新时间</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>code_hkd</td>
<td>now_hkd</td>
<td>changerate_hkd</td>
<td>code_rmb</td>
<td>now_rmb</td>
<td>changerate_rmb</td>
<td>AHcomparison</td>
<td>AHcomparisonrate</td>
<td>date_updated</td>
</tr>
</tbody></table>
</li>
<li>港股市场术语英文表示：<ol>
<li>港股主板：HKEXMainBoardinfo</li>
<li>港股创业板：GEMofHKEXinfo</li>
<li>知名港股</li>
<li>蓝筹股</li>
<li>红筹股</li>
<li>红筹成分股</li>
<li>国企股：SOEStocksinfo</li>
<li>国企成分股：SOEConstituentStocksinfo</li>
<li>港股通成份股：HKStockConnectConstituentStocksinfo</li>
<li>人民币交易港股</li>
<li>AH股比价：AHStockComparisoninfo</li>
<li>ADR</li>
<li>香港指数：HKStockIndexinfo</li>
</ol>
</li>
</ul>
</li>
<li>爬取港股基本信息（\spider\Get_HKStock\HKStockSpider().getxxInfo()）<ul>
<li>使用F12抓包，点击如“港股主板”按钮查询出对应的股票数据，刷新页面，过滤出js文件，找到对应的股票数据的get请求api（默认pn&#x3D;1，pz&#x3D;20，表示获取第一页大小为20的股票数据列表）；从中获取总数据行数”data”&#x2F;“total”，再次发送get请求（设置pn&#x3D;1，pz&#x3D;total）获取完整的该股票数据列表    </li>
<li>港股主板：’<a target="_blank" rel="noopener" href="https://86.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112408726538243180275_1714550583811&pn=1&pz=20&po=1&np=1&ut=bd1d9ddb04089700cf9c27f6f7426281&fltt=2&invt=2&wbp2u=8413067108550254%7C0%7C1%7C0%7Cweb&fid=f3&fs=m:116+t:3&fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&_=1714550583816">https://86.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112408726538243180275_1714550583811&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=8413067108550254|0|1|0|web&amp;fid=f3&amp;fs=m:116+t:3&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&amp;_=1714550583816</a>‘</li>
<li>港股创业板：<a target="_blank" rel="noopener" href="https://86.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112408726538243180275_1714550583811&pn=1&pz=20&po=1&np=1&ut=bd1d9ddb04089700cf9c27f6f7426281&fltt=2&invt=2&wbp2u=8413067108550254%7C0%7C1%7C0%7Cweb&fid=f3&fs=m:116+t:4&fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&_=1714550583886">https://86.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112408726538243180275_1714550583811&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=8413067108550254|0|1|0|web&amp;fid=f3&amp;fs=m:116+t:4&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&amp;_=1714550583886</a></li>
<li>知名港股：<a target="_blank" rel="noopener" href="https://86.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112408726538243180275_1714550583811&pn=1&pz=20&po=1&np=1&ut=bd1d9ddb04089700cf9c27f6f7426281&fltt=2&invt=2&wbp2u=8413067108550254%7C0%7C1%7C0%7Cweb&fid=f3&fs=b:MK0106&fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&_=1714550583906">https://86.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112408726538243180275_1714550583811&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=8413067108550254|0|1|0|web&amp;fid=f3&amp;fs=b:MK0106&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&amp;_=1714550583906</a></li>
<li>蓝筹股：<a target="_blank" rel="noopener" href="https://57.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112407221764962597832_1714570944282&pn=1&pz=20&po=1&np=1&ut=bd1d9ddb04089700cf9c27f6f7426281&fltt=2&invt=2&wbp2u=8413067108550254%7C0%7C1%7C0%7Cweb&fid=f3&fs=b:MK0105&fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&_=1714570944470">https://57.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112407221764962597832_1714570944282&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=8413067108550254|0|1|0|web&amp;fid=f3&amp;fs=b:MK0105&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&amp;_=1714570944470</a></li>
<li>红筹股：<a target="_blank" rel="noopener" href="https://57.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112407221764962597832_1714570944286&pn=1&pz=20&po=1&np=1&ut=bd1d9ddb04089700cf9c27f6f7426281&fltt=2&invt=2&wbp2u=8413067108550254%7C0%7C1%7C0%7Cweb&fid=f3&fs=b:MK0102&fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&_=1714570944490">https://57.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112407221764962597832_1714570944286&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=8413067108550254|0|1|0|web&amp;fid=f3&amp;fs=b:MK0102&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&amp;_=1714570944490</a></li>
<li>红筹成分：<a target="_blank" rel="noopener" href="https://57.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112407221764962597832_1714570944286&pn=1&pz=20&po=1&np=1&ut=bd1d9ddb04089700cf9c27f6f7426281&fltt=2&invt=2&wbp2u=8413067108550254%7C0%7C1%7C0%7Cweb&fid=f3&fs=b:MK0111&fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&_=1714570944499">https://57.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112407221764962597832_1714570944286&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=8413067108550254|0|1|0|web&amp;fid=f3&amp;fs=b:MK0111&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&amp;_=1714570944499</a></li>
<li>国企股：<a target="_blank" rel="noopener" href="https://86.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112408726538243180275_1714550583811&pn=1&pz=20&po=1&np=1&ut=bd1d9ddb04089700cf9c27f6f7426281&fltt=2&invt=2&wbp2u=8413067108550254%7C0%7C1%7C0%7Cweb&fid=f3&fs=b:MK0103&fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&_=1714550583915">https://86.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112408726538243180275_1714550583811&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=8413067108550254|0|1|0|web&amp;fid=f3&amp;fs=b:MK0103&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&amp;_=1714550583915</a></li>
<li>国企成分股：<a target="_blank" rel="noopener" href="https://86.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112408726538243180275_1714550583811&pn=1&pz=20&po=1&np=1&ut=bd1d9ddb04089700cf9c27f6f7426281&fltt=2&invt=2&wbp2u=8413067108550254%7C0%7C1%7C0%7Cweb&fid=f3&fs=b:MK0112&fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&_=1714550583919">https://86.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112408726538243180275_1714550583811&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=8413067108550254|0|1|0|web&amp;fid=f3&amp;fs=b:MK0112&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&amp;_=1714550583919</a></li>
<li>股港股通成份股：<a target="_blank" rel="noopener" href="https://57.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112407221764962597832_1714570944286&pn=1&pz=20&po=1&np=1&ut=bd1d9ddb04089700cf9c27f6f7426281&fltt=2&invt=2&wbp2u=8413067108550254%7C0%7C1%7C0%7Cweb&fid=f3&fs=b:MK0146,b:MK0144&fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&_=1714570944503">https://57.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112407221764962597832_1714570944286&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=8413067108550254|0|1|0|web&amp;fid=f3&amp;fs=b:MK0146,b:MK0144&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&amp;_=1714570944503</a></li>
<li>人民币交易港股：<a target="_blank" rel="noopener" href="https://57.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112407221764962597832_1714570944286&pn=1&pz=20&po=1&np=1&ut=bd1d9ddb04089700cf9c27f6f7426281&fltt=2&invt=2&wbp2u=8413067108550254%7C0%7C1%7C0%7Cweb&fid=f3&fs=m:116+s:64&fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&_=1714570944509">https://57.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112407221764962597832_1714570944286&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=8413067108550254|0|1|0|web&amp;fid=f3&amp;fs=m:116+s:64&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&amp;_=1714570944509</a></li>
<li>AH股比价：<a target="_blank" rel="noopener" href="https://57.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112407221764962597832_1714570944286&pn=1&pz=20&po=1&np=1&ut=bd1d9ddb04089700cf9c27f6f7426281&fltt=2&invt=2&wbp2u=8413067108550254%7C0%7C1%7C0%7Cweb&fid=f3&fs=b:MK0101&fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f20,f21,f23,f24,f25,f22,f11,f62,f128,f136,f115,f152,f191,f192,f193,f186,f185,f187,f189,f188&_=1714570944513">https://57.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112407221764962597832_1714570944286&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=8413067108550254|0|1|0|web&amp;fid=f3&amp;fs=b:MK0101&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f20,f21,f23,f24,f25,f22,f11,f62,f128,f136,f115,f152,f191,f192,f193,f186,f185,f187,f189,f188&amp;_=1714570944513</a></li>
<li>香港指数：<a target="_blank" rel="noopener" href="https://86.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112408726538243180275_1714550583811&pn=1&pz=20&po=1&np=1&ut=bd1d9ddb04089700cf9c27f6f7426281&fltt=2&invt=2&wbp2u=8413067108550254%7C0%7C1%7C0%7Cweb&fid=f3&fs=m:124,m:125,m:305&fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&_=1714550583922">https://86.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112408726538243180275_1714550583811&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=8413067108550254|0|1|0|web&amp;fid=f3&amp;fs=m:124,m:125,m:305&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&amp;_=1714550583922</a></li>
</ul>
</li>
<li>爬取港股历史数据（\spider\Get_HKStock\HKStockSpider().getxxHistory()）<ul>
<li>从各类港股基本信息表中获取股票代码替换secid，date为今日，查询其历史k线数据</li>
<li>一般情况，MySQL每张表最好不要超过2000万条数据，阿里的Java开发手册上也提出：单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。或者说，要根据实际场景分析。</li>
<li>港股日线数据(除A-H股价比，港股指数外)：<a target="_blank" rel="noopener" href="https://push2his.eastmoney.com/api/qt/stock/kline/get?cb=jQuery35106242902488344593_1714571208625&secid=116.%7Bsecid%7D&ut=fa5fd1943c7b386f172d6893dbfba10b&fields1=f1,f2,f3,f4,f5,f6&fields2=f51,f52,f53,f54,f55,f56,f57,f58,f59,f60,f61&klt=101&fqt=1&beg=0&end=20500101&smplmt=755&lmt=1000000&_=1714571208630">https://push2his.eastmoney.com/api/qt/stock/kline/get?cb=jQuery35106242902488344593_1714571208625&amp;secid=116.{secid}&amp;ut=fa5fd1943c7b386f172d6893dbfba10b&amp;fields1=f1%2Cf2%2Cf3%2Cf4%2Cf5%2Cf6&amp;fields2=f51%2Cf52%2Cf53%2Cf54%2Cf55%2Cf56%2Cf57%2Cf58%2Cf59%2Cf60%2Cf61&amp;klt=101&amp;fqt=1&amp;beg=0&amp;end=20500101&amp;smplmt=755&amp;lmt=1000000&amp;_=1714571208630</a></li>
<li>A-H股价比，港股指数日线数据先不弄。。</li>
</ul>
</li>
<li>数据更新（\spider\Update_HKStock.py）<ul>
<li>更新港股基本信息</li>
<li>更新港股历史数据</li>
<li>定时任务</li>
</ul>
</li>
<li>数据接口（Django实现）：以JSON形式返回各类港股历史数据到页面上，供其他的模块使用</li>
<li>数据下载（Django实现）：以JSON形式返回各类港股历史数据到页面上，右键“另存为”保存</li>
<li>数据维护</li>
</ol>
<h3 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h3><ul>
<li>项目结构 <img src="https://leo710aka.github.io/bk/datasite.png" width="550" height="300" alt=""></li>
</ul>
<h3 id="示例1：展示香港指数基本信息表-HKStockIndexinfo"><a href="#示例1：展示香港指数基本信息表-HKStockIndexinfo" class="headerlink" title="示例1：展示香港指数基本信息表 HKStockIndexinfo"></a><strong>示例1：展示香港指数基本信息表 HKStockIndexinfo</strong><img src="https://github.com/leo710aka/bk/blob/main/bishe1.png?raw=true" width="700" height="300" alt=""></h3><ol>
<li>编写model（datasite&#x2F;mainapp&#x2F;models.py）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HKStockIndexinfo</span>(models.Model):</span><br><span class="line">    code = models.CharField(max_length=<span class="number">12</span>, primary_key=<span class="literal">True</span>)  <span class="comment"># 假设code是主键</span></span><br><span class="line">    name = models.FloatField(max_length=<span class="number">20</span>, db_column=<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    now = models.FloatField(db_column=<span class="string">&#x27;now&#x27;</span>)</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        db_table = <span class="string">&#x27;HKStockIndexinfo&#x27;</span></span><br><span class="line">        managed = <span class="literal">False</span></span><br></pre></td></tr></table></figure></li>
<li>迁移，将 model与 MySQL中的表映射<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations  <span class="comment"># IDE console</span></span><br></pre></td></tr></table></figure></li>
<li>编写html（datasite&#x2F;mainapp&#x2F;templates&#x2F;hkstockindexinfo.html）<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>代码<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>名称<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    &#123;% for info in infos %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">&quot;color: #1e8ecc;&quot;</span>&gt;</span>&#123;&#123; info.code &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">&quot;color: #1e8ecc;&quot;</span>&gt;</span>&#123;&#123; info.name &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>编写应用请求（datasite&#x2F;mainapp&#x2F;views.py）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hkstockindexinfo</span>(<span class="params">request</span>):</span><br><span class="line">    infos = HKStockIndexinfo.objects.<span class="built_in">all</span>()                    <span class="comment"># 从MySQL中获取对应表的数据</span></span><br><span class="line">    context = &#123;<span class="string">&#x27;infos&#x27;</span>: infos&#125;                                <span class="comment"># 创建上下文字典</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;hkstockindexinfo.html&#x27;</span>, context)  <span class="comment"># 渲染模板</span></span><br></pre></td></tr></table></figure></li>
<li>配置路由（datasite&#x2F;datasite&#x2F;urls.py）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;hkstockindexinfo&#x27;</span>, views.hkstockindexinfo),  <span class="comment"># 不需要配置项目-应用两级url</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li>启动Django项目<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS E:\Code\datasite&gt; python manage.py runserver</span><br></pre></td></tr></table></figure></li>
<li>发送请求 <a target="_blank" rel="noopener" href="http://127.0.0.1:8000/hkstockindexinfo%EF%BC%8C">http://127.0.0.1:8000/hkstockindexinfo，</a> 展示香港指数基本信息表</li>
</ol>
<h3 id="示例2：使用Echart展示港股主板历史数据k线图"><a href="#示例2：使用Echart展示港股主板历史数据k线图" class="headerlink" title="示例2：使用Echart展示港股主板历史数据k线图"></a><strong>示例2：使用Echart展示港股主板历史数据k线图</strong><img src="https://github.com/leo710aka/bk/blob/main/bishe4.png?raw=true" width="700" height="300" alt=""></h3><ol>
<li>编写model（datasite&#x2F;mainapp&#x2F;models.py）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HKEXMainBoardhistory</span>(models.Model):</span><br><span class="line">    code = models.CharField(max_length=<span class="number">12</span>, primary_key=<span class="literal">True</span>)  <span class="comment"># 假设code是主键</span></span><br><span class="line">    date = models.CharField(max_length=<span class="number">10</span>, db_column=<span class="string">&#x27;date&#x27;</span>)</span><br><span class="line">    <span class="built_in">open</span> = models.FloatField(db_column=<span class="string">&#x27;open&#x27;</span>)</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        db_table = <span class="string">&#x27;HKEXMainBoardhistory&#x27;</span></span><br><span class="line">        managed = <span class="literal">False</span></span><br></pre></td></tr></table></figure></li>
<li>迁移，将 model与 MySQL中的表映射<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations  <span class="comment"># IDE console</span></span><br></pre></td></tr></table></figure></li>
<li>编写html（datasite&#x2F;mainapp&#x2F;templates&#x2F;historyklines.html）<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;% load static %&#125;  <span class="comment">&lt;!-- 在项目setting.py配置：STATIC_URL = &#x27;/static/&#x27; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>港股主板历史数据k线图<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入已经下载到本地/static/assets/js下的Echarts文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;&#123;% static &#x27;assets/js/echarts.js&#x27; %&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 1600px;height:800px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 从Echarts官网上复制K线图示例代码</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> chartDom = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;main&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> myChart = echarts.<span class="title function_">init</span>(chartDom);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> option;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 使用模板语言获取传递的 JSON 数据</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> jsonData = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="string">&#x27;&#123;&#123; jsonData | escapejs &#125;&#125;&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">splitData</span>(<span class="params">rawData</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// ...</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">renderItem</span>(<span class="params">params, api</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// ...</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 使用后端查询的数据，代替模版代码中原本外部引入的json文件</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> data = <span class="title function_">splitData</span>(jsonData);</span></span><br><span class="line"><span class="language-javascript">        myChart.<span class="title function_">setOption</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// ...</span></span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>编写应用请求（datasite&#x2F;mainapp&#x2F;views.py）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">historyklines</span>(<span class="params">request</span>):</span><br><span class="line">    code = request.GET.get(<span class="string">&#x27;code&#x27;</span>)  <span class="comment"># 获取请求中携带的code参数值</span></span><br><span class="line">    queryset = HKEXMainBoardhistory.objects.<span class="built_in">filter</span>(code=code)  <span class="comment"># 查询所有代码为 code 的数据</span></span><br><span class="line">    jsonData = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> queryset:  <span class="comment"># 构造二维数组</span></span><br><span class="line">        data_row = [</span><br><span class="line">            item.date, item.<span class="built_in">open</span>, item.now, item.low, item.high, item.volume</span><br><span class="line">        ]</span><br><span class="line">        jsonData.append(data_row)</span><br><span class="line">    jsonData_str = json.dumps(jsonData)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;historyklines.html&#x27;</span>, &#123;<span class="string">&#x27;jsonData&#x27;</span>: jsonData_str&#125;)</span><br></pre></td></tr></table></figure></li>
<li>配置路由（datasite&#x2F;datasite&#x2F;urls.py）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;historyklines&#x27;</span>, views.historyklines),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li>启动Django项目<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS E:\Code\datasite&gt; python manage.py runserver</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="示例3：提供数据接口供其他模块调用，下载历史数据"><a href="#示例3：提供数据接口供其他模块调用，下载历史数据" class="headerlink" title="示例3：提供数据接口供其他模块调用，下载历史数据"></a><strong>示例3：提供数据接口供其他模块调用，下载历史数据</strong><img src="https://github.com/leo710aka/bk/blob/main/bishe3.png?raw=true" width="700" height="300" alt=""></h3><ol>
<li>指的是xx股历史数据</li>
<li>编写Model、View，配置urls<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hkexmainboarddata</span>(<span class="params">request</span>):</span><br><span class="line">    code = request.GET.get(<span class="string">&#x27;code&#x27;</span>)</span><br><span class="line">    data = HKEXMainBoardhistory.objects.<span class="built_in">filter</span>(code=code)</span><br><span class="line">    data_dict_list = [&#123;<span class="string">&quot;code&quot;</span>: item.code, <span class="string">&quot;date&quot;</span>: item.date, <span class="string">&quot;open&quot;</span>: item.<span class="built_in">open</span>, <span class="string">&quot;now&quot;</span>: item.now,</span><br><span class="line">                       <span class="string">&quot;high&quot;</span>: item.high, <span class="string">&quot;low&quot;</span>: item.low, <span class="string">&quot;volume&quot;</span>: item.volume, <span class="string">&quot;amount&quot;</span>: item.amount,</span><br><span class="line">                       <span class="string">&quot;rate&quot;</span>: item.rate, <span class="string">&quot;changerate&quot;</span>: item.changerate, <span class="string">&quot;per&quot;</span>: item.per, <span class="string">&quot;zero&quot;</span>: item.zero&#125;</span><br><span class="line">                      <span class="keyword">for</span> item <span class="keyword">in</span> data]</span><br><span class="line">    <span class="comment"># 转换为 JSON 格式</span></span><br><span class="line">    data_json = json.dumps(data_dict_list)</span><br><span class="line">    <span class="comment"># 返回 JSON 响应</span></span><br><span class="line">    <span class="keyword">return</span> JsonResponse(data_json, safe=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure></li>
<li>查询页面：输入港股代码，点击“生成K线图”按钮发送xxklines请求&#x2F;点击“下载历史数据”展示历史数据（右键“另存为”下载）<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card &quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card-header&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span> <span class="attr">class</span>=<span class="string">&quot;card-title&quot;</span>&gt;</span>港股历史数据<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;myForm&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;codeInput&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 150px;&quot;</span>&gt;</span>请输入港股主板代码：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;codeInput&quot;</span> <span class="attr">name</span>=<span class="string">&quot;codeInput&quot;</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">id</span>=<span class="string">&quot;submitButton&quot;</span>&gt;</span>生成K线图<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">id</span>=<span class="string">&quot;submitButton0&quot;</span>&gt;</span>下载历史数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myForm&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;submit&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  event.<span class="title function_">preventDefault</span>(); <span class="comment">// 阻止表单默认提交行为</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 获取输入框中的内容</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> code = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;codeInput&#x27;</span>).<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">if</span> (event.<span class="property">submitter</span>.<span class="property">id</span> === <span class="string">&#x27;submitButton&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 构造生成K线图的请求URL</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> url = <span class="string">`http://127.0.0.1:8000/hkexmainboardklines?code=<span class="subst">$&#123;code&#125;</span>`</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 在新标签页中打开链接</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="title function_">open</span>(url, <span class="string">&#x27;_blank&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.<span class="property">submitter</span>.<span class="property">id</span> === <span class="string">&#x27;submitButton0&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 构造下载历史数据的请求URL</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> url = <span class="string">`http://127.0.0.1:8000/hkexmainboarddata?code=<span class="subst">$&#123;code&#125;</span>`</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 在新标签页中打开链接</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="title function_">open</span>(url, <span class="string">&#x27;_blank&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>

<h1 id="毕业答辩"><a href="#毕业答辩" class="headerlink" title="毕业答辩"></a>毕业答辩</h1><p>毕业答辩的意义是，校方为了进一步的审查论文。<br>考查内容可归纳如下：①进一步考查和验证毕业论文作者对所着论文论题的认识程度及当场论证论题的能力 ②进一步考查毕业论文作者对专业知识掌握的深度与广度 ③审查毕业论文是否学员自己独立完成<br>答辩时提问依据：①汇报PPT的内容 ②毕业论文的内容 ③汇报者的言语</p>
<h3 id="答辩安排"><a href="#答辩安排" class="headerlink" title="答辩安排"></a>答辩安排</h3><p>答辩日期：5月24日（13周周五），上午1-4节，8：50开始，预计到中午左右结束；<br>答辩地点：A4206<br>需携带资料:<br>1.答辩ppt 电子版（u盘）；2.一式3份双面打印的论文（最新版，不需要装帧封面）。<br>注意事项：<br>1.请大家提前半小时（上午8：20）到现场，调试好设备（电脑、投影仪、麦克风，等），所有的ppt都拷贝到指定电脑上（可以用课室的电脑，但建议至少带一台笔记本做备用）。<br>2.提前打印好3份毕设论文（简单的双面打印即可，不需要特别装帧封面，因为不是最终稿），答辩前统一交给老师翻阅。如果在答辩前对论文有修改，和提交系统的版本不一致也没关系，只要打印最新版就可以了。<br>3.每人答辩陈述时间5分钟左右（可以利用powerpoint的排练功能提前排练好），然后留3分钟左右回答老师的提问。<br>4.回答问题时要认真记录下老师提出的修改意见，并在答辩结束后按要求修改论文，然后提交论文最终版到维普系统；<br>5.答辩结束后，老师们会在维普系统上给论文和答辩过程打分，大家把论文最终版提交维普系统之后，可以直接从系统上下载并打印带有老师电子签名的各类表格（一般不需要找老师们手签）。最终版论文一定要装帧好封面，和全套打印的表格一起，按照顺序放入档案袋并交给导师。</p>
<h2 id="答辩内容"><a href="#答辩内容" class="headerlink" title="答辩内容"></a>答辩内容</h2><p>各位评委老师，同学们：<br>大家上午好! 我是<em>网络工程</em>专业的<em>蔡枫</em>，我的论文题目是<em><strong>基于内地与香港金融平台的在线量化投资的数据原型系统的设计与开发</strong></em>。<br>&lt;翻页&gt;<br>今天我将从以下四个方面阐述我的毕业论文内容。<br>&lt;翻页&gt;</p>
<h3 id="第一部分-选题背景及意义"><a href="#第一部分-选题背景及意义" class="headerlink" title="第一部分 选题背景及意义"></a>第一部分 选题背景及意义</h3><p>随着在线量化投资的普及，如何有效地收集和整理海量的互联网金融数据，成为了一大挑战。<br>&lt;翻页&gt;<br>一方面，互联网数据具有实时性，导致用户和金融公司都难以检索过去特定时间的完整金融数据。<br>另一方面，人们需花费大量时间在门户网站浏览实时金融信息，但缺乏明确直观的数据分析结果。<br>&lt;翻页&gt;<br>为有效解决以上问题，本论文设计并开发了基于网络爬虫的数据原型系统，实时获取互联网上的金融数据，并提供数据下载的功能。<br>另外，系统提供了数据可视化和数据分析的功能，用户能够从中获取具有参考价值的信息。<br>以及，作为综合性金融系统中的底层数据平台，能够为其他模块的开发提供数据源。<br>&lt;翻页&gt;</p>
<h3 id="第二部分-开发环境与技术"><a href="#第二部分-开发环境与技术" class="headerlink" title="第二部分 开发环境与技术"></a>第二部分 开发环境与技术</h3><p>&lt;翻页&gt;<br>首先介绍一下网络爬虫，其通过模拟人类浏览网页的行为，获取并解析网络信息。<br>&lt;翻页&gt;<br>如果目标网站提供了 API 接口，我们可以通过浏览器的开发者工具进行抓包，并在Python项目中直接调用以获取数据。<br>&lt;翻页&gt;<br>系统的开发语言为 Python，采用 Django 框架结合前端技术进行 Web 应用的构建。通过编写 MTV 三层架构代码，开发子系统的各功能。<br>&lt;翻页&gt;<br>本系统中选择 MySQL 作为数据库，存储爬取到的网络金融数据，以及进行后续的功能开发。<br>&lt;翻页&gt;<br>本系统的数据库中主要有两种表，即各类港股基本信息表和港股历史数据表。<br>&lt;翻页&gt;<br>在港股基本信息表中，包括股票代码、股票名称、最新价、涨跌额等基本信息，另外还添加了 date_updated 字段，以便在更新历史数据表时计算出所需更新数据的时间段。<br>&lt;翻页&gt;<br>在港股历史数据表中，保存了表示K线数据的相关字段。<br>&lt;翻页&gt;</p>
<h3 id="第三部分-系统设计与实现"><a href="#第三部分-系统设计与实现" class="headerlink" title="第三部分 系统设计与实现"></a>第三部分 系统设计与实现</h3><p>&lt;翻页&gt;<br>本文的数据原型系统是作为综合性金融系统底层的数据平台模块进行开发的，其他的量化因子分析模块和量化投资策略模块由小组成员负责开发。<br>&lt;翻页&gt;<br>在底层的数据平台，即本文的数据原型系统中，保存了香港金融市场股票的交易数据，包括了数据库建设模块、数据可视化模块、数据接口模块、数据分析模块这四个模块。<br>&lt;翻页&gt;<br>在数据库建设模块中，主要有三个程序，分别用于创建数据库和表，初始化表数据，以及更新表数据。<br>其中更新程序是利用 schedule 库，设置定时任务16点实时更新数据到各类港股基本信息表中，根据基本信息表中的的股票代码和更新时间，获取其自更新时间至今的K线数据添加到对应的表中同时修改“更新时间”为当日，以及定期对表执行“转储SQL”操作进行数据备份，以便在需要时快速重构。<br>&lt;翻页&gt;<br>在数据可视化模块中，提供了基本信息表格功能。点击子系统导航栏，选择港股类型，在子系统界面上对应的基本信息数据。<br>&lt;翻页&gt;<br>实现的基本步骤为：编写模型与数据库表映射，编写视图接收请求和模版页面，并配置好请求访问路径，即可通过浏览器访问系统功能。<br>&lt;翻页&gt;<br>另外，提供了历史数据K线图展示功能，根据前端输入的各类港股股票代码，从数据库中获取数据，并利用 ECharts 生成历史数据K线图。<br>&lt;翻页&gt;<br>其实现步骤类似前面介绍的基本信息表格。<br>&lt;翻页&gt;<br>在数据接口模块中，复用了历史数据K线图功能的功能界面和业务代码，根据输入的各类港股股票代码，从数据库中对应的历史数据表中获取数据，以JSON形式返回到新标签页面上。<br>&lt;翻页&gt;<br>数据可以供综合性金融系统中的其他模块使用，用户也可以在页面上右键“另存为”下载数据文件。<br>&lt;翻页&gt;<br>最后是数据分析模块：对于采集的金融数据作进一步的分析，呈现更直观和更有价值的信息。我们另外爬取了内地市场沪深京A股的数据，对比分析凸显港陆市场的数据差别。<br>&lt;翻页&gt;<br>首先，对于港股与沪深京A股，计算基本统计描述。<br>&lt;翻页&gt;<br>可以简单分析看出，香港市场在股价波动性和交易量方面普遍较大，呈现出更高的市场活力和波动性；<br>内地市场的平均股价虽然较低，但交易量和交易金额却相对较高，显示出更为稳定的交易情况。<br>&lt;翻页&gt;<br>然后进一步进行各类数据的可视化分析。我们进行了收盘价分布统计，这是放大后。。<br>&lt;翻页&gt;<br>然后是涨跌幅分布比较。。<br>&lt;翻页&gt;</p>
<h3 id="第四部分-总结与展望"><a href="#第四部分-总结与展望" class="headerlink" title="第四部分 总结与展望"></a>第四部分 总结与展望</h3><p>&lt;翻页&gt;<br>本次毕业设计的工作涵盖了搭建数据原型系统的各个方面，包括金融数据库的设计、系统前端和后端的开发等。<br>（数据采集：直接从东方财富网接口获取金融数据，并通过数据清洗和整理存储到数据库中。在开发时使用了大模型进行数据含义的分析和编写数据清洗代码，极大地提高了开发效率。对于前端的编写，同组的同学提供了模板，为开发带来了很大的便利。只需开发子系统功能界面，将模板页面中空缺内容区块覆盖。在系统后端的开发过程中，我快速学习了Django的开发流程，进行需求分析和功能设计后，解决实际开发问题，同时总结经验完善系统。）<br>同时，对于这几个方面，未来还有需要改进的地方。<br>&lt;翻页&gt;<br>对于这几个方面，未来也有需要改进的地方，如加强数据采集时对异常情况的处理，优化系统前后端性能等。。<br>（在数据采集方面，引入多线程实现对数据的并行处理，另外还需加强对异常情况的处理，确保系统稳健运行。在系统前端方面，进一步完善用户界面的设计和用户体验，考虑引入前端框架如React、Vue.js等，以提升前端开发的效率和灵活性，提供更加直观和友好的数据展示方式。在系统后端方面，不断优化系统架构和性能，加强对系统的监控和管理，及时发现和解决潜在的问题，确保系统长期稳定运行。）<br>&lt;翻页&gt;<br>最后感谢各位老师的聆听及指导，我的汇报到此结束。</p>
<h3 id="问答环节"><a href="#问答环节" class="headerlink" title="问答环节"></a>问答环节</h3><ol>
<li>为什么会选择这个课题?<br>(自身原因+外部因素&#x3D;选择的原因，把选择的原因放大，从多角度回答)<br>我认为计算机金融有潜力，以及量化投资的研究在当下是非常有价值的，有很强的现实意义，其中数据平台的构建是基石。<br>本次毕业设计的工作涵盖了搭建数据原型系统的各个方面，包括金融数据库的设计、系统前端和后端的搭建等，提供一种快速构建的思路。</li>
<li>论文的创新点体现在哪里?<br>(通过和已有成果或内容相比较,从内容和研究方法上来讲创新。)<br>回答参考:本篇毕业论文的创新之处在于讨论 xxx 的问题时不仅在 xxx 方面列出xxx，也从实际的角度进行了举例论证。一是在方法上，本文将Xx方法与XX方法相结合,能够有效消除单一方法带来的误差,有效提高了数据的精度(结果的有效性)。二是在理论上，综合近十年的文献发现，目前还没有研究学者提出 xXX方面的内容，本文在理论的提出上是一种全新的尝试</li>
<li>本论文中你主要做了什么?<br>查找了大量的文献、书籍报刊，对这些资料进行了精谀，结合国内外的研究现状，对 xxx问题进行了归纳总结;在此基础上，提炼出本课题的核心，对xxx展开研究，并运用 xxx 方法进行研究;对xxx 研究结果进行分析，提出 solvexxx 问题的建议及措施。</li>
<li>本论文的意义和目的是什么?<br>(理论意义+实践意义)在理论方面，本文应用了 Xxx的专业方法，对于丰富果，并以具体的 xxx 例子展开应用得到较好的应用结果。</li>
<li>写论文的过程中有哪些困难，怎么克服的?<br>(如实叙即可，但一定要说问题是 solve 的!)<br>在撰写论文的过程中在xx方面(资料收集问卷发放实验开展)遇到有关 xxx(找不到相应主题的学术文献)困难，在与指导老师沟通后，查阅了老师推。荐的相关书籍、资料以及文献信息，也请教了直系的学长学姐们，最后 solve 了相关问题，在此也非常感谢给我提供帮助的他们。</li>
<li>论文哪些地方可以继续改进?<br>目前对于这个课题的认识确实还不够具体，所以在xxx 方萄的研究片法有一定限度，研究成果与前辈们的研究成果也确实相似，没有做到能够更加深入的研究。同时也受限于条件没能更多的试验方法</li>
<li>论文中的数据和资料从哪里来?<br>我的资料主要来自于知网等学术网站和导师提供的资料文献，数据是通过调查法以及些同类课题的数据参考,再统一分析计算得出</li>
<li>论文中相关定义的解释，理论解释?<br>要求你掌握本文研究中重点的一些概念及定义。有一些概率可以做一些生活中的举例来加深记忆。回答的时候也可以根据定义来加以拓展，比如:老师，这个问题我是这样理解的，以生活中的案例来举例 xxx 概念就好。比 XXX中的XXXX，对xxx是非常重要的。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/05/01/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/" data-id="cmiae68a6000rl4v5fn8s1avr" data-title="毕 业 设 计" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-RabbitMQ" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/11/RabbitMQ/" class="article-date">
  <time class="dt-published" datetime="2024-01-11T02:58:11.000Z" itemprop="datePublished">2024-01-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/11/RabbitMQ/">RabbitMQ</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="一、初识MQ"><a href="#一、初识MQ" class="headerlink" title="一、初识MQ"></a>一、初识MQ</h1><h4 id="1-同步和异步通讯"><a href="#1-同步和异步通讯" class="headerlink" title="1. 同步和异步通讯"></a>1. 同步和异步通讯</h4><p>微服务间通讯有同步和异步两种方式：<br>1、同步通讯：就像打电话，需要实时响应；<br>2、异步通讯：就像发邮件，不需要马上回复。<br>两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发送邮件可以同时与多个人收发邮件，但是往往响应会有延迟。<img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717161939695.png?raw=true" width="700" height="200"> </p>
<ol>
<li><p><strong>同步通讯</strong><br> 我们之前学习的Feign调用就属于同步方式，虽然调用可以实时得到结果，但存在下面的问题：<img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717162004285.png?raw=true" width="700" height="200"><br> 同步调用的优点：</p>
<ul>
<li>时效性较强</li>
<li>可以立即得到结果</li>
</ul>
<p> 同步调用的问题：</p>
<ul>
<li>耦合度高</li>
<li>性能和吞吐能力下降</li>
<li>有额外的资源消耗</li>
<li>有级联失败问题</li>
</ul>
</li>
<li><p><strong>异步通讯</strong>：常见实现是事件驱动模式<br> 异步调用则可以避免上述问题：我们以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，调用物流服务，从仓库分配响应的库存并准备发货。<br> 在事件模式中，支付服务是事件发布者（publisher），在支付完成后只需要发布一个支付成功的事件（event），事件中带上订单id。订单服务和物流服务是事件订阅者（Consumer），订阅支付成功的事件，监听到事件后完成自己业务即可。为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个中间人（Broker）。发布者发布事件到Broker，不关心谁来订阅事件。订阅者从Broker订阅事件，不关心谁发来的消息。<img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210422095356088.png?raw=true"><br> Broker 是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。</p>
<p> <strong>好处：</strong></p>
<ul>
<li>吞吐量提升：无需等待订阅者处理完成，响应更快速</li>
<li>故障隔离：服务没有直接调用，不存在级联失败问题</li>
<li>调用间没有阻塞，不会造成无效的资源占用</li>
<li>耦合度极低，每个服务都可以灵活插拔，可替换</li>
<li>流量削峰：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件</li>
</ul>
<p> <strong>缺点：</strong></p>
<ul>
<li>架构复杂了，业务没有明显的流程线，不好管理；</li>
<li>需要依赖于Broker的可靠、安全、性能<br> 好在现在开源软件或云平台上 Broker 的软件是非常成熟的，比较常见的一种就是我们今天要学习的MQ技术。</li>
</ul>
</li>
</ol>
<h4 id="2-技术对比"><a href="#2-技术对比" class="headerlink" title="2. 技术对比"></a>2. 技术对比</h4><p>MQ，中文是消息队列（MessageQueue），字面来看就是存放消息的队列。也就是事件驱动架构中的Broker。<br>比较常见的MQ实现：ActiveMQ，RabbitMQ，RocketMQ，Kafka。几种常见MQ的对比：</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>RabbitMQ</strong></th>
<th><strong>ActiveMQ</strong></th>
<th><strong>RocketMQ</strong></th>
<th><strong>Kafka</strong></th>
</tr>
</thead>
<tbody><tr>
<td>公司&#x2F;社区</td>
<td>Rabbit</td>
<td>Apache</td>
<td>阿里</td>
<td>Apache</td>
</tr>
<tr>
<td>开发语言</td>
<td>Erlang</td>
<td>Java</td>
<td>Java</td>
<td>Scala&amp;Java</td>
</tr>
<tr>
<td>协议支持</td>
<td>AMQP，XMPP，SMTP，STOMP</td>
<td>OpenWire,STOMP，REST,XMPP,AMQP</td>
<td>自定义协议</td>
<td>自定义协议</td>
</tr>
<tr>
<td>可用性</td>
<td>高</td>
<td>一般</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>单机吞吐量</td>
<td>一般</td>
<td>差</td>
<td>高</td>
<td>非常高</td>
</tr>
<tr>
<td>消息延迟</td>
<td>微秒级</td>
<td>毫秒级</td>
<td>毫秒级</td>
<td>毫秒以内</td>
</tr>
<tr>
<td>消息可靠性</td>
<td>高</td>
<td>一般</td>
<td>高</td>
<td>一般</td>
</tr>
</tbody></table>
<p>追求可用性：Kafka、 RocketMQ 、RabbitMQ</p>
<p>追求可靠性：RabbitMQ、RocketMQ</p>
<p>追求吞吐能力：RocketMQ、Kafka</p>
<p>追求消息低延迟：RabbitMQ、Kafka</p>
<h1 id="二、快速入门"><a href="#二、快速入门" class="headerlink" title="二、快速入门"></a>二、快速入门</h1><h4 id="1-安装RabbitMQ"><a href="#1-安装RabbitMQ" class="headerlink" title="1. 安装RabbitMQ"></a>1. 安装RabbitMQ</h4><!-- 安装RabbitMQ，参考课前资料：![](https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717162628635.png?raw=true) -->
<p>MQ的基本结构：<img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717162752376.png?raw=true"><br>RabbitMQ中的一些角色：</p>
<ul>
<li>publisher：生产者</li>
<li>consumer：消费者</li>
<li>exchange：交换机，负责消息路由</li>
<li>queue：队列，存储消息</li>
<li>virtualHost：虚拟主机，隔离不同租户的exchange、queue、消息的隔离</li>
</ul>
<h4 id="2-RabbitMQ消息模型"><a href="#2-RabbitMQ消息模型" class="headerlink" title="2. RabbitMQ消息模型"></a>2. RabbitMQ消息模型</h4><!-- RabbitMQ官方提供了5个不同的Demo示例，对应了不同的消息模型： -->
<p><img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717163332646.png?raw=true"></p>
<h4 id="3-导入Demo工程"><a href="#3-导入Demo工程" class="headerlink" title="3. 导入Demo工程"></a>3. 导入Demo工程</h4><!-- 课前资料提供了一个Demo工程，mq-demo:![](https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717163253264.png?raw=true)
导入后可以看到结构如下： -->
<p><img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717163604330.png?raw=true"><br>包括三部分：</p>
<ul>
<li>mq-demo：父工程，管理项目依赖</li>
<li>publisher：消息的发送者</li>
<li>consumer：消息的消费者</li>
</ul>
<h4 id="4-入门案例"><a href="#4-入门案例" class="headerlink" title="4. 入门案例"></a>4. 入门案例</h4><p>简单队列模式的模型图：<img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717163434647.png?raw=true" width="700" height="200"><br>官方的HelloWorld是基于最基础的消息队列模型来实现的，只包括三个角色：</p>
<ul>
<li>publisher：消息发布者，将消息发送到队列queue</li>
<li>queue：消息队列，负责接受并缓存消息</li>
<li>consumer：订阅队列，处理队列中的消息</li>
</ul>
<ol>
<li>publisher实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PublisherTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMessage</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 1.1.设置连接参数，分别是：主机名（改成自己的ip）、端口号、vhost、用户名、密码</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.150.101&quot;</span>); </span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2.建立连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建通道Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.发送消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, rabbitmq!&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;发送消息成功：【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.关闭通道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>consumer实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.150.101&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2.建立连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建通道Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.订阅消息</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span><br><span class="line"><span class="params">                                       AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="comment">// 5.处理消息</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">                System.out.println(<span class="string">&quot;接收到消息：【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息。。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
消息被消费后，就消失（阅后即焚）</li>
</ol>
<hr>

<h1 id="三、SpringAMQP"><a href="#三、SpringAMQP" class="headerlink" title="三、SpringAMQP"></a>三、SpringAMQP</h1><p>SpringAMQP 是基于 RabbitMQ 封装的一套模板，并且还利用 SpringBoot 对其实现了自动装配，使用起来非常方便。<br>SpringAMQP提供了三个功能：</p>
<ul>
<li>自动声明队列、交换机及其绑定关系</li>
<li>基于注解的监听器模式，异步接收消息</li>
<li>封装了RabbitTemplate工具，用于发送消息 <img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717164024967.png?raw=true" width="400" height="200">
<img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717164038678.png?raw=true" width="400" height="200"></li>
</ul>
<h4 id="1-Basic-Queue-简单队列模型"><a href="#1-Basic-Queue-简单队列模型" class="headerlink" title="1. Basic Queue 简单队列模型"></a>1. Basic Queue 简单队列模型</h4><p>在父工程mq-demo中引入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>消息发送<br>首先配置MQ地址，在publisher服务的application.yml中添加配置：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">itcast</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure>
然后在publisher服务中编写测试类SpringAmqpTest，并利用RabbitTemplate实现消息发送：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAmqpTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSimpleQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 队列名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        <span class="comment">// 消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, spring amqp!&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>消息接收<br>首先配置MQ地址，在consumer服务的application.yml中添加配置：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">itcast</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure>
然后在consumer服务的<code>cn.itcast.mq.listener</code>包中新建一个类SpringRabbitListener，代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringRabbitListener</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;spring 消费者接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="2-WorkQueue"><a href="#2-WorkQueue" class="headerlink" title="2. WorkQueue"></a>2. WorkQueue</h4><p>Work queues，也被称为（Task queues），任务模型。简单来说就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。<br>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。此时就可以使用 work 模型，多个消费者共同处理消息处理，速度就能大大提高了。<img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717164238910.png?raw=true" width="400" height="200"></p>
<ol>
<li>消息发送：在publisher服务中的SpringAmqpTest类中添加一个测试方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * workQueue</span></span><br><span class="line"><span class="comment">     * 向队列中不停发送消息，模拟消息堆积。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWorkQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, message_&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message + i);</span><br><span class="line">        Thread.sleep(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>消息接收：要模拟多个消费者绑定同一个队列，我们在consumer服务的SpringRabbitListener中添加2个新的方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue1</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">20</span>);``</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue2</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;消费者2........接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">200</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>测试：启动ConsumerApplication后，在执行publisher服务中刚刚编写的发送测试方法testWorkQueue。<br>可以看到消费者1很快完成了自己的25条消息。消费者2却在缓慢的处理自己的25条消息。也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。这样显然是有问题的。<br>在spring中有一个简单的配置，可以解决这个问题。我们修改consumer服务的application.yml文件，添加配置：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="3-发布-订阅"><a href="#3-发布-订阅" class="headerlink" title="3. 发布&#x2F;订阅"></a>3. 发布&#x2F;订阅</h4><p>发布订阅的模型如图：<img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717165309625.png?raw=true" width="500" height="200"><br>可以看到，在订阅模型中，多了一个exchange角色，而且过程略有变化：</p>
<ul>
<li>Publisher：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）</li>
<li>Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有以下3种类型：<ul>
<li>Fanout：广播，将消息交给所有绑定到交换机的队列</li>
<li>Direct：定向，把消息交给符合指定routing key 的队列</li>
<li>Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</li>
</ul>
</li>
<li>Consumer：消费者，与以前一样，订阅队列，没有变化</li>
<li>Queue：消息队列也与以前一样，接收消息、缓存消息。</li>
</ul>
<p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！<br>这样，实现了一个消息发送给多个消费者。</p>
<h4 id="4-Fanout"><a href="#4-Fanout" class="headerlink" title="4. Fanout"></a>4. Fanout</h4><p>在广播模式下，消息发送流程是这样的：</p>
<ul>
<li>1）  可以有多个队列</li>
<li>2）  每个队列都要绑定到Exchange（交换机）</li>
<li>3）  生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定</li>
<li>4）  交换机把消息发送给绑定过的所有队列</li>
<li>5）  订阅队列的消费者都能拿到消息</li>
</ul>
<p>我们的计划是这样的：</p>
<ul>
<li>创建一个交换机 itcast.fanout，类型是Fanout</li>
<li>创建两个队列fanout.queue1和fanout.queue2，绑定到交换机itcast.fanout<img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717165509466.png?raw=true" width="500" height="200"></li>
</ul>
<ol>
<li>声明队列和交换机<br>Spring提供了一个接口Exchange，来表示所有不同类型的交换机：<img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717165552676.png?raw=true"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在consumer中创建一个类，声明队列和交换机</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Fanout类型交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span>&#123;    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;itcast.fanout&quot;</span>);    &#125;</span><br><span class="line">    <span class="comment">// 队列1，绑定交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue1</span><span class="params">()</span>&#123;    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue1&quot;</span>);    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1</span><span class="params">(Queue fanoutQueue1, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 队列2，绑定交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue2</span><span class="params">()</span>&#123;    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue2&quot;</span>);    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2</span><span class="params">(Queue fanoutQueue2, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>消息发送<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在publisher服务的SpringAmqpTest类中添加测试方法</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFanoutExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;itcast.fanout&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, everyone!&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送到交换机</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>消息接收<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在consumer服务的SpringRabbitListener中添加两个方法，作为消费者</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue1</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue2</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="5-Direct"><a href="#5-Direct" class="headerlink" title="5. Direct"></a>5. Direct</h4><p>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。<br>在Direct模型下：</p>
<ul>
<li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>BindingKey</code>（路由key）</li>
<li>消息的发送方在 向 Exchange发送消息时，必须指定消息的 <code>RoutingKey</code>。</li>
<li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>RoutingKey</code>进行判断，只有队列的<code>Bindingkey</code>与消息的 <code>Routingkey</code>完全一致，才会接收到消息</li>
<li>一个队列可以有多个BindingKey。如果多个队列具有相同的RoutingKey，则与Fanout功能类似(可以模拟广播)<br><img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717170223317.png?raw=true"></li>
</ul>
<ol>
<li>基于注解声明队列和交换机<br>基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。<br>在consumer的SpringRabbitListener中添加两个消费者，同时基于注解 <code>@RabbitListener</code> 来声明队列和交换机：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消费者1+队列+交换机+BindingKey</span></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到direct.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消费者2+队列+交换机+BindingKey</span></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到direct.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>消息发送<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendDirectExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;itcast.direct&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息，携带 RoutingKey</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;red&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="6-Topic"><a href="#6-Topic" class="headerlink" title="6.Topic"></a>6.Topic</h4><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候使用通配符！<br><code>Routingkey</code> 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code><br>通配符规则：<code>#</code>：匹配一个或多个词；<code>*</code>：匹配不多不少恰好1个词<br>举例：<code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code>；<code>item.*</code>：只能匹配<code>item.spu</code>  ​<br><img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717170705380.png?raw=true"><br>解释：</p>
<ul>
<li>Queue1：绑定的是<code>china.#</code> ，因此凡是以 <code>china.</code>开头的<code>routing key</code> 都会被匹配到。包括china.news和china.weather</li>
<li>Queue2：绑定的是<code>#.news</code> ，因此凡是以 <code>.news</code>结尾的 <code>routing key</code> 都会被匹配。包括china.news和japan.news</li>
</ul>
<ol>
<li>消息发送<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;china.news&quot;</span>, message);</span><br></pre></td></tr></table></figure></li>
<li>消息接收<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;china.#&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br></pre></td></tr></table></figure></li>
<li>总结<br> 描述下Direct交换机与Topic交换机的差异？<ul>
<li>Topic交换机接收的消息RoutingKey必须是多个单词，以 <code>.</code> 分割</li>
<li>Topic交换机与队列绑定时的bindingKey可以指定通配符</li>
<li><code>#</code>：代表0个或多个词</li>
<li><code>*</code>：代表1个词</li>
</ul>
</li>
</ol>
<h4 id="7-消息转换器"><a href="#7-消息转换器" class="headerlink" title="7.消息转换器"></a>7.消息转换器</h4><p>之前说过，Spring会把你发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。</p>
<p><img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20200525170410401.png?raw=true" alt="image-20200525170410401"></p>
<p>只不过，默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：</p>
<ul>
<li>数据体积过大</li>
<li>有安全漏洞</li>
<li>可读性差</li>
</ul>
<p>显然，JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。</p>
<p>在publisher和consumer两个服务中都引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置消息转换器。在启动类中添加一个Bean即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">jsonMessageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/11/RabbitMQ/" data-id="cmiae68a3000hl4v5btxucmzb" data-title="RabbitMQ" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2046/12/">December 2046</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2046/08/">August 2046</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/12/">December 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2046/12/30/nice-photo/">Nice Photo</a>
          </li>
        
          <li>
            <a href="/2046/08/27/Guitar/">Guitar 🎸</a>
          </li>
        
          <li>
            <a href="/2025/12/08/MongoDB/">MongoDB</a>
          </li>
        
          <li>
            <a href="/2024/10/22/Docker_Kubernetes/">Kubernetes</a>
          </li>
        
          <li>
            <a href="/2024/09/22/InfluxDB/">InfluxDB</a>
          </li>
        
          <li>
            <a href="/2024/09/22/Golang/">Golang</a>
          </li>
        
          <li>
            <a href="/2024/08/18/%E7%90%86%E8%B4%A2/">Lic Ai</a>
          </li>
        
          <li>
            <a href="/2024/07/07/%E7%BE%8E%E7%9A%84Midea/">美 的 Midea</a>
          </li>
        
          <li>
            <a href="/2024/05/01/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/">毕 业 设 计</a>
          </li>
        
          <li>
            <a href="/2024/01/11/RabbitMQ/">RabbitMQ</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 fengcai<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>