<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Qué miras Bobo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Qué miras Bobo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Qué miras Bobo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="fengcai">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Qué miras Bobo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="https://github.com/leo710aka/bk/blob/main/DT1.jpg?raw=true">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Qué miras Bobo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-nice-photo" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2046/12/30/nice-photo/" class="article-date">
  <time class="dt-published" datetime="2046-12-30T03:11:00.000Z" itemprop="datePublished">2046-12-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2046/12/30/nice-photo/">Nice Photo</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <br>
<br>
<img src="https://leo710aka.github.io/bk/bk.jpg" width="550" height="300" alt="Old Master">
<br>
<img src="https://leo710aka.github.io/bk/zq.jpg" width="550" height="300" alt="">
<br>
<br>
<img src="https://leo710aka.github.io/bk/3.jpg" width="550" height="300" alt="">
<br>
<br>
<!-- <img src="https://leo710aka.github.io/bk/4.jpg" width="750" height="300" alt=""> -->
<!-- <img src="https://leo710aka.github.io/bk/zq2.jpg" width="550" height="200" alt="">
<br>
<br>
<img src="https://leo710aka.github.io/bk/zq3.jpg" width="550" height="200" alt="">
<br> -->
<div style="display: flex; justify-content: center;">
    <img src="https://leo710aka.github.io/bk/zq2.jpg" style="width: 100%; margin-right: 5px;">
    <img src="https://leo710aka.github.io/bk/zq3.jpg" style="width: 100%; margin-left: 5px;">
</div>
<br>
<br>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2046/12/30/nice-photo/" data-id="clrggyur1000ylkv52zgod7c9" data-title="Nice Photo" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-RabbitMQ" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/11/RabbitMQ/" class="article-date">
  <time class="dt-published" datetime="2024-01-11T02:58:11.000Z" itemprop="datePublished">2024-01-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/11/RabbitMQ/">RabbitMQ</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-初识MQ"><a href="#1-初识MQ" class="headerlink" title="1.初识MQ"></a>1.初识MQ</h1><h2 id="1-1-同步和异步通讯"><a href="#1-1-同步和异步通讯" class="headerlink" title="1.1.同步和异步通讯"></a>1.1.同步和异步通讯</h2><p>微服务间通讯有同步和异步两种方式：</p>
<p>同步通讯：就像打电话，需要实时响应。</p>
<p>异步通讯：就像发邮件，不需要马上回复。</p>
<p><img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717161939695.png?raw=true" alt="image-20210717161939695"></p>
<p>两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发送邮件可以同时与多个人收发邮件，但是往往响应会有延迟。</p>
<h3 id="1-1-1-同步通讯"><a href="#1-1-1-同步通讯" class="headerlink" title="1.1.1.同步通讯"></a>1.1.1.同步通讯</h3><p>我们之前学习的Feign调用就属于同步方式，虽然调用可以实时得到结果，但存在下面的问题：</p>
<p><img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717162004285.png?raw=true" alt="image-20210717162004285"></p>
<p>总结：</p>
<p>同步调用的优点：</p>
<ul>
<li>时效性较强，可以立即得到结果</li>
</ul>
<p>同步调用的问题：</p>
<ul>
<li>耦合度高</li>
<li>性能和吞吐能力下降</li>
<li>有额外的资源消耗</li>
<li>有级联失败问题</li>
</ul>
<h3 id="1-1-2-异步通讯"><a href="#1-1-2-异步通讯" class="headerlink" title="1.1.2.异步通讯"></a>1.1.2.异步通讯</h3><p>异步调用则可以避免上述问题：</p>
<p>我们以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，调用物流服务，从仓库分配响应的库存并准备发货。</p>
<p>在事件模式中，支付服务是事件发布者（publisher），在支付完成后只需要发布一个支付成功的事件（event），事件中带上订单id。</p>
<p>订单服务和物流服务是事件订阅者（Consumer），订阅支付成功的事件，监听到事件后完成自己业务即可。</p>
<p>为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个中间人（Broker）。发布者发布事件到Broker，不关心谁来订阅事件。订阅者从Broker订阅事件，不关心谁发来的消息。</p>
<p><img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210422095356088.png?raw=true" alt="image-20210422095356088"></p>
<p>Broker 是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。</p>
<p>好处：</p>
<ul>
<li><p>吞吐量提升：无需等待订阅者处理完成，响应更快速</p>
</li>
<li><p>故障隔离：服务没有直接调用，不存在级联失败问题</p>
</li>
<li><p>调用间没有阻塞，不会造成无效的资源占用</p>
</li>
<li><p>耦合度极低，每个服务都可以灵活插拔，可替换</p>
</li>
<li><p>流量削峰：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>架构复杂了，业务没有明显的流程线，不好管理</li>
<li>需要依赖于Broker的可靠、安全、性能</li>
</ul>
<p>好在现在开源软件或云平台上 Broker 的软件是非常成熟的，比较常见的一种就是我们今天要学习的MQ技术。</p>
<h2 id="1-2-技术对比："><a href="#1-2-技术对比：" class="headerlink" title="1.2.技术对比："></a>1.2.技术对比：</h2><p>MQ，中文是消息队列（MessageQueue），字面来看就是存放消息的队列。也就是事件驱动架构中的Broker。</p>
<p>比较常见的MQ实现：</p>
<ul>
<li>ActiveMQ</li>
<li>RabbitMQ</li>
<li>RocketMQ</li>
<li>Kafka</li>
</ul>
<p>几种常见MQ的对比：</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>RabbitMQ</strong></th>
<th><strong>ActiveMQ</strong></th>
<th><strong>RocketMQ</strong></th>
<th><strong>Kafka</strong></th>
</tr>
</thead>
<tbody><tr>
<td>公司&#x2F;社区</td>
<td>Rabbit</td>
<td>Apache</td>
<td>阿里</td>
<td>Apache</td>
</tr>
<tr>
<td>开发语言</td>
<td>Erlang</td>
<td>Java</td>
<td>Java</td>
<td>Scala&amp;Java</td>
</tr>
<tr>
<td>协议支持</td>
<td>AMQP，XMPP，SMTP，STOMP</td>
<td>OpenWire,STOMP，REST,XMPP,AMQP</td>
<td>自定义协议</td>
<td>自定义协议</td>
</tr>
<tr>
<td>可用性</td>
<td>高</td>
<td>一般</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>单机吞吐量</td>
<td>一般</td>
<td>差</td>
<td>高</td>
<td>非常高</td>
</tr>
<tr>
<td>消息延迟</td>
<td>微秒级</td>
<td>毫秒级</td>
<td>毫秒级</td>
<td>毫秒以内</td>
</tr>
<tr>
<td>消息可靠性</td>
<td>高</td>
<td>一般</td>
<td>高</td>
<td>一般</td>
</tr>
</tbody></table>
<p>追求可用性：Kafka、 RocketMQ 、RabbitMQ</p>
<p>追求可靠性：RabbitMQ、RocketMQ</p>
<p>追求吞吐能力：RocketMQ、Kafka</p>
<p>追求消息低延迟：RabbitMQ、Kafka</p>
<h1 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2.快速入门"></a>2.快速入门</h1><h2 id="2-1-安装RabbitMQ"><a href="#2-1-安装RabbitMQ" class="headerlink" title="2.1.安装RabbitMQ"></a>2.1.安装RabbitMQ</h2><p>安装RabbitMQ，参考课前资料：</p>
<p><img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717162628635.png?raw=true" alt="image-20210717162628635"></p>
<p>MQ的基本结构：</p>
<p><img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717162752376.png?raw=true" alt="image-20210717162752376"></p>
<p>RabbitMQ中的一些角色：</p>
<ul>
<li>publisher：生产者</li>
<li>consumer：消费者</li>
<li>exchange个：交换机，负责消息路由</li>
<li>queue：队列，存储消息</li>
<li>virtualHost：虚拟主机，隔离不同租户的exchange、queue、消息的隔离</li>
</ul>
<h2 id="2-2-RabbitMQ消息模型"><a href="#2-2-RabbitMQ消息模型" class="headerlink" title="2.2.RabbitMQ消息模型"></a>2.2.RabbitMQ消息模型</h2><p>RabbitMQ官方提供了5个不同的Demo示例，对应了不同的消息模型：</p>
<p><img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717163332646.png?raw=true" alt="image-20210717163332646"></p>
<h2 id="2-3-导入Demo工程"><a href="#2-3-导入Demo工程" class="headerlink" title="2.3.导入Demo工程"></a>2.3.导入Demo工程</h2><p>课前资料提供了一个Demo工程，mq-demo:</p>
<p><img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717163253264.png?raw=true" alt="image-20210717163253264"></p>
<p>导入后可以看到结构如下：</p>
<p><img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717163604330.png?raw=true" alt="image-20210717163604330"></p>
<p>包括三部分：</p>
<ul>
<li>mq-demo：父工程，管理项目依赖</li>
<li>publisher：消息的发送者</li>
<li>consumer：消息的消费者</li>
</ul>
<h2 id="2-4-入门案例"><a href="#2-4-入门案例" class="headerlink" title="2.4.入门案例"></a>2.4.入门案例</h2><p>简单队列模式的模型图：</p>
<p> <img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717163434647.png?raw=true" alt="image-20210717163434647"></p>
<p>官方的HelloWorld是基于最基础的消息队列模型来实现的，只包括三个角色：</p>
<ul>
<li>publisher：消息发布者，将消息发送到队列queue</li>
<li>queue：消息队列，负责接受并缓存消息</li>
<li>consumer：订阅队列，处理队列中的消息</li>
</ul>
<h3 id="2-4-1-publisher实现"><a href="#2-4-1-publisher实现" class="headerlink" title="2.4.1.publisher实现"></a>2.4.1.publisher实现</h3><p>思路：</p>
<ul>
<li>建立连接</li>
<li>创建Channel</li>
<li>声明队列</li>
<li>发送消息</li>
<li>关闭连接和channel</li>
</ul>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PublisherTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMessage</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.150.101&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2.建立连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建通道Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.发送消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, rabbitmq!&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;发送消息成功：【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.关闭通道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="2-4-2-consumer实现"><a href="#2-4-2-consumer实现" class="headerlink" title="2.4.2.consumer实现"></a>2.4.2.consumer实现</h3><p>代码思路：</p>
<ul>
<li>建立连接</li>
<li>创建Channel</li>
<li>声明队列</li>
<li>订阅消息</li>
</ul>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.150.101&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2.建立连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建通道Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.订阅消息</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span><br><span class="line"><span class="params">                                       AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="comment">// 5.处理消息</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">                System.out.println(<span class="string">&quot;接收到消息：【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息。。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5.总结"></a>2.5.总结</h2><p>基本消息队列的消息发送流程：</p>
<ol>
<li><p>建立connection</p>
</li>
<li><p>创建channel</p>
</li>
<li><p>利用channel声明队列</p>
</li>
<li><p>利用channel向队列发送消息</p>
</li>
</ol>
<p>基本消息队列的消息接收流程：</p>
<ol>
<li><p>建立connection</p>
</li>
<li><p>创建channel</p>
</li>
<li><p>利用channel声明队列</p>
</li>
<li><p>定义consumer的消费行为handleDelivery()</p>
</li>
<li><p>利用channel将消费者与队列绑定</p>
</li>
</ol>
<h1 id="3-SpringAMQP"><a href="#3-SpringAMQP" class="headerlink" title="3.SpringAMQP"></a>3.SpringAMQP</h1><p>SpringAMQP是基于RabbitMQ封装的一套模板，并且还利用SpringBoot对其实现了自动装配，使用起来非常方便。</p>
<p>SpringAmqp的官方地址：<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-amqp">https://spring.io/projects/spring-amqp</a></p>
<p><img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717164024967.png?raw=true" alt="image-20210717164024967"></p>
<p><img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717164038678.png?raw=true" alt="image-20210717164038678"></p>
<p>SpringAMQP提供了三个功能：</p>
<ul>
<li>自动声明队列、交换机及其绑定关系</li>
<li>基于注解的监听器模式，异步接收消息</li>
<li>封装了RabbitTemplate工具，用于发送消息</li>
</ul>
<h2 id="3-1-Basic-Queue-简单队列模型"><a href="#3-1-Basic-Queue-简单队列模型" class="headerlink" title="3.1.Basic Queue 简单队列模型"></a>3.1.Basic Queue 简单队列模型</h2><p>在父工程mq-demo中引入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="3-1-1-消息发送"><a href="#3-1-1-消息发送" class="headerlink" title="3.1.1.消息发送"></a>3.1.1.消息发送</h3><p>首先配置MQ地址，在publisher服务的application.yml中添加配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">itcast</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure>



<p>然后在publisher服务中编写测试类SpringAmqpTest，并利用RabbitTemplate实现消息发送：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAmqpTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSimpleQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 队列名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        <span class="comment">// 消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, spring amqp!&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-1-2-消息接收"><a href="#3-1-2-消息接收" class="headerlink" title="3.1.2.消息接收"></a>3.1.2.消息接收</h3><p>首先配置MQ地址，在consumer服务的application.yml中添加配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">itcast</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure>



<p>然后在consumer服务的<code>cn.itcast.mq.listener</code>包中新建一个类SpringRabbitListener，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringRabbitListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;spring 消费者接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-1-3-测试"><a href="#3-1-3-测试" class="headerlink" title="3.1.3.测试"></a>3.1.3.测试</h3><p>启动consumer服务，然后在publisher服务中运行测试代码，发送MQ消息</p>
<h2 id="3-2-WorkQueue"><a href="#3-2-WorkQueue" class="headerlink" title="3.2.WorkQueue"></a>3.2.WorkQueue</h2><p>Work queues，也被称为（Task queues），任务模型。简单来说就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。</p>
<p><img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717164238910.png?raw=true" alt="image-20210717164238910"></p>
<p>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。</p>
<p>此时就可以使用work 模型，多个消费者共同处理消息处理，速度就能大大提高了。</p>
<h3 id="3-2-1-消息发送"><a href="#3-2-1-消息发送" class="headerlink" title="3.2.1.消息发送"></a>3.2.1.消息发送</h3><p>这次我们循环发送，模拟大量消息堆积现象。</p>
<p>在publisher服务中的SpringAmqpTest类中添加一个测试方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * workQueue</span></span><br><span class="line"><span class="comment">     * 向队列中不停发送消息，模拟消息堆积。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWorkQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, message_&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message + i);</span><br><span class="line">        Thread.sleep(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-2-2-消息接收"><a href="#3-2-2-消息接收" class="headerlink" title="3.2.2.消息接收"></a>3.2.2.消息接收</h3><p>要模拟多个消费者绑定同一个队列，我们在consumer服务的SpringRabbitListener中添加2个新的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue1</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue2</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;消费者2........接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到这个消费者sleep了1000秒，模拟任务耗时。</p>
<h3 id="3-2-3-测试"><a href="#3-2-3-测试" class="headerlink" title="3.2.3.测试"></a>3.2.3.测试</h3><p>启动ConsumerApplication后，在执行publisher服务中刚刚编写的发送测试方法testWorkQueue。</p>
<p>可以看到消费者1很快完成了自己的25条消息。消费者2却在缓慢的处理自己的25条消息。</p>
<p>也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。这样显然是有问题的。</p>
<h3 id="3-2-4-能者多劳"><a href="#3-2-4-能者多劳" class="headerlink" title="3.2.4.能者多劳"></a>3.2.4.能者多劳</h3><p>在spring中有一个简单的配置，可以解决这个问题。我们修改consumer服务的application.yml文件，添加配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure>



<h3 id="3-2-5-总结"><a href="#3-2-5-总结" class="headerlink" title="3.2.5.总结"></a>3.2.5.总结</h3><p>Work模型的使用：</p>
<ul>
<li>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理</li>
<li>通过设置prefetch来控制消费者预取的消息数量</li>
</ul>
<h2 id="3-3-发布-订阅"><a href="#3-3-发布-订阅" class="headerlink" title="3.3.发布&#x2F;订阅"></a>3.3.发布&#x2F;订阅</h2><p>发布订阅的模型如图：</p>
<p><img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717165309625.png?raw=true" alt="image-20210717165309625"></p>
<p>可以看到，在订阅模型中，多了一个exchange角色，而且过程略有变化：</p>
<ul>
<li>Publisher：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）</li>
<li>Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有以下3种类型：<ul>
<li>Fanout：广播，将消息交给所有绑定到交换机的队列</li>
<li>Direct：定向，把消息交给符合指定routing key 的队列</li>
<li>Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</li>
</ul>
</li>
<li>Consumer：消费者，与以前一样，订阅队列，没有变化</li>
<li>Queue：消息队列也与以前一样，接收消息、缓存消息。</li>
</ul>
<p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p>
<h2 id="3-4-Fanout"><a href="#3-4-Fanout" class="headerlink" title="3.4.Fanout"></a>3.4.Fanout</h2><p>Fanout，英文翻译是扇出，我觉得在MQ中叫广播更合适。</p>
<p><img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717165438225.png?raw=true" alt="image-20210717165438225"></p>
<p>在广播模式下，消息发送流程是这样的：</p>
<ul>
<li>1）  可以有多个队列</li>
<li>2）  每个队列都要绑定到Exchange（交换机）</li>
<li>3）  生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定</li>
<li>4）  交换机把消息发送给绑定过的所有队列</li>
<li>5）  订阅队列的消费者都能拿到消息</li>
</ul>
<p>我们的计划是这样的：</p>
<ul>
<li>创建一个交换机 itcast.fanout，类型是Fanout</li>
<li>创建两个队列fanout.queue1和fanout.queue2，绑定到交换机itcast.fanout</li>
</ul>
<p><img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717165509466.png?raw=true" alt="image-20210717165509466"></p>
<h3 id="3-4-1-声明队列和交换机"><a href="#3-4-1-声明队列和交换机" class="headerlink" title="3.4.1.声明队列和交换机"></a>3.4.1.声明队列和交换机</h3><p>Spring提供了一个接口Exchange，来表示所有不同类型的交换机：</p>
<p><img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717165552676.png?raw=true" alt="image-20210717165552676"></p>
<p>在consumer中创建一个类，声明队列和交换机：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.FanoutExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Fanout类型交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;itcast.fanout&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第1个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1</span><span class="params">(Queue fanoutQueue1, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第2个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2</span><span class="params">(Queue fanoutQueue2, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-4-2-消息发送"><a href="#3-4-2-消息发送" class="headerlink" title="3.4.2.消息发送"></a>3.4.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFanoutExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;itcast.fanout&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, everyone!&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-4-3-消息接收"><a href="#3-4-3-消息接收" class="headerlink" title="3.4.3.消息接收"></a>3.4.3.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加两个方法，作为消费者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue1</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue2</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-4-4-总结"><a href="#3-4-4-总结" class="headerlink" title="3.4.4.总结"></a>3.4.4.总结</h3><p>交换机的作用是什么？</p>
<ul>
<li>接收publisher发送的消息</li>
<li>将消息按照规则路由到与之绑定的队列</li>
<li>不能缓存消息，路由失败，消息丢失</li>
<li>FanoutExchange的会将消息路由到每个绑定的队列</li>
</ul>
<p>声明队列、交换机、绑定关系的Bean是什么？</p>
<ul>
<li>Queue</li>
<li>FanoutExchange</li>
<li>Binding</li>
</ul>
<h2 id="3-5-Direct"><a href="#3-5-Direct" class="headerlink" title="3.5.Direct"></a>3.5.Direct</h2><p>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。</p>
<p><img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717170041447.png?raw=true" alt="image-20210717170041447"></p>
<p> 在Direct模型下：</p>
<ul>
<li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</li>
<li>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li>
<li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</li>
</ul>
<p><strong>案例需求如下</strong>：</p>
<ol>
<li><p>利用@RabbitListener声明Exchange、Queue、RoutingKey</p>
</li>
<li><p>在consumer服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2</p>
</li>
<li><p>在publisher中编写测试方法，向itcast. direct发送消息</p>
</li>
</ol>
<p><img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717170223317.png?raw=true" alt="image-20210717170223317"></p>
<h3 id="3-5-1-基于注解声明队列和交换机"><a href="#3-5-1-基于注解声明队列和交换机" class="headerlink" title="3.5.1.基于注解声明队列和交换机"></a>3.5.1.基于注解声明队列和交换机</h3><p>基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。</p>
<p>在consumer的SpringRabbitListener中添加两个消费者，同时基于注解来声明队列和交换机：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到direct.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到direct.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-5-2-消息发送"><a href="#3-5-2-消息发送" class="headerlink" title="3.5.2.消息发送"></a>3.5.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendDirectExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;itcast.direct&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;red&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-5-3-总结"><a href="#3-5-3-总结" class="headerlink" title="3.5.3.总结"></a>3.5.3.总结</h3><p>描述下Direct交换机与Fanout交换机的差异？</p>
<ul>
<li>Fanout交换机将消息路由给每一个与之绑定的队列</li>
<li>Direct交换机根据RoutingKey判断路由给哪个队列</li>
<li>如果多个队列具有相同的RoutingKey，则与Fanout功能类似</li>
</ul>
<p>基于@RabbitListener注解声明队列和交换机有哪些常见注解？</p>
<ul>
<li>@Queue</li>
<li>@Exchange</li>
</ul>
<h2 id="3-6-Topic"><a href="#3-6-Topic" class="headerlink" title="3.6.Topic"></a>3.6.Topic</h2><h3 id="3-6-1-说明"><a href="#3-6-1-说明" class="headerlink" title="3.6.1.说明"></a>3.6.1.说明</h3><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候使用通配符！</p>
<p><code>Routingkey</code> 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code></p>
<p> 通配符规则：</p>
<p><code>#</code>：匹配一个或多个词</p>
<p><code>*</code>：匹配不多不少恰好1个词</p>
<p>举例：</p>
<p><code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code></p>
<p><code>item.*</code>：只能匹配<code>item.spu</code></p>
<p>​     </p>
<p>图示：</p>
<p> <img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717170705380.png?raw=true" alt="image-20210717170705380"></p>
<p>解释：</p>
<ul>
<li>Queue1：绑定的是<code>china.#</code> ，因此凡是以 <code>china.</code>开头的<code>routing key</code> 都会被匹配到。包括china.news和china.weather</li>
<li>Queue2：绑定的是<code>#.news</code> ，因此凡是以 <code>.news</code>结尾的 <code>routing key</code> 都会被匹配。包括china.news和japan.news</li>
</ul>
<p>案例需求：</p>
<p>实现思路如下：</p>
<ol>
<li><p>并利用@RabbitListener声明Exchange、Queue、RoutingKey</p>
</li>
<li><p>在consumer服务中，编写两个消费者方法，分别监听topic.queue1和topic.queue2</p>
</li>
<li><p>在publisher中编写测试方法，向itcast. topic发送消息</p>
</li>
</ol>
<p><img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717170829229.png?raw=true" alt="image-20210717170829229"></p>
<h3 id="3-6-2-消息发送"><a href="#3-6-2-消息发送" class="headerlink" title="3.6.2.消息发送"></a>3.6.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * topicExchange</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendTopicExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;itcast.topic&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;喜报！孙悟空大战哥斯拉，胜!&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;china.news&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-6-3-消息接收"><a href="#3-6-3-消息接收" class="headerlink" title="3.6.3.消息接收"></a>3.6.3.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;china.#&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到topic.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;#.news&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到topic.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-6-4-总结"><a href="#3-6-4-总结" class="headerlink" title="3.6.4.总结"></a>3.6.4.总结</h3><p>描述下Direct交换机与Topic交换机的差异？</p>
<ul>
<li>Topic交换机接收的消息RoutingKey必须是多个单词，以 <code>**.**</code> 分割</li>
<li>Topic交换机与队列绑定时的bindingKey可以指定通配符</li>
<li><code>#</code>：代表0个或多个词</li>
<li><code>*</code>：代表1个词</li>
</ul>
<h2 id="3-7-消息转换器"><a href="#3-7-消息转换器" class="headerlink" title="3.7.消息转换器"></a>3.7.消息转换器</h2><p>之前说过，Spring会把你发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。</p>
<p><img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20200525170410401.png?raw=true" alt="image-20200525170410401"></p>
<p>只不过，默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：</p>
<ul>
<li>数据体积过大</li>
<li>有安全漏洞</li>
<li>可读性差</li>
</ul>
<p>我们来测试一下。</p>
<h3 id="3-7-1-测试默认转换器"><a href="#3-7-1-测试默认转换器" class="headerlink" title="3.7.1.测试默认转换器"></a>3.7.1.测试默认转换器</h3><p>我们修改消息发送的代码，发送一个Map对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMap</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 准备消息</span></span><br><span class="line">    Map&lt;String,Object&gt; msg = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    msg.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    msg.put(<span class="string">&quot;age&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;simple.queue&quot;</span>,<span class="string">&quot;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>停止consumer服务</p>
<p>发送消息后查看控制台：</p>
<p><img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210422232835363.png?raw=true" alt="image-20210422232835363"></p>
<h3 id="3-7-2-配置JSON转换器"><a href="#3-7-2-配置JSON转换器" class="headerlink" title="3.7.2.配置JSON转换器"></a>3.7.2.配置JSON转换器</h3><p>显然，JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。</p>
<p>在publisher和consumer两个服务中都引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置消息转换器。</p>
<p>在启动类中添加一个Bean即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">jsonMessageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/11/RabbitMQ/" data-id="clrggyuqt000llkv535yw8et0" data-title="RabbitMQ" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Redis" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/10/Redis/" class="article-date">
  <time class="dt-published" datetime="2024-01-10T03:49:42.000Z" itemprop="datePublished">2024-01-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/10/Redis/">Redis</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Redis是一种支持 key-value 等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。 默认端口：<strong>6379</strong></p>
<h2 id="启动-Redis"><a href="#启动-Redis" class="headerlink" title="启动 Redis"></a>启动 Redis</h2><p>下载 Windows版 msi文件：<a target="_blank" rel="noopener" href="https://github.com/microsoftarchive/redis/releases">https://github.com/microsoftarchive/redis/releases</a><br>在环境变量中配好 Redis 的安装目录后，直接打开 cmd，启动 Redis 客户端<br>启动客户端后, 在客户端cmd窗口中测试 Redis 是否正常工作，设置密码（<strong>命令行设置的密码在服务重启后失效</strong>）<br>注意：<strong>在 Windows 环境下，Redis 不支持后台运行模式，因此在启动 Redis 服务器时必须保持 cmd 窗口一直打开</strong>。（如果想要在后台运行 Redis，可以考虑使用虚拟机或者 Linux 环境下的 Redis）</p>
<ul>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\蔡枫&gt;redis-cli   <span class="comment"># 启动 Redis 客户端（默认Redis服务端未关闭）</span></span><br><span class="line">127.0.0.1:6379&gt; ping                                <span class="comment"># 在 Redis 客户端中输入 ping 命令</span></span><br><span class="line">PONG                                                <span class="comment"># 返回 PONG 表示 正常工作</span></span><br><span class="line">127.0.0.1:6379&gt; config <span class="built_in">set</span> requirepass chskj.2020   <span class="comment"># 修改密码</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; auth chskj.2020                     <span class="comment"># 验证密码</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass              <span class="comment"># 查看密码</span></span><br><span class="line">1)<span class="string">&quot;requirepass&quot;</span></span><br><span class="line">2)<span class="string">&quot;chskj.2020&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="启动-重启-Redis-服务器，客户端"><a href="#启动-重启-Redis-服务器，客户端" class="headerlink" title="启动(重启) Redis 服务器，客户端"></a>启动(重启) Redis 服务器，客户端</h3><p>进入 Redis 的安装目录(D:\Redis)，打开 cmd 窗口(地址栏cmd回车)，执行 redis-server.exe redis.windows.conf，即可<strong>启动 Redis 服务器</strong>。<br>启动Redis服务器后，在 Redis 安装目录打开另一个 cmd 窗口，执行 redis-cli.exe，(或直接双击文件夹中的redis-cli.exe)即可<strong>启动（重启）Redis 客户端</strong>。</p>
<h3 id="库"><a href="#库" class="headerlink" title="库"></a>库</h3><p>Redis中有16个数据库（Database），每个数据库都是一个独立的命名空间，用于存储键值对数据。这些数据库被编号为0到15，默认情况下客户端连接到数据库0。可以通过<code>SELECT</code>命令选择数据库来切换不同的数据库空间，每个数据库都是相互隔离的，数据不会互相干扰。<br>每个数据库都可以包含键值对数据，命令和配置，但请注意，Redis的每个数据库是相对较小的，因此可以将不同类型的数据存储在不同的数据库中，以便更好地组织和管理数据。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 1   <span class="comment"># 切换到数据库1</span></span><br></pre></td></tr></table></figure>


<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Redis所有的key（键）都是字符串。我们在<strong>谈基础数据结构时，讨论的是存储值的数据类型</strong>，主要包括常见的5种数据类型，分别是：String、List、Set、Zset、Hash。 三种特殊的数据类型，分别是 HyperLogLogs（基数统计），Bitmaps (位图) 和 geospatial（地理位置）。 Redis5.0 中还增加了一个数据结构Stream，它借鉴了Kafka的设计，是一个新的强大的支持多播的可持久化的消息队列。</p>
<!-- ![](https://pdai.tech/images/db/redis/db-redis-object-2-2.png) -->
<table>
<thead>
<tr>
<th>结构类型</th>
<th>结构存储的值</th>
<th>结构的读写能力</th>
</tr>
</thead>
<tbody><tr>
<td><strong>String字符串</strong></td>
<td>可以是字符串、整数或浮点数</td>
<td>对整个字符串或字符串的一部分进行操作；对整数或浮点数进行自增或自减操作；</td>
</tr>
<tr>
<td><strong>List列表</strong></td>
<td>一个链表，链表上的每个节点都包含一个字符串</td>
<td>对链表的两端进行push和pop操作，读取单个或多个元素；根据值查找或删除元素；</td>
</tr>
<tr>
<td><strong>Set集合包</strong></td>
<td>含字符串的无序集合</td>
<td>字符串的集合，包含基础的方法有看是否存在添加、获取、删除；还包含计算交集、并集、差集等</td>
</tr>
<tr>
<td><strong>Hash散列</strong></td>
<td>包含键值对的无序散列表</td>
<td>包含方法有添加、获取、删除单个元素</td>
</tr>
<tr>
<td><strong>Zset有序集合</strong></td>
<td>和散列一样，用于存储键值对字符串成员与浮点数分数之间的有序映射；元素的排列顺序由分数的大小决定；</td>
<td>包含方法有添加、获取、删除单个元素以及根据分值范围或成员来获取元素</td>
</tr>
</tbody></table>
<h3 id="String字符串"><a href="#String字符串" class="headerlink" title="String字符串"></a>String字符串</h3><ul>
<li>String是redis中最基本的数据类型，一个key对应一个value。</li>
<li>String类型是二进制安全的，意思是 redis 的 string 可以包含任何数据。如数字，字符串，jpg图片或者序列化的对象。</li>
<li>实战场景<ul>
<li>缓存： 经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力。</li>
<li>计数器：redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。session：常见方案spring session + redis实现session共享，</li>
</ul>
</li>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> hello world    <span class="comment"># 设置存储在给定键中的值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get hello          <span class="comment"># 获取存储在给定键中的值</span></span><br><span class="line"><span class="string">&quot;world&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; del hello          <span class="comment"># 删除存储在给定键中的值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> counter 2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get counter       </span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; incr counter       <span class="comment"># 将键存储的值加1</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; get counter</span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; incrby counter 100 <span class="comment"># 将键存储的值加上整数</span></span><br><span class="line">(<span class="built_in">integer</span>) 103</span><br><span class="line">127.0.0.1:6379&gt; get counter</span><br><span class="line"><span class="string">&quot;103&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; decr counter       <span class="comment"># 将键存储的值减1</span></span><br><span class="line">(<span class="built_in">integer</span>) 102</span><br><span class="line">127.0.0.1:6379&gt; get counter</span><br><span class="line"><span class="string">&quot;102&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="List列表"><a href="#List列表" class="headerlink" title="List列表"></a>List列表</h3><ul>
<li>Redis中的List其实就是链表（Redis用双端链表实现List）。</li>
<li>使用List结构，我们可以轻松地实现最新消息排队功能（比如新浪微博的TimeLine）。List的另一个应用就是消息队列，可以利用List的 PUSH 操作，将任务存放在List中，然后工作线程再用 POP 操作将任务取出进行执行。</li>
<li>使用列表的技巧：lpush+lpop&#x3D;Stack(栈)，lpush+rpop&#x3D;Queue（队列），lpush+ltrim&#x3D;Capped Collection（有限集合），lpush+brpop&#x3D;Message Queue（消息队列）</li>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush mylist 1 2 ll <span class="built_in">ls</span> mem   <span class="comment"># 将给定值推入到列表左端，RPUSH 将给定值推入到列表右端</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1           <span class="comment"># 获取列表在给定范围上的所有值</span></span><br><span class="line">1) <span class="string">&quot;mem&quot;</span></span><br><span class="line">2) <span class="string">&quot;ls&quot;</span></span><br><span class="line">3) <span class="string">&quot;ll&quot;</span></span><br><span class="line">4) <span class="string">&quot;2&quot;</span></span><br><span class="line">5) <span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lindex mylist -1             <span class="comment"># 可以使用负数下标，以 -n 表示列表的倒数第n个元素</span></span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; rpop mylist                  <span class="comment"># 从列表的右端弹出一个值，并返回被弹出的值；lpop 从左弹</span></span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lindex mylist 10             <span class="comment"># index不在 mylist 的区间范围内</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><ul>
<li>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</li>
<li>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</li>
<li>实战场景<ul>
<li>标签（tag）,给用户添加标签，或用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人。</li>
<li>点赞，或点踩，收藏等，可以放到set中实现</li>
</ul>
</li>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myset hao hao1 xiaohao hao  <span class="comment"># 向集合添加一个或多个成员	</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; scard myset                      <span class="comment"># 获取集合的成员数	</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; smembers myset                   <span class="comment"># 返回集合中的所有成员	</span></span><br><span class="line">1) <span class="string">&quot;xiaohao&quot;</span></span><br><span class="line">2) <span class="string">&quot;hao1&quot;</span></span><br><span class="line">3) <span class="string">&quot;hao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; sismember myset hao              <span class="comment"># 判断 member 元素是否是集合 key 的成员</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Hash散列"><a href="#Hash散列" class="headerlink" title="Hash散列"></a>Hash散列</h3><ul>
<li>Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</li>
<li>实战场景 - 缓存： 能直观，相比string更节省空间，的维护缓存信息，如用户信息，视频信息等。</li>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset user name1 hao               <span class="comment"># 添加键值对	</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hset user email1 hao@163.com</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall user                      <span class="comment"># 获取散列中包含的所有键值对	</span></span><br><span class="line">1) <span class="string">&quot;name1&quot;</span></span><br><span class="line">2) <span class="string">&quot;hao&quot;</span></span><br><span class="line">3) <span class="string">&quot;email1&quot;</span></span><br><span class="line">4) <span class="string">&quot;hao@163.com&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hget user user                    <span class="comment"># 获取指定散列键的值</span></span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; hget user name1</span><br><span class="line"><span class="string">&quot;hao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hset user name2 xiaohao</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hdel user name1                   <span class="comment"># 如果给定键存在于散列中，那么就移除这个键</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall user</span><br><span class="line">1) <span class="string">&quot;email1&quot;</span></span><br><span class="line">2) <span class="string">&quot;hao@163.com&quot;</span></span><br><span class="line">3) <span class="string">&quot;name2&quot;</span></span><br><span class="line">4) <span class="string">&quot;xiaohao&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Zset有序集合"><a href="#Zset有序集合" class="headerlink" title="Zset有序集合"></a>Zset有序集合</h3><ul>
<li>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。</li>
<li>有序集合的成员是唯一的, 但分数(score)却可以重复。有序集合是通过两种数据结构实现：<ol>
<li>压缩列表(ziplist): ziplist是为了提高存储效率而设计的一种特殊编码的双向链表。它可以存储字符串或者整数，存储整数时是采用整数的二进制而不是字符串形式存储。它能在O(1)的时间复杂度下完成list两端的push和pop操作。但是因为每次操作都需要重新分配ziplist的内存，所以实际复杂度和ziplist的内存使用量相关</li>
<li>跳跃表(zSkiplist): 跳跃表的性能可以保证在查找，删除，添加等操作的时候在对数期望时间内完成，这个性能是可以和平衡树来相比较的，而且在实现方面比平衡树要优雅，这是采用跳跃表的主要原因。跳跃表的复杂度是O(log(n))。</li>
</ol>
</li>
<li>实战场景 - 排行榜：有序集合经典使用场景。例如小说视频等网站需要对用户上传的小说视频做排行榜，榜单可以按照用户关注数，更新时间，字数等打分，做排行。</li>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd myscoreset 100 hao 90 xiaohao  <span class="comment"># 将一个带有给定分值的成员添加到有序集合里面</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myscoreset 0 -1            <span class="comment"># 根据元素在有序集合中所处位置，从有序集合中获取多个元素</span></span><br><span class="line">1) <span class="string">&quot;xiaohao&quot;</span></span><br><span class="line">2) <span class="string">&quot;hao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZSCORE myscoreset hao</span><br><span class="line"><span class="string">&quot;100&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrem myscoreset hao               <span class="comment"># 如果给定元素成员存在于有序集合中，那么就移除这个元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>采用一种基数算法，用于完成独立总数的统计。（同一个人多次访问，只记一访问量）（独立访客）<br>占据空间小，无论统计多少个数据，只占12K的内存空间<br>不精确的统计算法，标准误差为 0.81%。</p>
<h3 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h3><p>不是一种独立的数据结构，实际上就是字符串<br>支持按位存取数据，可以将其看成是byte数组<br>适合存储索大量的连续的数据的布尔值。（记录一个人连续一年每天的签到情况 0&#x2F;1）（日活跃用户）</p>
<hr>


<h2 id="RedisTemplate"><a href="#RedisTemplate" class="headerlink" title="RedisTemplate"></a>RedisTemplate</h2><ul>
<li>Spring Boot提供了<code>RedisTemplate</code>作为与Redis交互的强大工具。通过<code>RedisTemplate</code>，您可以在java项目中执行各种Redis命令来操作数据，包括字符串、列表、集合、散列、有序集合等。以下是一些常见的Redis操作示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储数据：</span></span><br><span class="line">redisTemplate.opsForValue().set(<span class="string">&quot;myKey&quot;</span>, <span class="string">&quot;myValue&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (String) redisTemplate.opsForValue().get(<span class="string">&quot;myKey&quot;</span>);</span><br><span class="line"><span class="comment">// 列表操作：</span></span><br><span class="line">redisTemplate.opsForList().leftPush(<span class="string">&quot;myList&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">List&lt;String&gt; myList = redisTemplate.opsForList().range(<span class="string">&quot;myList&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 集合操作：</span></span><br><span class="line">redisTemplate.opsForSet().add(<span class="string">&quot;mySet&quot;</span>, <span class="string">&quot;member1&quot;</span>, <span class="string">&quot;member2&quot;</span>);</span><br><span class="line">Set&lt;String&gt; mySet = redisTemplate.opsForSet().members(<span class="string">&quot;mySet&quot;</span>);</span><br><span class="line"><span class="comment">// 散列操作：</span></span><br><span class="line">Map&lt;String, String&gt; myHash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">myHash.put(<span class="string">&quot;field1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">myHash.put(<span class="string">&quot;field2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">redisTemplate.opsForHash().putAll(<span class="string">&quot;myHash&quot;</span>, myHash);</span><br><span class="line"><span class="type">String</span> <span class="variable">fieldValue</span> <span class="operator">=</span> (String) redisTemplate.opsForHash().get(<span class="string">&quot;myHash&quot;</span>, <span class="string">&quot;field1&quot;</span>);</span><br><span class="line"><span class="comment">// 有序集合操作：</span></span><br><span class="line">redisTemplate.opsForZSet().add(<span class="string">&quot;myZSet&quot;</span>, <span class="string">&quot;member1&quot;</span>, <span class="number">1.0</span>);</span><br><span class="line">Set&lt;String&gt; myZSet = redisTemplate.opsForZSet().range(<span class="string">&quot;myZSet&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li>
<li>公共命令<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redisTemplate.delete(key);  <span class="comment">// 删除一个数据结构</span></span><br><span class="line">redisTemplate.hasKey(key);  <span class="comment">// 是否存在一个数据结构</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Redis-事务管理"><a href="#Redis-事务管理" class="headerlink" title="Redis 事务管理"></a>Redis 事务管理</h3><ul>
<li>要使用编程式事务<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTransaction</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">SessionCallback</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">execute</span><span class="params">(RedisOperations redisOperations)</span> <span class="keyword">throws</span> DataAccessException &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> <span class="string">&quot;text:tx&quot;</span>;           </span><br><span class="line">            redisOperations.multi();         <span class="comment">// 启用事务</span></span><br><span class="line">            redisOperations.opsForSet().add(redisKey, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">            redisOperations.opsForSet().add(redisKey, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">            redisOperations.opsForSet().add(redisKey, <span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">            <span class="comment">// redis事务内做查询，无效</span></span><br><span class="line">            <span class="comment">// redis事务中的所有代码在事务提交后一起执行</span></span><br><span class="line">            System.out.println(redisOperations.opsForSet().members(redisKey));            </span><br><span class="line">            <span class="keyword">return</span> redisOperations.exec();   <span class="comment">// 提交事务</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>


<h2 id="Redis缓存问题"><a href="#Redis缓存问题" class="headerlink" title="Redis缓存问题"></a>Redis缓存问题</h2><p>在高并发的业务场景下，数据库大多数情况都是用户并发访问最薄弱的环节。所以，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问Mysql等数据库。这样可以大大缓解数据库的压力。<strong>当缓存库出现时，必须要考虑如下问题：</strong></p>
<ol>
<li><strong>缓存穿透</strong><ul>
<li>问题来源<br> 缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求。由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义，<br> 在流量大时，可能DB就挂掉了，要是有人利用不存在的kev频繁攻击我们的应用，这就是漏洞.<br> 如发起为id为”-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</li>
<li>1、接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;&#x3D;0的直接拦截<br> 2、从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒 (设置太长会导致正常情况也没法使用)。这样可以防止攻击用户反复用同一个id暴力攻击<br> 3、布隆过滤器。bloomfilter就类似于一个hash set，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断个key是否存在于某容器，不存在就直接返回。布隆过滤器的关键就在于hash算法和容器大小，</li>
</ul>
</li>
<li><strong>缓存击穿</strong><ul>
<li>问题来源：    缓存击穿是指缓存中没有但数据库中有的数据(一般是缓存时间到期)，这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力.</li>
<li>1、设置热点数据永远不过期<br> 2、接口限流与熔断，降级。重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些 &#x2F;3务不可用时候，进行熔断，失败快速返回机制。<br> 3、加互斥锁</li>
</ul>
</li>
<li><strong>缓存雪崩</strong><ul>
<li>问题来源： 缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</li>
<li>1、缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生<br> 2、如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中<br> 3、设置热点数据永远不过期.</li>
</ul>
</li>
<li><strong>缓存污染(或满了)</strong><ul>
<li>缓存污染问题说的是缓存中一些只会被访问一次或者几次的的数据，被访问完后，再也不会被访问到，但这部分数据依然留存在缓存中，消耗缓存空间.</li>
<li>缓存污染会随着数据的持续增加而逐渐显露，随着服务的不新运行，缓存中会存在大量的永远不会再次被访问的数据。缓存空间是有限的，如果缓存空间满了，再往缓存里写数据时就会有额外开销，影响Redis性能。这部分额外开销主要是指写的时候判断淘汰策略，根据淘汰策略去选择要淘汰的数据，然后进行删除操作。</li>
</ul>
</li>
</ol>
<h3 id="缓存淘汰策略"><a href="#缓存淘汰策略" class="headerlink" title="缓存淘汰策略"></a>缓存淘汰策略</h3><p>Redis共支持八种淘汰策略，分别是noeviction, volatile-random、 volatile-ttl， volatile-ru、 volatile-lfuallkeys-lru、allkeys-Iandom 和 allkevs-lfu 策略。主要看分三类看:</p>
<ul>
<li>不淘汰<br>noeviction (v4.0后默认的)：一旦缓存被写满了，再有写请求来时，Redis 不再提供服务，而是直接返回错误。这种策略不会淘汰数据，所以无法解决缓存污染问题。一般生产环境不建议使用。</li>
<li>对设置了过期时间的数据中进行淘汰<br>随机 volatile-random：在设置了过期时间的键值对中，进行随机删除。因为是随机删除，无法把不再访问的数据筛选出来，所以可能依然会存在缓存污染现象，无法解决<strong>缓存污染</strong>问题。<br>tvolatile-ttl：Redis在筛选需删除的数据时，越早过期的数据越优先被选择。随机删除就无法解决缓存污染问题。<br>volatile-lru：LRU 算法的全称是 Least Recently Used，按照最近最少使用的原则来筛选数据<br>volatile-lfu：LFU 缓存策略是在 LRU 策略基础上，为每个数据增加了一个计数器，来统计这个数据的访问次数。当使用 LFU 策略筛选淘汰数据时，首先会根据数据的访问次数进行筛选，把访问次数最低的数据淘汰出缓存。如果两个数据的访问次数相同，LFU 策略再比较这两个数据的访问时效性，把距离上一次访问时间更久的数据淘汰出缓存。</li>
<li>全部数据进行淘汰<br>随机 allkeys-random：从所有键值对中随机选择并删除数据。<br>allkeys-lru：使用 LRU 算法在所有数据中进行筛选。<br>allkeys-lfu：使用 LFU 算法在所有数据中进行筛选。</li>
</ul>
<h2 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h2><p>Redis 提供了两种主要的持久化方式，用于在系统重启时保持数据的持久性：RDB 持久化和 AOF 持久化。<br>用户可以根据实际需求选择 RDB 持久化、AOF 持久化或两者结合使用。通常情况下，AOF 持久化是更安全的选择，因为它可以提供更好的持久性保障，但也需要更多的磁盘空间。</p>
<ol>
<li><strong>RDB 持久化：</strong><ul>
<li>RDB 持久化是通过在指定的时间间隔内将内存中的数据集快照写入磁盘的方式来实现的。</li>
<li>快照是一个二进制文件，它记录了某个时间点上 Redis 数据集的所有键值对。</li>
<li>RDB 持久化是一个“点对点”操作，它在指定的时间点创建了一个数据快照。</li>
<li>RDB 持久化适用于备份、灾难恢复等场景。<br>RDB 持久化的配置选项可以在 Redis 配置文件中进行设置，例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1      # 表示在 900 秒（15分钟）内，如果至少有 1 个 key 发生了变化，则执行快照操作</span><br><span class="line">save 300 10     # 表示在 300 秒（5分钟）内，如果至少有 10 个 key 发生了变化，则执行快照操作</span><br><span class="line">save 60 10000   # 表示在 60 秒内，如果至少有 10000 个 key 发生了变化，则执行快照操作</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>AOF 持久化：</strong><ul>
<li>AOF（Append Only File）持久化记录了服务器执行的所有写操作指令，以追加的方式将这些指令记录到一个文件中。</li>
<li>AOF 持久化是一个“追加”操作，每个写操作都被追加到文件末尾。</li>
<li>AOF 持久化适用于对数据的实时持久化需求。<br>AOF 持久化的配置选项可以在 Redis 配置文件中进行设置，例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes            # 启用 AOF 持久化</span><br><span class="line">appendfsync everysec      # 每秒钟执行一次 fsync 操作</span><br></pre></td></tr></table></figure></li>
<li><code>appendfsync</code> 选项可以设置 <code>always</code>、<code>everysec</code> 或 <code>no</code>。<code>always</code> 表示每个写命令都会立即被写入磁盘，<code>everysec</code> 表示每秒执行一次 fsync 操作，<code>no</code> 表示由操作系统自行决定何时进行写入磁盘操作。</li>
<li>Redis 还提供了 AOF 重写机制，可以通过 <code>auto-aof-rewrite-percentage</code> 和 <code>auto-aof-rewrite-min-size</code> 选项配置。这允许 Redis 在不停机的情况下优化 AOF 文件的大小。</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/10/Redis/" data-id="clrggyuqu000nlkv5d0gigvq1" data-title="Redis" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-SpringCloud" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/07/SpringCloud/" class="article-date">
  <time class="dt-published" datetime="2024-01-07T02:58:11.000Z" itemprop="datePublished">2024-01-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/07/SpringCloud/">SpringCloud</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署。优点：架构简单、部署成本低。缺点：耦合度高，扩展性差，适合小型项目。例如:学生管理系统<br><strong>分布式架构</strong>：根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务。松耦合，扩展性好，但架构复杂，难度大。适合大型互联网项目，例如:京东、淘宝<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/3.png?raw=true?raw=true" width="700" height="200"><br>分布式架构的要考虑的问题有：服务拆分粒度如何？服务集群地址如何维护？服务之间如何实现远程调用？服务健康状态如何感知？</p>
<p><strong>微服务</strong>：一种良好的分布式架构方案。</p>
<ul>
<li>优点：拆分粒度更小、服务更独立、耦合度更低。缺点：架构非常复杂，运维、监控、部署难度提高</li>
<li>微服务特点：<ul>
<li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责，避免重复业务开发；每个服务单元都可以独立开发、部署、扩展和管理。这些服务单元相互协作，通过网络进行通信，通常使用轻量级的通信机制（如HTTP或消息队列）进行交互。使得应用程序更具弹性、可扩展性和灵活性，同时也有利于团队之间的独立开发和部署。</li>
<li>面向服务：微服务对外暴露业务接口，供其他微服务使用。</li>
<li>自治：团队独立、技术独立、数据独立、部署独立，不同微服务都应该有自己的数据库。</li>
<li>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题。<img src="https://github.com/leo710aka/bk/blob/main/springcloud/1.png?raw=true?raw=true" width="700" height="200"> 
再加上服务异常定位、节点状态监控、自动化部署
<img src="https://github.com/leo710aka/bk/blob/main/springcloud/2.png?raw=true?raw=true" width="700" height="200"></li>
</ul>
</li>
</ul>
<p>微服务这种方案需要技术框架来落地，全球的互联网公司都在积极尝试自己的微服务落地技术。在国内最知名的就是SpringCloud和阿里巴巴的Dubbo（升级SpringCloudAlibaba（实现了SpringCloud接口，是SpringCloud的一部分））微服务技术对比：<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/4.png?raw=true?raw=true" width="700" height="200"><br>企业中常见的四种需求：<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/5.png?raw=true?raw=true" width="700" height="200"> </p>
<h2 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h2><p>SpringCloud 是一个基于 Spring Boot 的开源框架，旨在简化构建分布式系统中的微服务架构。它提供了一系列工具和库，用于实现微服务架构中常见的模式和功能，如服务发现、负载均衡、配置管理、断路器模式、消息总线等。<br>SpringCloud 集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验:<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/6.png?raw=true?raw=true" width="600" height="200">  </p>
<ul>
<li>服务拆分<ul>
<li>微服务需要根据业务模块拆分，做到单一职责，避免重复业务开发；</li>
<li>微服务可以将业务暴露为接口，供其他微服务使用。</li>
<li>不同微服务都应该有自己的数据库。</li>
<li>cloud-demo：父工程，管理依赖<ul>
<li>order-service：订单微服务，负责订单相关业务</li>
<li>user-service：用户微服务，负责用户相关业务<br>  要求：订单微服务和用户微服务都必须有各自的数据库，相互独立；订单服务和用户服务都对外暴露Restful的接口；订单服务如果需要查询用户信息，只能调用用户服务的Restful接口，不能查询用户数据库  <img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210713211009593.png?raw=true" width="200" height="200"></li>
</ul>
</li>
</ul>
</li>
<li>远程调用<ul>
<li>在一个微服务中，在java代码中发送 http 请求，使用另一个微服务的接口，获取另一个微服务数据库的数据</li>
<li>在一个微服务的启动类（本身也是配置类）中注册 RestTemplate，配置成 Bean；</li>
<li>在 service 中注入 restTemplate，getForObject(“url”) 发送http请求，将返回的 json 数据转换为制定对象类型</li>
</ul>
</li>
</ul>
<h3 id="Eureka-服务注册中心"><a href="#Eureka-服务注册中心" class="headerlink" title="Eureka 服务注册中心"></a>Eureka 服务注册中心</h3><ul>
<li>在 Eureka 架构中，微服务角色有两类:<ul>
<li>EurekaServer:服务端，注册中心。记录服务信息、心跳监控</li>
<li>EurekaClient:客户端<ul>
<li>Provider:服务提供者，例如案例中的 user-service<br>  注册自己的信息到 EurekaServer<br>  每隔30秒向EurekaServer发送心跳</li>
<li>consumer:服务消费者，例如案例中的 order-service<br>  根据服务名称从 EurekaServer 拉取服务列表<br>  基于服务列表做负载均衡，选中一个微服务后发起远程调用</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://github.com/leo710aka/bk/blob/main/springcloud/7.png?raw=true?raw=true" width="600" height="200">  

<ul>
<li>Eureka的作用<ul>
<li>消费者该如何获取服务提供者具体信息?<br>  服务提供者启动时向 eureka 注册自己的信息，eureka 保存这些信息，消费者根据服务名称向 eureka 拉取提供者信息</li>
<li>如果有多个服务提供者，消费者该如何选择?<br>  服务消费者利用负载均衡算法，从服务列表中挑选一个</li>
<li>消费者如何感知服务提供者健康状态?<br>  服务提供者会每隔30秒向 EurekaServer 发送心跳请求，报告健康状态 eureka 会更新记录服务列表信息，心跳不正常会被剔除，消费者就可以拉取到最新的信息</li>
</ul>
</li>
<li>eureka 服务搭建：eruka自己就是一个微服务。新建项目，引入 eureka-server 依赖；编写启动类，添加 @EnableEurekaServer 注解；添加application.yml，添加配置</li>
<li>eureka 服务注册：把一个微服务注册到 EurekaServer。<ol>
<li>微服务项目引入 eureka-client 依赖，</li>
<li>在 application.yml 编写依赖：name、url…</li>
</ol>
</li>
<li>eureka服务发现：<br>  服务拉取是（服务A）基于（服务B）服务名称获取（服务B多个实例）服务列表，然后在对服务列表做负载均衡<ol>
<li>修改 orderService（服务B）的代码，修改访问的 userService 的url路径，用服务名代替ip、端口，消除硬编码:  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span><span class="string">&quot;http://userservice/user/&quot;</span> + order.getUserId();</span><br></pre></td></tr></table></figure></li>
<li>在 order-service 项目（服务B）的启动类 OrderApplication中 的 RestTemplate 添加负载均衡注解  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="Ribbon-负载均衡"><a href="#Ribbon-负载均衡" class="headerlink" title="Ribbon 负载均衡"></a>Ribbon 负载均衡</h2><ul>
<li>负载均衡原理<ul>
<li>加了 @LoadBalanced 注解的RestTemplate，发送的请求将会被 Ribbon 拦截（SpringCloudRibbon的底层采用了一个拦截器），对地址做了修改，处理后发送 HTTP 请求<br>  基本流程如下：<ul>
<li>拦截我们的RestTemplate请求<a target="_blank" rel="noopener" href="http://userservice/user/1">http://userservice/user/1</a></li>
<li>RibbonLoadBalancerClient会从请求url中获取服务名称，也就是user-service</li>
<li>DynamicServerListLoadBalancer根据user-service到eureka拉取服务列表</li>
<li>eureka返回列表，localhost:8081、localhost:8082</li>
<li>IRule利用内置负载均衡规则，从列表中选择一个，例如localhost:8081</li>
<li>RibbonLoadBalancerClient修改请求地址，用localhost:8081替代userservice，得到<a target="_blank" rel="noopener" href="http://localhost:8081/user/1%EF%BC%8C">http://localhost:8081/user/1，</a> 发起真实请求<br>  <img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210713224724673.png?raw=true"></li>
</ul>
</li>
</ul>
</li>
<li>负载均衡策略IRule<ul>
<li>IRule 接口：决定了负载均衡的策略，每一个子接口都是一种规则，轮询、随机、、、 通过定义 IRule 实现可以修改负载均衡策略</li>
<li>负载均衡策略：负载均衡的规则都定义在IRule接口中，而IRule有很多不同的实现类：<br> <img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210713225653000.png?raw=true"><table>
<thead>
<tr>
<th><strong>内置负载均衡规则类</strong></th>
<th><strong>规则描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>RoundRobinRule</td>
<td>简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td>
</tr>
<tr>
<td>AvailabilityFilteringRule</td>
<td>对以下两种服务器进行忽略：   （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。  （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的<clientName>.<clientConfigNameSpace>.ActiveConnectionsLimit属性进行配置。</td>
</tr>
<tr>
<td>WeightedResponseTimeRule</td>
<td>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td>
</tr>
<tr>
<td><strong>ZoneAvoidanceRule</strong>【默认】</td>
<td>以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做<strong>轮询</strong>。</td>
</tr>
<tr>
<td>BestAvailableRule</td>
<td>忽略那些短路的服务器，并选择并发数较低的服务器。</td>
</tr>
<tr>
<td>RandomRule</td>
<td>随机选择一个可用的服务器。</td>
</tr>
<tr>
<td>RetryRule</td>
<td>重试机制的选择逻辑</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li>自定义负载均衡策略<ol>
<li>代码方式：在order-service中的OrderApplication类中，定义一个新的IRule：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">randomRule</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则：  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">userservice:</span> <span class="comment"># 给某个微服务配置负载均衡规则，这里是userservice服务</span></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span> <span class="comment"># 负载均衡规则 </span></span><br></pre></td></tr></table></figure></li>
<li><strong>注意</strong>，一般用默认的负载均衡规则，不做修改。</li>
</ol>
</li>
<li>饥饿加载<ul>
<li>Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line"><span class="attr">eager-load:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">clients:</span> <span class="string">userservice</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>

<h2 id="Nacos注册中心【8848】"><a href="#Nacos注册中心【8848】" class="headerlink" title="Nacos注册中心【8848】"></a>Nacos注册中心【8848】</h2><ul>
<li><strong>Nacos</strong> 是阿里巴巴的产品，现在是 SpringCloud 中的一个组件。相比 Eureka 功能更加丰富，在国内受欢迎程度较高。</li>
<li><strong>Nacos服务搭建：</strong>下载安装包，解压，在 D:\nacos-server-1.4.1\bin 目录下cmd运行指令: <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup.<span class="built_in">cmd</span> -m standalone</span><br></pre></td></tr></table></figure>
浏览器打开 <a target="_blank" rel="noopener" href="http://10.195.138.48:8848/nacos/index.html#/login">http://10.195.138.48:8848/nacos/index.html#/login</a> ,输入账号&#x2F;密码：nacos</li>
</ul>
<h4 id="1-Nacos服务注册或发现"><a href="#1-Nacos服务注册或发现" class="headerlink" title="1. Nacos服务注册或发现"></a>1. Nacos服务注册或发现</h4><p>父工程添加 spring-cloud-alibaba 依赖；微服务项目引入 nacos.discovery 依赖，yml 配置 nacos 地址 spring.cloudnacos.server-addr<br>Nacos 是 SpringCloudAlibaba 的组件，而 SpringCloudAlibaba 也遵循 SpringCloud 中定义的服务注册、服务发现规范。因此使用 Nacos 和使用 Eureka 对于微服务来说，并没有太大区别。</p>
<ol>
<li>引入依赖：<br>在cloud-demo父工程的pom文件中的<code>&lt;dependencyManagement&gt;</code>中引入SpringCloudAlibaba的依赖；<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
然后在子微服务 user-service 和 order-service 中的pom文件中引入nacos-discovery依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>配置nacos地址：在user-service和order-service的application.yml中添加nacos地址：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">    <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br></pre></td></tr></table></figure></li>
<li>重启微服务后，登录nacos管理页面<a target="_blank" rel="noopener" href="http://10.195.138.48:8848/nacos/index.html#/">http://10.195.138.48:8848/nacos/index.html#/</a> ,可以看到微服务信息<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210713231439607.png?raw=true" width="600" height="200"></li>
</ol>
<h4 id="2-Nacos服务分级存储"><a href="#2-Nacos服务分级存储" class="headerlink" title="2. Nacos服务分级存储"></a>2. <strong>Nacos服务分级存储</strong></h4><p>一个<strong>服务</strong>可以有多个<strong>实例</strong>，例如我们的user-service，可以有：127.0.0.1:8081，127.0.0.1:8082，127.0.0.1:8083<br>假如这些实例分布于全国各地的不同机房，例如：127.0.0.1:8081在上海机房，127.0.0.1:8082在上海机房，127.0.0.1:8083在杭州机房。    Nacos就将同一机房内的实例 划分为一个<strong>集群</strong>。</p>
<ul>
<li>也就是说，user-service是服务，一个服务可以包含多个集群，如杭州、上海，每个集群下可以有多个实例，形成分级模型：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210713232522531.png?raw=true" width="600" height="200">  
微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群：
<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210713232658928.png?raw=true" width="600" height="200">  </li>
<li>配置集群：修改user-service的application.yml文件，添加集群配置：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">    <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">    <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span> <span class="comment"># 集群名称</span></span><br></pre></td></tr></table></figure></li>
<li>同集群优先的负载均衡：默认的<code>ZoneAvoidanceRule</code>并不能实现根据同集群优先来实现负载均衡。因此Nacos中提供了一个<code>NacosRule</code>的实现，可以优先从同集群中挑选实例。<br>修改order-service的application.yml文件，修改负载均衡规则：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">userservice:</span></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class="comment"># 负载均衡规则 </span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-权重配置："><a href="#3-权重配置：" class="headerlink" title="3. 权重配置："></a>3. <strong>权重配置：</strong></h4><p>默认情况下NacosRule是同集群内随机挑选，不会考虑机器的性能问题。因此，Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高。<br>在nacos控制台，找到user-service的实例列表，点击编辑，在弹出的窗口修改权重：（<strong>注意</strong>：权重为0，则该实例永远不会被访问）<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210713235133225.png?raw=true"><br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210713235235219.png?raw=true" width="300" height="200"> </p>
<h4 id="4-环境隔离："><a href="#4-环境隔离：" class="headerlink" title="4. 环境隔离："></a>4. <strong>环境隔离</strong>：</h4><p>Nacos提供了namespace来实现环境隔离功能（比如把一些功能紧密的服务隔离在一起，不能被另一些服务访问）</p>
<ul>
<li>nacos中可以有多个namespace</li>
<li>namespace下可以有group、service等</li>
<li>不同namespace之间相互隔离，例如不同namespace的服务互相不可见<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210714000101516.png?raw=true" width="500" height="200"></li>
</ul>
<ol>
<li>创建namespace：默认情况下，所有service、data、group都在同一个namespace，名为public：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210714000414781.png?raw=true" width="300" height="200"> 
我们可以点击页面新增按钮，添加一个namespace；然后，填写表单，创建一个新的namespace：
<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210714000505928.png?raw=true" width="300" height="200"> </li>
<li>给微服务配置namespace：只能通过修改配置来实现。例如，修改order-service的application.yml文件：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">    <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">    <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">492a7d5d-237b-46a1-a99a-fa8e98e4b0f9</span> <span class="comment"># 命名空间，填ID</span></span><br></pre></td></tr></table></figure>
重启order-service后，访问控制台，可以看到下面的结果：<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210714000830703.png?raw=true"><br>此时访问order-service，因为namespace不同，会导致找不到userservice，控制台会报错：<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210714000941256.png?raw=true"></li>
</ol>
<h4 id="5-Nacos与Eureka的区别"><a href="#5-Nacos与Eureka的区别" class="headerlink" title="5. Nacos与Eureka的区别"></a>5. Nacos与Eureka的区别</h4><p>Nacos和Eureka整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异：<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210714001728017.png?raw=true"></p>
<ul>
<li>Nacos与eureka的共同点<ul>
<li>都支持服务注册和服务拉取</li>
<li>都支持服务提供者心跳方式做健康检测</li>
</ul>
</li>
<li>Nacos与Eureka的区别<ul>
<li>Nacos的服务实例分为两种类型：<ul>
<li>临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。</li>
<li>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。<br>  配置一个服务实例为永久实例：  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">    <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">ephemeral:</span> <span class="literal">false</span> <span class="comment"># 设置为非临时实例</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li>
<li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li>
<li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li>
<li>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</li>
</ul>
</li>
</ul>
<h4 id="6-Nacos配置管理："><a href="#6-Nacos配置管理：" class="headerlink" title="6. Nacos配置管理："></a>6. <strong>Nacos配置管理</strong>：</h4><p>Nacos除了可以做注册中心，同样可以做配置管理来使用。</p>
<ul>
<li><strong>统一配置管理</strong><br>当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。我们需要一种统一配置管理方案，可以集中管理所有实例的配置。<br>Nacos一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新。(不用重启服务就能更新)  <img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714164426792.png?raw=true" width="500" height="200"> <ol>
<li>在nacos中添加配置文件<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714164742924.png?raw=true" width="500" height="200">   <img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714164856664.png?raw=true" width="500" height="200"> <blockquote>
<p>注意：项目的核心配置，需要热更新的配置才有放到nacos管理的必要。基本不会变更的一些配置还是保存在微服务本地比较好。</p>
</blockquote>
</li>
<li>从微服务拉取配置：微服务要拉取nacos中管理的配置，并且与本地的application.yml配置合并，才能完成项目启动。 但如果尚未读取application.yml，又如何得知nacos地址呢？<br>因此spring引入了一种新的配置文件：bootstrap.yaml文件，会在application.yml之前被读取，流程如下：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/L0iFYNF.png?raw=true"><br>首先，在user-service服务中，引入nacos-config的客户端依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos配置管理依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
然后，在user-service中添加一个bootstrap.yaml文件，内容如下：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userservice</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment">#开发环境，这里是dev </span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># Nacos地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 文件后缀名</span></span><br></pre></td></tr></table></figure>
这里会根据spring.cloud.nacos.server-addr获取nacos地址，再根据<br><code>$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</code>作为文件id，来读取配置。本例中，就是去读取<code>userservice-dev.yaml</code>：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714170845901.png?raw=true" width="500" height="200"><br>读取nacos配置：在user-service中的UserController中添加业务逻辑，读取pattern.dateformat配置<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714170337448.png?raw=true"></li>
</ol>
</li>
<li><strong>配置热更新</strong><br>我们最终的目的，是修改nacos中的配置后，微服务中无需重启即可让配置生效，也就是<strong>配置热更新</strong>。可以使用两种方式：<ol>
<li>方式一：在 @Value 注入的变量所在类上添加注解 @RefreshScope：<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714171036335.png?raw=true"></li>
<li>方式二：使用 @ConfigurationProperties 注解代替 @Value 注解。<br>在 user-service 服务中，添加一个类，读取 patterrn.dateformat 属性：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.user.config;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;pattern&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PatternProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String dateformat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在 UserController 中使用这个类代替 @Value：<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714171316124.png?raw=true"></li>
</ol>
</li>
<li><strong>配置共享</strong><br>其实微服务启动时，会去nacos读取多个配置文件，例如：<ul>
<li><code>[spring.application.name]-[spring.profiles.active].yaml</code>，例如：userservice-dev.yaml</li>
<li><code>[spring.application.name].yaml</code>，例如：userservice.yaml<br>而<code>[spring.application.name].yaml</code>不包含环境，因此可以被多个环境共享。下面我们通过案例来测试配置共享：</li>
</ul>
<ol>
<li>添加一个环境共享配置：我们在nacos中添加一个userservice.yaml文件：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714173233650.png?raw=true" width="500" height="200"> </li>
<li>在user-service中读取共享配置<!-- 
在user-service服务中，修改PatternProperties类，读取新添加的属性：
![image-20210714173324231](https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714173324231.png?raw=true)
在user-service服务中，修改UserController，添加一个方法：
![image-20210714173721309](https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714173721309.png?raw=true)
 --></li>
<li>运行两个UserApplication，使用不同的profile<br>？？<!-- 
修改UserApplication2这个启动项，改变其profile值：
![image-20210714173538538](https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714173538538.png?raw=true)
![image-20210714173519963](https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714173519963.png?raw=true)
这样，UserApplication(8081)使用的profile是dev，UserApplication2(8082)使用的profile是test。
启动UserApplication和UserApplication2
访问http://localhost:8081/user/prop，结果：
![image-20210714174313344](https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714174313344.png?raw=true)
访问http://localhost:8082/user/prop，结果：
![image-20210714174424818](https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714174424818.png?raw=true)
可以看出来，不管是dev，还是test环境，都读取到了envSharedValue这个属性的值。 --></li>
<li>配置共享的优先级<br>当nacos、服务本地同时出现相同属性时，优先级有高低之分：<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714174623557.png?raw=true"></li>
</ol>
</li>
<li><strong>搭建Nacos集群</strong><br>企业生产中强调“高可用”，Nacos 生产环境下一定要部署为集群状态，部署方式参考课前资料中的文档：nacos集群搭建.md</li>
</ul>
<hr>

<h2 id="Feign-远程调用"><a href="#Feign-远程调用" class="headerlink" title="Feign 远程调用"></a>Feign 远程调用</h2><p>以前利用 RestTemplate 发起远程调用的代码，存在下面的问题：1、代码可读性差，编程体验不统一；2、参数复杂URL难以维护<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714174814204.png?raw=true"><br>Feign是一个声明式的http客户端，其作用就是帮助我们优雅的实现http请求的发送，解决上面提到的问题。</p>
<h4 id="1-Feign替代RestTemplate"><a href="#1-Feign替代RestTemplate" class="headerlink" title="1. Feign替代RestTemplate"></a>1. Feign替代RestTemplate</h4><p>Fegin的使用步骤如下：</p>
<ol>
<li>引入依赖：在order-service服务的pom文件中引入feign的依赖：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>添加注解：在order-service的启动类添加注解开启Feign的功能：<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714175102524.png?raw=true"></li>
<li>编写Feign的客户端：在order-service中新建一个接口，内容如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;userservice&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这个客户端主要是基于SpringMVC的注解来声明远程调用的信息，比如：服务名称：userservice，请求方式：GET，请求路径：&#x2F;user&#x2F;{id}，请求参数：Long id，返回值类型：User<br>这样，Feign就可以帮助我们发送http请求，无需自己使用RestTemplate来发送了。</li>
<li>测试：修改order-service中的OrderService类中的queryOrderById方法，使用Feign客户端代替RestTemplate：<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714175415087.png?raw=true"></li>
</ol>
<h4 id="2-自定义配置"><a href="#2-自定义配置" class="headerlink" title="2. 自定义配置"></a>2. 自定义配置</h4><p>Feign可以支持很多的自定义配置，如下表所示：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>feign.Logger.Level</strong></td>
<td>修改日志级别</td>
<td>包含四种不同的级别：NONE、BASIC、HEADERS、FULL</td>
</tr>
<tr>
<td>feign.codec.Decoder</td>
<td>响应结果的解析器</td>
<td>http远程调用的结果做解析，例如解析json字符串为java对象</td>
</tr>
<tr>
<td>feign.codec.Encoder</td>
<td>请求参数编码</td>
<td>将请求参数编码，便于通过http请求发送</td>
</tr>
<tr>
<td>feign. Contract</td>
<td>支持的注解格式</td>
<td>默认是SpringMVC的注？</td>
</tr>
<tr>
<td>feign. Retryer</td>
<td>失败重试机制</td>
<td>请求失败的重试机制，默认是没有，不过会使用Ribbon的重试</td>
</tr>
</tbody></table>
<p>一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的@Bean覆盖默认Bean即可。<br>自定义配置的两种方法：</p>
<ol>
<li>配置文件方式：基于配置文件修改feign的日志级别可以针对单个服务，也可以针对所有服务：</li>
<li>Java代码方式：也可以基于Java代码来修改日志级别，先声明一个类，然后声明一个Logger.Level的对象<br>如果要<strong>全局生效</strong>，将其放到启动类的@EnableFeignClients这个注解中；如果是<strong>局部生效</strong>，则把它放到对应的@FeignClient这个注解中</li>
</ol>
<h4 id="3-Feign使用优化"><a href="#3-Feign使用优化" class="headerlink" title="3. Feign使用优化"></a>3. Feign使用优化</h4><p>Feign 是一个声明式客户端，只是把声明变成 http 请求，底层还是发http请求，依赖于其它的框架。其底层客户端实现包括：URLConnection：默认实现，不支持连接池；Apache HttpClient：支持连接池；OKHttp：支持连接池。因此提高Feign的性能主要手段就是使用<strong>连接池</strong>代替默认的URLConnection。用Apache的HttpClient来演示：</p>
<ul>
<li>引入依赖：在order-service的pom文件中引入Apache的HttpClient依赖：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--httpClient的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>配置连接池：在order-service的application.yml中添加配置：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span> <span class="comment"># default全局的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">BASIC</span> <span class="comment"># 日志级别，BASIC就是基本的请求和响应信息</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启feign对HttpClient的支持</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">200</span> <span class="comment"># 最大的连接数</span></span><br><span class="line">    <span class="attr">max-connections-per-route:</span> <span class="number">50</span> <span class="comment"># 每个路径的最大连接数</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-最佳实践"><a href="#4-最佳实践" class="headerlink" title="4. 最佳实践"></a>4. 最佳实践</h4><p>所谓最近实践，就是使用过程中总结的经验，最好的一种使用方式。<br>可以发现，Feign的客户端与服务提供者的controller代码非常相似。有没有一种办法简化这种重复的代码编写呢？</p>
<ol>
<li><strong>继承方式：</strong>一样的代码可以通过继承来共享：</li>
</ol>
<ul>
<li>定义一个API接口，利用定义方法，并基于SpringMVC注解做声明。</li>
<li>Feign客户端和Controller都集成改接口<br>  <img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714190640857.png?raw=true"><br>  优点：简单，实现了代码共享<br>  缺点：服务提供方、服务消费方紧耦合，参数列表中的注解映射并不会继承，因此Controller中必须再次声明方法、参数列表、注解</li>
</ul>
<ol start="2">
<li><strong>抽取方式</strong>：将Feign的Client抽取为独立模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用。<br>例如，将UserClient、User、Feign的默认配置都抽取到一个feign-api包中，所有微服务引用该依赖包，即可直接使用。<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714214041796.png?raw=true"></li>
</ol>
<hr>

<h2 id="Gateway-服务网关"><a href="#Gateway-服务网关" class="headerlink" title="Gateway 服务网关"></a>Gateway 服务网关</h2><p>Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。</p>
<h4 id="1-为什么需要网关"><a href="#1-为什么需要网关" class="headerlink" title="1. 为什么需要网关"></a>1. 为什么需要网关</h4><p>Gateway网关是我们服务的守门神，所有微服务的统一入口。架构图：<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714210131152.png?raw=true" width="600" height="200"> </p>
<p>网关的<strong>核心功能特性</strong>：</p>
<ul>
<li><strong>权限控制</strong>：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</li>
<li><strong>路由和负载均衡</strong>：一切请求都必须先经过gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。</li>
<li><strong>限流</strong>：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。<br>在SpringCloud中网关的实现包括两种：gateway、zuul<br>Zuul是基于Servlet的实现，属于阻塞式编程。而SpringCloudGateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</li>
</ul>
<h4 id="2-gateway快速入门"><a href="#2-gateway快速入门" class="headerlink" title="2. gateway快速入门"></a>2. gateway快速入门</h4><ol>
<li>创建 SpringBoot 工程 gateway 服务，引入网关依赖<br>创建服务：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714210919458.png?raw=true" width="700" height="200"><br>引入依赖：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--网关--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--nacos服务发现依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>编写启动类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GatewayApplication</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		SpringApplication.run(GatewayApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编写基础配置和路由规则：创建application.yml文件，内容如下：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span> <span class="comment"># 网关端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span> <span class="comment"># 网关路由配置</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span>      <span class="comment"># 1. 路由id，自定义，只要唯一即可</span></span><br><span class="line">          <span class="comment"># uri: http://127.0.. # 路由的目标地址 http就是固定地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userservice</span> <span class="comment"># 2. 路由的目标地址 lb就是负载均衡，后面跟服务名称</span></span><br><span class="line">          <span class="attr">predicates:</span>           <span class="comment"># 3. 路由断言，也就是判断请求是否符合路由规则的条件</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span>     <span class="comment"># 这个是按照路径匹配，只要以/user/开头就符合要求</span></span><br><span class="line">                                <span class="comment"># 4. 路由过滤器</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">order-service</span>     <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
我们将符合<code>Path</code>规则的一切请求，都代理到<code>uri</code>参数指定的地址。本例中，我们将 <code>/user/**</code>开头的请求，代理到<code>lb://userservice</code>，lb是负载均衡，根据服务名拉取服务列表，实现负载均衡。</li>
<li>启动网关服务进行测试<br>重启网关，访问<a target="_blank" rel="noopener" href="http://localhost:10010/user/1%E6%97%B6%EF%BC%8C">http://localhost:10010/user/1时，</a> 符合<code>/user/**</code>规则，请求转发到uri：<a target="_blank" rel="noopener" href="http://userservice/user/1%EF%BC%8C">http://userservice/user/1，</a> 得到了结果：<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714211908341.png?raw=true"></li>
<li>网关路由的流程图<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714211742956.png?raw=true"></li>
</ol>
<h4 id="3-断言工厂"><a href="#3-断言工厂" class="headerlink" title="3. 断言工厂"></a>3. 断言工厂</h4><p>我们在配置文件中写的断言规则只是字符串，这些字符串会被Predicate Factory读取并处理，转变为路由判断的条件<br>例如Path&#x3D;&#x2F;user&#x2F;**是按照路径匹配，这个规则是由 <code>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory</code>类来处理的，像这样的断言工厂在SpringCloudGateway还有十几个:</p>
<table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>说明</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td>After</td>
<td>是某个时间点后的请求</td>
<td>-  After&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver]</td>
</tr>
<tr>
<td>Before</td>
<td>是某个时间点之前的请求</td>
<td>-  Before&#x3D;2031-04-13T15:14:47.433+08:00[Asia&#x2F;Shanghai]</td>
</tr>
<tr>
<td>Between</td>
<td>是某两个时间点之前的请求</td>
<td>-  Between&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver],  2037-01-21T17:42:47.789-07:00[America&#x2F;Denver]</td>
</tr>
<tr>
<td>Cookie</td>
<td>请求必须包含某些cookie</td>
<td>- Cookie&#x3D;chocolate, ch.p</td>
</tr>
<tr>
<td>Header</td>
<td>请求必须包含某些header</td>
<td>- Header&#x3D;X-Request-Id, \d+</td>
</tr>
<tr>
<td>Host</td>
<td>请求必须是访问某个host（域名）</td>
<td>-  Host&#x3D;<strong>.somehost.org,</strong>.anotherhost.org</td>
</tr>
<tr>
<td>Method</td>
<td>请求方式必须是指定方式</td>
<td>- Method&#x3D;GET,POST</td>
</tr>
<tr>
<td>Path</td>
<td>请求路径必须符合指定规则</td>
<td>- Path&#x3D;&#x2F;red&#x2F;{segment},&#x2F;blue&#x2F;**</td>
</tr>
<tr>
<td>Query</td>
<td>请求参数必须包含指定参数</td>
<td>- Query&#x3D;name, Jack或者-  Query&#x3D;name</td>
</tr>
<tr>
<td>RemoteAddr</td>
<td>请求者的ip必须是指定范围</td>
<td>- RemoteAddr&#x3D;192.168.1.1&#x2F;24</td>
</tr>
<tr>
<td>Weight</td>
<td>权重处理</td>
<td></td>
</tr>
</tbody></table>
<h4 id="4-过滤器工厂"><a href="#4-过滤器工厂" class="headerlink" title="4. 过滤器工厂"></a>4. 过滤器工厂</h4><p>GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理：<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714212312871.png?raw=true" width="700" height="200"> </p>
<ol>
<li><strong>路由过滤器的种类</strong>：Spring提供了31种不同的路由过滤器工厂。例如：<table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>AddRequestHeader</td>
<td>给当前请求添加一个请求头</td>
</tr>
<tr>
<td>RemoveRequestHeader</td>
<td>移除请求中的一个请求头</td>
</tr>
<tr>
<td>AddResponseHeader</td>
<td>给响应结果中添加一个响应头</td>
</tr>
<tr>
<td>RemoveResponseHeader</td>
<td>从响应结果中移除有一个响应头</td>
</tr>
<tr>
<td>RequestRateLimiter</td>
<td>限制请求的流量</td>
</tr>
</tbody></table>
</li>
<li><strong>请求头过滤器</strong>：以AddRequestHeader 为例来讲解。<blockquote>
<p><strong>需求</strong>：给所有进入userservice的请求添加一个请求头：Truth&#x3D;itcast is freaking awesome!  </p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只需要修改gateway服务的application.yml文件，添加路由过滤即可</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> <span class="comment"># 当前过滤器写在userservice路由下，因此仅仅对访问userservice的请求有效</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://userservice</span> </span><br><span class="line">        <span class="attr">predicates:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/user/**</span> </span><br><span class="line">        <span class="attr">filters:</span> <span class="comment"># 过滤器</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=Truth,</span> <span class="string">Itcast</span> <span class="string">is</span> <span class="string">freaking</span> <span class="string">awesome!</span> <span class="comment"># 添加请求头</span></span><br></pre></td></tr></table></figure></li>
<li><strong>默认过滤器</strong>：如果要对所有的路由都生效，则可以将过滤器工厂写到default下。格式如下：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> </span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://userservice</span> </span><br><span class="line">        <span class="attr">predicates:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/user/**</span></span><br><span class="line">      <span class="attr">default-filters:</span> <span class="comment"># 默认过滤项</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">AddRequestHeader=Truth,</span> <span class="string">Itcast</span> <span class="string">is</span> <span class="string">freaking</span> <span class="string">awesome!</span> </span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="5-全局过滤器"><a href="#5-全局过滤器" class="headerlink" title="5. 全局过滤器"></a>5. 全局过滤器</h4><ol>
<li>全局过滤器作用<br>  上一节学习的过滤器，网关提供了31种，但每一种过滤器的作用都是固定的。如果我们希望拦截请求，做自己的业务逻辑则没办法实现。全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样。区别在于GatewayFilter通过配置定义，处理逻辑是固定的；而GlobalFilter的逻辑需要自己写代码实现。<br>  定义方式是实现GlobalFilter接口。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  处理当前请求，有必要的话通过&#123;<span class="doctag">@link</span> GatewayFilterChain&#125;将请求交给下一个过滤器处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange 请求上下文，里面可以获取Request、Response等信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chain 用来把请求委托给下一个过滤器 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> Mono&lt;Void&gt;&#125; 返回标示当前过滤器业务结束</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  在filter中编写自定义逻辑，可以实现下列功能：<strong>登录状态判断、权限校验、请求限流</strong>等</li>
<li>自定义全局过滤器<br>  <strong>需求：</strong>定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：（如果同时满足则放行，否则拦截）<br>  1、参数中是否有authorization，<br>  2、authorization参数值是否为admin<br>  <strong>实现：</strong>在gateway中定义一个过滤器：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order(-1)</span> <span class="comment">// 过滤器优先级</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizeFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取请求参数</span></span><br><span class="line">        MultiValueMap&lt;String, String&gt; params = exchange.getRequest().getQueryParams();</span><br><span class="line">        <span class="comment">// 2.获取authorization参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">auth</span> <span class="operator">=</span> params.getFirst(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.校验</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(auth)) &#123;</span><br><span class="line">            <span class="comment">// 放行</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.拦截</span></span><br><span class="line">        <span class="comment">// 4.1.禁止访问，设置状态码</span></span><br><span class="line">        exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);</span><br><span class="line">        <span class="comment">// 4.2.结束处理</span></span><br><span class="line">        <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>过滤器执行顺序<br>  请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter<br>  请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器： <img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714214228409.png?raw=true"></li>
</ol>
<ul>
<li>排序的规则是什么呢？<ul>
<li>每一个过滤器都必须指定一个int类型的order值，<strong>order值越小，优先级越高，执行顺序越靠前</strong>。</li>
<li>GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定</li>
<li>路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增。</li>
<li>当过滤器的order值一样时，会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行。<!-- 详细内容，可以查看源码：
`org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator#getFilters()`方法是先加载defaultFilters，然后再加载某个route的filters，然后合并。
`org.springframework.cloud.gateway.handler.FilteringWebHandler#handle()`方法会加载全局过滤器，与前面的过滤器合并后根据order排序，组织过滤器链 --></li>
</ul>
</li>
</ul>
<h4 id="6-跨域问题"><a href="#6-跨域问题" class="headerlink" title="6. 跨域问题"></a>6. 跨域问题</h4><ol>
<li><strong>什么是跨域问题</strong>：<br>域名不一致就是跨域，主要包括：域名不同： <a target="_blank" rel="noopener" href="http://www.taobao.com/">www.taobao.com</a> 和 <a target="_blank" rel="noopener" href="http://www.taobao.org/">www.taobao.org</a> 和 <a target="_blank" rel="noopener" href="http://www.jd.com;/">www.jd.com；</a> 域名相同，端口不同：localhost:8080 和 localhost:8081<br>跨域问题：浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题<br>解决方案：CORS <a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2016/04/cors.html">https://www.ruanyifeng.com/blog/2016/04/cors.html</a></li>
<li><strong>模拟跨域问题</strong><br>找到课前资料的页面文件：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714215713563.png?raw=true"><br>放入tomcat或者nginx这样的web服务器中，启动并访问。<br>可以在浏览器控制台看到下面的错误：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714215832675.png?raw=true"><br>从localhost:8090访问localhost:10010，端口不同，显然是跨域的请求。</li>
<li><strong>解决跨域问题</strong>：在gateway服务的application.yml文件中，添加下面的配置：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="comment"># 。。。</span></span><br><span class="line">      <span class="attr">globalcors:</span> <span class="comment"># 全局的跨域处理</span></span><br><span class="line">        <span class="attr">add-to-simple-url-handler-mapping:</span> <span class="literal">true</span> <span class="comment"># 解决options请求被拦截问题</span></span><br><span class="line">        <span class="attr">corsConfigurations:</span></span><br><span class="line">          <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span></span><br><span class="line">            <span class="attr">allowedOrigins:</span> <span class="comment"># 允许哪些网站的跨域请求 </span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://localhost:8090&quot;</span></span><br><span class="line">            <span class="attr">allowedMethods:</span> <span class="comment"># 允许的跨域ajax的请求方式</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;GET&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;POST&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;DELETE&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;PUT&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;OPTIONS&quot;</span></span><br><span class="line">            <span class="attr">allowedHeaders:</span> <span class="string">&quot;*&quot;</span> <span class="comment"># 允许在请求中携带的头信息</span></span><br><span class="line">            <span class="attr">allowCredentials:</span> <span class="literal">true</span> <span class="comment"># 是否允许携带cookie</span></span><br><span class="line">            <span class="attr">maxAge:</span> <span class="number">360000</span> <span class="comment"># 这次跨域检测的有效期</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>





      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/07/SpringCloud/" data-id="clrggyur0000vlkv55h0ma9fo" data-title="SpringCloud" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-骏伯" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/04/%E9%AA%8F%E4%BC%AF/" class="article-date">
  <time class="dt-published" datetime="2024-01-04T02:58:11.000Z" itemprop="datePublished">2024-01-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/04/%E9%AA%8F%E4%BC%AF/">骏 伯</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>使命：让移动互联网营销简单高效; 价值观：创造价值，分享价值; 愿景：做最受信赖的移动互联网营销服务商;</p>
<p>WiFi：gzjunbo01888</p>
<hr>

<p>公司邮箱（FOXMAIL绑定登录） 账户：<a href="mailto:&#x63;&#x61;&#105;&#x66;&#x40;&#x67;&#122;&#x6a;&#x75;&#x6e;&#98;&#111;&#x2e;&#110;&#101;&#x74;">&#x63;&#x61;&#105;&#x66;&#x40;&#x67;&#122;&#x6a;&#x75;&#x6e;&#98;&#111;&#x2e;&#110;&#101;&#x74;</a> 密码 cxxxxxxx</p>
<p>OA系统网址 <a target="_blank" rel="noopener" href="http://oa.jetmobo.com/wui/index.html?v=1591093552740#/main/workflow/add?menuIds=1,12&menuPathIds=1,12&_key=t0lres">http://oa.jetmobo.com/wui/index.html?v=1591093552740#/main/workflow/add?menuIds=1,12&amp;menuPathIds=1,12&amp;_key=t0lres</a> 账号：caif 密码：cxxxxxxx</p>
<p>yapi（接口文档定义）：<a target="_blank" rel="noopener" href="http://yapi.gzjunbo.net/project/100/interface/api/32013">http://yapi.gzjunbo.net/project/100/interface/api/32013</a></p>
<p>Confluence（文档管理）产研在线：<a target="_blank" rel="noopener" href="http://doc.junbo.top/#all-updates">http://doc.junbo.top/#all-updates</a> 账户：caif 密码 139xxxxxxxx</p>
<p>Git 仓库：<a target="_blank" rel="noopener" href="http://git.gzjunbo.net/">http://git.gzjunbo.net/</a> 账户：caif 密码 cxxxxxxx</p>
<p>jenkins（开发线，用于系统构建发布）：<a target="_blank" rel="noopener" href="http://test-jenkins.gzjunbo.net/jenkins/">http://test-jenkins.gzjunbo.net/jenkins/</a> 账号：caif 密码 YLIYrOh1cfgu2kB</p>
<hr>

<ul>
<li><p>系统开发指南：<a target="_blank" rel="noopener" href="http://doc.junbo.top/pages/viewpage.action?pageId=5168806">http://doc.junbo.top/pages/viewpage.action?pageId=5168806</a></p>
<ul>
<li>配置 Gradle 的环境变量：<br>  找到idea的settings中搜索gradle，找到对应自己电脑环境的gradle-home目录 D:&#x2F;gradle-6.0<br>  在 D:&#x2F;gradle-6.0&#x2F;init.d 目录下新建一个文件名为init.gradle，编辑内容为（固定写法）：  <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ext &#123;</span><br><span class="line">    nexus = <span class="string">&#x27;http://nexus.jetmobo.com&#x27;</span></span><br><span class="line">    username = <span class="string">&#x27;这是下载包权限用户：找运维提供&#x27;</span></span><br><span class="line">    password = <span class="string">&#x27;这是下载包权限密码：找运维提供&#x27;</span></span><br><span class="line">    upload_username = <span class="string">&#x27;这是上传包权限用户：找运维提供&#x27;</span></span><br><span class="line">    upload_password = <span class="string">&#x27;这是上传包权限密码：找运维提供&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>MySQL使用、Redis使用、RabbitMQ使用：在application-xxx.yml配置连接信息；</li>
<li>服务请求流程：Service层直接返回BO，不允许返回DO和Response对象。如果有失败信息需要返回，通过异常往上抛，由调用方捕获异常进行处理。</li>
</ul>
</li>
<li><p>系统开发流程：<a target="_blank" rel="noopener" href="http://doc.junbo.top/pages/viewpage.action?pageId=5158235">http://doc.junbo.top/pages/viewpage.action?pageId=5158235</a></p>
<ul>
<li>项目结构 junbo-xxx<br>  xxx-soa：注册中心提供api接口服务，供其他服务调用<br>  –xxx-api：接口命名，参数定义。<br>  –xxx-service：核心实现与数据库交互，业务流程逻辑处理。<br>  xxx-web：用于web端提供http接口。<br>  xxx-frontend：前端工程。</li>
<li>区分环境配置：项目中除了基础公共配置外，按不同的环境，区分不同的配置。不同环境的代码与配置无需做调整，只需要在服务启动时增加Dspring.profiles.active &#x3D; {域标识}配置项，通过调整启动参数来适配不同环境。<br>  开发环境 dev，测试环境 test，生产环境 prod</li>
<li>接口定义：通常系统开发中，我们需要接口定义写到接口管理系统 <a target="_blank" rel="noopener" href="http://rap.gzjunbo.net/">http://rap.gzjunbo.net/</a> 中。</li>
</ul>
</li>
<li><p>后端开发规范：<a target="_blank" rel="noopener" href="http://doc.junbo.top/pages/viewpage.action?pageId=28431534">http://doc.junbo.top/pages/viewpage.action?pageId=28431534</a></p>
<ul>
<li>JAVA 开发规范的要点总结:</li>
</ul>
<ol>
<li>命名规范:采用驼峰命名法(例如:userName)和“下划线命名法”(例如:user_name)。类名使用大驼峰命名法(例如:UserName),方法名、变量名使用小驼峰命名法(例如:getUserName)。常量全部大写,单词间下划线隔开(例如:MAX_COUNT)。</li>
<li>代码格式规范:左大括号前不换行,左大括号后换行。右大括号前换行,若后有else等则不换行。使用4个空格进行缩进。单行字符数限120,方法限200行,类限1000行。</li>
<li>分层规范:分为展现层、接口层、业务层、通用层、数据层。上层可依赖下层,下层不能依赖上层。对外提供接口的服务必为接口,内部实现用Impl结尾。</li>
<li>异常规范:自定义分层异常,继承基础异常。每层只抛本层异常,不直接抛下层异常。异常信息包含错误码和消息。禁止使用普通Exception。</li>
<li>日志规范:使用SLF4J门面日志,禁用println。方法入口和出口加日志。日志内容包括现场信息和异常栈。生产禁debug日志,有选择info日志。按天滚动,单文件100M,最多保留10个。</li>
<li>缓存规范:推荐Redis。键名小写:[应用名]:[模块名]:[内容名]。缓存操作失败不能影响业务流程。</li>
<li>消息队列规范:队列名小写:[应用名].[模块名].[队列名]。应用名在开发部门唯一,防止冲突。</li>
</ol>
<ul>
<li>应用日志规范<ul>
<li>日志的作用：一般在程序上线之后，一旦发生异常，第一件事就是要弄清楚当时发生了什么。用户当时做了什么操作，环境有无影响，数据有什么变化，是不是反复发生等，然后再进一步的确定大致是哪个方面的问题。确定是程序的问题之后再交由开发人员去重现、研究、提出解决方案。这时，日志就给我们提供了第一手的资料。</li>
<li>日志级别：<br>  TRACE：用于调试目的-包括最详细的信息。<br>  DEBUG：用于调试目的。主要是开发是阶段使用，使用场景通常是开发和测试阶段对于一些关键操作是否执行的输出，开发人员可以把各种内容详细记录到Debug信息，尽可能的在开阶段发现和排查问题。<br>  INFO：发生了一件正常的、意料之中的、相关的事件。包含了关键的日志信息，主要作用是保留工作期间的信息，开发人员可以保留关键日志便于运维提取关键逻辑的执行日志信息，因为INFO日志会在线上日志控制台实时打印，所以需要保留最为关键的信息，建议在完成之后本地调整为INFO级别测试。<br>  WARN：发生了一些意想不到的事情（尽管不一定是错误），但需要密切关注。<br>  ERROR：应用程序发生错误。遇到严重影响业务执行的场景就需要打印ERROR日志，如果影响不是特别大，只是需要关注问题的情况则打印WARN 级别日志。</li>
<li>日志初始化  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(SomeClass.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>日志示例  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOGGER.info(<span class="string">&quot;userInfo is &#123;&#125;&quot;</span>, user)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>数据库规约：…</li>
</ul>
</li>
<li><p>骏伯全域系统架构（规划）：<a target="_blank" rel="noopener" href="http://doc.junbo.top/pages/viewpage.action?pageId=22671541">http://doc.junbo.top/pages/viewpage.action?pageId=22671541</a></p>
</li>
<li><p>编码红线：<a target="_blank" rel="noopener" href="http://doc.junbo.top/pages/viewpage.action?pageId=27687695">http://doc.junbo.top/pages/viewpage.action?pageId=27687695</a><br>应关闭资源，使用 finally 或者 try-with-resources 解决<br>跳转语句不应出现在 “finally” 代码块中<br>…<br>代码异味检测标准与修改示例：<a target="_blank" rel="noopener" href="http://doc.junbo.top/pages/viewpage.action?pageId=23773753">http://doc.junbo.top/pages/viewpage.action?pageId=23773753</a></p>
</li>
<li><p>单元测试编写指导文章：<a target="_blank" rel="noopener" href="http://doc.junbo.top/pages/viewpage.action?pageId=5157969">http://doc.junbo.top/pages/viewpage.action?pageId=5157969</a></p>
</li>
<li><p>权益业务架构：<a target="_blank" rel="noopener" href="http://doc.junbo.top/pages/viewpage.action?pageId=25051462">http://doc.junbo.top/pages/viewpage.action?pageId=25051462</a></p>
</li>
<li><p>运营号卡业务白皮书：<a target="_blank" rel="noopener" href="http://doc.junbo.top/pages/viewpage.action?pageId=27658986">http://doc.junbo.top/pages/viewpage.action?pageId=27658986</a></p>
</li>
<li><p>业务开发部新人指引：<a target="_blank" rel="noopener" href="http://doc.junbo.top/pages/viewpage.action?pageId=5148323">http://doc.junbo.top/pages/viewpage.action?pageId=5148323</a></p>
</li>
<li><p>敏捷实践指南：<a target="_blank" rel="noopener" href="http://doc.junbo.top/pages/viewpage.action?pageId=12830307">http://doc.junbo.top/pages/viewpage.action?pageId=12830307</a><br>敏捷开发：一种应对快速变化需求的一种软件开发能力。相对于”非敏捷”，更强调程序员团队与业务专家之间的紧密协作、面对面的沟通（认为比书面的文档更有效）、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好地适应需求变化的代码编写和团队组织方法，也更注重做为软件开发中人的作用。</p>
</li>
</ul>
<hr>

<h2 id="2024-01-10"><a href="#2024-01-10" class="headerlink" title="2024.01.10"></a>2024.01.10</h2><p>模块 服务？一个服务占用一个端口， 在 .gradle 配置<br>{<br>    demo-api: 服务化接口定义项目<br>    demo-service: 服务化实现项目<br>}<br>api 接口与实现 分离，<br>UserApi接口上加 @FeignClient， 请求均分发送到多台服务器上<br>spring注入 与 单例模式。。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/04/%E9%AA%8F%E4%BC%AF/" data-id="clrggyur1000zlkv54y571cm0" data-title="骏 伯" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-面试" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/10/11/%E9%9D%A2%E8%AF%95/" class="article-date">
  <time class="dt-published" datetime="2023-10-11T03:11:00.000Z" itemprop="datePublished">2023-10-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/10/11/%E9%9D%A2%E8%AF%95/">面 逝</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>围绕简历准备：<a target="_blank" rel="noopener" href="https://www.wondercv.com/cvs/5hCOzINo/editor">https://www.wondercv.com/cvs/5hCOzINo/editor</a>,<br>个人技能：<a target="_blank" rel="noopener" href="https://leo710aka.github.io/2023/10/10/%E6%8A%80%E8%83%BD/">https://leo710aka.github.io/2023/10/10/%E6%8A%80%E8%83%BD/</a></p>
<h2 id="开场"><a href="#开场" class="headerlink" title="开场"></a>开场</h2><ul>
<li><p><strong>自我介绍</strong><br>1、面试官您好，我是蔡枫，广东东莞人，本科就读于华南理工大学计算机学院。我在大三的时候参加了一个在线编程网站开发的项目，之后开始学习 Java 开发技术与相关框架。我有两段实习经历，分别是广州创世科技和东莞电信，我不仅参与到了实际业务代码的编写中，还对团队中的开发流程有了一定的了解。我也希望能够加入到您公司团队，参与到实际的项目开发中。<br>2、结合 优势、亮点、基本情况：（言简意赅、语言精炼，控制时间）<br>和应聘岗位相关的经历：。。<br>为什么能够胜任：。。<br>为什么要应聘该岗位~求职动机：。。<br>注意：重点介绍满足岗位要求的三个优势和亮点，表现出对岗位的理解和自己清晰的职业规划，表示愿意长期从事这个岗位</p>
</li>
<li><p>自我推荐。<br>我觉得我对所从事的每一个项目都很努力、负责、勤勉。我在努力成为一个能够不惧解决困难和能够持续学习的人。</p>
</li>
<li><p><strong>你对本公司的情况了解吗？为什么选择我们公司？</strong><br>1、对公司的了解：（行业的前景+公司的规模+公司在行业中的地位+特色产品）<br>2、自己跟岗位的匹配：（结合岗位要求+自我经历）<br>3、符合自己的职业规划：</p>
</li>
<li><p>说一下你的社团活动？你的论文？<br>我在华工青年志愿者指导中心担任宣传部的部长，这将我的摄影能力和对志愿服务的热情结合起来。我多次承担志愿活动现场的拍摄任务，用相机展现志愿者们的奉献精神，通过青志公众号推文等形式在校园中传播志愿精神。<br>我参加了一个“深度学习-图像处理”项目。五周的时间里，通过导师的授课讲解与指导，我拓展了该领域的专业知识，接着着手阅读文献和动手做实验。之后，我便与小组成员紧密合作，从主题确定，到文献的深入研读，完成论文写作，最终发表。</p>
</li>
</ul>
<h2 id="个人"><a href="#个人" class="headerlink" title="个人"></a>个人</h2><ul>
<li><p>请用三个词描述您的性格特点<br><strong>诚实，勤奋，谦虚。</strong>在学习知识和与人交往的过程中，我始终保持坦诚和真实，对自己和他人负责。面对生活中的挑战，我积极看待并勤奋努力，相信努力终会有所回报。谦虚让我保持谦逊和虚心，愿意倾听他人意见并不断学习成长。</p>
</li>
<li><p>你个性上最大的特点是什么？你的朋友或同事如何形容你？<br><strong>适应能力和幽默感</strong>。他们说我是一个诚实、工作努力、负责任的人，对家庭和朋友都很关心。</p>
</li>
<li><p>你最大的弱点是什么？你怎样对待自己的失败？<br>我缺乏工作经验，但我正在学习。慢热，很多时候不会主动聊天发言，可能错过一些交朋友和展示自己的机会，但我在积极改变。<br>人生来都不是十全十美的，我相信我有机会改正我的错误。</p>
</li>
<li><p>你能使组里气氛活跃，并且易于沟通吗？<br>我会尽力，和团队中的成员<strong>沟通</strong>，向他们发问、学习。因为在团队里工作最重要的一件事就是集思广益，而不要只是一个人闷头单干。沟通是很重要的，不仅可以提高工作质量和效率，也可以产生活力。</p>
</li>
<li><p>如何处理与同事在工作中意见的不和？与上级意见冲突？<br>我要以更清楚和文明的方式提出我的看法，使对方了解我的观点。<br>我会尊重上级，上级一般更有经验，思考更全面，要通过积极沟通找到一个更合适的解决方法。</p>
</li>
<li><p><strong>眼下你生活中最重要的是什么？你未来几年的规划是什么？</strong><br>对我来说，能在这个领域找到工作是最重要的。<br>规划好职业生涯，与同事们很好地合作。我希望能充分展示我在这个行业的能力和智慧。</p>
</li>
<li><p>偶像？企业家？<br>里奥梅西。除了足球方面的，他有着世界上最宝贵的天赋，谦逊。他沉默地担下所有责任，用实际行动回复质疑和诋毁，以及他个人和职业生涯中的种种挫折，共同让他成长为了这个世界上最坚强的男人。<br>任正非？？。一位民族企业家，实干家（尊重教师和科学家）。他的企业即使在最艰难的时刻，也坚持研发投入，有着向上的风气。</p>
</li>
</ul>
<hr>

<h2 id="职业"><a href="#职业" class="headerlink" title="职业"></a>职业</h2><ul>
<li><p><strong>了解 Java 后端开发这个行业岗位吗？是否符合期许？</strong><br>我认为 Java 后端开发是一个非常有挑战性的领域，开发能够为人们的生活带来便利的软件，对我来说是有趣的。<br>在互联网企业应用广泛，有活力，发展前景好？？<br>Java 作为一门强大而灵活的编程语言，具有广泛的应用领域，尤其在企业级应用开发中表现出色。<br>我在大学期间学习和做项目的过程中接触到了Java编程，并且在后来的时间加强了对相关技术的学习。我期望能够在一个具有挑战性、创新性和学习机会的团队中工作，我也希望自己能成为一个能够解决困难和不断学习的人。Java开发是一个不错的领域。<br>我身边的同学大多数也选择软件开发。。</p>
</li>
<li><p>认为怎样是好的开发工程师？<br>1.<strong>技术深度和广度：</strong> 了解Java语言的方方面面，包括基础语法、多线程、IO等，熟悉常用的框架和工具。以及其他相关技术<br>2.<strong>问题解决能力：</strong> 具有良好的问题解决能力。能够独立分析问题、理解需求、提出解决方案，并快速有效地实现。<br>3.<strong>代码质量：</strong> 写出高质量的、可维护的代码。注重代码规范、模块化和可测试性。<br>4.<strong>团队协作：</strong> 良好的团队协作能力是软件开发中至关重要的一环。有效沟通、分享知识，并能够与团队成员协作解决问题。<br>5.<strong>持续学习：</strong> 技术日新月异，一个好的开发者应该保持持续学习的习惯，关注新技术的发展，随时准备适应行业的变化。<br>6.<strong>创新思维：</strong> 善于提出新的、创造性的解决方案，对于提升产品和团队的效率具有积极的作用。<br>7.<strong>用户导向：</strong> 理解产品和项目的业务需求，站在用户的角度思考问题，以用户体验为中心。</p>
</li>
</ul>
<hr>

<h2 id="实习（骏伯）"><a href="#实习（骏伯）" class="headerlink" title="实习（骏伯）"></a>实习（骏伯）</h2><ul>
<li><p>广州骏伯网络？<br>使命：让移动互联网营销简单高效; 价值观：创造价值，分享价值; 愿景：做最受信赖的移动互联网营销服务商;</p>
</li>
<li><p>工作<br>产品研发中心-应用开发部-基础建设组 - Java开发实习生 - 2024.1.8 ~</p>
</li>
<li><p>？</p>
</li>
</ul>
<h2 id="实习（创世）"><a href="#实习（创世）" class="headerlink" title="实习（创世）"></a>实习（创世）</h2><ul>
<li><p>“牙医星球”小程序，做了什么？</p>
<ol>
<li>接口设计？<br>  根据用户提供的功能清单和产品原型图，结合已有的数据库表字段，尝试设计了小程序“个人中心”部分的接口以及相关的数据库字段设计。<br>  例如，根据用户id查询和修改用户信息，分页查询用户在这个小程序上报名的课程列表，查询用户学习在线课程的记录。<br>  同时，也设计了在线课程学习记录表，按照用户id分区创建不同的线上课学习记录表，避免把所有用户的学习记录放到一张表中。其中“连续学习天数”这个字段，放到了user_info表中作为用户属性字段；同时在user_info表中增加了一个“最近学习日期”，在更新“连续学习天数”时可根据“最近学习日期”判断是否连续，同时将“最近学习日期”更新。</li>
<li>视频弹幕功能？<br>  使用 WebSocket 协议，在一个持久连接上进行全双工通信，实现客户端和服务器之间的实时通信。与传统的HTTP通信相比，减少了网络开销和延迟。<br>  使用 ws 实现实时弹幕的功能：客户端与服务端建立 ws 连接后，使用 WebSocket包中的Session类保存与这个客户端的连接会话，根据ws 连接中携带的用户的connectionId，将这个session保存在静态的线程安全的ConcurrentHashMap中，同时在redis中创建&#x2F;刷新该用户信息；当服务端收到客户端通过ws连接发送的消息时，从reids中找到所有 最近70s内创建&#x2F;刷新的 用户连接的connectionId，在Map中找到对应的session，给用户端发送这条新弹幕，同时刷新redis中的用户信息。<br>  第一次接触http以外的协议，websocket协议是http的升级，服务端接口使用的是@ServerEndpoint(“&#x2F;“)获取连接信息。对于获取connectionId这个请求，应该在ws连接之前发生，所以使用一个controller实现获取connectionId请求，随后客户端使用js代码调用ws接口，建立ws连接。在开发过程中，发现有关弹幕的service类无法在ws接口中正确注入，所以建议把（通过mybatis）保存弹幕信息到数据库这个行为也分开在controller中实现，点击“发送弹幕”后，先调用controller保存弹幕信息，然后调用ws接口实现实时弹幕。</li>
</ol>
</li>
<li><p>编程平台项目，做了什么？</p>
<ol>
<li>项目整体情况：一个在线少儿编程竞赛平台，学生登录平台，在竞赛时间内获取试题，答题和提交。构建在SSM + SpringBoot上，有统一的返回结果格式 JsonResult，统一的成功&#x2F;失败返回码。</li>
<li>学生登录：<ul>
<li>生成图像验证码uuid：UUID生成验证码唯一标识 uuid，Hutool 库生成一个圆形验证码。将 uuid 和 验证码的base64编码 返还前端。将验证码标识和验证码内容以键值对的形式（uuid，code）存储到 Redis中，有效期为60秒。</li>
<li>发生短信验证码sendsms：同时以 JsonResult给前端返回该手机号下的所有学生账号（以label、value形式，返回数组 List&lt;Map&lt;String, Object&gt;&gt; stu）因为一个家长的手机号可对应多个孩子的学生账号</li>
<li>登录：使用手机号+学生姓名+密码登录。验证密码是否正确（base64编码+md5加密【不可逆】后，与数据库中存的密码去除头四个尾两个字符后比较），验证码uuid是否存在（返还给前端的标识）且正确（用户输入的验证码），</li>
<li>修改密码：一系列的判断，提交是否为null或空、账号是否存在、新密码是否满足给定的正则格式，接着要与数据库中的原密码（可）和同一登录账号下其他学生密码（不可）判断是否重复。用户输入的密码存入数据库，要经过：base64加密，和项目密钥连接后进行 MD5哈希加密，再通过randomTest.getRandomStr()随机增加到前4个字符和后2个字符。</li>
</ul>
</li>
<li>编程题判题：<ul>
<li>@Transactional(rollbackFor &#x3D; Exception.class) 声明事务，将提交编译题方法 <code>getCompileAnswer</code>包裹在一个数据库事务中，抛异常后回滚。</li>
<li>判断学生id存在，是否在比赛时间，是否已提前交卷（有scoreRecord记录）</li>
<li>使用 restTemplate给布置在服务器上的”判题机”发生编程题判题请求，返回判题结果</li>
<li>如果没有提交记录，新增compileAnswer，判断剩余提交次数；如果此次提交编程题成绩大于原纪录中的，更新记录</li>
<li>返回前端：（success: ; resultCode: ; resultMsg: ; data:通过样例数，平均时间，平均内存）</li>
</ul>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>与产品经理，前端沟通？<br>原来使用coding代码协同和项目管理，在蓝湖放了原型设计，通过微信沟通。后面统一改用飞书。<br>先开一个项目启动会，确定如静态页面，接口开放，前后端连接调试的进度，时间管理。。？？<br>开发过程里，我通过看产品原型进行理解，结合项目代码和文档理解，开发接口时与前端对接。。。</p>
</li>
<li><p>你遇到的最大的挑战是什么？怎么解决的？<br>一开始的时候，我虽然有ssm，mybatis基础，但是等于一些注解，方法还是一知半解，而且没有看过项目代码，不会看接口文档，没用过git等，，一整个就是非常无从下手。后来就是硬着把需求相关的代码看完，每个小细节都自己查方法或者问同事，从最简单的一个需求开始一个个解决，测试，提交，逐渐上手。当然后面也把缺的技术补上了。<br>（技术上遇到的困难，应该就是复杂的业务逻辑吧，如编程题判题）</p>
</li>
<li><p>在过往的实习中，从身边的人学到了什么？<br>1.<strong>技术深度和实践经验：</strong> 有经验的开发者，他们可能分享一些最佳实践、遇到的坑以及如何解决问题的经验。<br>2.<strong>团队协作和沟通技巧：</strong> 在团队中，学习如何有效地与他人合作、沟通，共同推动项目的进展。是开发中重要一环。<br>3.<strong>项目管理和时间管理：</strong> 观察和学习如何进行项目管理：任务的分配、进度的追踪、问题的解决等，和学会管理自己的时间<br>4.<strong>代码审查和质量保障：</strong> 学习如何进行代码审查，提高代码质量。理解测试的重要性，包括单元测试、集成测试等。<br>5.<strong>解决问题的方法：</strong> 实际开发中会遇到各种各样的问题。从经验丰富的开发者，学到更多解决问题的方法和技巧。<br>6.<strong>职业发展规划：</strong> 与有经验的人交流，了解他们的职业发展路径，收集关于职业规划和技能提升的建议。<br>7.<strong>行业趋势和新技术：</strong> 有助于保持对行业的敏感性，并做好未来的职业规划。</p>
</li>
<li><p>在项目开发中，什么时候让你感到获得了成就感？<br>1.<strong>项目完成阶段：</strong> 成功地完成一个项目的不同阶段或整个项目时，会带来成就感。2.<strong>解决难题：</strong> 遇到复杂的技术难题，经过努力和钻研后成功解决，这种时刻会让你感到非常有成就感，特别是那些曾经让你感到困扰的问题。3.<strong>用户满意。</strong> 4.<strong>团队协作：</strong> 项目中的团队合作是一个重要的方面。当你与团队成员协同工作，成功地推动项目的进展，共同克服了困难，整个团队的成功会带来强烈的成就感。5.<strong>学到新知识：</strong> 在项目中学到新技术、工具或方法，应用这些知识解决实际问题，这种学习和应用的过程本身就是一种成就感。6.<strong>项目的成功实施：</strong> 当项目成功实施，交付给用户并产生了积极的影响时，你会感到自己的努力和贡献是有意义的。7.<strong>持续改进：</strong> 成功地推动了项目的持续改进，通过引入新的工程实践、工具或流程，使项目更加高效和可维护。</p>
</li>
</ul>
<hr>

<h2 id="项目（论坛）"><a href="#项目（论坛）" class="headerlink" title="项目（论坛）"></a>项目（论坛）</h2><ul>
<li><p><strong>论坛系统项目</strong>（高校信息平台。。。）</p>
<ul>
<li>项目描述：一个基本功能完整的论坛项目。主要功能有：基于邮件激活的注册方式，区别登陆状态为游客或已登录用户展示不同界面与功能。支持用户上传头像，实现了发布帖子、评论帖子、发送私信等功能，以及点赞，关注与系统通知功能。<br>  项⽬构建在 Spring Boot + SSM 框架之上，并统⼀的进⾏了状态管理、事务管理、异常处理。</li>
<li>核心功能:<br>  1、用户模块：使用 Spring Email 辅助发送注册激活邮件，并且使用 Interceptor 拦截器赋予不同类型的用户权限，解决 http 无状态带来的缺陷问题，保护需登录才能查看的资源。<br>  2、内容模块：使用 Spring AOP 面向切面编程思想统一记录日志；数据库连接使用 Mybatis 框架来完成，实现SQL语句和代码的分离，解除了SQL语句与代码的耦合。<br>  3、通知模块：使用 Kafka 消息队列构建异步消息系统，实现点赞关注与通知间削峰。</li>
<li>项目优化：<br>  1、引入 Redis 数据库，优化项目中 Session 的使用并利用 Redis 实现点赞和关注功能。<br>  2、使用 Caffeine + Redis 实现两级缓存，优化了热门帖子的访问。<img src="https://leo710aka.github.io/bk/job1.png" width="750" height="300" alt=""></li>
</ul>
</li>
<li><p>介绍项目</p>
<ol>
<li>梳理系统的项目背景以及整个系统架构设计与运转流程</li>
<li>技术上的亮点:”我在处理数据的过程中，实现了数据的一致性和可靠性，做到了数据零丢失”、“项目引入了规则引擎，其中解决了xxx的业务问题，使得工作效率极大提升”… 等等</li>
<li>业务上的亮点:”实现了业务隔离，不同类型之间的业务互不干扰，从原来的xxx提升到了、”参考自某平台的xx功XXx”能，从零开始实现了业务，使得平台收益增加了xxx”.. 等等</li>
<li>梳理项目还可提升的地方：无论是提高性能，还是提高工作效率，总会有的。这时候如果能吹下自己对比过某某公司的同类型系统，借鉴了某某某优点，基于目前自身的业务觉得还有哪里可以继续优化</li>
</ol>
</li>
<li><p>请简要介绍一下你的项目？<br>实现了一个基本功能完整的论坛项目，主要使用了Springboot、Mybatis、MySQL、Redis、Kafka、等工具。主要实现了用户的注册、登录、发帖、点赞、系统通知、按热度排序、搜索等功能。另外引入了redis数据库来提升网站的整体性能，实现了用户凭证的存取、点赞关注的功能。基于 Kafka 实现了系统通知：当用户获得点赞、评论后得到通知。利用定时任务定期计算帖子的分数，并在页面上展现热帖排行榜。</p>
</li>
<li><p>如何实现项目的注册问题？<br>我们对每一个请求的开发都是由Dao——&gt;sevice——controller层。在插入数据前，会对数据进行空值验证，对账号邮箱进行重复性验证，使用map来存储错误信息，如果controller层拿到的map为空就说明注册成功，进行后续的激活处理。在插入数据时，会对密码进行加盐处理后，在使用MD5算法进行加密，然后存储到数据库，最开始的数据Status设为0，表示无效，需要进行激活处理。<br>项目如何实现用户唯一性检验：在创建MySQL表时，使用unqiue关键字保证用户名username字段的唯一性。另外，在注册用户时进行重复性验证，如果已经用户已经存在，不能进行注册。</p>
</li>
<li><p>登录状态保存在哪<br>保存在用户凭证表，包括用户id，用户凭证，用户状态和过期时间，对于用户凭证表是0有效1无效。在登录时验证账号密码是否为空，或者密码是否错误等，如果没有错误就生成登录凭证。</p>
</li>
<li><p>用户登陆上之后怎么显示登录页面<br>用户在登录后会以ticket名称为key，以及实际的ticket为value创建一个cookie存入浏览器，之后服务端根据用户凭证在用户凭证表中查询user信息封装在模板中然后返回给浏览器。代码和流程如下图所示<br>这个过程是每一个用户登录都会存在的，所以我们需要拦截器来处理。同时对于服务端来说，同时可能会有大量的浏览器请求，所以这里还涉及到线程安全问题。</p>
</li>
<li><p>拦截器（Interceptor）<br>目的：让未登录用户不能访问某些页面<br>原理：在方法前标注自定义注解，拦截所有的请求，只处理带有该注解的方法。<br>拦截器：1.自定义拦截器 2.配置拦截器<br>首先验证用户（preHandle方法），如果用户存在，则在本次请求中持有用户，放进hostHolder里<br>经过controller后，返回到拦截器，拦截器再将用户信息存入model。<br>自定义拦截器需要实现HandlerInterceptor，然后重写preHandle（controller前执行）,postHandle（controller后执行）,以及afterCompletion（模板解析后执行）<br>配置拦截器：需要实现WebMvcConfigurer接口，然后重写addInterceptors方法，排除拦截静态页面。</p>
</li>
<li><p>ThreadLocal（线程安全）<br>从上面的代码可以看出，ThreadLocal  set赋值的时候首先会获取当前线程thread,并获取thread线程中的ThreadLocalMap属性。如果map属性不为空，则直接更新value值，如果map为空，则实例化threadLocalMap,并将value值初始化<br>ThreadLocalMap是ThreadLocal的内部静态类，而它的构成主要是用Entry来保存数据 ，而且还是继承的弱引用。在Entry内部使用ThreadLocal作为key，使用我们设置的value作为value。<br>通过当前线程对象的getMap()方法获取ThreadMap对象 然后将当前ThreadLocal对象作为key值存入map 这能保证线程内的资源共享而不同线程之间独立</p>
</li>
<li><p>项目哪块用到AOP了？（面向切面编程）<br>项目中统一处理日志时，用到了AOP。如果我们在每个业务组件中都记录日志，那么会产生非常多的重复代码。如果我们采用OOP的思想，将记录日志的功能封装成一个bean去调用，那么会产生耦合度高等问题。因为记录日志本身不属于业务需求，它属于系统需求，所以我们不应该将业务需求和系统需求耦合在一起，这个时候我们就需要用AOP来处理。AOP解决统一处理系统需求的方式是将代码定义到一个额外的bean，叫切面组件Aspect，这个组件在程序运行之前就需要被框架织入到某些连接点。切面组件的pointcut声明织入到哪个位置，通知Advice方法声明切面要处理什么样的逻辑。</p>
</li>
<li><p>项目中redis怎么用的</p>
<ul>
<li>缓存点赞和关注：<ol>
<li>Redis缓存用户点赞数用String类型，以用户ID为key，点赞时，自增，取消赞时，自减；<br>  缓存实体点赞数，set类型，用户给实体点赞时添加进列表，取消赞时则移除，最后用size统计；</li>
<li>缓存粉丝列表，使用zset，存入粉丝的id和关注的时间戳，使用zCard获得粉丝数量。利用reverseRange的时间戳反向排序，按关注时间加载粉丝列表。</li>
</ol>
</li>
<li>优化登录：<ol>
<li>使用Redis缓存用户信息：将user缓存到Redis中，获取user时，先从Redis获取。取不到时，则从数据库中查询，再缓存到Redis中。因为很多界面都要用到user信息，并发时，频繁的访问数据库，会导致数据库崩溃。变更数据库时，先更新数据库，再清空缓存；</li>
<li>使用Redis缓存验证码：原本添加到session中，减轻服务器压力。将验证码存到Redis中，方便查询检验；<br>  当⽤户点击刷新验证码时，服务端⾸先给当前需要登陆的游客，设置⼀个随机字符串(kaptchaOwner)，⽤于标识当前这个游客，然后将随机字符串存⼊到cookie中，返回给浏览器，然后服务端的redis保存 “key:随机字符串,value:验证码”。接着⽤户输⼊⽤户名，密码，验证码，再次点击登陆时，服务端会从cookie中拿到kaptchaOwner,通过它，可以从Redis中得到正确的验证码，然后与⽤户输⼊的验证码做⽐较，看是否⼀致。<br>  验证码需要频繁的访问与刷新，对性能要求很高；验证码不需要永久存储，通常在很短的时间内就会失效；分布式部署时，存在session共享问题；</li>
<li>登录凭证：原本添加到MySQL中，为减轻每次登录都去查询数据库的压力，将登录凭证ticket缓存在Redis中，防止每次都要进行数据库的查询，提高并发能力。退出登录时，原本要修改数据库中的登录凭证，现在只需要修改Redis即可。</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>为什么⽤Redis？<br>1、Redis是⼀种基于键值对的NoSQL数据库，它⽀持多种数据结构：字符串、哈希、列表、集合、有序集合等<br>2、Redis将所有的数据都存在内存中，所以它的读写性能⼗分惊⼈。同时，还可以将数据以快照或者⽇志的形式保存到硬盘上。<br>3、缓存、排⾏榜(热⻔帖⼦)、计数器、社交⽹络(点赞数)、消息队列等。</p>
</li>
<li><p>redis的key怎么设计（怎样存储的点赞、关注、缓存用户数据）？<br>redis的key是String类型的，编写了一个工具类来生成redis的key。key由多个单词拼接而成，中间采用冒号隔开，有的单词是固定的，有些单词是动态的。<br>点赞使用set类型存储，key为点赞对象，set中保存点赞人的ID<br>关注使用zSet类型存储，key为被关注者，set保存关注者以及关注时间为score<br>缓存用户数据使用Value类型，key为用userID得到的key，value为user对象（设置过期时间，且数据修改时需要清除缓存）<br>验证码是与user相关的，但是这里我们不能直接传入userId,因为还未登录，我们不知道用户是谁。这里传入了一个字符串owner，这是在用户访问登录页面的时候，给他发一个凭证（随机字符串），存到cookie里，用的时候从cookie内将这个owner取出来，在得到rediskey，然后获取验证码，与输入的验证码进行对比。</p>
</li>
</ul>
<ul>
<li><p>缓存点赞数如何实现<br>帖子和评论的赞一起存，统称为实体的赞。还需要统计用户的赞（用户的帖子和评论收到的赞的总和）。因为如果统计用户所有帖子和评论的赞得到用户获得的赞太麻烦，所以这里以用户ID采用rediskey工具拼接为key记录点赞数量（这就会涉及到事务操作。用户的帖子或者评论的点赞数增加了对应的用户的赞要增加）。<br>具体实现：使用redis来存储点赞数，首先需要构造redis的key，<br>点赞使用set类型存储，key为点赞对象，set中保存点赞人的ID<br>点赞的时候需要判断用户是否已经点赞：通过redistemplate.opsforSet().ismember方法 如果已经点过赞了就要把点赞记录删除 否则添加数据。 这里用到了事务操作 重写了execute方法<br>项目中的redis在存储用户信息时，是只读模式。</p>
</li>
<li><p>如何解决缓存和数据库的数据不一致问题？<br>缓存和数据库的数据不一致一般是由两个原因导致的，提供了相应的解决方案。<br>1、删除缓存值或更新数据库失败而导致数据不一致，可以使用重试机制确保删除或更新操作成功。<br>2、在删除缓存值、更新数据库的这两步操作中，有其他线程的并发读操作，导致其他线程读取到旧值，应对方案是延迟双删。<br>重试机制：具体来说，可以把要删除的缓存值或者是要更新的数据库值暂存到消息队列中。当应用没有能够成功地删除缓存值或者是更新数据库值时，可以从消息队列中重新读取这些值，然后再次进行删除或更新。如果能够成功地删除或更新，我们就要把这些值从消息队列中去除，以免重复操作，此时，我们也可以保证数据库和缓存的数据一致了。否则的话，我们还需要再次进行重试。如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了 。<br>延迟双删： 一般应用于先删除缓存，再更新数据库的多线程并发访问的情况。这是因为，先更新数据库值，再删除缓存值的情况下，如果线程 A 删除了数据库中的值，但还没来得及删除缓存值，线程 B 就开始读取数据了，那么此时，线程 B 查询缓存时，发现缓存命中，就会直接从缓存中读取旧值。不过，在这种情况下，如果其他线程并发读缓存的请求不多，那么，就不会有很多请求读取到旧值。而且，线程 A 一般也会很快删除缓存值，这样一来，其他线程再次读取时，就会发生缓存缺失，进而从数据库中读取最新值。所以，这种情况对业务的影响较小。<br><img src="https://img-blog.csdnimg.cn/572d2e33e1b44d998ab28d103f895ea9.png"></p>
</li>
</ul>
<ul>
<li><p>怎么理解⽣产者和消费者？⽣产者发消息是主动调⽤；消费者接受消息，是⼀个被动调⽤的过程(监听)</p>
</li>
<li><p>kafka消息模型和常见术语？</p>
<ul>
<li>kafka入门：Apache Kafka是一个分布式流平台。一个分布式的流平台应该包含3点关键的能力：</li>
<li>kafka特点<ul>
<li>高吞吐量：处理TB级的海量数据</li>
<li>消息持久化：持久化，将数据存储到硬盘上，而不仅仅存储在内存中，长久保存消息，存到硬盘中的读取速度远远小于内存，读写硬盘的效率高低取决于读取硬盘的方式，硬盘的顺序读写的效率是很高的，kafka保证对硬盘消息的读写都是顺序的；</li>
<li>高可靠性：kafka是分布式部署，一台服务器挂了，还有别的，有容错机制</li>
<li>高拓展性：集群的服务器不够时，可以扩展服务器，只需简单的配置</li>
</ul>
</li>
<li>kafka术语<br>  消息模型：发布-订阅模型，消费者订阅了某一主题（topic）后，生产者采用类似广播的方式，将消息通过主题传递给所有的订阅者。<br>  Topic：主题，类似于文件夹，用来存放不同的数据。<br>  Partition：主题分区，同一主题的不同分区可以存放在不同的Broker上面，保证并发能力和负载均衡。<br>  Offset：消息在Partition中的存放位置。<br>  Broker：可以理解为kafka集群里面的一台或多台服务器，它本身是没有复制的，上面可能运行着topic1的leader， topic2的follower等等。</li>
</ul>
</li>
</ul>
<ul>
<li>项目哪里用到了kafka？<br>当有点赞，评论，关注请求时，会发送系统通知点赞，评论，关注的对象。在处理系统信息时，使用到了Kafka，具体来说，先定义了生产者类和消费者类，其中生产者被点赞&#x2F;评论&#x2F;关注功能对应的Controller使用，产生消息。而消费者负责消息（message）到来时，把消息存到数据库内。<br>触发事件之后, ⽣产者⽣产消息，消费者监听到有消息之后 -&gt; 将消息队列中的事件Event(或者可以简单的看作消息)取出 -&gt; 按需要将其封装为Message对象，并且持久化到数据库中保存。</li>
</ul>
<ul>
<li><p>消息队列放到内存还是磁盘？放磁盘为什么还这么快？</p>
<ul>
<li>Kafka的消息是保存或缓存在磁盘上的，一般认为在磁盘上读写数据是会降低性能的，因为寻址会比较消耗时间，但是实际上，Kafka的特性之一就是高吞吐率。从数据写入和读取两方面分析，为什么Kafka速度这么快</li>
<li>写入数据：磁盘读写的快慢取决于你怎么使用它，也就是顺序读写或者随机读写。在顺序读写的情况下，磁盘的顺序读写速度和内存持平。因为硬盘是机械结构，每次读写都会寻址-&gt;写入，其中寻址是一个“机械动作”，它是最耗时的。所以硬盘最讨厌随机I&#x2F;O，最喜欢顺序I&#x2F;O。为了提高读写硬盘的速度，Kafka就是使用顺序I&#x2F;O。<br>  即便是顺序写入硬盘，硬盘的访问速度还是不可能追上内存。所以Kafka的数据并不是实时的写入硬盘 ，它充分利用了现代操作系统分页存储来利用内存提高I&#x2F;O效率。</li>
<li>读取数据：实现了零拷贝</li>
</ul>
</li>
<li><p>优化⽹站的性能<br>本地缓存：将数据缓存在应用服务器上，性能最好。常用缓存工具: Ehcache、 Guava、 Caffeine等<br>分布式缓存：将数据缓存在NoSQL数据库上，跨服务器。常用缓存工具: MemCache、 Redis等。<br>多级缓存：&gt;一级缓存 (本地缓存) &gt; 二级缓存 (分布式缓存) &gt; DB；避免缓存雪崩 (缓存失效，大量请求直达DB)，提高系统的可用性</p>
</li>
</ul>
<hr>

<h2 id="八股（Java）"><a href="#八股（Java）" class="headerlink" title="八股（Java）"></a>八股（Java）</h2><ul>
<li><p><strong>封装</strong>？int -&gt; Integer<br>Java面向对象语言，一切操作以对象为基础。对象中封装了属性和操作，使用灵活，数据不被外部修改。Integer初始值为null，存储在堆内存；int初始值0，存储在栈空间。封装类在处理集合、泛型、反射等场景中非常有用。</p>
</li>
<li><p>String<br>String 是不可变类。不可变类指的是无法修改对象的值，当你创建一个 String 对象之后，这个对象就无法被修改。像执行s +&#x3D; “a”; 返回的是一个新的 String 对象，老的 s 指向的对象不会发生变化，只是 s 的引用指向了新的对象而已。“不可变”最主要的好处就是安全，在多线程环境下也是线程安全的；然后，配合常量池可以节省内存空间，且获取效率也更高（如果常量池里面已经有这个字符串对象了，就不需要新建，直接返回即可）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &quot;字面量创建字符串&quot;：yesA 是一个引用指向了堆里面的字符串常量池里的对象 a。如果字符串常量池已经有了 a，那么直接返回其引用，如果没有 a，则会创建 a 对象，然后返回其引用。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">yesA</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>; <span class="type">String</span> <span class="variable">yesB</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;                </span><br><span class="line">System.out.printIn(yesA == yesB);  <span class="comment">// true</span></span><br><span class="line"><span class="comment">// &quot;new String创建字符串&quot;：先判断字符串常量池里面是否有 a，如果没有 a 则创建一个 a。然后会在堆内存里面创建一个对象 a，返回堆内存对象 a 的引用，也就是说返回的不是字符串常量池里面的 a</span></span><br><span class="line">yesA = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>); yesB = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>);           </span><br><span class="line">System.out.println(yesA == yesB);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">yesA</span> <span class="operator">=</span> <span class="string">&quot;aaabbb&quot;</span>;            <span class="comment">// 通过字面量定义了 yesA，在字符串常量池里创建 aaabbb 对象，返回其引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">yesB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;bbb&quot;</span>); <span class="comment">// 返回堆内的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">yesC</span> <span class="operator">=</span> yesB.intern();       <span class="comment">// intern()：判断下 yesB 引用指向的值在字符串常量里面是否有，如果没有就在字符串常量池里面新建一个 aaabbb 对象，返回其引用，如果有则直接返回引用。</span></span><br><span class="line">System.out.println(yesA == yesB);  <span class="comment">// false</span></span><br><span class="line">System.out.println(yesA == yesC);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>JDK 1.6 时，字符串常量池是放置在永久代的; JDK 1.7 之后字符串常量池是放在堆内的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">yesB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;bbb&quot;</span>);  <span class="comment">// 此时，堆内会新建一个 aaabbb 对象，字符串常量池里不会创建，因为并没有出现 aaabbb 这个字面量。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">yesC</span> <span class="operator">=</span> yesB.intern();       <span class="comment">// 1.7 之后，如果堆内已经存在某个字符串对象的话，再调用 intern 此时不会在字符串常量池内新建对象，而是直接保存这个引用然后返回。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">yesA</span> <span class="operator">=</span> <span class="string">&quot;aaabbb&quot;</span>;            <span class="comment">// yesA 得到的引用与 yesC 和 yesB 一致，都指向堆内的 aaabbb 对象。</span></span><br><span class="line">System.out.println(yesA == yesB);  <span class="comment">// true</span></span><br><span class="line">System.out.println(yesA == yesC);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>String 连接？<ol>
<li><strong>使用 <code>+</code> 运算符</strong>：字符串连接最简单的方法，但在大量连接操作时可能效率较低，因为它会生成多个临时的字符串对象。</li>
<li>**使用 <code>StringBuilder</code>**：可变的字符序列，适用于需要频繁进行字符串连接的场景。<code>append</code> 方法用于添加字符串内容，最后使用 <code>toString</code> 方法获取最终的字符串。适合单线程环境下使用。</li>
<li>**使用 <code>StringBuffer</code>**：与 <code>StringBuilder</code> 类似，也是可变的字符序列，但不同之处在于 <code>StringBuffer</code> 是线程安全的，适用于多线程环境。</li>
</ol>
</li>
</ul>
<ul>
<li>JDK9为什么要将 String 的底层实现由 char[] 改为 byte[]？<br>jdk中字符用utf-16编码，一个字符char要占用2个字节；但是对于由纯英文字符和ascii字符组成的字符串，只需要一个字节就可以表示所有ascii字符，使用 byte[] 可以节省一半空间。<br>只有在需要存储非ascii字符时，才会使用char[]</li>
</ul>
<ul>
<li><p>静态 static</p>
<ol>
<li>静态变量（Static Variables）：被声明为 <code>static</code> 的成员变量，属于类而不是类的实例。它被所有类的实例共享，只有一个副本存在于内存中。</li>
<li>静态方法（Static Methods）：被声明为 <code>static</code> 的方法，它不需要实例化类就可以直接通过类名调用。静态方法不能访问非静态成员，也无法使用 <code>this</code> 关键字。<br>  静态方法凭什么不能访问成员方法：因为成员方法属于对象实例，静态方法属于类本身，静态方法第一次加载(方法区)的时候还没有对象(堆)，也就无法调用成员方法</li>
<li>静态代码块（Static Blocks）：是包含在类中的静态块，它在类加载时执行，并且只执行一次。通常用于初始化静态变量或执行一些静态的初始化操作。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 静态代码块</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>静态内部类（Static Inner Classes）：在类中使用 <code>static</code> 关键字修饰的内部类。静态内部类与外部类实例无关，可以直接通过外部类名访问。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClass</span> &#123;</span><br><span class="line">        <span class="comment">// 静态内部类</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  在使用静态成员时需要注意，它们的生命周期与类的生命周期相同，当类加载时会被初始化。静态成员属于类而不是对象，在合适的场景下能提供便利和效率。然而，过度使用静态成员可能会导致耦合度高和难以测试等问题，因此需要根据实际情况慎重使用。</li>
</ol>
</li>
<li><p>静态变量、静态代码块、普通代码块和构造方法的执行顺序？<br>  执行顺序可以总结为：静态变量（按定义顺序初始化） -&gt; 静态代码块（按定义顺序执行） -&gt; 普通代码块（对象实例化时按照定义顺序执行） -&gt; 构造方法。</p>
<ol>
<li>静态变量（静态成员变量）：在类加载时按照定义的顺序依次执行初始化，不论该变量在类中定义的位置如何，只会初始化一次。</li>
<li>静态代码块（Static Blocks）：静态代码块在类加载时执行，优先于普通代码块和构造方法。静态代码块只会执行一次。</li>
<li>普通代码块（普通初始化块）：普通代码块在对象实例化时执行，在构造方法之前执行。每次创建对象都会执行一次。</li>
<li>构造方法（Constructor）：构造方法在对象创建时执行，用于初始化对象。在普通代码块执行完毕后执行。</li>
</ol>
</li>
</ul>
<ul>
<li><p>子类继承父类，且都包含静态方法、构造方法。。<br>顺序：父类静态方法 -&gt; 父类静态代码块 -&gt; 子类静态方法 -&gt; 子类静态代码块 -&gt; 父类普通代码块 -&gt; 父类构造方法 -&gt; 子类普通代码块 -&gt; 子类构造方法</p>
</li>
<li><p>抽象类（Abstract Class）：</p>
<ol>
<li><strong>特点</strong>：抽象类是一种不能被实例化的类，通常用于定义其他类的结构和行为。它可以包含抽象方法（只有方法签名，没有具体实现），以及普通的方法和字段。一个类只能继承一个抽象类。可以包含构造函数，可以有访问修饰符（public、private、protected）的方法。子类必须实现抽象类中的所有抽象方法，除非子类也是抽象类。</li>
<li><strong>使用场景</strong>：当需要创建一个类，并在其中定义一些方法的行为，但不希望该类被实例化时，可以使用抽象类。抽象类也适合用于在类层次结构中作为其他类的基类，提供通用方法和字段，而具体实现交给其子类。</li>
</ol>
</li>
<li><p>接口（Interface）：</p>
<ol>
<li><strong>特点</strong>：接口是一种完全抽象的类别，其中只包含方法的签名，但没有方法的实际实现。类可以实现多个接口，但接口不能包含字段或非抽象方法（在Java 8之后，引入了默认方法和静态方法）。</li>
<li><strong>使用场景</strong>：当不同类需要共享某些行为，但它们属于不同的类层次结构时，接口是一个很好的选择。接口允许类定义一组规范，以确保实现类必须提供接口中定义的所有方法。可以使用接口来实现多态性，允许不同的类实现相同的接口并具有不同的行为。</li>
</ol>
</li>
<li><p>接口与抽象类：<br>  接口和抽象类都是为了实现代码的重用和提供一致的编程接口而设计的。然而，接口更多地用于定义规范和合同，以确保实现类提供特定的行为，而抽象类更多地用于提供一些通用的方法和行为实现。</p>
<ul>
<li>抽象类和接口都用于实现多态性和提供一致的编程接口。它们通常用于大型项目中的类层次结构设计和代码组织。</li>
<li>在设计框架或库时，接口是一个有用的工具，因为它可以定义规范和标准，并允许用户通过实现接口来提供自定义行为。</li>
<li>抽象类用于将一些通用方法和字段提取到一个父类中，以便子类可以继承和共享这些功能。</li>
</ul>
</li>
<li><p>？？设计模式：<a target="_blank" rel="noopener" href="https://fengxiuyang.cn/articles/67">https://fengxiuyang.cn/articles/67</a></p>
</li>
<li><p>java集合：<a target="_blank" rel="noopener" href="https://leo710aka.github.io/2021/09/03/Java%E9%9B%86%E5%90%88/">https://leo710aka.github.io/2021/09/03/Java集合/</a></p>
</li>
<li><p>Java 的 List？<br>List在Java里边是一个接口，常见的实现类有ArrayList和LinkedList，ArrayList底层数据结构是数组，LinkedList链表。</p>
</li>
<li><p><strong>ArrayList</strong><br>实现了动态扩容。当new ArrayList()时，默认会有一个大小为0空的Object数组。第一次add添加数据的时候，会给数组初始化一个默认值<strong>10</strong>的大小。使用ArrayList在每一次add的时候，会先去计算数组空间；如果空间是够的，直接追加上去；如果不够，那就得扩容。在源码里边，有个grow方法，每一次扩容原来的<strong>1.5倍</strong>，之后会调用arraycopy来对数组进行拷贝。<br>日常开发中用得最多的是ArrayList呢：是由底层的数据结构来决定的，在日常开发中，遍历的需求比增删要多，即便是增删也是往往在List的尾部添加就OK了。像在尾部添加元素，ArrayList的时间复杂度也就O(1)另外的是，ArrayList的增删底层调用的copyOf()被优化过；现代CPU对内存可以块操作，ArrayList的增删一点儿也不会比LinkedList慢？？</p>
</li>
<li><p>线程安全的List还有什么？<br>首先，我们也可以用Collections来将ArrayList来包装一下，变成线程安全。在java.util.concurrent包下还有一个类，叫做<strong>CopyOnWriteArrayList</strong>，是一个线程安全的List，底层是通过复制数组的方式来实现的。在add()方法会加lock锁，然后会复制出一个新的数组，往新的数组里边add真正的元素，最后把array的指向改变为新的数组，get()方法又或是size()方法只是获取array所指向的数组的元素或者大小。读不加锁，写加锁。CopyOnWriteArrayList跟文件系统的COW机制是很像的。缺点：很耗费内存，每次set()&#x2F;add()都会复制一个数组出来；另外只能保证数据的最终一致性，不能保证数据的实时一致性。</p>
</li>
<li><p>Vector 你了解吗？<br>Vector是底层结构是数组，一般现在已经很少用了。相对于ArrayList，它是线程安全的，在扩容的时候直接扩容两倍。</p>
</li>
<li><p>Map 了解多少？<br>Map在Java里边是一个接口，常见的实现类有HashMap、LinkedHashMap、TreeMap和ConcurrentHashMap<br>在Java里边，哈希表的结构是数组+链表的方式。HashMap底层数据结构是数组+链表&#x2F;红黑树；LinkedHashMap是数组+链表&#x2F;红黑树+双向链表；TreeMap是红黑树；而ConcurrentHashMap是数组+链表&#x2F;红黑树 </p>
</li>
<li><p><strong>HashMap</strong></p>
<ul>
<li>实现原理：其实就是有个 Entry 数组，Entry 保存了 key 和 value。当你要塞入一个键值对的时候，会根据一个 hash 算法计算 key 的 hash 值，然后通过数组大小 <code>n-1 &amp; hash</code> 值之后，得到一个数组的下标，然后往那个位置塞入这个 Entry。为了解决 hash 冲突的问题，采用了链表法<ul>
<li>在 JDK1.7 及之前链表的插入采用的是头插法，即在链表的头部插入新的 Entry。在 JDK1.8 的时候，改成了尾插法，并且引入了红黑树。当链表的长度大于 8 且数组大小大于等于 64 的时候，就把链表转化成红黑树，当红黑树节点小于 6 的时候，又会退化成链表。</li>
<li>为什么 JDK 1.8 要对 HashMap 做红黑树这个改动？主要是避免 hash 冲突导致链表的长度过长，这样 get 的时候时间复杂度严格来说就不是 O(1) 了，因为可能需要遍历链表来查找命中的 Entry。</li>
<li>为什么定义链表长度为 8 且数组大小大于等于 64 才转红黑树？不要链表直接用红黑树不就得了吗？因为红黑树节点的大小是普通节点大小的两倍，所以为了节省内存空间不会直接只用红黑树，只有当节点到达一定数量才会转成红黑树，这里定义的是 8（泊松分布）</li>
<li>为什么节点少于 6 要从红黑树转成链表？也是为了平衡时间和空间，节点太少链表遍历也很快，节约内存。</li>
</ul>
</li>
<li>HashMap <strong>默认大小为16，负载因子的大小为0.75。</strong><ul>
<li>HashMap的大小只能是2次幂的，假设你传一个10进去，实际上最终HashMap的大小是16（具体的实现在tableSizeFor可以看到）把元素放进HashMap的时候，需要算出这个元素所在的位置（hash）。在HashMap里用的是位运算来代替取模，更加高效。HashMap的大小只能是2次幂时，才能合理用位运算替代取模。 </li>
<li>负载因子的大小决定着哈希表的扩容和哈希冲突。比如默认的HashMap大小为16，负载因子为0.75，这意味着数组最多只能放16*0.75&#x3D;12个元素，每次put元素进去的时候，都会检查HashMap的大小有没有超过这个阈值，一旦超过12，则哈希表需要扩容。如果把负载因子调高了，哈希冲突的概率会增高，同样会耗时（因为查找的速度变慢了）</li>
</ul>
</li>
<li>hash 函数的优化：1.8后，在put元素的时候传递的Key，先算出正常的哈希值，然后与高16位做异或运算，产生最终的哈希值。这样做的好处可以增加了随机性，减少了碰撞冲突的可能性。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>扩容</strong> rehash 的优化：默认是扩原来的2倍（因为HashMap的大小只能是2次幂）。</li>
<li><strong>put</strong>：首先对key做hash运算，计算出该key所在的index。如果没碰撞，直接放到数组中，如果碰撞了，需要判断目前数据结构是链表还是红黑树，根据不同的情况来进行插入。假设key是相同的，则替换到原来的值。最后判断哈希表如果满了，扩容。</li>
<li><strong>get</strong>：还是对key做hash运算，计算出该key所在的index，然后判断是否有hash冲突。假设没有冲突直接返回，假设有冲突则判断当前数据结构是链表还是红黑树，分别从不同的数据结构中取出。<br>  在HashMap中怎么判断一个元素是否相同？首先会比较hash值，随后会用&#x3D;&#x3D;运算符和equals()来判断该元素是否相同。如果只有hash值相同，那说明该元素哈希冲突了，如果hash值和equals() || &#x3D;&#x3D; 都相同，那说明该元素是同一个。</li>
</ul>
</li>
<li><p>LinkedHashMap？<br>LinkedHashMap底层结构是数组+链表+双向链表，实际上它继承了HashMap，在HashMap的基础上维护了一个双向链表<br>LinkedHashMap 把 HashMap 的 Entry 加了两个指针：before 和 after。就是要把塞入的 Entry 之间进行关联，串成双向链表；有了这个双向链表，我们的插入可以是有序的，这里的有序不是指大小有序，而是插入有序。LinkedHashMap在遍历的时候实际用的是双向链表来遍历的，所以LinkedHashMap的大小不会影响到遍历的性能</p>
<img src="https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/640-20230912141802980.png" width="550" height="300" alt="">
并且内部还有个 accessOrder 成员，默认是 false， 代表链表是顺序是按插入顺序来排的，如果是 true 则会根据访问顺序来进行调整，就是咱们熟知的 LRU 那种，如果哪个节点访问了，就把它移到最后，代表最近访问的节点。
</li>
<li><p>TreeMap呢？<br>TreeMap的底层数据结构是红黑树，TreeMap的key不能为null（如果为null，那还怎么排序呢），TreeMap有序是通过实现 Comparable 接口或者自定义实现一个 comparator 传入构造函数，这样塞入的节点就会根据你定义的规则进行排序。如果comparator为null，那么就使用自然顺序 </p>
</li>
<li><p>ConcurrentHashMap？<br>ConcurrentHashMap是线程安全的Map实现类，它在juc包下的。线程安全的Map实现类除了ConcurrentHashMap还有一个叫做Hashtable。当然了，也可以使用Collections来包装出一个线程安全的Map。但无论是Hashtable还是Collections包装出来的都比较低效（因为是直接在外层套synchronize），所以一般都使用ConcurrentHashMap<br>HashMap不是线程安全的，多线程环境下有可能会有数据丢失和获取不了最新数据的问题<br>ConcurrentHashMap的底层数据结构是数组+链表&#x2F;红黑树，它能支持高并发的访问和更新，线程安全的。通过在部分加锁和利用CAS算法来实现同步，在get的时候没有加锁，Node都用了volatile给修饰。在扩容时，会给每个线程分配对应的区间，并且为了防止putVal导致数据不一致，会给线程的所负责的区间加锁。</p>
</li>
<li><p>注解？<br>注解在我的理解下，就是代码中的特殊标记，这些标记可以在编译、类加载、运行时被读取，并执行相对应的处理。<br>注解在开发中是非常常见的，比如Spring框架的 @Controller &#x2F; @Param &#x2F; @Select 等等。一些项目也用到lombok的注解，@Slf4j &#x2F; @Data 等等。Java原生也有@Overried、@Deprecated、@FunctionalInterface等基本注解。Java原生的基本注解大多数用于「标记」和「检查」还，此外有一种叫做元Annotation（元注解），所谓的元Annotation就是用来修饰注解的。<br>常用的元Annotation有@Retention 和@Target。@Retention注解可以简单理解为设置注解的生命周期，而@Target表示这个注解可以修饰哪些地方（比如方法、还是成员变量、还是包等等）<br>那你自己写过注解吗？？<a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv22578322/?spm_id_from=333.999.0.0&jump_opus=1">https://www.bilibili.com/read/cv22578322/?spm_id_from=333.999.0.0&amp;jump_opus=1</a></p>
</li>
<li><p>泛型？<br>在Java中的泛型简单来说就是：在创建对象或调用方法的时候才明确下具体的类型<br>使用泛型的好处就是代码更加简洁（无需强制转换），程序更加健壮（编译期间没有警告，在运行期就无ClassCastException）<br>使用场景：操作集合的时候，List<String> lists &#x3D; new ArrayList&lt;&gt;();<br>如果是其他场景的话，那就是在写「基础组件」的时候了：再明确一下泛型就是「在创建对象或调用方法的时候才明确下具体的类型」，而组件为了做到足够的通用性，是不知道「用户」传入什么类型参数进来的，所以在这种情况下用泛型就是很好的实践。 </p>
</li>
<li><p><strong>Java 反射</strong>？<br>简单来说，反射就是Java可以给我们在运行时获取类的信息<br>什么是「运行时」：在编译器写的代码是 .java 文件，经过javac 编译会变成 .class 文件，class 文件会被JVM装载运行（这里就是真正运行着我们所写的代码（虽然是被编译过的），也就所谓的运行时。<br>为什么要在「运行时」获取类的信息：其实就是为了让我们所写的代码更具有「通用性」和「灵活性」。一个好用的“工具”是需要兼容各种情况的，不知道用该“工具”的用户传入的是什么对象，但你需要帮他们得到需要的结果。例如 SpringMVC 你在方法上写上对象，传入的参数就会帮你封装到对象上；Mybatis可以让我们只写接口，不写实现类，就可以执行SQL；在类上加上@Component注解，Spring就帮你创建对象…<br>这些统统都有反射的身影：约定大于配置，配置大于硬编码。通过”约定”使用姿势，使用反射在运行时获取相应的信息（毕竟作为一个”工具“是真的不知道你是怎么用的），实现代码功能的「通用性」和「灵活性」 </p>
</li>
<li><p>泛型是会擦除的，那为什么反射能获取到泛型的信息呢？<br>泛型的信息只存在编译阶段，在class字节码就看不到泛型的信息了。那为什么下面这段代码能获取得到泛型的信息呢？<br>可以理解为泛型擦除是有范围的，定义在类上的泛型信息是不会被擦除的。？？？<br>Java 编译器仍在 class 文件以 Signature 属性的方式保留了泛型信息。Type作为顶级接口，Type下还有几种类型，比如TypeVariable、ParameterizedType、WildCardType、GenericArrayType、以及Class。通过这些接口我们就可以在运行时获取泛型相关的信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类，定义泛型&lt;T&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseDao</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseDao</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass();</span><br><span class="line">        <span class="type">ParameterizedType</span>  <span class="variable">pt</span> <span class="operator">=</span> (ParameterizedType) clazz.getGenericSuperclass(); </span><br><span class="line">        clazz = (Class) pt.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">        System.out.println(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> <span class="keyword">extends</span> <span class="title class_">BaseDao</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        BaseDao&lt;User&gt; userDao = <span class="keyword">new</span> <span class="title class_">UserDao</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果输出</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">com</span>.entity.User</span><br></pre></td></tr></table></figure>
</li>
<li><p>你了解动态代理吗？<br>动态代理其实就是代理模式的一种，代理模式是设计模式之一。代理模型有静态代理和动态代理。静态代理需要自己写代理类，实现对应的接口，比较麻烦。在Java中，动态代理常见的又有两种实现方式：JDK动态代理和CGLIB代理。<br>JDK动态代理其实就是运用了反射的机制，而CGLIB代理则用的是利用ASM框架，通过修改其字节码生成子类来处理。JDK动态代理会帮我们实现接口的方法，通过invokeHandler对所需要的方法进行增强。<br>动态代理这一技术在实际或者框架原理中是非常常见的。像上面所讲的Mybatis不用写实现类，只写接口就可以执行SQL，又或是SpringAOP 等等好用的技术，实际上用的就是动态代理。</p>
</li>
<li><p>Java 的NIO？<br><a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv22750549/?spm_id_from=333.999.0.0&jump_opus=1">https://www.bilibili.com/read/cv22750549/?spm_id_from=333.999.0.0&amp;jump_opus=1</a><br>Java NIO 是JDK 1.4 开始有的，其目的是为了提高速度。传统IO是一次一个字节地处理数据，NIO是以块（缓冲区）的形式处理数据。最主要的是，NIO可以实现非阻塞，而传统IO只能是阻塞的。IO的实际场景是文件IO和网络IO，NIO在网络IO场景下提升就尤其明显了。 </p>
</li>
<li><p>Java 编译到执行的过程？</p>
<ul>
<li>“Java 跨平台”：因为有 JVM 屏蔽了底层操作系统。Java源代码会被编译为class文件，class文件运行在JVM之上。JVM是面向操作系统的，它负责把Class字节码解释成系统所能识别的指令并执行，同时也负责程序运行时内存的管理。安装JDK的时可以发现JDK是分「不同的操作系统」，JDK里是包含JVM的，所以Java依赖着JVM实现了『跨平台』</li>
<li>Java源码到执行的过程，从JVM的角度看可以总结为四个步骤：编译-&gt;加载-&gt;解释-&gt;执行<ul>
<li>「编译」java源代码 经过 语法分析、语义分析、注解处理 最后才生成会class文件。对泛型的擦除和Lombok就是在编译阶段干的。 </li>
<li>「加载」又可以细分步骤为：装载-&gt;连接-&gt;初始化。装载则把class文件装载至JVM，连接则校验class信息、分配内存空间及赋默认值，初始化则为变量赋值为正确的初始值。连接里又可以细化为：验证、准备、解析<ul>
<li>【装载时机】为了节省内存的开销，并不会一次性把所有的类都装载至JVM，而是等到「有需要」的时候才进行装载（比如new和反射等等） 【装载发生】class文件是通过「类加载器」装载到jvm中的，为了防止内存中出现多份同样的字节码，使用了<strong>双亲委派机制</strong></li>
<li>【装载规则】JDK 中的本地方法类一般由根加载器（Bootstrp loader）装载，JDK 中内部实现的扩展类一般由扩展加载器（ExtClassLoader）实现装载，而程序中的类文件则由系统加载器（AppClassLoader）实现装载。</li>
<li>装载这个阶段它做的事情可以总结为：查找并加载类的二进制数据，在JVM「堆」中创建一个java.lang.Class类的对象，并将类相关的信息存储在JVM「方法区」中 </li>
<li>「连接」这个阶段它做的事情可以总结为：对class的信息进行验证、为「类变量」分配内存空间并对其赋默认值。又可以细化为几个步骤：1. 验证：验证类是否符合 Java 规范和 JVM 规范 2. 准备：为类的静态变量分配内存，初始化为系统的初始值 3. 解析：将符号引用转为直接引用的过程 </li>
<li>接下来就是「初始化」阶段了，可以总结为：为类的静态变量赋予正确的初始值。过程大概就是收集class的静态变量、静态代码块、静态方法至()方法，随后从上往下开始执行。如果「实例化对象」则会调用方法对实例变量进行初始化，并执行对应的构造方法内的代码。</li>
</ul>
</li>
<li>「解释」则是把字节码转换成操作系统可识别的执行指令，在JVM中会有字节码解释器和即时编译器。在解释时会对代码进行分析，查看是否为「热点代码」，如果为「热点代码」则触发JIT编译，下次执行时就无需重复进行解释，提高解释速度<ul>
<li>JVM会对「热点代码」做编译，非热点代码直接进行解释。当JVM发现某个方法或代码块的运行特别频繁的时候，就有可能把这部分代码认定为「热点代码」。</li>
<li>使用「热点探测」来检测是否为热点代码。「热点探测」一般有两种方式，计数器和抽样。HotSpot使用的是「计数器」的方式进行探测，为每个方法准备了两类计数器：方法调用计数器和回边计数器。这两个计数器都有一个确定的阈值，当计数器超过阈值溢出了，就会触发JIT编译。即时编译器把热点方法的指令码保存起来，下次执行的时候就无需重复的进行解释，直接执行缓存的机器语言。</li>
</ul>
</li>
<li>「执行」 操作系统把解释器解析出来的指令码，调用系统的硬件执行最终的程序指令。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>双亲委派模型</strong></p>
<ul>
<li>上次提到了：class文件是通过「类加载器」装载至JVM中的，为了防止内存中存在多份同样的字节码，使用了双亲委派机制（它不会自己去尝试加载类，而是把请求委托给父加载器去完成，依次向上）</li>
<li>JDK 中的本地方法类一般由根加载器（Bootstrp loader）装载，内部实现的扩展类一般由扩展加载器（ExtClassLoader）实现装载，而程序中的类文件则由系统加载器（AppClassLoader）实现装载。<br>  AppClassLoader的父加载器为Ext ClassLoader、Ext ClassLoader的父加载器为BootStrap ClassLoader。这里的父子关系并不是通过继承实现的，而是组合。</li>
<li>打破双亲委派机制：自定义ClassLoader，重写loadClass方法（只要不依次往上交给父加载器进行加载，就算是打破双亲委派机制） </li>
<li>打破双亲委派机制案例：Tomcat<ul>
<li>为了Web应用程序类之间隔离，为每个应用程序创建WebAppClassLoader类加载器</li>
<li>为了Web应用程序类之间共享，把ShareClassLoader作为WebAppClassLoader的父类加载器，如果WebAppClassLoader加载器找不到，则尝试用ShareClassLoader进行加载</li>
<li>为了Tomcat本身与Web应用程序类隔离，用CatalinaClassLoader类加载器进行隔离和加载Tomcat本身的类</li>
<li>为了Tomcat与Web应用程序类共享，用CommonClassLoader作为CatalinaClassLoader和ShareClassLoader的父类加载器</li>
<li>ShareClassLoader、CatalinaClassLoader、CommonClassLoader的目录可以在Tomcat的catalina.properties进行配置   <img src="https://leo710aka.github.io/bk/job6.png" width="450" height="300" alt=""></li>
</ul>
</li>
<li>线程上下文加载器：由于类加载的规则，很可能导致父加载器加载时依赖子加载器的类，导致无法加载成功（BootStrap ClassLoader无法加载第三方库的类），所以存在「线程上下文加载器」来进行加载。 ？？？</li>
</ul>
</li>
<li><p>JVM的内存结构？ <a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv25819369/?spm_id_from=333.999.0.0&jump_opus=1">https://www.bilibili.com/read/cv25819369/?spm_id_from=333.999.0.0&amp;jump_opus=1</a></p>
<ul>
<li>前面提到了：class文件会被类加载器装载至JVM中，并且JVM会负责程序「运行时」的「内存管理」。而JVM的内存结构，往往指的就是JVM定义的「运行时数据区域」。简单来说就分为了5大块：方法区、堆、程序计数器、虚拟机栈、本地方法栈</li>
<li>要值得注意的是：这是JVM「规范」的分区概念，到具体的实现落地，不同的厂商实现可能是有所区别的。 </li>
<li><strong>程序计数器</strong>：线程切换意味着「中断」和「恢复」，那自然就需要有一块区域来保存「当前线程的执行信息」。所以，程序计数器就是用于记录各个线程执行的字节码的地址（分支、循环、跳转、异常、线程恢复等都依赖于计数器）</li>
<li><strong>虚拟机栈</strong>：每个线程在创建的时候都会创建一个「虚拟机栈」，每次方法调用都会创建一个「栈帧」。每个「栈帧」会包含几块内容：局部变量表、操作数栈、动态连接和返回地址。它的作用：它保存方法的局部变量、部分变量的计算并参与了方法的调用和返回。</li>
<li><strong>本地方法栈</strong>：本地方法栈跟虚拟机栈的功能类似，虚拟机栈用于管理 Java 函数的调用，而本地方法栈则用于管理本地方法的调用。这里的「本地方法」指的是「非Java方法」，一般本地方法是使用C语言实现的。</li>
<li><strong>方法区</strong>：在HotSpot虚拟机，就会常常提到「永久代」这个词，「JDK8前」用「永久代」实现了「方法区」，而很多其他厂商虚拟机其实是没有「永久代」的概念的。JDK8中，已经用「元空间」来替代了「永久代」作为「方法区」的实现了<ul>
<li>方法区主要是用来存放已被虚拟机加载的「类相关信息」：包括类信息、常量池<br>  类信息又包括了类的版本、字段、方法、接口和父类等信息。<br>  常量池又可以分「静态常量池」和「运行时常量池」<ul>
<li>静态常量池主要存储的是「字面量」以及「符号引用」等信息，也包括了我们说的「字符串常量池」。</li>
<li>运行时常量池存储的是「类加载」时生成的「直接引用」等信息。</li>
</ul>
</li>
<li>又值得注意的是：从「逻辑分区」的角度而言「常量池」是属于「方法区」的。但自从在「JDK7」以后，就已经把「运行时常量池」和「静态常量池」转移到了「堆」内存中进行存储（对于「物理分区」来说「运行时常量池」和「静态常量池』就属于堆）</li>
<li>从「JDK8」已经把「方法区」的实现从「永久代」变成「元空间」，有什么区别？<br>  最主要的区别就是：「元空间」存储不在虚拟机中，而是使用本地内存，JVM 不会再出现方法区的内存溢出，以往「永久代」经常因为内存不够用导致跑出OOM异常。按JDK8版本，总结起来其实就相当于：「类信息」是存储在「元空间」的（也有人把「类信息」这块叫做「类信息常量池」，主要是叫法不同，意思到位就好）。而「常量池」用JDK7开始，从「物理存储」角度上就在「堆中」，这是没有变化的。</li>
</ul>
</li>
<li><strong>堆</strong>：堆是线程共享的区域，几乎类的实例和数组分配的内存都来自于它。「堆」被划分为「新生代」和「老年代」，「新生代」又被进一步划分为 Eden 和 Survivor 区，最后 Survivor 由 From Survivor 和 To Survivor 组成。将「堆内存」分开了几块区域，主要跟「内存回收」有关（垃圾回收机制）</li>
</ul>
</li>
<li><p>java的对象是怎么被回收的？<a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv25951929/?spm_id_from=333.999.0.0&jump_opus=1">https://www.bilibili.com/read/cv25951929/?spm_id_from=333.999.0.0&amp;jump_opus=1</a></p>
</li>
<li><p>CMS垃圾收集器 <a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv26111304/?spm_id_from=333.999.0.0&jump_opus=1">https://www.bilibili.com/read/cv26111304/?spm_id_from=333.999.0.0&amp;jump_opus=1</a></p>
</li>
<li><p>G1垃圾收集器 <a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv26352521/?spm_id_from=333.999.0.0&jump_opus=1">https://www.bilibili.com/read/cv26352521/?spm_id_from=333.999.0.0&amp;jump_opus=1</a></p>
</li>
<li><p>JVM调优到底是干啥的？</p>
<ul>
<li>我们一般优化系统的思路是这样的：<ol>
<li>一般来说关系型数据库是先到瓶颈，首先排查是否为数据库的问题（这个过程中就需要评估自己建的索引是否合理、是否需要引入分布式缓存、是否需要分库分表等等）</li>
<li>然后，我们会考虑是否需要扩容（横向和纵向都会考虑）（这个过程中我们会怀疑是系统的压力过大或者是系统的硬件能力不足导致系统频繁出现问题）</li>
<li>接着，应用代码层面上排查并优化（扩容是不能无止境的，里头里外都是钱阿。这个过程中我们会审视自己写的代码是否存在资源浪费的问题，又或者是在逻辑上可存在优化的地方，比如说通过并行的方式处理某些请求）</li>
<li>再接着，JVM层面上排查并优化（审视完代码之后，这个过程我们观察JVM是否存在多次GC问题等等）</li>
<li>最后，网络和操作系统层面排查（这个过程查看内存&#x2F;CPU&#x2F;网络&#x2F;硬盘读写指标是否正常等等）</li>
</ol>
</li>
<li>绝大多数情况下到第三步就结束了，一般经过「运维团队」给我们设置的JVM和机器上的参数已经满足绝大多数的需求了。</li>
<li>在我的理解下，调优JVM其实就是在「理解」JVM内存结构以及各种垃圾收集器前提下，结合自己的现有的业务来「调整参数」，使自己的应用能够正常稳定运行。一般调优JVM我们认为会有几种指标可以参考：『吞吐量』、『停顿时间』和『垃圾回收频率』。基于这些指标，我们就有可能需要调整：<ol>
<li>内存区域大小以及相关策略（比如整块堆内存占多少、新生代占多少、老年代占多少、Survivor占多少、晋升老年代的条件等等）比如（-Xmx：设置堆的最大值、-Xms：设置堆的初始值、-Xmn：表示年轻代的大小、-XX:SurvivorRatio：伊甸区和幸存区的比例等等）（按经验来说：IO密集型的可以稍微把「年轻代」空间加大些，因为大多数对象都是在年轻代就会灭亡。内存计算密集型的可以稍微把「老年代」空间加大些，对象存活时间会更长些）</li>
<li>垃圾回收器（选择合适的垃圾回收器，以及各个垃圾回收器的各种调优参数）比如（-XX:+UseG1GC：指定 JVM 使用的垃圾回收器为 G1、-XX:MaxGCPauseMillis：设置目标停顿时间、-XX:InitiatingHeapOccupancyPercent：当整个堆内存使用达到一定比例，全局并发标记阶段 就会被启动等等）<br>  没错，这些都是因地制宜，具体问题具体分析（前提是得懂JVM的各种基础知识，基础知识都不懂，谈何调优）</li>
</ol>
</li>
<li>一般我们是「遇到问题」之后才进行调优的，而遇到问题后需要利用各种的「工具」进行排查<ol>
<li>通过jps命令查看Java进程「基础」信息（进程号、主类）。这个命令很常用的就是用来看当前服务器有多少Java进程在运行，它们的进程号和加载主类是啥</li>
<li>通过jstat命令查看Java进程「统计类」相关的信息（类加载、编译相关信息统计，各个内存区域GC概况和统计）。这个命令很常用于看GC的情况</li>
<li>通过jinfo命令来查看和调整Java进程的「运行参数」。</li>
<li>通过jmap命令来查看Java进程的「内存信息」。这个命令很常用于把JVM内存信息dump到文件，然后再用MAT( Memory Analyzer tool 内存解析工具)把文件进行分析</li>
<li>通过jstack命令来查看JVM「线程信息」。这个命令用常用语排查死锁相关的问题</li>
<li>还有近期比较热门的Arthas（阿里开源的诊断工具），涵盖了上面很多命令的功能且自带图形化界面。</li>
</ol>
</li>
<li>JVM的JIT优化技术：比较出名的有两种：方法内联和逃逸分析<br>  所谓方法内联就是把「目标方法」的代码复制到「调用的方法」中，避免发生真实的方法调用<br>  因为每次方法调用都会生成栈帧（压栈出栈记录方法调用位置等等）会带来一定的性能损耗，所以「方法内联」的优化可以提高一定的性能。在JVM中也有相关的参数给予我们指定（-XX:MaxFreqInlineSize、-XX:MaxInlineSize）<br>  而「逃逸分析」则是判断一个对象是否被外部方法引用或外部线程访问的分析技术，如果「没有被引用」，就可以对其进行优化，比如说：<ol>
<li>锁消除（同步忽略）：该对象只在方法内部被访问，不会被别的地方引用，那么就一定是线程安全的，可以把锁相关的代码给忽略掉</li>
<li>栈上分配：该对象只会在方法内部被访问，直接将对象分配在「栈」中（Java默认是将对象分配在「堆」中，是需要通过JVM垃圾回收期进行回收，需要损耗一定的性能，而栈内分配则快很多）</li>
<li>标量替换&#x2F;分离对象：当程序真正执行的时候可以不创建这个对象，而直接创建它的成员变量来代替。将对象拆分后，可以分配对象的成员变量在栈或寄存器上，原本的对象就无需分配内存空间了</li>
</ol>
</li>
</ul>
</li>
<li><p>怎么理解Java多线程？  <a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv22973356/?spm_id_from=333.999.0.0&jump_opus=1">https://www.bilibili.com/read/cv22973356/?spm_id_from=333.999.0.0&amp;jump_opus=1</a></p>
</li>
<li><p>Java内存模型？ Java3y <a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv24200309/?spm_id_from=333.999.0.0&jump_opus=1">https://www.bilibili.com/read/cv24200309/?spm_id_from=333.999.0.0&amp;jump_opus=1</a></p>
</li>
</ul>
<h2 id="八股（Spring）"><a href="#八股（Spring）" class="headerlink" title="八股（Spring）"></a>八股（Spring）</h2><ul>
<li><p>SpringMVC 流程<br>？？<a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv26597569/?spm_id_from=333.999.0.0&jump_opus=1">https://www.bilibili.com/read/cv26597569/?spm_id_from=333.999.0.0&amp;jump_opus=1</a></p>
<img src="https://leo710aka.github.io/bk/job2.png" width="750" height="300" alt="">
</li>
<li><p>SpringMvc的service层为什么用的是接口？为什么不直接使用实现类？？<br>  Service 层负责处理业务逻辑、调用数据访问层（DAO，Data Access Object）并与控制器层进行交互。使用接口而不是直接使用实现类呢，这主要有以下几个原因：</p>
<ol>
<li>解耦和可扩展性：使用接口将 Service 层与其实现类解耦。通过面向接口编程，控制器（或其他类）可以只依赖于接口而不是具体的实现类。这样使得代码更加灵活，能够轻松切换不同的实现类或者模拟测试用的虚拟实现。</li>
<li>单一职责原则：接口定义了 Service 层的契约和行为，实现类负责具体的逻辑实现。这符合单一职责原则，即一个类应该只负责一项职责。</li>
<li>测试和模拟：？？接口的使用使得单元测试更加容易。在测试时，可以使用模拟实现来替代真正的实现类，从而更好地进行单元测试。通过模拟，可以控制和验证不同的行为，而无需依赖于底层实现细节。</li>
<li>依赖注入：？？Spring 容器能够通过依赖注入将接口的实现类注入到需要的地方，而不需要直接关注具体的实现细节。</li>
</ol>
</li>
<li><p>切换一个接口下的不同的实现类有什么意义？为什么不直接使用不同的实现类？</p>
<ol>
<li>灵活性和可维护性：使用接口定义规范可以提高代码的灵活性。通过面向接口编程，可以将调用方与具体实现类解耦，使得代码更易于维护和修改。如果后续需要替换实现类或引入新的实现，只需要修改实现类的绑定，而不需要修改调用方的代码。</li>
<li>解耦和依赖注入：接口的使用支持依赖注入，使得系统更易于管理和测试。依赖注入能够减少类之间的耦合度，提高了代码的可测试性，有利于单元测试和模拟测试。</li>
<li>扩展性和适应性：使用接口和不同的实现类使得系统更具扩展性。根据不同的需求和场景，可以轻松地切换实现类，使得系统更具适应性和灵活性。</li>
<li>遵循设计原则：使用接口遵循了面向对象编程的设计原则，如开闭原则（对扩展开放，对修改关闭）、单一职责原则等。这种设计模式使得代码更清晰、更易于理解和维护。</li>
</ol>
</li>
</ul>
<ul>
<li>Spring IOC<br>  Spring IOC 解决的是对象管理和对象依赖的问题。IOC容器可以理解为一个对象工厂，我们都把该对象交给工厂，工厂管理这些对象的创建以及依赖关系；需要用对象的时候，从工厂里边获取就好了<ul>
<li>「控制反转」指：把原有自己掌控的事交给别人去处理。它更多的是一种思想或者可以理解为设计模式。比如：本来由我们自己new出来的对象，现在交由IOC容器，把对象的控制权交给它方了</li>
<li>「注入依赖」：是「控制反转」的实现方式，对象无需自行创建或者管理它的依赖关系，依赖关系将被「自动注入」到需要它们的对象当中去</li>
<li>用Spring IOC有什么好处吗？主要在于「将对象集中统一管理」并且「降低耦合度」<br>  如果项目里的对象都是就new下就完事了，没有多个实现类，那没事，不用Spring也没啥问题。但 Spring核心不仅仅IOC啊，除了把对象创建出来，还有一整套的Bean生命周期管理。用Spring IOC 可以方便 单元测试、对象创建复杂、对象依赖复杂、单例等等的，什么都可以交给Spring IOC</li>
<li>你们项目一般是怎么把对象交给IOC容器管理的？换个问法：一般是怎么定义Bean的？<br>  Spring提供了4种方式，分别是：1):注解 2):XML 3):JavaConfig 4):基于Groovy DSL配置<br>  日常写业务代码一般用注解来定义各种对象，责任链这种一般配置在XML，「注解」解决不了的就用JavaConfig。反正就是定义元数据，能给到Spring解析就好了</li>
</ul>
</li>
</ul>
<ul>
<li><p>Spring AOP<br>Spring AOP 解决的是 非业务代码抽取的问题。<br>？？？AOP 底层的技术是动态代理，在Spring内实现依赖的是BeanPostProcessor<br>比如我们需要在方法上注入些「重复性」的非业务代码，就可以利用Spring AOP。所谓「面向切面编程」在我理解下其实就是在方法前后增加非业务代码 </p>
<img src="https://leo710aka.github.io/bk/job3.png" width="550" height="300" alt="">
</li>
<li><p>说说SpringBean生命周期原理？<br>？？</p>
<img src="https://leo710aka.github.io/bk/job4.png" width="650" height="300" alt="">

</li>
<li><p>说说SpringBoot自动配置。<br>SpringBoot有着“约定大于配置”的理念，这一理念一定程度上可以用“SpringBoot自动配置”来解释。<br>在使用SpringBoot的时候，肯定会依赖于autoconfigure这么一个包？？<br>autoconfigure这个包里会有一个spring.factories文件，该文件定义了100+个入口的配置类。比如我们经常使用的redis、kafka等等这样常见的中间件都预置了配置类。当我们在启动SpringBoot项目的时候，内部就会加载这个spring.factories文件，进而去加载“有需要”的配置类。那我们在使用相关组件的时候，就会非常的方便（因为配置类已经初始化了一大部分配置信息）。一般我们只要在application配置文件写上对应的配置，就能通过各种template类直接操作对应的组件啦。<br>不是所有的配置类都会加载的，假设我们没有引入redis-starter的包，那Redis的配置类就不会被加载。具体Spring在实现的时候就是使用<code>@ConditionalXXX</code>进行判断的。比如Redis的配置类就会有@ConditionalOnClass({RedisOperations.class})的配置，说明当前环境下如果有RedisOperations.class这个字节码，才会去加载Redis的配置类。？？</p>
</li>
<li><p>你对SpringBoot starter的理解？<br>starter这东西就是为了方便调用方去使用相关的组件的嘛，Spring框架也给我们实现了很多好用的starter。<br>比如以前我们要用Mybatis框架，可能会引入各种的包才能使用。而starter就是做了一层封装，把相关要用到的jar都给包起来了，并且也写好了对应的版本。这我们使用的时候就不需要引入一堆jar包且管理版本类似的问题了。<br>最后聊下你是怎么看这块源码的？？思路：我先从启动类开始，会有个@SpringBootApplication，后面会定位到一个自动配置的注解@EnableAutoConfiguration，那最后就能看到注解内部会去META-INF&#x2F;spring.factories加载配置类</p>
</li>
</ul>
<h2 id="八股（MyBatis）"><a href="#八股（MyBatis）" class="headerlink" title="八股（MyBatis）"></a>八股（MyBatis）</h2><p><a target="_blank" rel="noopener" href="https://leo710aka.github.io/2022/03/11/Mysql/">https://leo710aka.github.io/2022/03/11/Mysql/</a></p>
<ul>
<li><p>MyBatis。有没有完整地学习过一个框架？以及其他框架？<br>MyBatis（以前称为iBatis）是一个开源的<strong>Java持久层框架</strong>，用于将对象与关系数据库的表之间进行映射。MyBatis 通过 XML 或注解配置文件描述 Java 对象与数据库之间的映射关系，并提供了一些方便的查询语言（类似于SQL）来进行数据库操作。<br>JDBC（Java Database Connectivity）是 Java 语言用于与关系型数据库进行交互的一种标准接口。JDBC 提供了一组 Java API，允许开发者通过 Java 代码来执行 SQL 查询、更新数据库、以及处理数据库事务等操作。</p>
</li>
<li><p>Mybatis是怎么分页的？<br>  逻辑分页：先查出数据，如何自己编写逻辑实现分页；物理分页：使用mysql提供的分页关键词limit<br>  Mybatis提供了 3 种分页方式：</p>
<ol>
<li>mybatis mapper配置文件写分页sql，直接在select语句里面加limit</li>
<li>？？使用mybatis提供的RowBounds对象，实现内存级的分页</li>
<li>？？基于mybatis中的Interceptor拦截器，在select语句执行之前动态拼接分页关键字</li>
</ol>
</li>
<li><p>#{} 与 ${} 的区别？<br>  两种占位符，都是实现动态sql的方式，可以把参数传递到xml中，执行操作前，mybatis会对这两个占位符进行动态解析</p>
<ol>
<li><strong><code>#&#123;&#125;</code>（预编译）</strong>：<code>#&#123;&#125;</code> 是 MyBatis 的预处理语法，会在 SQL 中使用占位符 <code>?</code> 的形式，通过预编译的方式来处理参数，可以有效防止 SQL 注入攻击。使用 <code>#&#123;&#125;</code> 时，MyBatis 会将传入的参数值转义并进行预编译，同时会根据参数的类型决定使用不同的 JDBC 类型。这种方式可以确保 SQL 的安全性。</li>
<li><strong><code>$&#123;&#125;</code>（拼接字符串）</strong>：<code>$&#123;&#125;</code> 是 MyBatis 的字符串替换语法，会直接将传入的参数值以字符串的形式拼接到 SQL 语句中。使用 <code>$&#123;&#125;</code> 时，需要注意潜在的 SQL 注入风险，因为参数值会直接替换到 SQL 语句中，不会进行预编译。</li>
<li><code>#&#123;&#125;</code> 适用于参数值，防止 SQL 注入，用于预编译。<code>$&#123;&#125;</code> 适用于非参数值，直接将参数值拼接到 SQL 语句中。在开发中，推荐使用 <code>#&#123;&#125;</code> 来处理参数，以保障 SQL 的安全性。<code>$&#123;&#125;</code> 的使用应谨慎，尽量避免直接将用户输入的数据用于 <code>$&#123;&#125;</code> 形式的参数。</li>
</ol>
</li>
</ul>
<h2 id="八股（MySQL）"><a href="#八股（MySQL）" class="headerlink" title="八股（MySQL）"></a>八股（MySQL）</h2><p><a target="_blank" rel="noopener" href="https://leo710aka.github.io/2022/03/11/Mysql/">https://leo710aka.github.io/2022/03/11/Mysql/</a></p>
<ul>
<li><p>SQL 注入的原理和类型<br>1、恶意拼接查询 2、利用注释执行非法命令 3、传入非法参数 4、添加额外条件<br>如何避免 SQL 注入 ？<br>1、过滤输入内容，校验字符串：在数据提交到数据库之前，就把用户输入中的不合法字符剔除掉。<br>2、参数化查询：参数化查询目前被视作是预防 SQL 注入攻击最有效的方法。指在设计与数据库连接并访问数据时，在需要填入数值或数据的地方，使用参数（Parameter）来给值。</p>
</li>
<li><p>存储引擎。</p>
<ul>
<li>？？</li>
<li>MyISAM 和 InnoDB 有什么区别？<br>  （1）InnoDB 支持行级别的锁粒度，MyISAM 不支持，只支持表级别的锁粒度。<br>  （2）MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别。<br>  （3）MyISAM 不支持外键，而 InnoDB 支持。<br>  （4）MyISAM 不支持 MVCC，而 InnoDB 支持。<br>  （5）虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。<br>  （6）MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。<br>  （7）InnoDB 的性能比 MyISAM 更强大。</li>
</ul>
</li>
<li><p>索引。</p>
<ul>
<li>在 MySQL 中，索引是一种特殊的数据结构，用于加快数据库表中数据的检索速度。索引在数据库表中的一个或多个列上创建，可以将这些列的值快速映射到实际数据的物理位置。</li>
<li>聚集索引，非聚集索引，主键？<ul>
<li>聚集索引：在MySQL中，聚集索引决定了数据在磁盘上的物理存储顺序，即数据的存储顺序与索引顺序一致。在InnoDB存储引擎中，主键索引就是一个聚集索引。如果表没有显式定义主键，则InnoDB会选择一个唯一非空的索引来充当聚集索引。</li>
<li>非聚集索引：非聚集索引在磁盘上维护索引键和对应数据行的引用，索引键的顺序与实际数据行的物理存储顺序无关。在MySQL中，除了InnoDB存储引擎的聚集索引（主键索引），其他索引都是非聚集索引，例如普通索引或唯一索引。</li>
<li>主键：主键是一种用于唯一标识表中每一行数据的列或列组合。主键列的值必须唯一且不为空（NULL）。在InnoDB中，主键索引是表的物理排序顺序，它是表的聚集索引。如果表没有显式定义主键，InnoDB会选择一个合适的唯一非空索引来充当主键索引。</li>
</ul>
</li>
<li>B+ Tree(InnoDB)索引<ul>
<li>数据分块存储，每一块称为一页。所有的值都是按顺序存储的，并且每一个叶子到根的距离相同。</li>
<li>非叶节点存储数据的边界，叶子节点存储指向数据行的指针。通过边界缩小数据的范围，从而避免全表扫描，加快了查找的速度。</li>
<li>B+ 树索引是一种索引结构，通常用于数据库管理系统中作为数据的索引方式。它可以用作聚集索引或非聚集索引，并不是严格意义上的主键索引。在数据库中，B+树索引在不同存储引擎下，例如在InnoDB中作为主键索引（聚集索引）使用，或作为其他索引（非聚集索引）的实现。  <img src="https://leo710aka.github.io/bk/job5.png" width="550" height="300" alt=""></li>
</ul>
</li>
<li>为什么 MySQL 的索引要使用 B+ 树而不是其它树形结构？<br>  1、B+树能显著减少IO次数，提高效率。因为 B 树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致 IO 操作变多，查询性能变低。<br>  2、B+树的查询效率更加稳定。因为数据放在叶子节点。<br>  3、B+树能提高范围查询的效率。因为叶子节点指向下一个叶子节点。</li>
<li>MySQL 索引失效的几种情况<br>  1、有 or 必全有索引。要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引。 2、复合索引未用左列字段。对于复合索引，如果不使用前列，后续列也将无法使用。 3、like以%开头;  4、需要类型转换。存在索引列的数据类型隐形转换，则用不上索引。 5、where中索引列有数学运算。 6、where中索引列使用了函数。 7、如果mysql觉得全表扫描更快时（数据少）。</li>
</ul>
</li>
<li><p>联合索引（Composite Index）<br>  也称为复合索引，是指同时包含多个列的索引，它可以更加精确地定位数据，提高查询的效率。<br>  通常情况下，一个表中可能存在多个需要经常用于查询的列，使用联合索引可以将这些列组合起来，建立一个复合索引。在查询时，如果查询条件同时包含联合索引中的多个列，数据库可以直接使用索引定位到符合条件的行，避免了全表扫描，提高了查询效率。<br>  需要注意的是，在使用联合索引时，需要考虑索引的顺序。通常情况下，应该将最常用于查询的字段放在索引的前面，这样可以更加有效地利用索引。另外，联合索引也存在一些限制。由于索引是按照索引列的顺序建立的，因此只有在查询条件中包含索引的最左侧的列时，MySQL 才能利用这个索引。如果查询条件中包含的列不是索引的最左侧列，那么 MySQL 就无法使用这个索引。<br>  此外，由于联合索引包含多个列，因此其维护成本也相对较高。如果经常更新其中一个列的值，可能会导致索引的重建，影响数据库的性能。因此，在建立联合索引时，应该根据具体的应用场景，权衡利弊，避免滥用。</p>
<ul>
<li>如何使用联合索引？<br>  1、联合索引的最左前缀匹配指的是where条件一定要有联合索引的第一个字段<br>  2、是否走联合索引与where条件的顺序无关，只与字段有关</li>
<li>联合索引的最左前缀匹配原则<br>  最左前缀匹配原则指的是，在使用联合索引时，MySQL 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询（如 &gt;、&lt;）才会停止匹配。对于 &gt;&#x3D;、&lt;&#x3D;、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配。所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。</li>
<li>联合索引的作用？<br>  1、减少io操作的开销和磁盘空间的开销；<br>  2、提升性能。索引列越多，通过索引筛选出的数据越少。<br>  3、覆盖索引。直接通过遍历索引取得数据，无需回表。<br>  提高查询效率：联合索引可以加速对多列数据的查询，对于联合索引中包含的列，可以同时使用它们进行筛选，减少了查询的数据量，提高了查询效率。<br>  减少磁盘IO：联合索引可以将多个列的数据存储在一起，减少了需要读取的磁盘块数，从而降低了IO的开销。<br>  优化排序操作：如果查询需要按照联合索引中的多个列进行排序，联合索引可以避免对多个独立索引的排序操作，从而提高排序操作的效率</li>
</ul>
</li>
<li><p>MySQL 单表为什么不要超过 2千万条 时最优？</p>
<ul>
<li>查询性能：随着数据量的增加，查询可能变得更慢，特别是在没有合适索引支持的情况下。大表需要更多的计算资源和时间来处理查询，可能导致性能下降。</li>
<li>索引和缓存：维护大表的索引和缓存可能会变得更加困难。索引的大小随着数据量的增加而增加，这可能导致索引扫描变慢，同时也会增加对内存的需求。<br>  1、一个高度为 3 的 B+ 树可以存放： 1170X1170X16&#x3D;21902400 条这样的记录,即2千万多些，通过主键查询一条数据，只需要3次磁盘IO访问，当超出2千万条时，索引树高度为4。<br>  2、mysql都有缓存，树高度为3时，第一层和第二层的数据都在缓存，高度为3查询效率很快，但是超过高度4时，查询效率就急速下降了。</li>
<li>锁和并发：在执行更新或删除操作时，数据库可能需要对表进行锁定，以确保数据的一致性。大表的锁定可能会阻塞其他操作，影响并发性能。</li>
</ul>
</li>
<li><p>分表？</p>
<ul>
<li>分表是一种应对大表数据量的常见方法。通过将大表拆分为多个小表（分区），可以减轻数据库管理系统的负担，提高查询性能和管理效率。分表可以根据业务逻辑或特定的列值进行拆分，例如按时间范围、地理区域等方式进行分区。</li>
<li>在考虑分表之前，建议进行以下操作：<br>  优化查询和索引：确保数据库表有适当的索引来支持常见的查询，并优化查询语句以提高性能。<br>  垂直和水平分割：考虑将大表进行垂直切分（按列拆分）或水平切分（按行拆分）以减少单个表的数据量。<br>  使用分区：针对数据库支持的分区功能，可以考虑根据特定的标准将表分成多个逻辑分区。<br>  数据库优化：定期清理无用数据、重新构建索引、优化数据库配置等，以提高数据库的整体性能。</li>
</ul>
</li>
<li><p>事务。</p>
<ul>
<li>事务的特性：原子性、一致性、隔离性、持久性</li>
<li>事务的隔离性<br>  1、并发异常:第一类丢失更新、第二类丢失更新脏读、不可重复读、幻读<br>  2、隔离级别: Read Uncommitted、Read Conmitted、Repeatable Read、Serializable</li>
<li>Spring事务管理：声明式事务、编程式事务</li>
</ul>
</li>
<li><p>锁</p>
<ul>
<li>范围<br>  表级锁：开销小、加锁快，，发生锁冲突的概率高、并发度低，不会出现死锁<br>  行级锁：开销大、加锁慢，发生锁冲突的概率低、并发度高，会出现死锁</li>
<li>类型 (InnoDB)<br>  共享锁 (s) : 行级，读取一行<br>  排他锁 (x) : 行级，更新一行<br>  意向共享锁 (IS): 表级，准备加共享锁<br>  意向排他锁 (Ix) : 表级，准备加排他锁<br>  间隙锁 (NK) : 行级，使用范围条件时</li>
<li>对范围内不存在的记录加锁。一是为了防止幻读，二是为了满足恢复和复制的需要</li>
<li>加锁<br>  增加行级锁之前，InnoDB会自动给表加意向锁<br>  执行DML语句时，InnoDB会自动给数据加排他锁<br>  执行DQL语句时<ul>
<li>共享锁 (s) :SELECT … FROM … WHERE … LOCK IN SHARE MODE</li>
<li>排他锁 (x) :SELECT … FROM … WHERE … FOR UPDATE;</li>
<li>间隙锁 (NK) : 上述sQ采用范围条件时，InnoDB对不存在的记录自动增加间隙锁</li>
</ul>
</li>
<li>死锁</li>
<li>悲观锁</li>
<li>乐观锁</li>
</ul>
</li>
<li><p>范式。</p>
</li>
<li><p>存储过程。</p>
</li>
</ul>
<h2 id="八股（Redis）"><a href="#八股（Redis）" class="headerlink" title="八股（Redis）"></a>八股（Redis）</h2><ul>
<li><p>为什么要用Redis？<br>无论Redis、MySQL、HDFS、HBase都是存储数据的地方，因为设计理念的不同，我们会根据不同的应用场景使用不同的存储。<br>像Redis一般我们会把它用作于缓存（当然，日常有的应用场景比较简单，用个HashMap也能解决很多的问题了<br>为什么Redis可以这么快？首先，它是纯内存操作，内存本身就很快。其次，它是单线程的，Redis服务器核心是基于非阻塞的IO多路复用机制，单线程避免了多线程的频繁上下文切换问题</p>
</li>
<li><p>Redis持久化。<br>Redis是基于内存的，假设不做任何操作，只要Redis服务器重启（或者中途故障挂掉了）那内存的数据就会没掉<br>所以Redis提供了持久化机制给我们用，分别是RDB和AOF<br>RDB指的就是：根据我们自己配置的时间或者手动去执行BGSAVE或SAVE命令，Redis就会去生成RDB文件。这个RDB文件实际上就是一个经过压缩的二进制文件，Redis可以通过这个文件在启动的时候来还原我们的数据<br>AOF则是：把Redis服务器接收到的所有写命令都记录到日志中。Redis重跑一遍这个记录下的日志文件，就相当于还原了数据<br><a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv28294981/?spm_id_from=333.999.0.0&jump_opus=1">https://www.bilibili.com/read/cv28294981/?spm_id_from=333.999.0.0&amp;jump_opus=1</a></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>key</th>
<th>string</th>
<th>hash</th>
<th>list</th>
<th>set</th>
<th>sorted set</th>
<th>bitmap</th>
<th>hyperloglog</th>
</tr>
</thead>
<tbody><tr>
<td>最大存储数据量</td>
<td>512M</td>
<td>512M</td>
<td>2^32 - 1</td>
<td>2^32 - 1</td>
<td>2^32 -1</td>
<td></td>
<td>512M</td>
<td>12K</td>
</tr>
</tbody></table>
<ul>
<li><p>过期策略。<br>Redis会把设置了过期时间的key放入一个独立的字典里，在key过期时并不会立刻删除它<br>Redis会通过如下两种策略，来删除过期的key:<br>1、惰性删除：客户端访问某个key时，Redis会检查该key是否过期，若过期则删除。(问题: 有些键值对,可能已经过期了,但是由于没有再被访问,导致未被删除,因而占用内存)。<br>2、定期扫描：Redis默认每秒执行10次过期扫描 (配置hz选项) ，扫描策略如下 (1). 从过期字典中随机选择20个key; (2)删除这20个key中已过期的key; (3)如果过期的key的比例超过25%，则重复步骤1</p>
</li>
<li><p>淘汰策略<br>当Redis占用内存超出最大限制(maxmemory)时，可采用如下策略(maxmemory-policy)淘汰一些数据以腾出空间继续提供读写服务:<br>noeviction：对可能导致增大内存的命令返回错误 (大多数写命令，DEL除外)<br>volatile-ttl：在设置了过期时间的key中，选择剩余寿命(TTI) 最短的key，将其淘汰<br>volatile-lru：在设置了过期时间的kev中，选择最少使用的kev (LRu) ，将其淘汰:<br>volatile-random：在设置了过期时间的key中，随机选择一些key，将其淘汰;<br>allkeys-lru：在所有的ke中，选择最少使用的key (LRu) ，将其淘汰<br>allkeys-random：在所有的key中，随机选择一些key，将其淘汰<br>(这里其实还有volatile-lfu、allkeys-lfu，所谓&#x3D;&#x3D;LFU算法&#x3D;&#x3D;，就是先考虑键值对访问的次数，优先淘汰访问次数少的键值对，对于访问次数相同的键值对，再选择最近久未被访问的键值对进行淘汰(也就是LRU算法))<br>LRU算法：维护一个链表，用于顺序存储被访问过的key。在访问数据时，最新访问过的kev将被移动到表头, 即最近访问的key在表头，最少访问的key在表尾。</p>
</li>
<li><p>缓存穿透<br>场景：查询根本不存在的数据，使得请求直达存储层导致其负载过大，甚至宕机。<br>解决方案：<br>1、缓存空对象：存储层未命中后，仍然将空值存入缓存层。再次访问该数据时，缓存层会直接返回空值<br>2、布隆过滤器：将所有存在的key提前存入布隆过滤器，在访问缓存层之前，先通过过滤器拦截，若请求的是不存在的key，则直接返回空值.</p>
</li>
<li><p>缓存击穿<br>场景：一份热点数据，它的访问量非常大。在其缓存失效瞬间，大量请求直达存储层，导致服务崩溃<br>解决方案：<br>1、加互斥锁：对数据的访问加互斥锁，当一个线程访问该数据时，其他线程只能等待这个线程访问过后，缓存中的数据将被重建，届时其他线程就可以直接从缓存取值.<br>2、永不过期：不设置过期时间，所以不会出现上述问题，这是“物理”上的不过期。为每个value设置逻辑过期时间，当发现该值逻辑过期时，使用单独的线程重建缓存.</p>
</li>
<li><p>缓存雪崩<br>场景：由于某些原因，缓存层不能提供服务，导致所有的请求直达存储层，造成存储层宕机。<br>解决方案：<br>1、避免同时过期：设置过期时间时，附加一个随机数，避免大量的key同时过期.<br>2、构建高可用的Redis缓存：部署多个Redis实例，个别节点宕机，依然可以保持服务的整体可用。<br>3、构建多级缓存：增加本地缓存，在存储层前面多加一级屏障，降低请求直达存储层的几率<br>4、启用限流和降级措施：对存储层增加限流措施，当请求超出限制时，对其提供降级服务。</p>
</li>
<li><p>？？Redis 多节点部署主要有以下几种方式：</p>
</li>
</ul>
<ol>
<li>主从复制（Master-Slave Replication）：主从复制是 Redis 的基本高可用性架构。一个 Redis 主节点可以拥有多个从节点，主节点负责写操作和同步数据到从节点，从节点负责复制主节点的数据。当主节点不可用时，可以选择一个从节点提升为主节点，实现故障切换。</li>
<li>哨兵模式（Redis Sentinel）：Redis Sentinel 是用于监控 Redis 实例并支持自动故障转移的组件。它可以监控多个 Redis 主从复制集群，当主节点不可用时，自动将一个从节点晋升为新的主节点，保证服务的可用性。哨兵模式提供了更强大的故障检测和自动切换功能。</li>
<li>集群模式（Redis Cluster）：Redis Cluster 是 Redis 提供的分布式解决方案，用于在多个节点之间分片存储数据。Redis Cluster 将数据分成多个槽（slot），每个槽可以分配给集群中的不同节点。它支持横向扩展、高可用性和自动数据分片。当集群中的某个节点不可用时，可以通过复制和重新分片来保证服务的可用性。</li>
<li>第三方解决方案：除了 Redis 官方提供的方案外，还有一些第三方解决方案可以用于构建 Redis 的多节点部署，比如一些代理软件或者中间件，它们提供了更多高级功能，比如自动负载均衡、故障转移等。</li>
</ol>
<ul>
<li>分布式锁<br>场景：修改时，经常需要先将数据读取到内存，在内存中修改后再存回去。在分布式应用中，可能多个进程同时执行上述操作，而读取和修改非原子操作，所以会产生冲突。增加分布式锁，可以解决此类问题.<br>基本原理：<br>1、同步锁：在多个线程都能访问到的地方，做一个标记，标识该数据的访问权限。<br>2、分布式锁：在多个进程都能访问到的地方，做一个标记，标识该数据的访问权限<br>实现方式：1、基于数据库实现分布式锁 2、基于Redis实现分布式锁 3、基于zookeeper实现分布式锁</li>
</ul>
<h2 id="八股（网-络）"><a href="#八股（网-络）" class="headerlink" title="八股（网 络）"></a>八股（网 络）</h2><p><a target="_blank" rel="noopener" href="https://leo710aka.github.io/2022/02/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">https://leo710aka.github.io/2022/02/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</a></p>
<ul>
<li>介绍 TCP&#x2F;IP 模型。</li>
</ul>
<h2 id="八股（操-作-系-统）"><a href="#八股（操-作-系-统）" class="headerlink" title="八股（操 作 系 统）"></a>八股（操 作 系 统）</h2><ul>
<li><p>进程与进程？</p>
</li>
<li><p>进程之间的通信如何实现？</p>
</li>
<li><p>多线程编程。</p>
</li>
<li><p>多进程与多线程有什么区别？</p>
</li>
<li><p>垃圾回收的优点和原理是什么？并考虑两种回收机制。</p>
</li>
</ul>
<hr>

<h2 id="反问"><a href="#反问" class="headerlink" title="反问"></a>反问</h2><ul>
<li><p>关于公司，岗位有什么想问的？<br>1.<strong>关于公司：</strong>“公司的核心价值观是什么？” “能否分享一下公司的发展战略和未来规划？” “公司的文化是怎样的？”<br>2.<strong>关于团队和领导：</strong> “我将会与哪些团队成员合作？” “对于这个岗位，我将直接报告给谁？””团队的工作氛围是怎样的？”<br>3.<strong>关于岗位：</strong> “这个岗位的主要职责是什么？绩效评估标准？”  “在这个岗位上，有没有机会进行培训和专业发展？”<br>4.<strong>关于工作环境：</strong>“公司对于员工的工作生活平衡看法？公司的灵活工作政策？” “关于工作场所和设施有什么特别的安排？”<br>5.<strong>关于发展机会：</strong> “公司是否鼓励内部晋升和职业发展？”  “可以谈谈员工在公司成长的例子吗？”<br>6.<strong>关于期望：</strong>“对于这个职位，你们期望新员工在短期和长期内能够做到什么？” “公司对于创新和改进有怎样的期望？”<br>7.<strong>关于团队协作：</strong>“在团队中如何促进协作和团队精神？”  “有没有定期的团队活动或培训？”<br>8.<strong>关于招聘流程：</strong>“对于这个岗位的招聘流程是怎样的？”  “预计多久会有关于我的招聘决定？”</p>
</li>
<li><p>？？你如何评价我们的面试过程？<br>1、<strong>积极、建设性的角度</strong>：强调你对面试过程的积极印象，比如面试官的专业性、问题的多样性和挑战性等。表达感激之情，感谢他们给予的机会并展现出你对公司或团队的兴趣。<br>2、<strong>注意事项和改进建议</strong>：提及你认为面试过程中可能的改进点，但要以建设性的方式提出，不要过于批评或负面。例如，可以提议增加某些技术领域的深入问题，或者更多关于公司文化和团队合作的问题，以更好地了解公司的工作环境。</p>
</li>
<li><p>？？有什么要分享给面试官的？<br>1.、<strong>展示你的准备和兴趣</strong>：提到你在公司产品、服务、项目方面的研究和了解，表现出你对公司的热情和积极性。说明你对该公司的价值观、愿景或在该领域的兴趣，并解释为什么你认为你的技能和经验与公司的需求相匹配。<br>2、<strong>自我评价和亮点</strong>：强调你认为自己最突出的技能、经验或个人特质，并解释为什么这些对公司或团队会有价值。提供具体的案例或经验，展示你的领导能力、团队合作精神、解决问题的能力等方面的优势。<br>3、<strong>职业发展展望</strong>：谈论你对未来职业发展的期望，并说明你希望在该公司或类似领域发展自己的职业生涯。表现出你对个人成长和对公司做出贡献的愿望。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/10/11/%E9%9D%A2%E8%AF%95/" data-id="clrggyur20010lkv5e9ts6jax" data-title="面 逝" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-技能" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/10/10/%E6%8A%80%E8%83%BD/" class="article-date">
  <time class="dt-published" datetime="2023-10-10T03:11:00.000Z" itemprop="datePublished">2023-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/10/10/%E6%8A%80%E8%83%BD/">寄 能</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="教育经历"><a href="#教育经历" class="headerlink" title="教育经历"></a>教育经历</h2><p><a href="mailto:&#x32;&#48;&#50;&#48;&#51;&#x30;&#x34;&#x34;&#48;&#48;&#x31;&#48;&#x40;&#109;&#x61;&#x69;&#108;&#46;&#x73;&#x63;&#117;&#x74;&#46;&#x65;&#100;&#x75;&#46;&#x63;&#110;">&#x32;&#48;&#50;&#48;&#51;&#x30;&#x34;&#x34;&#48;&#48;&#x31;&#48;&#x40;&#109;&#x61;&#x69;&#108;&#46;&#x73;&#x63;&#117;&#x74;&#46;&#x65;&#100;&#x75;&#46;&#x63;&#110;</a>    <em>2020.09 - 2024.08</em>  <strong>GPA: 3.31</strong><br><strong>主修课程：</strong>计算机网络, 操作系统, 数据结构与算法分析, C++, Java<br><strong>在校经历：</strong>曾获学校与企业奖学金，三好学生，校级”优秀公益组织骨干”等荣誉，以共同第一作者发表国际会议论文一篇（已录用）。曾加入学院青马工程班学习，担任华工青年志愿者指导中心宣传部副部长，有丰富的志愿活动和学生组织经历。<br><strong>荣誉奖项：</strong>五粮液优秀学生奖学金 (2023.10)，华南理工大学三等奖学金 (2022.09)，广东省第十一届大运会“优秀志愿者” (2022.06)，”青马工程”班”优秀学员”<br>2022—2023学年度 “三好学生”×?，校级“优秀公益组织骨干”<br>2021—2022学年度 “三好学生”，“两优两红优秀共青团员”<br><strong>语言技能：</strong>英语CET-6 <em><strong>486</strong></em> (2022.06)<br><strong><em>Publications</em>：</strong>[1] <strong>Feng Cai</strong>, Jingxu Peng, Peng Zhou, “Current Study on Image Restoration Leveraging CNNs and GANs”, 2023 International Conference on Data Science, Advanced Algorithm and Intelligent Computing (DAI 2023) (Accepted)【<em>All accepted papers will be published by Springer (ISSN: 2194-5357), and published papers will be submitted to DBLP, IET INSPEC, Crossref and Google Scholar for indexing</em>】</p>
<h2 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h2><h4 id="Java-后端方向："><a href="#Java-后端方向：" class="headerlink" title="Java 后端方向："></a>Java 后端方向：</h4><ul>
<li>熟练掌握 Java 基础，集合等相关知识，了解常见的设计模式。</li>
<li>熟悉 JVM 的垃圾回收机制、类加载机制及 Java 的内存区域。</li>
<li>熟悉 Java 并发编程，掌握JUC中常用的工具类，如 ConcurrentHashMap 等，熟悉多线程，线程池，Java 内存模型。</li>
<li>熟悉 OSI 七层模型和 TCP&#x2F; IP 四层体系分层结构，掌握常见网络协议，如 HTTP&#x2F; HTTPS、TCP、UDP、DNS等。</li>
<li>熟练使用 MySQL 数据库，熟悉 MySQL 索引、事务、存储引擎、锁机制。</li>
<li>熟悉操作系统的进程通信、死锁、内存管理等知识。了解Linux 常用命令。</li>
<li>熟悉 Redis 数据类型使用场景和内部实现，熟悉持久化和过期淘汰策略，熟悉缓存高并发场景，<br>比如缓存穿透、缓存击穿、缓存雪崩。</li>
<li>熟练使用 Spring Boot、Spring、MybatisPlus 等常用框架，熟悉 Spring IOC 、AOP 原理，了解 Nacos 、Zookeeper 等常见组件。</li>
<li>数据结构：了解常见数据结构如数组、链表、栈、队列、二叉树等;熟悉常用算法如双指针、递归、排序算法等</li>
<li>？？消息队列：熟悉 RabbitMg 的使用，了解消息可靠性的保证、死信队列、延时队列等，了解 Kafka 的基本使用</li>
<li>？？微服务：了解 SpringCloud 常用的微服务组件及其使用;如NacosRibbonFeign、HystrixGateway等</li>
</ul>
<h2 id="实习经历"><a href="#实习经历" class="headerlink" title="实习经历"></a>实习经历</h2><ul>
<li><strong>广东创世科技有限公司</strong>__Java开发工程师助理__2023.03-2023.05__广州<br><code>牙医星球小程序</code>：负责“个人中心”部分接口以及相关数据库字段的设计，实现了在线视频的弹幕功能。<br><code>广东省青少年科技创客大赛系统</code>：参与了该在线编程竞赛平台的学生端功能开发。在已有项目的基础上，编写完善了学生登录、编程题判题等方面的代码。与产品经理和前端进行了高效积极的沟通合作，能够使用 Git, Docker 协同开发。</li>
<li><strong>中国电信股份有限公司东莞分公司</strong>__IT开发工程师__2023.07-2023.08__东莞<br>参与电信AI知识库的建设，打造电信业务专家水平的对话机器人。负责测试本地知识库，完善知识云文档，以及收集资料供大<br>语言模型进行训练。此外，接触了开源项目，学习了深度学习框架。</li>
</ul>
<h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2><h4 id="论坛系统项目"><a href="#论坛系统项目" class="headerlink" title="论坛系统项目"></a><strong>论坛系统项目</strong></h4><p>一个基本功能完整的论坛项目。项目主要功能有: 基于邮件激活的注册方式，基于 MD5 加密与加盐的密码存储方式登录功能加<br>入了随机验证码的验证。实现登陆状态检查为游客与已登录用户展示不同界面与功能。支持用户上传头像，实现发布帖子、评<br>论帖子、发送私信与过滤敏感词等功能。实现了点赞，关注与系统通知功能。</p>
<ul>
<li>项⽬构建在 Spring Boot + SSM 框架之上，并统⼀的进⾏了状态管理、事务管理、异常处理；</li>
<li>利⽤ Redis 实现了点赞和关注功能，单机可达5000TPS；（对频繁需要访问的数据，如用户基本信息使用Redis作为本地缓存，提高服务器性能。采用事务管理保证数据的正确，采用“先更新数据库，再删除缓存”策略保证数据库与缓存数据的一致性；）</li>
<li>利⽤ Kafka 实现了异步的站内通知，单机可达7000TPS；（在用户被点赞、评论、关注后，放入异步队列，以系统通知的方式推送给用户）</li>
<li>利⽤ ElasticSearch 实现了全⽂搜索功能，可准确匹配搜索结果，并⾼亮显示关键词；</li>
<li>利⽤ Caffeine + Redis 实现了两级缓存，并优化了热⻔帖⼦的访问，单机可达8000QPS。</li>
<li>利⽤ Spring Security 实现了权限控制，实现了多重⻆⾊、URL级别的权限管理；</li>
<li>利⽤ HyperLogLog、Bitmap 分别实现了 UV、 DAU 的统计功能，100万⽤户数据只需*M内存空间；</li>
<li>利⽤ Quartz 实现了任务调度功能，并实现了定时计算帖⼦分数、定时清理垃圾⽂件等功n能；</li>
<li>利⽤ Actuator 对应⽤的 Bean 、缓存、⽇志、路径等多个维度进⾏了监控，并通过⾃定义的端点对数据库连接进⾏了监控。</li>
</ul>
<h4 id="论坛系统项目（-高校就业信息分享平台）"><a href="#论坛系统项目（-高校就业信息分享平台）" class="headerlink" title="论坛系统项目（-&gt; 高校就业信息分享平台）"></a>论坛系统项目（-&gt; 高校就业信息分享平台）</h4><p><strong>项目描述</strong>：一个基本功能完整的论坛项目。主要功能有: 基于邮件激活的注册方式，区别登陆状态为游客或已登录用户展示不同界面与功能。支持用户上传头像，实现了发布帖子、评论帖子、发送私信与过滤敏感词等功能，以及点赞，关注与系统通知功能。<br>项⽬构建在 Spring Boot + SSM 框架之上，并统⼀的进⾏了状态管理、事务管理、异常处理。<br>（项目是一个以就业信息分享为基点的信息分享平台，在平台上学生可进行就业信息或者学习资源的分享，增加学习就业信息的获取渠道，例如，发布帖子，发布招聘信息，学生间可以互相关注，私信来互相分享资源。）<br><strong>核心功能</strong>:<br>1、用户模块：使用 Spring Email 辅助发送注册激活邮件，并且使用 Interceptor 拦截器赋予不同类型的用户权限，解决http无状态带来的缺陷问题，保护需登录才能查看的资源。<br>2、内容模块：使用 Spring AOP 面向切面编程思想统一记录日志；数据库连接使用 Mybatis 框架来完成，实现SQL语句和代码的分离，解除了SQL语句与代码的耦合。<br>3、通知模块：使用 Kafka 消息队列构建异步消息系统，实现点赞关注与通知（系统）间削峰。<br><strong>项目优化</strong>:<br>1、引入 Redis 数据库，优化项目中 Session 的使用并利用 Redis 实现点赞和关注功能。<br>2、使用 Caffeine + Redis 实现两级缓存，优化了热门帖子的访问。（借用 Jmeter 工具测试吞提升20倍）<br>(使用 Spring Security 提高系统的安全性，防CSRF攻击；使用拦截器解决登录状态剧新及频繁刷新问题)</p>
<h2 id="社团-组织经历"><a href="#社团-组织经历" class="headerlink" title="社团&#x2F;组织经历"></a>社团&#x2F;组织经历</h2><ul>
<li><strong>华南理工大学青年志愿者指导中心</strong>  <em>宣传部 副部长</em> 2022.04-2023.04<br>1.承接中心的摄影任务，组织志愿活动的现场拍摄，负责培养部门成员的基本摄影能力；<br>2.协助完成中心公众号推文制作，宣传大运会、广州马拉松、志愿一条街等活动中的志愿服务工作；<br>3.负责部门的内建工作，营造良好氛围。</li>
</ul>
<h2 id="个人陈述-个人优势"><a href="#个人陈述-个人优势" class="headerlink" title="个人陈述&#x2F;个人优势"></a>个人陈述&#x2F;个人优势</h2><ol>
<li>本科就读于华南理工大学网络工程专业，曾获学校与企业奖学金，校级”优秀公益组织骨干”，三好学生等荣誉，<br>以共同第一作者发表国际会议论文一篇（已录用）；</li>
<li>曾加入学院青马工程班学习，担任华工青年志愿者指导中心宣传部副部长，有丰富的志愿活动和学生组织经历；</li>
<li>熟悉 Java 开发，能够熟练使用 Spring Boot、Spring、Mybatis 等常用框架，有着坚实的专业知识和实践经验；</li>
<li>大学期间，我参与了多个项目或实习，不仅深入了解了软件开发流程，还培养了问题解决的能力和团队协作技巧； </li>
<li>我对信息科技领域充满热情，对新技术和趋势保持关注，有较强的自我学习能力。希望能在企业数字化转型中，应用技术来推动创新和提高效率。</li>
</ol>
<h2 id="应聘理由"><a href="#应聘理由" class="headerlink" title="应聘理由"></a>应聘理由</h2><p>我对Java后端和软件开发有着坚实的专业知识和实践经验。在大学期间，我参与了多个项目或实习，不仅深入了解了软件开发流程，还培养了问题解决的能力和团队协作技巧。<br>东莞银行一直以来都在金融科技方面取得了卓越的成就，我渴望加入这个充满活力和创新的团队，共同推动银行业务的数字化转型。我相信自己的技术背景和对金融领域的热情将使我成为东莞银行信息科技团队的有力资产。</p>
<ol>
<li>个人优势：<br>作为一个经验丰富的Java软件开发者，我在面向对象编程、分布式系统设计以及大规模数据处理方面具备深厚的技术功底。我在之前的项目中，成功地设计和实施了高性能的、可扩展的Java应用程序，这使我对云核心网线Java软件开发的挑战充满信心。我的解决问题的能力以及对新技术的快速学习适应能力，将使我能够在贵公司的项目中迅速融入并取得成绩。</li>
<li>选择行业：<br>我一直对云计算和核心网络领域保持浓厚的兴趣，深知这是当今数字化时代的基础。贵公司在云核心网线方面的领先地位以及对新技术的持续投资，使我对能够参与并推动这个领域的发展充满憧憬。我渴望加入贵公司，通过亲身参与和贡献，不断提升自身技术水平，同时为公司在行业内的创新发展贡献力量。</li>
<li>商业价值：<br>我深刻理解软件开发不仅仅是技术问题，更是在商业环境中为客户提供切实解决方案的过程。我注重将技术与商业需求相结合，通过深入了解客户需求，迅速响应市场变化，为公司创造有价值的产品。我相信我的经验和技能将有助于提高贵公司的竞争力，实现商业和技术的双赢。</li>
</ol>
<h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><p>入学以来，我始终保持着积极向上的态度，希望在各方面都能够取得进步。在这段充实的时光里，我探索了知识的广度和深度，结识了众多志同道合的朋友，培养了坚韧的意志力，以及树立了对未来充满信心的决心。</p>
<ol>
<li>思想上：我热爱祖国，积极学习党的理论，加入了学院青马工程班学习，努力成为一名合格的入党积极分子。我热心公益服务，在校青志宣传部担任副部长，为志愿精神在校园中的传递而努力。也在各项活动中积极参与志愿者工作，帮助有需要的人。</li>
<li>学习上：我能够比较自觉和广泛地学习专业知识，勤奋刻苦，在各科目中都取得了不错的成绩，获得校级奖学金两次。我努力保持学习的热情，也参与到前沿的科研项目中，发表的一篇国际会议论文已被录用。</li>
<li>课余生活中，我也积极参与了各种文体活动。我乐于与人沟通，把握团队合作的机会，在学习与人协作的过程中，我的沟通和协调能力得到了不断加强。我也积极参与到课外实践中，完成了两段企业实习。这不仅锻炼了我的专业技能，更在团队协作的过程中，培养了实际解决问题的能力。同时，我也在不断思考未来的职业发展和目标，努力打下一个好的基础。<br>未来的日子里，我将继续发扬个人优点，脚踏实地，真诚做人，潜心做事，不断地提高自己，为社会作出更大的贡献！</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/10/10/%E6%8A%80%E8%83%BD/" data-id="clrggyur0000ulkv58k31a6am" data-title="寄 能" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Colab" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/31/Colab/" class="article-date">
  <time class="dt-published" datetime="2023-07-31T02:25:07.000Z" itemprop="datePublished">2023-07-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/31/Colab/">Colab</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>Google Colab</strong>是谷歌提供的免费<strong>Jupyter</strong>笔记本环境，不需要配置环境（本质是<strong>Linux虚拟机</strong>），可以加!运行bash命令。提供一定免费的GPU，可以跑 Tensorflow、Pytorch 等深度学习框架。Google Colab提供的资源量是受限制的，所有 Colab 运行时都会在一段时间后重置。Colab Pro 订阅者的使用量仍会受到限制，但相比非订阅者可享有的限额要多出大约一倍。Colab Pro+ 订阅者还可获享更高的稳定性。</p>
<p>使用Colab训练比较重要的是处理好路径的关系，找到哪个文件在哪里，文件夹的执行目录在哪里，就可以比较简单的运行起程序了，不过Colab确实存在断线问题，我们需要时刻保存好文件，因此我将权值直接保存在云盘上，这样也不会丢失。<br><strong>12h</strong>的限额比较难受，有时候没到时间就限额了。因此需要及时保存训练的模型，长时间不用gpu的情况下也会被限额（Pro版也一样），因此训练完建议及时改成gpu或停止。</p>
<h3 id="Google-Drive"><a href="#Google-Drive" class="headerlink" title="Google Drive"></a>Google Drive</h3><p>谷歌云盘，谷歌云端硬盘。免费用户可以获取15G的空间，付费用户根据套餐可以选择最大20TB的储存空间。<br><strong>虚拟机根目录为 &#x2F;content，谷歌云盘地址为 &#x2F;content&#x2F;Drive&#x2F;MyDrive</strong></p>
<h3 id="深度学习库的下载"><a href="#深度学习库的下载" class="headerlink" title="深度学习库的下载"></a>深度学习库的下载</h3><p>使用git clone指令进行下载，然后通过cd指令将根目录转移到了xx文件夹。<strong>此时根目录为 &#x2F;content&#x2F;xx</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!git <span class="built_in">clone</span> https://github.com/xx/xx.git</span><br><span class="line">%<span class="built_in">cd</span> xx/</span><br></pre></td></tr></table></figure>

<h3 id="数据集与预训练权重的上传"><a href="#数据集与预训练权重的上传" class="headerlink" title="数据集与预训练权重的上传"></a>数据集与预训练权重的上传</h3><p>数据集压缩，上传Google Drive，在colab中打开的jupyter文件（等于打开了一个Linux<strong>虚拟机本地</strong>）中挂载Google Drive；将数据集从Drive中复制到当前根目录，解压。<strong>直接将数据集布置在谷歌云盘会导致大量的云盘数据传输，且谷歌云盘和虚拟机之间存在通信带宽，速度远不及本地(虚拟机)文件，因此需要将数据集复制解压到本地(虚拟机)里进行处理。</strong> (<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44791964/article/details/123659637?spm=1001.2014.3001.5501">https://blog.csdn.net/weixin_44791964/article/details/123659637?spm=1001.2014.3001.5501</a>)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!<span class="built_in">cp</span> /content/Drive/MyDrive/xx.zip ./</span><br><span class="line">!unzip ./xx.zip -d ./</span><br></pre></td></tr></table></figure>
<p>预训练权重存放在 &#x2F;content&#x2F;Drive&#x2F;MyDrive&#x2F;Models&#x2F;xx，然后创建logs和model_data。model_data放置的是预训练文件,logs放置的是网络训练过程中产生的权值。</p>
<h3 id="保存路径设置"><a href="#保存路径设置" class="headerlink" title="保存路径设置"></a>保存路径设置</h3><p>如果将权值保存在当前根目录下的logs文件夹（&#x2F;content&#x2F;xx&#x2F;logs），发生断线网络就白训练了，浪费大量的时间。<br>可以将google云盘软连接到根目录下，那么即使断线，权值也保留在云盘中。<br>本文之前在云盘中创建了logs文件夹（&#x2F;content&#x2F;Drive&#x2F;MyDrive&#x2F;Models&#x2F;xx&#x2F;logs），将该文件夹链接到当前根目录下的logs文件夹中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!<span class="built_in">ln</span> -s /content/Drive/MyDrive/Models/xx/logs logs   <span class="comment"># 即/content/xx/logs</span></span><br></pre></td></tr></table></figure>
<h3 id="开始训练"><a href="#开始训练" class="headerlink" title="开始训练"></a>开始训练</h3><p>1、标注文件的处理<br>2、训练文件的处理<br>1）预训练文件的使用。<br>2）保存周期的设置，这个设置是因为云盘的存储空间有限，每代都保存会导致存储空间满出。<br>3、开始训练：!python train.py</p>
<h3 id="常用-colab-命令"><a href="#常用-colab-命令" class="headerlink" title="常用 colab 命令"></a>常用 colab 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import shutil</span><br><span class="line">shutil.copytree(<span class="string">&quot;复制的文件夹&quot;</span>,<span class="string">&quot;目标路径+目标路径下的文件夹&quot;</span>)  <span class="comment"># 复制路径下的文件夹</span></span><br><span class="line">shutil.copytree(<span class="string">&quot;/content/drive/My Drive/channel&quot;</span>,<span class="string">&quot;/content/drive/My Drive/channel10&quot;</span>) <span class="comment"># ex</span></span><br><span class="line">shutil.rmtree(<span class="string">&quot;移除路径下的文件夹&quot;</span>) <span class="comment"># 移除路径下的文件夹</span></span><br><span class="line">shutil.copy(<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>) <span class="comment"># 复制单个文件的命令  同上</span></span><br><span class="line"><span class="comment"># 删除单个文件可以右键删除</span></span><br><span class="line">!<span class="built_in">pwd</span> <span class="comment"># 显示当前目录, /content 为根目录</span></span><br><span class="line">import os </span><br><span class="line">os.chdir(<span class="string">&quot;/content/federated-learning&quot;</span>) <span class="comment"># 变更根目录操作</span></span><br><span class="line">!python <span class="string">&quot;/content/federated-learning/main_nn.py&quot;</span> <span class="comment"># 运行python 文件</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/31/Colab/" data-id="clrggyuql0008lkv5d4u8bg79" data-title="Colab" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Pytorch" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/14/Pytorch/" class="article-date">
  <time class="dt-published" datetime="2023-07-14T03:58:39.000Z" itemprop="datePublished">2023-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/14/Pytorch/">Pytorch</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="TensorBoard"><a href="#TensorBoard" class="headerlink" title="TensorBoard"></a>TensorBoard</h3><p>打开localhost:6006，访问TensorBoard，查看TensorFlow模型的图形、损失函数、精度等信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorboardX <span class="keyword">import</span> SummaryWriter</span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;xxx&quot;</span>)               <span class="comment"># 在文件夹里新建一个abc文件夹</span></span><br><span class="line">writer.add_scalar(<span class="string">&quot;y=2i&quot;</span>, <span class="number">2</span>*i, i)           <span class="comment"># 加坐标</span></span><br><span class="line">writer.add_images(<span class="string">&quot;test_data&quot;</span>, imgs, step)  <span class="comment"># 加图</span></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Pycharm -&gt; Terminal</span></span><br><span class="line">PS C:\Users\cf\Documents\Visual Studio Code\Python\learn_pytorch&gt; tensorboard --logdir=<span class="string">&quot;xxx&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="nn-Module"><a href="#nn-Module" class="headerlink" title="nn.Module"></a>nn.Module</h3><p>基本神经网络</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">cf</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__int__</span>(<span class="params">self</span>):   <span class="built_in">super</span>().__init__()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):      <span class="comment"># 必须重写forword()</span></span><br><span class="line">        output = <span class="built_in">input</span> + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>

<p><strong>输入层（Input Layer）：</strong>接受原始图像或数据作为输入。<br><strong>卷积层（Convolutional Layer）：</strong>进行特征提取。通过卷积操作，利用卷积核（或过滤器）从输入图像中提取特定的特征，如边缘、纹理等。卷积核会在整个图像上滑动，产生特征图。<br>卷积核的输入通道数与输入数据的通道数对应，卷积核的输出通道数与卷积核的数量对应。<br>卷积操作在神经网络中扮演着关键的角色，它通过特征提取、参数共享、空间局部性和参数数量控制等方面，使得卷积神经网络成为图像处理和计算机视觉任务中非常有效的工具。<br><strong>池化层（Pooling Layer）</strong>【最大ceil, 最小floor】：降采样和减少参数，避免过拟合。池化操作对特征图进行降采样，减少特征图的尺寸，并保留重要的特征信息。常用的池化方式为最大池化（Max Pooling）和平均池化（Average Pooling）。<br><strong>非线性激活：</strong>线性变换（如全连接层）在神经网络中只能实现线性映射，而现实世界中的数据和任务通常都是非线性的。为了解决这个问题，需要在网络中引入非线性激活函数，以增加网络的表达能力和灵活性。 给网络中引入非线性特征，以训练出符合各种曲线的模型。<br>·ReLU（Rectified Linear Unit）：f(x) &#x3D; max(0, x)，它在x大于0时是线性的，小于等于0时为0，能够有效地解决梯度消失问题。<br>·Sigmoid：f(x) &#x3D; 1 &#x2F; (1 + exp(-x))，它将输入映射到[0, 1]区间，用于二分类问题。<br>·Tanh：f(x) &#x3D; (exp(x) - exp(-x)) &#x2F; (exp(x) + exp(-x))，它将输入映射到[-1, 1]区间，也用于解决梯度消失问题。<br><strong>正则化层（Regularization Layer）：</strong>正则化层用于防止过拟合。过拟合是指模型在训练数据上表现良好，但在未见过的测试数据上表现较差的现象。正则化层通过添加一些额外的约束或惩罚项来控制模型的复杂度，以避免过度拟合。<br>·L1正则化：将参数的绝对值加入到损失函数中，使得模型倾向于产生稀疏的权重矩阵。<br>·L2正则化：将参数的平方加入到损失函数中，限制权重的大小，防止权重过大造成过拟合。<br>·Dropout正则化：随机在训练过程中丢弃一部分神经元，减少神经元之间的共适应性，提高泛化能力。<br><strong>全连接层（Fully Connected Layer）：</strong>将特征矩阵集合向量化。与卷积层不同，全连接层的神经元排成一列，这些神经元与前一层神经元通过权值互连，呈全连接结构。全连接层的层数以及每层神经元数并不固定。通常层数越高，神经元数目越少。<br>功能：进行分类。在卷积和池化层之后，通过全连接层将得到的特征映射转换为一维向量，并通过一系列的全连接神经元进行分类操作，将输入映射到对应的类别概率。<br><strong>输出层（Output Layer）：</strong>经过多层特征提取后，最后一层输出层可视为分类器，预测输入样本的类别。通常使用Softmax函数将全连接层的输出转换为类别概率分布，确定输入图像最可能属于哪个类别。<br><img src="https://leo710aka.github.io/bk/nn.png"></p>
<p>Sequential</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">self.model1 = Sequential(</span><br><span class="line">            Conv2d(in_channels=<span class="number">3</span>, out_channels=<span class="number">32</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(kernel_size=<span class="number">2</span>, ceil_mode=<span class="literal">True</span>),</span><br><span class="line">            Conv2d(<span class="number">32</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),     <span class="comment"># 二维卷积层</span></span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Flatten(),</span><br><span class="line">            Linear(<span class="number">1024</span>, <span class="number">64</span>),</span><br><span class="line">            Linear(<span class="number">64</span>, <span class="number">10</span>)</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>

<p>一次训练+验证：准备数据 - 加载数据 - 准备模型 - 设置损失函数 - 设置优化器 - 开始训练 - 验证 - 聚合展示</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):  <span class="comment"># 共20轮训练</span></span><br><span class="line">    running_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> dataloader:  <span class="comment"># 对数据进行一轮学习</span></span><br><span class="line">        imgs, targets = data</span><br><span class="line">        output = fc(imgs)</span><br><span class="line">        result_loss = loss(output, targets)  <span class="comment"># 计算损失</span></span><br><span class="line">        optim.zero_grad()  <span class="comment"># 优化器中，梯度置0</span></span><br><span class="line">        result_loss.backward()  <span class="comment"># 损失函数求梯度，反向传播</span></span><br><span class="line">        optim.step()  <span class="comment"># 优化器，优化卷积核参数</span></span><br><span class="line">        running_loss = running_loss + result_loss</span><br><span class="line">    <span class="built_in">print</span>(running_loss)</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/14/Pytorch/" data-id="clrggyuqs000jlkv58nfkhg0o" data-title="Pytorch" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Anaconda" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/10/Anaconda/" class="article-date">
  <time class="dt-published" datetime="2023-07-10T06:15:42.000Z" itemprop="datePublished">2023-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/10/Anaconda/">Anaconda</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol>
<li>利用 Anaconda，创建不同版本的虚拟环境，配置不同的包（如不同版本的 Pytorch），以管理不同的项目。</li>
<li>用 Pycharm 打开项目时，点击添加解释器 —&gt; 添加本地解释器，选择该项目对应的 conda 虚拟环境下，该虚拟环境的 python 解释器。选择使用这个虚拟环境对应的编辑器，就是选择了使用这个环境运行项目，使用这个环境中配好的包等等。</li>
<li>所以要注意终端使用的是哪个编辑器，是否与当前项目使用的编辑器匹配。否则 pip install 把包装到一个虚拟环境，而当前项目运行在另一个虚拟环境中，便无法 import 已安装的包。</li>
</ol>
<h3 id="新建虚拟环境"><a href="#新建虚拟环境" class="headerlink" title="新建虚拟环境"></a>新建虚拟环境</h3><p>打开Anaconda Prompt，创建一个名字为py36的python版本为3.6的虚拟环境（默认地址已改成D:\anaconda3\envs），并查看已有环境：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(base) C:\Users\cf&gt;conda create -n py36 python=3.6</span><br><span class="line">Proceed ([y]/n)? y</span><br><span class="line">(base) C:\Users\cf&gt;conda <span class="built_in">env</span> list</span><br><span class="line"><span class="comment"># conda environments:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">  base                  *  D:\anaconda3</span><br><span class="line">  py36                     D:\anaconda3\envs\py36</span><br></pre></td></tr></table></figure>

<p>激活（切换）环境，并查看该环境下已有包：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(base) C:\Users\cf&gt;conda activate py36</span><br><span class="line">(py36) C:\Users\cf&gt;pip list</span><br></pre></td></tr></table></figure>
<h3 id="装包"><a href="#装包" class="headerlink" title="装包"></a>装包</h3><p>方法1：在 Anaconda Prompt 中进入该环境后，执行 conda install … 或 pip install …(需要关闭代理)<br>方法2：在 Pycharm的terminal（终端），执行安装指令（此时所处的是 Pycharm终端 的环境（不一定是此时加载的项目的环境））</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其他pip指令</span></span><br><span class="line">pip list                                     <span class="comment"># 列出所有已安装的pip包</span></span><br><span class="line">pip install package_name==desired_version    <span class="comment"># 安装指定版本的Python包</span></span><br><span class="line">pip install --target=... package_name        <span class="comment"># 指定pip install包的路径</span></span><br><span class="line">pip show package_name                        <span class="comment"># 查看安装好的包的信息</span></span><br></pre></td></tr></table></figure>

<h3 id="Jupyter-Notebook"><a href="#Jupyter-Notebook" class="headerlink" title="Jupyter Notebook"></a>Jupyter Notebook</h3><p><font color= "#87CEFA  "><strong>以任意行为块，便于代码阅读和测试修改。</strong></font> 在一个环境中安装 jupyter notebook 后，运行:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(py36) C:\Users\cf&gt;jupyter notebook        </span><br></pre></td></tr></table></figure>
<p>在浏览器打开8888端口使用 <a target="_blank" rel="noopener" href="http://localhost:8888/?token=7e39781c1e364fa7a5ee95ef290ffa92eb0caef0c19aaad8">http://localhost:8888/?token=7e39781c1e364fa7a5ee95ef290ffa92eb0caef0c19aaad8</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/10/Anaconda/" data-id="clrggyuqj0004lkv5asuad9bl" data-title="Anaconda" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2046/12/">December 2046</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2046/12/30/nice-photo/">Nice Photo</a>
          </li>
        
          <li>
            <a href="/2024/01/11/RabbitMQ/">RabbitMQ</a>
          </li>
        
          <li>
            <a href="/2024/01/10/Redis/">Redis</a>
          </li>
        
          <li>
            <a href="/2024/01/07/SpringCloud/">SpringCloud</a>
          </li>
        
          <li>
            <a href="/2024/01/04/%E9%AA%8F%E4%BC%AF/">骏 伯</a>
          </li>
        
          <li>
            <a href="/2023/10/11/%E9%9D%A2%E8%AF%95/">面 逝</a>
          </li>
        
          <li>
            <a href="/2023/10/10/%E6%8A%80%E8%83%BD/">寄 能</a>
          </li>
        
          <li>
            <a href="/2023/07/31/Colab/">Colab</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 fengcai<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>