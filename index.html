<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Qué miras Bobo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Qué miras Bobo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Qué miras Bobo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="fengcai">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Qué miras Bobo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="https://github.com/leo710aka/bk/blob/main/DT1.jpg?raw=true">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Qué miras Bobo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-nice-photo" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2046/12/30/nice-photo/" class="article-date">
  <time class="dt-published" datetime="2046-12-30T03:11:00.000Z" itemprop="datePublished">2046-12-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2046/12/30/nice-photo/">Nice Photo</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <br>
<br>
<img src="https://leo710aka.github.io/bk/bk.jpg" width="550" height="300" alt="">
<div style="text-align:center;text-shadow: 2px 2px 2px #888888;">Old Master</div>
<br>
<img src="https://leo710aka.github.io/bk/zq.jpg" width="550" height="300" alt="">
<br>
<img src="https://leo710aka.github.io/bk/3.jpg" width="550" height="300" alt="">
<br>
<!-- <img src="https://leo710aka.github.io/bk/4.jpg" width="750" height="300" alt=""> -->
<!-- <img src="https://leo710aka.github.io/bk/zq2.jpg" width="550" height="200" alt="">
<br>
<br>
<img src="https://leo710aka.github.io/bk/zq3.jpg" width="550" height="200" alt="">
<br> -->
<!-- <div style="display: flex; justify-content: center;">
    <img src="https://leo710aka.github.io/bk/zq2.jpg" style="width: 100%; margin-right: 5px;">
    <img src="https://leo710aka.github.io/bk/zq3.jpg" style="width: 100%; margin-left: 5px;">
</div> -->
<img src="https://leo710aka.github.io/bk/zq2.jpg" width="550" height="300" alt="">
<br>
<img src="https://leo710aka.github.io/bk/zq3.jpg" width="550" height="300" alt="">
<br>
<br>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2046/12/30/nice-photo/" data-id="cm0cja96q000om4v5f0uvaanx" data-title="Nice Photo" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Guitar" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/27/Guitar/" class="article-date">
  <time class="dt-published" datetime="2024-08-27T13:55:11.000Z" itemprop="datePublished">2024-08-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/27/Guitar/">guitar 🎸</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="乐理"><a href="#乐理" class="headerlink" title="乐理"></a>乐理</h2><img src="https://github.com/leo710aka/bk/blob/main/chord.png?raw=true" width="450" height="300" alt="和弦">

<p>十二平均律</p>
<h2 id="谱子"><a href="#谱子" class="headerlink" title="谱子"></a>谱子</h2><img src="https://github.com/leo710aka/bk/blob/main/%E9%80%81%E5%88%AB.png?raw=true" width="450" height="300" alt="送别">

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/27/Guitar/" data-id="cm0cja96e0003m4v57yh537lp" data-title="guitar 🎸" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-保险" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/18/%E4%BF%9D%E9%99%A9/" class="article-date">
  <time class="dt-published" datetime="2024-08-18T08:55:11.000Z" itemprop="datePublished">2024-08-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/18/%E4%BF%9D%E9%99%A9/">保 险</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="社会保障"><a href="#社会保障" class="headerlink" title="社会保障"></a>社会保障</h2><p>国家或社会通过对国民收入的再分配，使公民在遇到特定风险或困难时能够获得基本生活保障。本质是追求一种公平。</p>
<h2 id="社会保险"><a href="#社会保险" class="headerlink" title="社会保险"></a><strong>社会保险</strong></h2><ol>
<li><strong>养老保险</strong>：为了保障老年人退休后的基本生活，通过个人和单位的缴费，在退休后按月领取养老金。个人在达到法定退休年龄时，如果满足缴费年限等条件，就可以领取养老金。</li>
<li><strong>医疗保险</strong>：旨在为参保人员提供医疗费用的报销或补偿，以减轻医疗费用的负担。参保人员在生病住院或接受治疗时，可以通过医保报销一部分或全部的医疗费用。</li>
<li>失业保险：为因非个人原因失去工作的参保人员提供一定时间内的生活保障金，帮助他们在失业期间维持基本生活。</li>
<li>工伤保险：用于保障因工作原因遭受意外伤害或职业病的劳动者，提供医疗费用和伤残补助，甚至提供生活保障金等。</li>
<li>生育保险：主要为参保女性在生育期间提供一定的经济补助和医疗费用报销。</li>
</ol>
<h3 id="社保卡"><a href="#社保卡" class="headerlink" title="社保卡"></a>社保卡</h3><p>佛山社保卡如何申领？“一人一卡”清理又是个啥？ <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/9uQ5qGOYv35BGRgs4OvzvA">https://mp.weixin.qq.com/s/9uQ5qGOYv35BGRgs4OvzvA</a></p>
<h3 id="医保"><a href="#医保" class="headerlink" title="医保"></a>医保</h3><ul>
<li>医疗保险是一种社会保障制度。通常由个人和单位共同缴纳，参保人员在医疗机构就诊时可以通过医保报销部分或全部的医疗费用。</li>
<li>通过医保报销的费用是由医保基金支付的，而这个基金是由全体参保人员（包括你和你的单位）共同缴纳的资金组成的。<strong>个人缴纳的那部分医保费用只是整个基金的一部分，而报销的金额往往远超过个人单独缴纳的部分，这正是医保体系的优势所在</strong>。</li>
<li>医保的使用方法？？<ol>
<li>参保登记：参加医保的员工会在企业办理社保时一同办理医保，个人需要定期缴纳医保费用。</li>
<li>医保卡或电子医保凭证：参保人员会获得一张医保卡，或者可以使用电子医保凭证（通过手机App，如“国家医保服务平台”或微信等）。该卡或凭证用于在医院或药店就医时进行身份验证和费用结算。</li>
<li>定点医院就诊： 在中国，医保使用一般要求在医保定点医院（通常是参保人选择或默认的几家医院）就诊。非定点医院就诊费用可能不能报销或报销比例较低。就诊时，需要在挂号和缴费时出示医保卡或电子医保凭证。医保可以覆盖部分门诊费用，根据病种、医院等级和医保政策的不同，报销比例也有所不同。</li>
<li>住院&#x2F;药品使用： 通过医保报销大部分住院&#x2F;药品费用。</li>
<li>如果需要在佛山以外的城市就医，可以在异地开通医保异地结算服务。这样在异地看病时也能使用佛山的医保报销。</li>
</ol>
</li>
</ul>
<h3 id="住房公积金"><a href="#住房公积金" class="headerlink" title="住房公积金"></a>住房公积金</h3><ul>
<li>住房公积金是一种社会福利制度，而不是严格意义上的社会保障。</li>
<li>住房公积金是国家为帮助职工解决住房问题而设立的一项长期住房储金。它由职工个人和单位共同缴纳，归职工个人所有，并在一定条件下用于购房、建房、房屋维修或者租房等住房相关支出。</li>
<li>职工可以在以下情况下提取住房公积金：购买、建造、翻建、大修自住住房。偿还住房贷款本息（利率低）。支付房租。离职或退休后可以提取全部住房公积金。</li>
<li>住房公积金可以断缴。如果有购房计划或其他需要公积金支持的需求，最好避免长时间断缴。<ul>
<li>可以断缴：如果你换工作、辞职、或者暂时没有固定工作，住房公积金可以暂时断缴。没有法律强制要求必须连续缴纳。一旦找到新工作或稳定下来，你可以恢复缴纳住房公积金。新单位会重新为你开设账户或继续使用之前的账户。</li>
<li>断缴的影响<br>  <strong>贷款购房影响</strong>：<strong>影响贷款资格</strong>，在申请住房公积金贷款时，很多地方要求申请人在最近的6个月或12个月内连续缴纳公积金。如果公积金断缴，可能会影响你申请住房公积金贷款的资格。<strong>贷款额度影响</strong>，公积金贷款额度通常与公积金的缴纳时间和余额挂钩。如果断缴时间较长，贷款额度可能会受到影响。<br>  <strong>影响提取条件</strong>：如果计划通过提取公积金支付房租或购房时，断缴可能会影响提取公积金的条件，因为很多地方要求提取前必须有一定的连续缴纳记录。</li>
<li>如何减少断缴的影响：<br>  补缴：在新单位入职后，你可以尝试与单位协商，进行断缴期间的补缴。这可能会恢复你在断缴期间的公积金记录。<br>  灵活就业人员公积金：有些城市允许灵活就业人员或个体工商户自行缴纳公积金，可以考虑这一方式以避免断缴。</li>
</ul>
</li>
<li>住房公积金在中国是可以随着工作地点的变更而进行转移的。<ul>
<li>通常的步骤是：在新城市的新工作单位会为你开设一个新的住房公积金账户。向新单位的公积金管理中心申请将旧账户的公积金余额转入新账户。新单位所在的公积金管理中心会联系原城市的公积金管理中心，办理资金转移。公积金转移通常需要一定时间，一旦转移完成，你的住房公积金余额将会合并到新城市的账户中。</li>
</ul>
</li>
</ul>
<h2 id="商业保险"><a href="#商业保险" class="headerlink" title="商业保险"></a>商业保险</h2><p>【当代年轻人没了铁饭碗，还能负重奔跑多久？北京二胎家庭如何转移风险？】 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV16F4m1V7wv/?share_source=copy_web&vd_source=2cbe8cdd54a75d0c43fcdefa624d3fbe">https://www.bilibili.com/video/BV16F4m1V7wv/?share_source=copy_web&amp;vd_source=2cbe8cdd54a75d0c43fcdefa624d3fbe</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/18/%E4%BF%9D%E9%99%A9/" data-id="cm0cja96p000nm4v59fqk4fid" data-title="保 险" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-美的Midea" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/07/%E7%BE%8E%E7%9A%84Midea/" class="article-date">
  <time class="dt-published" datetime="2024-07-07T02:58:11.000Z" itemprop="datePublished">2024-07-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/07/%E7%BE%8E%E7%9A%84Midea/">美 的 Midea</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="2024-07-08"><a href="#2024-07-08" class="headerlink" title="2024.07.08"></a>2024.07.08</h2><p>入职第一天，熟悉运维平台，目标实现其自动化，后续参与到美的云<br><img src="https://leo710aka.github.io/bk/midea.jpg"></p>
<!-- <img src="https://leo710aka.github.io/bk/midea.jpg" width="350" height="300" alt=""> -->

<h4 id="7-09"><a href="#7-09" class="headerlink" title="7.09"></a>7.09</h4><!-- > **7.09** -->

<p><strong>需求一</strong>，熟悉新旧平台的功能和调用关系，拆分业务需求开发步骤，编写文档，每日汇报进展，熟悉开发流程、、<br>第一周：软工院作为非互联网公司的非核心业务的底层平台建设部门，结果导向，组员一年社招；)无校招培养。？</p>
<!-- <img src="https://leo710aka.github.io/bk/midea1.jpg" width="350" height="300" alt=""> -->


<h4 id="7-17"><a href="#7-17" class="headerlink" title="7.17"></a>7.17</h4><p>EDP培训 ＋ GMC（头脑风暴&#x2F;产品调研&#x2F;拉通对齐&gt;&gt;技术）<br>T型人才(广度＋深度)，开发技术+产品思维-&gt;架构师<br>不设限，主动承担任务，机会莫名来：) take other people’s jobs and become indispensable to the team..<br><img src="https://leo710aka.github.io/bk/midea2.jpg" width="450" height="300" alt=""></p>
<h4 id="7-23"><a href="#7-23" class="headerlink" title="7.23"></a><strong>7.23</strong></h4><p>Alex: the scope of teamwork minus everyone’s responsibility is not null..<br>复杂的事情简单化(思考简化)，简单的事情复杂化(做到极致)<br>工作就是生活，生活就是工作，不需要平衡（找到热爱的工作）<br>成功的百分比 &#x3D; 做事 &#x2F; (个人 + 做事)；做事的比例越大，成功的概率越大<br><img src="https://leo710aka.github.io/bk/midea3.jpg" width="450" height="300" alt=""></p>
<h4 id="7-29"><a href="#7-29" class="headerlink" title="7.29"></a><strong>7.29</strong></h4><p>MGC结营<br>融入团队？主动承担？谈论未知？如何选择自己在团队中的角色，人设？？<br>圈子</p>
<!-- <img src="https://leo710aka.github.io/bk/midea4.jpg" width="350" height="300" alt=""> -->

<h4 id="8-14"><a href="#8-14" class="headerlink" title="8.14"></a><strong>8.14</strong></h4><p>窝囊费：) 7300(扣除五险一金扣税)(+2300公积金)+500(补贴)-800(房租水电)-2000(吃喝玩乐)&#x3D;5000(+2300公积金)</p>
<table>
<thead>
<tr>
<th>五险</th>
<th>个人缴纳金额</th>
<th>公司缴纳金额</th>
<th>总计</th>
</tr>
</thead>
<tbody><tr>
<td>-</td>
<td>898.9</td>
<td>1834.88</td>
<td>2733.78</td>
</tr>
<tr>
<td>养老保险</td>
<td>767.2</td>
<td>1438.5</td>
<td>2205.7</td>
</tr>
<tr>
<td>医疗保险</td>
<td>115.2</td>
<td>281.3</td>
<td>393.82</td>
</tr>
<tr>
<td>失业保险</td>
<td>19.18</td>
<td>76.72</td>
<td>95.9</td>
</tr>
<tr>
<td>工伤保险</td>
<td>0</td>
<td>38.36</td>
<td>38.36</td>
</tr>
<tr>
<td>生育保险</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>个人住房公积金</th>
<th>个人补充公积金</th>
<th>公司缴纳金额</th>
<th>月缴纳金额合计</th>
</tr>
</thead>
<tbody><tr>
<td>1151</td>
<td>480</td>
<td>671</td>
<td>2302</td>
</tr>
</tbody></table>
<h4 id="8-17"><a href="#8-17" class="headerlink" title="8.17"></a>8.17</h4><p>佛山校友会迎新<br>“努力会发光，先有为后有位”，“头三年不要动，把这一套学会”<br>程序员的本质核心竞争力是什么？</p>
<h4 id="8-19-ALEX"><a href="#8-19-ALEX" class="headerlink" title="8.19 ALEX"></a>8.19 ALEX</h4><p>最近和一些软工院同学深入聊了一下他们的职业发展规划，我发现很多同学对自己的职业发展方向是模糊不清的，对职业发展的规划很大程度上是基于自己想象的不切实际的路径。当然，职业发展规划是一个极难的事情，就像一个组织的战略方向最难把握，一个人的职业发展方向也是极难把握的，因为看清未来和把握方向需要极高的认知能力和丰富的实践经验。</p>
<p>职业发展规划的核心是两个问题：目标是什么，路径是什么。假定你的理想是成为一名企业家型人才，这里企业家型人才不只包括企业创始人，还包括这个企业里面那些每天负责做各种商业决策并且负责拿到商业结果的人。这里，我不建议把目标制定成升级或者当上什么官职，因为这样目标能否实现不是你能掌控的。命运要掌握在自己手里，不是别人手里。那切实可行的路径是什么？路径要提前想清楚，否则就行开车没有导航，随性开，那你大概率会走很多弯路，甚至掉进坑里。这里我假定你是普通人家的孩子，你父母没法轻飘飘给你十几个“小目标”让你去随便创业练手，亏了也无所谓；这里我还假定你不是马云张一鸣这样的天才，如果你是，那你可以直奔主题，直接去创业；如果你不是，还直奔主题，那大概率会失败。我这里给大家指清一个对普通家庭出身的普通人来说，只要肯努力肯学习，就能够成为企业家型人才的实现路径：专家型人才—》领军型人才—》企业家型人才。</p>
<p>如何成为专家型人才？第一步，你经过努力成为你团队的top performer，就是S员工。怎么才能成为团队的top performer呢？思路很简单，首先和你的主管对齐目标，其次做到结果远超预期。怎么才能做到结果远超预期呢？思路也很简单：最大的努力程度+需要啥学啥。学习的途径包括读书（推荐微信读书），向优秀的同事学经验，向失败的同事学教训。第二步，你成为团队专家，即你要用你的技术能力赋能和帮助你团队的其他同学。怎么判断你是否是你团队的专家呢？很简单，大家遇到技术难题的时候，他们首先找你帮忙么？你经常向其他同学传授经验和技能么？当你团队有同学遇到搞不定的难题的时候，你的主管是不是第一个想到你，让你去辅导这个同学搞定难题。第三步，你成为行业专家，在这个行业，你是技术最牛之一，你非常清楚这个行业的技术水位，你做出的东西的技术水平比肩甚至超越业界同行的最高水平。要想成为专家型人才，我建议你要有一个role model。软工院的部长和TL们都是专家型人才，你可以把你团队的TL或者部长作为你的role model。正如我之前所说，软工院是你成长的平台，是你成为专家型人才的平台，不要把软工院当做你打工当做你用劳动换取报酬的地方。认知决定思维，思维决定行动，行动决定结果。</p>
<p>如何成为领军型人才？你要具备在一个公司把一大块领域从零做起的能力，你要具备带几百人大团队的能力，你要具备战略思维能力，你要具备为几百甚至上千人的团队制定战略目标和实现路径的能力。</p>
<p>如何成为企业家型人才？你要具备商业思维能力，你要能把一块业务从零做起来，你要知道你竞争对手是谁，他们在做什么，你怎么在竞争中战胜他们。</p>
<p>美的鼓励内部企业家，鼓励人人成为企业家，鼓励每个人每个组织把自己的蛋糕做大。<strong>等软工院把商业化输出做起来，随着我们外部蛋糕越做越大，我们这个平台自然需要你成为专家型人才，领军型人才，和企业家型人才</strong>。让我们大家携起手来，把我们的事业做大！</p>
<h4 id="8-22"><a href="#8-22" class="headerlink" title="8.22"></a>8.22</h4><p><strong>需求一</strong>：完成第一版8.14，自测8.15，，mr，code review，sit，测试，uat，发版8.22、、<br>反思、、在开发同事的指导下完成了开发，缺少对产品的思考，没有对需求进行120%的思考和完成。。</p>
<h4 id="8-24"><a href="#8-24" class="headerlink" title="8.24"></a>8.24</h4><p>顺德校友会迎新<br>why Midea？1.生活成本低（特别是住宿好通勤方便）2.相比下工作轻松（能够有自己的时间学习业务以外的东西）</p>
<h4 id="8-27-Steven"><a href="#8-27-Steven" class="headerlink" title="8.27 Steven"></a>8.27 Steven</h4><p>深入一个领域，，<br>先做一点功能点，然后负责一个模块，到不同系统的交互、、<br>多学基础，与外包的区别。。与人沟通的能力<br>幂等，整体设计，微服务治理，看项目源码，，<br>干半年就不是应届生了。社会很残酷，前两年要快速成长；思考两&#x2F;五年后的情况、、<br>开发整个过一遍，打包，发版，，<br>多讨论，多问，code review</p>
<h4 id="8-29"><a href="#8-29" class="headerlink" title="8.29"></a>8.29</h4><p>邮件：设计一个功能，，关注点，逻辑路径，通用性</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/07/%E7%BE%8E%E7%9A%84Midea/" data-id="cm0cja96r000rm4v57ix3dak5" data-title="美 的 Midea" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-毕业设计" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/05/01/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/" class="article-date">
  <time class="dt-published" datetime="2024-05-01T03:11:00.000Z" itemprop="datePublished">2024-05-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/05/01/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/">毕 业 设 计</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="选-题"><a href="#选-题" class="headerlink" title="选 题"></a><strong>选 题</strong></h2><p><em>基于内地与香港金融平台的在线量化投资的数据原型系统的设计与开发_</em>_</p>
<h3 id="论文结构"><a href="#论文结构" class="headerlink" title="论文结构"></a>论文结构</h3><p>摘 要 II<br>Abstract III<br>目 录 V<br>第一章 绪论<br>1.1 引言<br>1.2 研究背景<br>1.3 研究现状<br>1.4 课题来源及意义<br>1.5 论文结构<br>第二章 数据原型系统开发环境和工具<br>2.1 Python爬虫<br>2.2 Django框架<br>2.3 设计模式<br>2.4 前端开发框架<br>2.5 开源图形库 ECharts<br>2.6 本章小结<br>第三章 数据原型系统架构设计<br>3.1 综合性金融系统架构设计<br>3.2 数据原型系统架构设计<br>3.3 功能接口设计<br>3.4 数据库设计<br>第四章 数据原型系统的实现<br>4.1从金融平台获取数据实现<br>4.2 数据库查询实现<br>4.3 数据可视化实现<br>4.4 Echarts 图形库渲染生成统计图表<br>4.5 数据下载接口实现<br>4.6 数据维护接口实现<br>第五章 数据原型系统的测试及结果<br>5.1 数据更新模块测试<br>5.2 数据下载模块测试<br>5.3 数据分析模块测试<br>5.4 数据维护模块测试<br>5.5 本章小结<br>第六章 结论<br>1.论文工作总结<br>2.工作展望<br>参考文献<br>致谢</p>
<h3 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h3><ul>
<li>香港市场股票数据库的构建<ul>
<li>MySql数据库：股票、基金、期货</li>
<li>数据库表结构：参考旧论文&#x2F;直接用东方财富网表头</li>
<li>用python爬虫爬取数据, 数据清洗, 爬取历史数据</li>
</ul>
</li>
<li>获取香港期货代码 \spider\Get_Future_Info.py<ul>
<li>数据库创建  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CreateDatabase</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, new_database</span>):</span><br><span class="line">        self.new_database = new_database</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_new_database</span>(<span class="params">self</span>):</span><br><span class="line">        connection = pymysql.connect(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, user=<span class="string">&#x27;root&#x27;</span>, password=<span class="string">&#x27;078114&#x27;</span>, cursorclass=pymysql.cursors.DictCursor)</span><br><span class="line">        new_database_name = self.new_database</span><br><span class="line">        cursor = connection.cursor()</span><br><span class="line">        cursor.execute(<span class="string">f&quot;CREATE DATABASE <span class="subst">&#123;new_database_name&#125;</span>&quot;</span>)</span><br><span class="line">        cursor.close()</span><br><span class="line">        connection.close()</span><br></pre></td></tr></table></figure></li>
<li>数据库操作  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Database</span>:          </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">InsertFutureInfo</span>(<span class="params">self, item</span>):  <span class="comment"># 插入数据</span></span><br><span class="line">        mydb = pymysql.connect(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">3306</span>, user=<span class="string">&#x27;root&#x27;</span>, password=<span class="string">&#x27;078114&#x27;</span>, database=<span class="string">&#x27;finance&#x27;</span>, charset=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">        cursor = mydb.cursor()</span><br><span class="line">        sql = <span class="string">&quot;insert into futureinfo values(%s, %s)&quot;</span></span><br><span class="line">        cursor.executemany(sql, item) <span class="comment"># 要传入一个二维列表或元组的列表作为参数 item，每个子列表或元组应包含两个元素，对应着 SQL 语句中的两个 %s，用于插入数据库表中的两个字段的值</span></span><br><span class="line">        mydb.commit()</span><br><span class="line">        cursor.close()</span><br><span class="line">        mydb.close()</span><br></pre></td></tr></table></figure></li>
<li>爬虫操作  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取期货列表：东方财富网今天期货市场中港交所的期货列表信息（??不确定是不是完整期货信息）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getInfo</span>(<span class="params">self</span>): </span><br><span class="line">    url_base = <span class="string">&#x27;https://futsseapi.eastmoney.com/list/HKSTOCKF?callback=aaa_callback&amp;xx&#x27;</span></span><br><span class="line">    all_data = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>): <span class="comment"># 默认30页？</span></span><br><span class="line">        url = url_base.<span class="built_in">format</span>(size=<span class="number">20</span>, page=i)</span><br><span class="line">        data_str = requests.get(url).text</span><br><span class="line">        json_str = data_str[data_str.index(<span class="string">&#x27;(&#x27;</span>) + <span class="number">1</span>:-<span class="number">1</span>] <span class="comment"># 去除 JSON 数据中的回调函数</span></span><br><span class="line">        data_list = json.loads(json_str)[<span class="string">&quot;list&quot;</span>]</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> data_list:</span><br><span class="line">            tmp = [item[<span class="string">&#x27;dm&#x27;</span>], item[<span class="string">&#x27;name&#x27;</span>]] <span class="comment"># 期货代码，期货名称</span></span><br><span class="line">            all_data.append(tmp)</span><br><span class="line">    Database().InsertFutureInfo(all_data) </span><br></pre></td></tr></table></figure>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取历史期货数据：通过之前获取的期货列表信息，根据期货代码获取其历史（日线）数据（??不确定完整）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getHistory</span>(<span class="params">self</span>): </span><br><span class="line">    url_base = <span class="string">&#x27;https://push2his.eastmoney.com/api/qt/stock/kline/get?secid=130.&#123;secid&#125;&amp;xx&#x27;</span></span><br><span class="line">    all_data = <span class="built_in">list</span>()</span><br><span class="line">    code_list = Database().GetCodeList() <span class="comment"># 获取期货列表信息</span></span><br><span class="line">    <span class="keyword">for</span> dm <span class="keyword">in</span> tqdm(code_list):</span><br><span class="line">        url = url_base.<span class="built_in">format</span>(secid=dm) <span class="comment"># 日线数据</span></span><br><span class="line">        response = requests.get(url=url, timeout=<span class="number">15</span>)</span><br><span class="line">        klines_data = json.loads(response.text)[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;klines&#x27;</span>]</span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> klines_data:</span><br><span class="line">            res_data = data.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">            res_data = [dm] + res_data <span class="comment"># 元组首位加上期货代码</span></span><br><span class="line">            all_data.append(res_data)</span><br><span class="line">    Database().InsertFutureHistory(all_data)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="系统开发"><a href="#系统开发" class="headerlink" title="系统开发"></a>系统开发</h2><ul>
<li>系统架构<ul>
<li>前端：Django+Template，Echarts</li>
<li>后端：Django，MySQL，定时任务</li>
</ul>
</li>
<li>主要工作（原）<ul>
<li>四大模块：数据更新、数据下载、数据分析、数据维护<ul>
<li>一、香港数据<ol>
<li>数据实时更新 （1.1 数据列表(香港股票，香港基金，香港指数，香港期货，香港交易所),1.2 基本信息数据（股票、基金、期货），1.3 基本信息， 1.4 财务报表， 1.5 香港历史交易数据（香港股票，香港基金，香港指数，香港期货）， 1.6 当日交易数据（香港股票，香港基金，香港指数，香港期货）） </li>
<li>数据下载 （2.1 列表数据下载(香港股票，香港基金，香港指数，香港期货，香港交易所)，2.2 基本信息数据下载（股票、基金、期货），2.3 基本信息下载， 2.4 财务报表数据下载， 2.5 香港历史交易数据下载（大陆股票，大陆基金，大陆指数，大陆期货）， 2.6 当日交易数据下载（香港股票，香港基金，香港指数，香港期货））</li>
<li>数据分析 （3.1 列表数据分析(香港股票，香港基金，香港指数，香港期货，香港交易所)，3.2 基本信息数据分析（股票、基金、期货），3.3 基本信息分析， 3.4 财务报表数据分析， 3.5 大陆历史交易数据分析（大陆股票，大陆基金，大陆指数，大陆期货）， 3.6 当日交易数据分析（大陆股票，大陆基金，大陆指数，大陆期货））</li>
<li>数据维护 （4.1 数据导出 4.1.1 数据列表导出(香港股票，香港基金，香港指数，香港期货，香港交易所),4.1.2 基本信息数据导出（股票、基金、期货），4.1.3 基本信息数据导出， 4.1.4 财务报表导出， 4.1.5 香港历史交易数据导出（香港陆股票，香港基金，香港指数，香港期货）， 4.1.6 当日交易数据导出（香港股票，香港基金，香港指数，香港期货）， 4.2 数据导入 4.2.1 数据列表导入(香港股票，香港基金，香港指数，香港期货，香港交易所),4.2.2 基本信息数据导入（股票、基金、期货），4.2.3 基本信息数据导入， 4.2.4 财务报表导入， 4.2.5 香港历史交易数据导入（香港股票，香港基金，香港指数，香港期货）， 4.2.6 当日交易数据导入（香港股票，香港基金，香港指数，香港期货））】</li>
</ol>
</li>
<li>二、香港相关数据还要包括 【1 深港通、沪港通数据；2. 在港上市的大陆股票；3. 在港国企股；4. 港股的科创板】</li>
</ul>
</li>
</ul>
</li>
<li><strong>主要工作（真）</strong><ul>
<li><strong>主要是要多完成港股中相关数据内容：</strong><a target="_blank" rel="noopener" href="https://quote.eastmoney.com/center/ggsc.html">港股主板、港股创业板、知名港股、蓝筹股、红筹股、红筹成分股、国企股、国企成分股、港股通成份股、人民币交易港股、AH股比价、香港指数</a> </li>
<li><strong>突出两地股市的差别：对这几个港股数据，提供数据展示（调用其他同学的接口同时展现大陆数据），数据更新、维护、下载的功能；最好论文还要有一些分析的结果，需要自己做一些结果和图表出来，系统上时间不够可以不加</strong></li>
</ul>
</li>
<li>开发流程<ul>
<li>港股数据爬取（spider）：<br>  创建各类港股基本信息表：获取“港股市场xx股”（在今日）的信息列表，将“股票代码”、“股票名称”等保存在数据库对应的基本信息表中，同时保存“更新时间”为今日<br>  创建各类港股历史数据表：根据“港股市场xx股”的基本信息表中的股票代码，获取该股至今的历史数据，将“股票代码, 名称, k线数据, 时间”存入对应的历史数据表中</li>
<li>港股数据更新（spider）：<br>  更新各类港股基本信息表：获取“港股市场xx股”（在今日）的信息列表，将对应表中不存在的“股票代码”的数据存入并且保存“更新时间”为今日，将原本存在的股票信息和“更新时间”更新<br>  更新各类港股历史数据表：根据“港股市场xx股”的基本信息表中的“股票代码”和“更新时间”，获取从“更新时间”至今的历史数据，存入对应的历史数据表中（无序）</li>
<li>港股基本数据展示（Django）：展示各类港股基本信息表</li>
<li>港股K线图展示（Django）：根据股票代码，结合Echarts展示各类港股历史数据的K线图</li>
<li>提供数据接口供其他的模块使用（Django）：以JSON形式返回各类港股历史数据到页面上</li>
<li>数据下载（Django）：以JSON形式返回各类港股历史数据到页面上，右键“另存为”下载</li>
<li>数据维护：导入，导出</li>
</ul>
</li>
</ul>
<h3 id="数据库建设"><a href="#数据库建设" class="headerlink" title="数据库建设"></a>数据库建设</h3><ol>
<li>创建数据库和表（\spider\DB_Fund.py）<ul>
<li>xx股基本信息表 xxinfo<table>
<thead>
<tr>
<th>股票代码</th>
<th>股票名称</th>
<th>最新价</th>
<th>涨跌额</th>
<th>涨跌幅</th>
<th>今开</th>
<th>最高</th>
<th>最低</th>
<th>昨收</th>
<th>成交量(股)</th>
<th>成交额</th>
<th>更新日期</th>
</tr>
</thead>
<tbody><tr>
<td>code</td>
<td>name</td>
<td>now</td>
<td>change</td>
<td>changerate</td>
<td>open</td>
<td>high</td>
<td>low</td>
<td>yesterday_close</td>
<td>volume</td>
<td>amount</td>
<td>date_updated</td>
</tr>
</tbody></table>
</li>
<li>xx股历史数据表 xxhistory<table>
<thead>
<tr>
<th>code</th>
<th>date</th>
<th>open</th>
<th>now</th>
<th>high</th>
<th>low</th>
<th>volume</th>
<th>amount</th>
<th>rate</th>
<th>changerate</th>
<th>per</th>
<th>zero</th>
</tr>
</thead>
</table>
</li>
<li>A-H股基本信息表 AHStockComparisoninfo<table>
<thead>
<tr>
<th>名称</th>
<th>H股代码</th>
<th>最新价(HKD)</th>
<th>涨跌幅</th>
<th>A股代码</th>
<th>最新价(RMB)</th>
<th>涨跌幅</th>
<th>比价（A&#x2F;H）</th>
<th>溢价（A&#x2F;H）%</th>
<th>更新时间</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>code_hkd</td>
<td>now_hkd</td>
<td>changerate_hkd</td>
<td>code_rmb</td>
<td>now_rmb</td>
<td>changerate_rmb</td>
<td>AHcomparison</td>
<td>AHcomparisonrate</td>
<td>date_updated</td>
</tr>
</tbody></table>
</li>
<li>港股市场术语英文表示：<ol>
<li>港股主板：HKEXMainBoardinfo</li>
<li>港股创业板：GEMofHKEXinfo</li>
<li>知名港股</li>
<li>蓝筹股</li>
<li>红筹股</li>
<li>红筹成分股</li>
<li>国企股：SOEStocksinfo</li>
<li>国企成分股：SOEConstituentStocksinfo</li>
<li>港股通成份股：HKStockConnectConstituentStocksinfo</li>
<li>人民币交易港股</li>
<li>AH股比价：AHStockComparisoninfo</li>
<li>ADR</li>
<li>香港指数：HKStockIndexinfo</li>
</ol>
</li>
</ul>
</li>
<li>爬取港股基本信息（\spider\Get_HKStock\HKStockSpider().getxxInfo()）<ul>
<li>使用F12抓包，点击如“港股主板”按钮查询出对应的股票数据，刷新页面，过滤出js文件，找到对应的股票数据的get请求api（默认pn&#x3D;1，pz&#x3D;20，表示获取第一页大小为20的股票数据列表）；从中获取总数据行数”data”&#x2F;“total”，再次发送get请求（设置pn&#x3D;1，pz&#x3D;total）获取完整的该股票数据列表    </li>
<li>港股主板：’<a target="_blank" rel="noopener" href="https://86.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112408726538243180275_1714550583811&pn=1&pz=20&po=1&np=1&ut=bd1d9ddb04089700cf9c27f6f7426281&fltt=2&invt=2&wbp2u=8413067108550254%7C0%7C1%7C0%7Cweb&fid=f3&fs=m:116+t:3&fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&_=1714550583816">https://86.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112408726538243180275_1714550583811&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=8413067108550254|0|1|0|web&amp;fid=f3&amp;fs=m:116+t:3&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&amp;_=1714550583816</a>‘</li>
<li>港股创业板：<a target="_blank" rel="noopener" href="https://86.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112408726538243180275_1714550583811&pn=1&pz=20&po=1&np=1&ut=bd1d9ddb04089700cf9c27f6f7426281&fltt=2&invt=2&wbp2u=8413067108550254%7C0%7C1%7C0%7Cweb&fid=f3&fs=m:116+t:4&fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&_=1714550583886">https://86.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112408726538243180275_1714550583811&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=8413067108550254|0|1|0|web&amp;fid=f3&amp;fs=m:116+t:4&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&amp;_=1714550583886</a></li>
<li>知名港股：<a target="_blank" rel="noopener" href="https://86.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112408726538243180275_1714550583811&pn=1&pz=20&po=1&np=1&ut=bd1d9ddb04089700cf9c27f6f7426281&fltt=2&invt=2&wbp2u=8413067108550254%7C0%7C1%7C0%7Cweb&fid=f3&fs=b:MK0106&fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&_=1714550583906">https://86.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112408726538243180275_1714550583811&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=8413067108550254|0|1|0|web&amp;fid=f3&amp;fs=b:MK0106&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&amp;_=1714550583906</a></li>
<li>蓝筹股：<a target="_blank" rel="noopener" href="https://57.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112407221764962597832_1714570944282&pn=1&pz=20&po=1&np=1&ut=bd1d9ddb04089700cf9c27f6f7426281&fltt=2&invt=2&wbp2u=8413067108550254%7C0%7C1%7C0%7Cweb&fid=f3&fs=b:MK0105&fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&_=1714570944470">https://57.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112407221764962597832_1714570944282&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=8413067108550254|0|1|0|web&amp;fid=f3&amp;fs=b:MK0105&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&amp;_=1714570944470</a></li>
<li>红筹股：<a target="_blank" rel="noopener" href="https://57.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112407221764962597832_1714570944286&pn=1&pz=20&po=1&np=1&ut=bd1d9ddb04089700cf9c27f6f7426281&fltt=2&invt=2&wbp2u=8413067108550254%7C0%7C1%7C0%7Cweb&fid=f3&fs=b:MK0102&fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&_=1714570944490">https://57.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112407221764962597832_1714570944286&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=8413067108550254|0|1|0|web&amp;fid=f3&amp;fs=b:MK0102&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&amp;_=1714570944490</a></li>
<li>红筹成分：<a target="_blank" rel="noopener" href="https://57.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112407221764962597832_1714570944286&pn=1&pz=20&po=1&np=1&ut=bd1d9ddb04089700cf9c27f6f7426281&fltt=2&invt=2&wbp2u=8413067108550254%7C0%7C1%7C0%7Cweb&fid=f3&fs=b:MK0111&fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&_=1714570944499">https://57.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112407221764962597832_1714570944286&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=8413067108550254|0|1|0|web&amp;fid=f3&amp;fs=b:MK0111&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&amp;_=1714570944499</a></li>
<li>国企股：<a target="_blank" rel="noopener" href="https://86.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112408726538243180275_1714550583811&pn=1&pz=20&po=1&np=1&ut=bd1d9ddb04089700cf9c27f6f7426281&fltt=2&invt=2&wbp2u=8413067108550254%7C0%7C1%7C0%7Cweb&fid=f3&fs=b:MK0103&fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&_=1714550583915">https://86.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112408726538243180275_1714550583811&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=8413067108550254|0|1|0|web&amp;fid=f3&amp;fs=b:MK0103&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&amp;_=1714550583915</a></li>
<li>国企成分股：<a target="_blank" rel="noopener" href="https://86.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112408726538243180275_1714550583811&pn=1&pz=20&po=1&np=1&ut=bd1d9ddb04089700cf9c27f6f7426281&fltt=2&invt=2&wbp2u=8413067108550254%7C0%7C1%7C0%7Cweb&fid=f3&fs=b:MK0112&fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&_=1714550583919">https://86.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112408726538243180275_1714550583811&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=8413067108550254|0|1|0|web&amp;fid=f3&amp;fs=b:MK0112&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&amp;_=1714550583919</a></li>
<li>股港股通成份股：<a target="_blank" rel="noopener" href="https://57.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112407221764962597832_1714570944286&pn=1&pz=20&po=1&np=1&ut=bd1d9ddb04089700cf9c27f6f7426281&fltt=2&invt=2&wbp2u=8413067108550254%7C0%7C1%7C0%7Cweb&fid=f3&fs=b:MK0146,b:MK0144&fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&_=1714570944503">https://57.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112407221764962597832_1714570944286&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=8413067108550254|0|1|0|web&amp;fid=f3&amp;fs=b:MK0146,b:MK0144&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&amp;_=1714570944503</a></li>
<li>人民币交易港股：<a target="_blank" rel="noopener" href="https://57.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112407221764962597832_1714570944286&pn=1&pz=20&po=1&np=1&ut=bd1d9ddb04089700cf9c27f6f7426281&fltt=2&invt=2&wbp2u=8413067108550254%7C0%7C1%7C0%7Cweb&fid=f3&fs=m:116+s:64&fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&_=1714570944509">https://57.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112407221764962597832_1714570944286&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=8413067108550254|0|1|0|web&amp;fid=f3&amp;fs=m:116+s:64&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&amp;_=1714570944509</a></li>
<li>AH股比价：<a target="_blank" rel="noopener" href="https://57.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112407221764962597832_1714570944286&pn=1&pz=20&po=1&np=1&ut=bd1d9ddb04089700cf9c27f6f7426281&fltt=2&invt=2&wbp2u=8413067108550254%7C0%7C1%7C0%7Cweb&fid=f3&fs=b:MK0101&fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f20,f21,f23,f24,f25,f22,f11,f62,f128,f136,f115,f152,f191,f192,f193,f186,f185,f187,f189,f188&_=1714570944513">https://57.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112407221764962597832_1714570944286&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=8413067108550254|0|1|0|web&amp;fid=f3&amp;fs=b:MK0101&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f20,f21,f23,f24,f25,f22,f11,f62,f128,f136,f115,f152,f191,f192,f193,f186,f185,f187,f189,f188&amp;_=1714570944513</a></li>
<li>香港指数：<a target="_blank" rel="noopener" href="https://86.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112408726538243180275_1714550583811&pn=1&pz=20&po=1&np=1&ut=bd1d9ddb04089700cf9c27f6f7426281&fltt=2&invt=2&wbp2u=8413067108550254%7C0%7C1%7C0%7Cweb&fid=f3&fs=m:124,m:125,m:305&fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&_=1714550583922">https://86.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112408726538243180275_1714550583811&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=8413067108550254|0|1|0|web&amp;fid=f3&amp;fs=m:124,m:125,m:305&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f20,f21,f23,f24,f25,f26,f22,f33,f11,f62,f128,f136,f115,f152&amp;_=1714550583922</a></li>
</ul>
</li>
<li>爬取港股历史数据（\spider\Get_HKStock\HKStockSpider().getxxHistory()）<ul>
<li>从各类港股基本信息表中获取股票代码替换secid，date为今日，查询其历史k线数据</li>
<li>一般情况，MySQL每张表最好不要超过2000万条数据，阿里的Java开发手册上也提出：单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。或者说，要根据实际场景分析。</li>
<li>港股日线数据(除A-H股价比，港股指数外)：<a target="_blank" rel="noopener" href="https://push2his.eastmoney.com/api/qt/stock/kline/get?cb=jQuery35106242902488344593_1714571208625&secid=116.%7Bsecid%7D&ut=fa5fd1943c7b386f172d6893dbfba10b&fields1=f1,f2,f3,f4,f5,f6&fields2=f51,f52,f53,f54,f55,f56,f57,f58,f59,f60,f61&klt=101&fqt=1&beg=0&end=20500101&smplmt=755&lmt=1000000&_=1714571208630">https://push2his.eastmoney.com/api/qt/stock/kline/get?cb=jQuery35106242902488344593_1714571208625&amp;secid=116.{secid}&amp;ut=fa5fd1943c7b386f172d6893dbfba10b&amp;fields1=f1%2Cf2%2Cf3%2Cf4%2Cf5%2Cf6&amp;fields2=f51%2Cf52%2Cf53%2Cf54%2Cf55%2Cf56%2Cf57%2Cf58%2Cf59%2Cf60%2Cf61&amp;klt=101&amp;fqt=1&amp;beg=0&amp;end=20500101&amp;smplmt=755&amp;lmt=1000000&amp;_=1714571208630</a></li>
<li>A-H股价比，港股指数日线数据先不弄。。</li>
</ul>
</li>
<li>数据更新（\spider\Update_HKStock.py）<ul>
<li>更新港股基本信息</li>
<li>更新港股历史数据</li>
<li>定时任务</li>
</ul>
</li>
<li>数据接口（Django实现）：以JSON形式返回各类港股历史数据到页面上，供其他的模块使用</li>
<li>数据下载（Django实现）：以JSON形式返回各类港股历史数据到页面上，右键“另存为”保存</li>
<li>数据维护</li>
</ol>
<h3 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h3><ul>
<li>项目结构 <img src="https://leo710aka.github.io/bk/datasite.png" width="550" height="300" alt=""></li>
</ul>
<h3 id="示例1：展示香港指数基本信息表-HKStockIndexinfo"><a href="#示例1：展示香港指数基本信息表-HKStockIndexinfo" class="headerlink" title="示例1：展示香港指数基本信息表 HKStockIndexinfo"></a><strong>示例1：展示香港指数基本信息表 HKStockIndexinfo</strong><img src="https://github.com/leo710aka/bk/blob/main/bishe1.png?raw=true" width="700" height="300" alt=""></h3><ol>
<li>编写model（datasite&#x2F;mainapp&#x2F;models.py）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HKStockIndexinfo</span>(models.Model):</span><br><span class="line">    code = models.CharField(max_length=<span class="number">12</span>, primary_key=<span class="literal">True</span>)  <span class="comment"># 假设code是主键</span></span><br><span class="line">    name = models.FloatField(max_length=<span class="number">20</span>, db_column=<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    now = models.FloatField(db_column=<span class="string">&#x27;now&#x27;</span>)</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        db_table = <span class="string">&#x27;HKStockIndexinfo&#x27;</span></span><br><span class="line">        managed = <span class="literal">False</span></span><br></pre></td></tr></table></figure></li>
<li>迁移，将 model与 MySQL中的表映射<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations  <span class="comment"># IDE console</span></span><br></pre></td></tr></table></figure></li>
<li>编写html（datasite&#x2F;mainapp&#x2F;templates&#x2F;hkstockindexinfo.html）<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>代码<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>名称<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    &#123;% for info in infos %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">&quot;color: #1e8ecc;&quot;</span>&gt;</span>&#123;&#123; info.code &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">&quot;color: #1e8ecc;&quot;</span>&gt;</span>&#123;&#123; info.name &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>编写应用请求（datasite&#x2F;mainapp&#x2F;views.py）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hkstockindexinfo</span>(<span class="params">request</span>):</span><br><span class="line">    infos = HKStockIndexinfo.objects.<span class="built_in">all</span>()                    <span class="comment"># 从MySQL中获取对应表的数据</span></span><br><span class="line">    context = &#123;<span class="string">&#x27;infos&#x27;</span>: infos&#125;                                <span class="comment"># 创建上下文字典</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;hkstockindexinfo.html&#x27;</span>, context)  <span class="comment"># 渲染模板</span></span><br></pre></td></tr></table></figure></li>
<li>配置路由（datasite&#x2F;datasite&#x2F;urls.py）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;hkstockindexinfo&#x27;</span>, views.hkstockindexinfo),  <span class="comment"># 不需要配置项目-应用两级url</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li>启动Django项目<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS E:\Code\datasite&gt; python manage.py runserver</span><br></pre></td></tr></table></figure></li>
<li>发送请求 <a target="_blank" rel="noopener" href="http://127.0.0.1:8000/hkstockindexinfo%EF%BC%8C">http://127.0.0.1:8000/hkstockindexinfo，</a> 展示香港指数基本信息表</li>
</ol>
<h3 id="示例2：使用Echart展示港股主板历史数据k线图"><a href="#示例2：使用Echart展示港股主板历史数据k线图" class="headerlink" title="示例2：使用Echart展示港股主板历史数据k线图"></a><strong>示例2：使用Echart展示港股主板历史数据k线图</strong><img src="https://github.com/leo710aka/bk/blob/main/bishe4.png?raw=true" width="700" height="300" alt=""></h3><ol>
<li>编写model（datasite&#x2F;mainapp&#x2F;models.py）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HKEXMainBoardhistory</span>(models.Model):</span><br><span class="line">    code = models.CharField(max_length=<span class="number">12</span>, primary_key=<span class="literal">True</span>)  <span class="comment"># 假设code是主键</span></span><br><span class="line">    date = models.CharField(max_length=<span class="number">10</span>, db_column=<span class="string">&#x27;date&#x27;</span>)</span><br><span class="line">    <span class="built_in">open</span> = models.FloatField(db_column=<span class="string">&#x27;open&#x27;</span>)</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        db_table = <span class="string">&#x27;HKEXMainBoardhistory&#x27;</span></span><br><span class="line">        managed = <span class="literal">False</span></span><br></pre></td></tr></table></figure></li>
<li>迁移，将 model与 MySQL中的表映射<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations  <span class="comment"># IDE console</span></span><br></pre></td></tr></table></figure></li>
<li>编写html（datasite&#x2F;mainapp&#x2F;templates&#x2F;historyklines.html）<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;% load static %&#125;  <span class="comment">&lt;!-- 在项目setting.py配置：STATIC_URL = &#x27;/static/&#x27; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>港股主板历史数据k线图<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入已经下载到本地/static/assets/js下的Echarts文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;&#123;% static &#x27;assets/js/echarts.js&#x27; %&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 1600px;height:800px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 从Echarts官网上复制K线图示例代码</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> chartDom = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;main&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> myChart = echarts.<span class="title function_">init</span>(chartDom);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> option;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 使用模板语言获取传递的 JSON 数据</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> jsonData = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="string">&#x27;&#123;&#123; jsonData | escapejs &#125;&#125;&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">splitData</span>(<span class="params">rawData</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// ...</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">renderItem</span>(<span class="params">params, api</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// ...</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 使用后端查询的数据，代替模版代码中原本外部引入的json文件</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> data = <span class="title function_">splitData</span>(jsonData);</span></span><br><span class="line"><span class="language-javascript">        myChart.<span class="title function_">setOption</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// ...</span></span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>编写应用请求（datasite&#x2F;mainapp&#x2F;views.py）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">historyklines</span>(<span class="params">request</span>):</span><br><span class="line">    code = request.GET.get(<span class="string">&#x27;code&#x27;</span>)  <span class="comment"># 获取请求中携带的code参数值</span></span><br><span class="line">    queryset = HKEXMainBoardhistory.objects.<span class="built_in">filter</span>(code=code)  <span class="comment"># 查询所有代码为 code 的数据</span></span><br><span class="line">    jsonData = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> queryset:  <span class="comment"># 构造二维数组</span></span><br><span class="line">        data_row = [</span><br><span class="line">            item.date, item.<span class="built_in">open</span>, item.now, item.low, item.high, item.volume</span><br><span class="line">        ]</span><br><span class="line">        jsonData.append(data_row)</span><br><span class="line">    jsonData_str = json.dumps(jsonData)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;historyklines.html&#x27;</span>, &#123;<span class="string">&#x27;jsonData&#x27;</span>: jsonData_str&#125;)</span><br></pre></td></tr></table></figure></li>
<li>配置路由（datasite&#x2F;datasite&#x2F;urls.py）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;historyklines&#x27;</span>, views.historyklines),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li>启动Django项目<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS E:\Code\datasite&gt; python manage.py runserver</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="示例3：提供数据接口供其他模块调用，下载历史数据"><a href="#示例3：提供数据接口供其他模块调用，下载历史数据" class="headerlink" title="示例3：提供数据接口供其他模块调用，下载历史数据"></a><strong>示例3：提供数据接口供其他模块调用，下载历史数据</strong><img src="https://github.com/leo710aka/bk/blob/main/bishe3.png?raw=true" width="700" height="300" alt=""></h3><ol>
<li>指的是xx股历史数据</li>
<li>编写Model、View，配置urls<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hkexmainboarddata</span>(<span class="params">request</span>):</span><br><span class="line">    code = request.GET.get(<span class="string">&#x27;code&#x27;</span>)</span><br><span class="line">    data = HKEXMainBoardhistory.objects.<span class="built_in">filter</span>(code=code)</span><br><span class="line">    data_dict_list = [&#123;<span class="string">&quot;code&quot;</span>: item.code, <span class="string">&quot;date&quot;</span>: item.date, <span class="string">&quot;open&quot;</span>: item.<span class="built_in">open</span>, <span class="string">&quot;now&quot;</span>: item.now,</span><br><span class="line">                       <span class="string">&quot;high&quot;</span>: item.high, <span class="string">&quot;low&quot;</span>: item.low, <span class="string">&quot;volume&quot;</span>: item.volume, <span class="string">&quot;amount&quot;</span>: item.amount,</span><br><span class="line">                       <span class="string">&quot;rate&quot;</span>: item.rate, <span class="string">&quot;changerate&quot;</span>: item.changerate, <span class="string">&quot;per&quot;</span>: item.per, <span class="string">&quot;zero&quot;</span>: item.zero&#125;</span><br><span class="line">                      <span class="keyword">for</span> item <span class="keyword">in</span> data]</span><br><span class="line">    <span class="comment"># 转换为 JSON 格式</span></span><br><span class="line">    data_json = json.dumps(data_dict_list)</span><br><span class="line">    <span class="comment"># 返回 JSON 响应</span></span><br><span class="line">    <span class="keyword">return</span> JsonResponse(data_json, safe=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure></li>
<li>查询页面：输入港股代码，点击“生成K线图”按钮发送xxklines请求&#x2F;点击“下载历史数据”展示历史数据（右键“另存为”下载）<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card &quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card-header&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span> <span class="attr">class</span>=<span class="string">&quot;card-title&quot;</span>&gt;</span>港股历史数据<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;myForm&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;codeInput&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 150px;&quot;</span>&gt;</span>请输入港股主板代码：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;codeInput&quot;</span> <span class="attr">name</span>=<span class="string">&quot;codeInput&quot;</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">id</span>=<span class="string">&quot;submitButton&quot;</span>&gt;</span>生成K线图<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">id</span>=<span class="string">&quot;submitButton0&quot;</span>&gt;</span>下载历史数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myForm&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;submit&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  event.<span class="title function_">preventDefault</span>(); <span class="comment">// 阻止表单默认提交行为</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 获取输入框中的内容</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> code = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;codeInput&#x27;</span>).<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">if</span> (event.<span class="property">submitter</span>.<span class="property">id</span> === <span class="string">&#x27;submitButton&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 构造生成K线图的请求URL</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> url = <span class="string">`http://127.0.0.1:8000/hkexmainboardklines?code=<span class="subst">$&#123;code&#125;</span>`</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 在新标签页中打开链接</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="title function_">open</span>(url, <span class="string">&#x27;_blank&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.<span class="property">submitter</span>.<span class="property">id</span> === <span class="string">&#x27;submitButton0&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 构造下载历史数据的请求URL</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> url = <span class="string">`http://127.0.0.1:8000/hkexmainboarddata?code=<span class="subst">$&#123;code&#125;</span>`</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 在新标签页中打开链接</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="title function_">open</span>(url, <span class="string">&#x27;_blank&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>

<h1 id="毕业答辩"><a href="#毕业答辩" class="headerlink" title="毕业答辩"></a>毕业答辩</h1><p>毕业答辩的意义是，校方为了进一步的审查论文。<br>考查内容可归纳如下：①进一步考查和验证毕业论文作者对所着论文论题的认识程度及当场论证论题的能力 ②进一步考查毕业论文作者对专业知识掌握的深度与广度 ③审查毕业论文是否学员自己独立完成<br>答辩时提问依据：①汇报PPT的内容 ②毕业论文的内容 ③汇报者的言语</p>
<h3 id="答辩安排"><a href="#答辩安排" class="headerlink" title="答辩安排"></a>答辩安排</h3><p>答辩日期：5月24日（13周周五），上午1-4节，8：50开始，预计到中午左右结束；<br>答辩地点：A4206<br>需携带资料:<br>1.答辩ppt 电子版（u盘）；2.一式3份双面打印的论文（最新版，不需要装帧封面）。<br>注意事项：<br>1.请大家提前半小时（上午8：20）到现场，调试好设备（电脑、投影仪、麦克风，等），所有的ppt都拷贝到指定电脑上（可以用课室的电脑，但建议至少带一台笔记本做备用）。<br>2.提前打印好3份毕设论文（简单的双面打印即可，不需要特别装帧封面，因为不是最终稿），答辩前统一交给老师翻阅。如果在答辩前对论文有修改，和提交系统的版本不一致也没关系，只要打印最新版就可以了。<br>3.每人答辩陈述时间5分钟左右（可以利用powerpoint的排练功能提前排练好），然后留3分钟左右回答老师的提问。<br>4.回答问题时要认真记录下老师提出的修改意见，并在答辩结束后按要求修改论文，然后提交论文最终版到维普系统；<br>5.答辩结束后，老师们会在维普系统上给论文和答辩过程打分，大家把论文最终版提交维普系统之后，可以直接从系统上下载并打印带有老师电子签名的各类表格（一般不需要找老师们手签）。最终版论文一定要装帧好封面，和全套打印的表格一起，按照顺序放入档案袋并交给导师。</p>
<h2 id="答辩内容"><a href="#答辩内容" class="headerlink" title="答辩内容"></a>答辩内容</h2><p>各位评委老师，同学们：<br>大家上午好! 我是<em>网络工程</em>专业的<em>蔡枫</em>，我的论文题目是<em><strong>基于内地与香港金融平台的在线量化投资的数据原型系统的设计与开发</strong></em>。<br>&lt;翻页&gt;<br>今天我将从以下四个方面阐述我的毕业论文内容。<br>&lt;翻页&gt;</p>
<h3 id="第一部分-选题背景及意义"><a href="#第一部分-选题背景及意义" class="headerlink" title="第一部分 选题背景及意义"></a>第一部分 选题背景及意义</h3><p>随着在线量化投资的普及，如何有效地收集和整理海量的互联网金融数据，成为了一大挑战。<br>&lt;翻页&gt;<br>一方面，互联网数据具有实时性，导致用户和金融公司都难以检索过去特定时间的完整金融数据。<br>另一方面，人们需花费大量时间在门户网站浏览实时金融信息，但缺乏明确直观的数据分析结果。<br>&lt;翻页&gt;<br>为有效解决以上问题，本论文设计并开发了基于网络爬虫的数据原型系统，实时获取互联网上的金融数据，并提供数据下载的功能。<br>另外，系统提供了数据可视化和数据分析的功能，用户能够从中获取具有参考价值的信息。<br>以及，作为综合性金融系统中的底层数据平台，能够为其他模块的开发提供数据源。<br>&lt;翻页&gt;</p>
<h3 id="第二部分-开发环境与技术"><a href="#第二部分-开发环境与技术" class="headerlink" title="第二部分 开发环境与技术"></a>第二部分 开发环境与技术</h3><p>&lt;翻页&gt;<br>首先介绍一下网络爬虫，其通过模拟人类浏览网页的行为，获取并解析网络信息。<br>&lt;翻页&gt;<br>如果目标网站提供了 API 接口，我们可以通过浏览器的开发者工具进行抓包，并在Python项目中直接调用以获取数据。<br>&lt;翻页&gt;<br>系统的开发语言为 Python，采用 Django 框架结合前端技术进行 Web 应用的构建。通过编写 MTV 三层架构代码，开发子系统的各功能。<br>&lt;翻页&gt;<br>本系统中选择 MySQL 作为数据库，存储爬取到的网络金融数据，以及进行后续的功能开发。<br>&lt;翻页&gt;<br>本系统的数据库中主要有两种表，即各类港股基本信息表和港股历史数据表。<br>&lt;翻页&gt;<br>在港股基本信息表中，包括股票代码、股票名称、最新价、涨跌额等基本信息，另外还添加了 date_updated 字段，以便在更新历史数据表时计算出所需更新数据的时间段。<br>&lt;翻页&gt;<br>在港股历史数据表中，保存了表示K线数据的相关字段。<br>&lt;翻页&gt;</p>
<h3 id="第三部分-系统设计与实现"><a href="#第三部分-系统设计与实现" class="headerlink" title="第三部分 系统设计与实现"></a>第三部分 系统设计与实现</h3><p>&lt;翻页&gt;<br>本文的数据原型系统是作为综合性金融系统底层的数据平台模块进行开发的，其他的量化因子分析模块和量化投资策略模块由小组成员负责开发。<br>&lt;翻页&gt;<br>在底层的数据平台，即本文的数据原型系统中，保存了香港金融市场股票的交易数据，包括了数据库建设模块、数据可视化模块、数据接口模块、数据分析模块这四个模块。<br>&lt;翻页&gt;<br>在数据库建设模块中，主要有三个程序，分别用于创建数据库和表，初始化表数据，以及更新表数据。<br>其中更新程序是利用 schedule 库，设置定时任务16点实时更新数据到各类港股基本信息表中，根据基本信息表中的的股票代码和更新时间，获取其自更新时间至今的K线数据添加到对应的表中同时修改“更新时间”为当日，以及定期对表执行“转储SQL”操作进行数据备份，以便在需要时快速重构。<br>&lt;翻页&gt;<br>在数据可视化模块中，提供了基本信息表格功能。点击子系统导航栏，选择港股类型，在子系统界面上对应的基本信息数据。<br>&lt;翻页&gt;<br>实现的基本步骤为：编写模型与数据库表映射，编写视图接收请求和模版页面，并配置好请求访问路径，即可通过浏览器访问系统功能。<br>&lt;翻页&gt;<br>另外，提供了历史数据K线图展示功能，根据前端输入的各类港股股票代码，从数据库中获取数据，并利用 ECharts 生成历史数据K线图。<br>&lt;翻页&gt;<br>其实现步骤类似前面介绍的基本信息表格。<br>&lt;翻页&gt;<br>在数据接口模块中，复用了历史数据K线图功能的功能界面和业务代码，根据输入的各类港股股票代码，从数据库中对应的历史数据表中获取数据，以JSON形式返回到新标签页面上。<br>&lt;翻页&gt;<br>数据可以供综合性金融系统中的其他模块使用，用户也可以在页面上右键“另存为”下载数据文件。<br>&lt;翻页&gt;<br>最后是数据分析模块：对于采集的金融数据作进一步的分析，呈现更直观和更有价值的信息。我们另外爬取了内地市场沪深京A股的数据，对比分析凸显港陆市场的数据差别。<br>&lt;翻页&gt;<br>首先，对于港股与沪深京A股，计算基本统计描述。<br>&lt;翻页&gt;<br>可以简单分析看出，香港市场在股价波动性和交易量方面普遍较大，呈现出更高的市场活力和波动性；<br>内地市场的平均股价虽然较低，但交易量和交易金额却相对较高，显示出更为稳定的交易情况。<br>&lt;翻页&gt;<br>然后进一步进行各类数据的可视化分析。我们进行了收盘价分布统计，这是放大后。。<br>&lt;翻页&gt;<br>然后是涨跌幅分布比较。。<br>&lt;翻页&gt;</p>
<h3 id="第四部分-总结与展望"><a href="#第四部分-总结与展望" class="headerlink" title="第四部分 总结与展望"></a>第四部分 总结与展望</h3><p>&lt;翻页&gt;<br>本次毕业设计的工作涵盖了搭建数据原型系统的各个方面，包括金融数据库的设计、系统前端和后端的开发等。<br>（数据采集：直接从东方财富网接口获取金融数据，并通过数据清洗和整理存储到数据库中。在开发时使用了大模型进行数据含义的分析和编写数据清洗代码，极大地提高了开发效率。对于前端的编写，同组的同学提供了模板，为开发带来了很大的便利。只需开发子系统功能界面，将模板页面中空缺内容区块覆盖。在系统后端的开发过程中，我快速学习了Django的开发流程，进行需求分析和功能设计后，解决实际开发问题，同时总结经验完善系统。）<br>同时，对于这几个方面，未来还有需要改进的地方。<br>&lt;翻页&gt;<br>对于这几个方面，未来也有需要改进的地方，如加强数据采集时对异常情况的处理，优化系统前后端性能等。。<br>（在数据采集方面，引入多线程实现对数据的并行处理，另外还需加强对异常情况的处理，确保系统稳健运行。在系统前端方面，进一步完善用户界面的设计和用户体验，考虑引入前端框架如React、Vue.js等，以提升前端开发的效率和灵活性，提供更加直观和友好的数据展示方式。在系统后端方面，不断优化系统架构和性能，加强对系统的监控和管理，及时发现和解决潜在的问题，确保系统长期稳定运行。）<br>&lt;翻页&gt;<br>最后感谢各位老师的聆听及指导，我的汇报到此结束。</p>
<h3 id="问答环节"><a href="#问答环节" class="headerlink" title="问答环节"></a>问答环节</h3><ol>
<li>为什么会选择这个课题?<br>(自身原因+外部因素&#x3D;选择的原因，把选择的原因放大，从多角度回答)<br>我认为计算机金融有潜力，以及量化投资的研究在当下是非常有价值的，有很强的现实意义，其中数据平台的构建是基石。<br>本次毕业设计的工作涵盖了搭建数据原型系统的各个方面，包括金融数据库的设计、系统前端和后端的搭建等，提供一种快速构建的思路。</li>
<li>论文的创新点体现在哪里?<br>(通过和已有成果或内容相比较,从内容和研究方法上来讲创新。)<br>回答参考:本篇毕业论文的创新之处在于讨论 xxx 的问题时不仅在 xxx 方面列出xxx，也从实际的角度进行了举例论证。一是在方法上，本文将Xx方法与XX方法相结合,能够有效消除单一方法带来的误差,有效提高了数据的精度(结果的有效性)。二是在理论上，综合近十年的文献发现，目前还没有研究学者提出 xXX方面的内容，本文在理论的提出上是一种全新的尝试</li>
<li>本论文中你主要做了什么?<br>查找了大量的文献、书籍报刊，对这些资料进行了精谀，结合国内外的研究现状，对 xxx问题进行了归纳总结;在此基础上，提炼出本课题的核心，对xxx展开研究，并运用 xxx 方法进行研究;对xxx 研究结果进行分析，提出 solvexxx 问题的建议及措施。</li>
<li>本论文的意义和目的是什么?<br>(理论意义+实践意义)在理论方面，本文应用了 Xxx的专业方法，对于丰富果，并以具体的 xxx 例子展开应用得到较好的应用结果。</li>
<li>写论文的过程中有哪些困难，怎么克服的?<br>(如实叙即可，但一定要说问题是 solve 的!)<br>在撰写论文的过程中在xx方面(资料收集问卷发放实验开展)遇到有关 xxx(找不到相应主题的学术文献)困难，在与指导老师沟通后，查阅了老师推。荐的相关书籍、资料以及文献信息，也请教了直系的学长学姐们，最后 solve 了相关问题，在此也非常感谢给我提供帮助的他们。</li>
<li>论文哪些地方可以继续改进?<br>目前对于这个课题的认识确实还不够具体，所以在xxx 方萄的研究片法有一定限度，研究成果与前辈们的研究成果也确实相似，没有做到能够更加深入的研究。同时也受限于条件没能更多的试验方法</li>
<li>论文中的数据和资料从哪里来?<br>我的资料主要来自于知网等学术网站和导师提供的资料文献，数据是通过调查法以及些同类课题的数据参考,再统一分析计算得出</li>
<li>论文中相关定义的解释，理论解释?<br>要求你掌握本文研究中重点的一些概念及定义。有一些概率可以做一些生活中的举例来加深记忆。回答的时候也可以根据定义来加以拓展，比如:老师，这个问题我是这样理解的，以生活中的案例来举例 xxx 概念就好。比 XXX中的XXXX，对xxx是非常重要的。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/05/01/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/" data-id="cm0cja96q000qm4v52j0b3msp" data-title="毕 业 设 计" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-RabbitMQ" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/11/RabbitMQ/" class="article-date">
  <time class="dt-published" datetime="2024-01-11T02:58:11.000Z" itemprop="datePublished">2024-01-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/11/RabbitMQ/">RabbitMQ</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="一、初识MQ"><a href="#一、初识MQ" class="headerlink" title="一、初识MQ"></a>一、初识MQ</h1><h4 id="1-同步和异步通讯"><a href="#1-同步和异步通讯" class="headerlink" title="1. 同步和异步通讯"></a>1. 同步和异步通讯</h4><p>微服务间通讯有同步和异步两种方式：<br>1、同步通讯：就像打电话，需要实时响应；<br>2、异步通讯：就像发邮件，不需要马上回复。<br>两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发送邮件可以同时与多个人收发邮件，但是往往响应会有延迟。<img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717161939695.png?raw=true" width="700" height="200"> </p>
<ol>
<li><p><strong>同步通讯</strong><br> 我们之前学习的Feign调用就属于同步方式，虽然调用可以实时得到结果，但存在下面的问题：<img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717162004285.png?raw=true" width="700" height="200"><br> 同步调用的优点：</p>
<ul>
<li>时效性较强</li>
<li>可以立即得到结果</li>
</ul>
<p> 同步调用的问题：</p>
<ul>
<li>耦合度高</li>
<li>性能和吞吐能力下降</li>
<li>有额外的资源消耗</li>
<li>有级联失败问题</li>
</ul>
</li>
<li><p><strong>异步通讯</strong>：常见实现是事件驱动模式<br> 异步调用则可以避免上述问题：我们以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，调用物流服务，从仓库分配响应的库存并准备发货。<br> 在事件模式中，支付服务是事件发布者（publisher），在支付完成后只需要发布一个支付成功的事件（event），事件中带上订单id。订单服务和物流服务是事件订阅者（Consumer），订阅支付成功的事件，监听到事件后完成自己业务即可。为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个中间人（Broker）。发布者发布事件到Broker，不关心谁来订阅事件。订阅者从Broker订阅事件，不关心谁发来的消息。<img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210422095356088.png?raw=true"><br> Broker 是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。</p>
<p> <strong>好处：</strong></p>
<ul>
<li>吞吐量提升：无需等待订阅者处理完成，响应更快速</li>
<li>故障隔离：服务没有直接调用，不存在级联失败问题</li>
<li>调用间没有阻塞，不会造成无效的资源占用</li>
<li>耦合度极低，每个服务都可以灵活插拔，可替换</li>
<li>流量削峰：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件</li>
</ul>
<p> <strong>缺点：</strong></p>
<ul>
<li>架构复杂了，业务没有明显的流程线，不好管理；</li>
<li>需要依赖于Broker的可靠、安全、性能<br> 好在现在开源软件或云平台上 Broker 的软件是非常成熟的，比较常见的一种就是我们今天要学习的MQ技术。</li>
</ul>
</li>
</ol>
<h4 id="2-技术对比"><a href="#2-技术对比" class="headerlink" title="2. 技术对比"></a>2. 技术对比</h4><p>MQ，中文是消息队列（MessageQueue），字面来看就是存放消息的队列。也就是事件驱动架构中的Broker。<br>比较常见的MQ实现：ActiveMQ，RabbitMQ，RocketMQ，Kafka。几种常见MQ的对比：</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>RabbitMQ</strong></th>
<th><strong>ActiveMQ</strong></th>
<th><strong>RocketMQ</strong></th>
<th><strong>Kafka</strong></th>
</tr>
</thead>
<tbody><tr>
<td>公司&#x2F;社区</td>
<td>Rabbit</td>
<td>Apache</td>
<td>阿里</td>
<td>Apache</td>
</tr>
<tr>
<td>开发语言</td>
<td>Erlang</td>
<td>Java</td>
<td>Java</td>
<td>Scala&amp;Java</td>
</tr>
<tr>
<td>协议支持</td>
<td>AMQP，XMPP，SMTP，STOMP</td>
<td>OpenWire,STOMP，REST,XMPP,AMQP</td>
<td>自定义协议</td>
<td>自定义协议</td>
</tr>
<tr>
<td>可用性</td>
<td>高</td>
<td>一般</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>单机吞吐量</td>
<td>一般</td>
<td>差</td>
<td>高</td>
<td>非常高</td>
</tr>
<tr>
<td>消息延迟</td>
<td>微秒级</td>
<td>毫秒级</td>
<td>毫秒级</td>
<td>毫秒以内</td>
</tr>
<tr>
<td>消息可靠性</td>
<td>高</td>
<td>一般</td>
<td>高</td>
<td>一般</td>
</tr>
</tbody></table>
<p>追求可用性：Kafka、 RocketMQ 、RabbitMQ</p>
<p>追求可靠性：RabbitMQ、RocketMQ</p>
<p>追求吞吐能力：RocketMQ、Kafka</p>
<p>追求消息低延迟：RabbitMQ、Kafka</p>
<h1 id="二、快速入门"><a href="#二、快速入门" class="headerlink" title="二、快速入门"></a>二、快速入门</h1><h4 id="1-安装RabbitMQ"><a href="#1-安装RabbitMQ" class="headerlink" title="1. 安装RabbitMQ"></a>1. 安装RabbitMQ</h4><!-- 安装RabbitMQ，参考课前资料：![](https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717162628635.png?raw=true) -->
<p>MQ的基本结构：<img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717162752376.png?raw=true"><br>RabbitMQ中的一些角色：</p>
<ul>
<li>publisher：生产者</li>
<li>consumer：消费者</li>
<li>exchange：交换机，负责消息路由</li>
<li>queue：队列，存储消息</li>
<li>virtualHost：虚拟主机，隔离不同租户的exchange、queue、消息的隔离</li>
</ul>
<h4 id="2-RabbitMQ消息模型"><a href="#2-RabbitMQ消息模型" class="headerlink" title="2. RabbitMQ消息模型"></a>2. RabbitMQ消息模型</h4><!-- RabbitMQ官方提供了5个不同的Demo示例，对应了不同的消息模型： -->
<p><img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717163332646.png?raw=true"></p>
<h4 id="3-导入Demo工程"><a href="#3-导入Demo工程" class="headerlink" title="3. 导入Demo工程"></a>3. 导入Demo工程</h4><!-- 课前资料提供了一个Demo工程，mq-demo:![](https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717163253264.png?raw=true)
导入后可以看到结构如下： -->
<p><img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717163604330.png?raw=true"><br>包括三部分：</p>
<ul>
<li>mq-demo：父工程，管理项目依赖</li>
<li>publisher：消息的发送者</li>
<li>consumer：消息的消费者</li>
</ul>
<h4 id="4-入门案例"><a href="#4-入门案例" class="headerlink" title="4. 入门案例"></a>4. 入门案例</h4><p>简单队列模式的模型图：<img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717163434647.png?raw=true" width="700" height="200"><br>官方的HelloWorld是基于最基础的消息队列模型来实现的，只包括三个角色：</p>
<ul>
<li>publisher：消息发布者，将消息发送到队列queue</li>
<li>queue：消息队列，负责接受并缓存消息</li>
<li>consumer：订阅队列，处理队列中的消息</li>
</ul>
<ol>
<li>publisher实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PublisherTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMessage</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 1.1.设置连接参数，分别是：主机名（改成自己的ip）、端口号、vhost、用户名、密码</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.150.101&quot;</span>); </span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2.建立连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建通道Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.发送消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, rabbitmq!&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;发送消息成功：【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.关闭通道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>consumer实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.150.101&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2.建立连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建通道Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.订阅消息</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span><br><span class="line"><span class="params">                                       AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="comment">// 5.处理消息</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">                System.out.println(<span class="string">&quot;接收到消息：【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息。。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
消息被消费后，就消失（阅后即焚）</li>
</ol>
<hr>

<h1 id="三、SpringAMQP"><a href="#三、SpringAMQP" class="headerlink" title="三、SpringAMQP"></a>三、SpringAMQP</h1><p>SpringAMQP 是基于 RabbitMQ 封装的一套模板，并且还利用 SpringBoot 对其实现了自动装配，使用起来非常方便。<br>SpringAMQP提供了三个功能：</p>
<ul>
<li>自动声明队列、交换机及其绑定关系</li>
<li>基于注解的监听器模式，异步接收消息</li>
<li>封装了RabbitTemplate工具，用于发送消息 <img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717164024967.png?raw=true" width="400" height="200">
<img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717164038678.png?raw=true" width="400" height="200"></li>
</ul>
<h4 id="1-Basic-Queue-简单队列模型"><a href="#1-Basic-Queue-简单队列模型" class="headerlink" title="1. Basic Queue 简单队列模型"></a>1. Basic Queue 简单队列模型</h4><p>在父工程mq-demo中引入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>消息发送<br>首先配置MQ地址，在publisher服务的application.yml中添加配置：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">itcast</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure>
然后在publisher服务中编写测试类SpringAmqpTest，并利用RabbitTemplate实现消息发送：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAmqpTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSimpleQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 队列名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        <span class="comment">// 消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, spring amqp!&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>消息接收<br>首先配置MQ地址，在consumer服务的application.yml中添加配置：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">itcast</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure>
然后在consumer服务的<code>cn.itcast.mq.listener</code>包中新建一个类SpringRabbitListener，代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringRabbitListener</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;spring 消费者接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="2-WorkQueue"><a href="#2-WorkQueue" class="headerlink" title="2. WorkQueue"></a>2. WorkQueue</h4><p>Work queues，也被称为（Task queues），任务模型。简单来说就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。<br>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。此时就可以使用 work 模型，多个消费者共同处理消息处理，速度就能大大提高了。<img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717164238910.png?raw=true" width="400" height="200"></p>
<ol>
<li>消息发送：在publisher服务中的SpringAmqpTest类中添加一个测试方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * workQueue</span></span><br><span class="line"><span class="comment">     * 向队列中不停发送消息，模拟消息堆积。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWorkQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, message_&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message + i);</span><br><span class="line">        Thread.sleep(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>消息接收：要模拟多个消费者绑定同一个队列，我们在consumer服务的SpringRabbitListener中添加2个新的方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue1</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">20</span>);``</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue2</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;消费者2........接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">200</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>测试：启动ConsumerApplication后，在执行publisher服务中刚刚编写的发送测试方法testWorkQueue。<br>可以看到消费者1很快完成了自己的25条消息。消费者2却在缓慢的处理自己的25条消息。也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。这样显然是有问题的。<br>在spring中有一个简单的配置，可以解决这个问题。我们修改consumer服务的application.yml文件，添加配置：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="3-发布-订阅"><a href="#3-发布-订阅" class="headerlink" title="3. 发布&#x2F;订阅"></a>3. 发布&#x2F;订阅</h4><p>发布订阅的模型如图：<img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717165309625.png?raw=true" width="500" height="200"><br>可以看到，在订阅模型中，多了一个exchange角色，而且过程略有变化：</p>
<ul>
<li>Publisher：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）</li>
<li>Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有以下3种类型：<ul>
<li>Fanout：广播，将消息交给所有绑定到交换机的队列</li>
<li>Direct：定向，把消息交给符合指定routing key 的队列</li>
<li>Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</li>
</ul>
</li>
<li>Consumer：消费者，与以前一样，订阅队列，没有变化</li>
<li>Queue：消息队列也与以前一样，接收消息、缓存消息。</li>
</ul>
<p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！<br>这样，实现了一个消息发送给多个消费者。</p>
<h4 id="4-Fanout"><a href="#4-Fanout" class="headerlink" title="4. Fanout"></a>4. Fanout</h4><p>在广播模式下，消息发送流程是这样的：</p>
<ul>
<li>1）  可以有多个队列</li>
<li>2）  每个队列都要绑定到Exchange（交换机）</li>
<li>3）  生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定</li>
<li>4）  交换机把消息发送给绑定过的所有队列</li>
<li>5）  订阅队列的消费者都能拿到消息</li>
</ul>
<p>我们的计划是这样的：</p>
<ul>
<li>创建一个交换机 itcast.fanout，类型是Fanout</li>
<li>创建两个队列fanout.queue1和fanout.queue2，绑定到交换机itcast.fanout<img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717165509466.png?raw=true" width="500" height="200"></li>
</ul>
<ol>
<li>声明队列和交换机<br>Spring提供了一个接口Exchange，来表示所有不同类型的交换机：<img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717165552676.png?raw=true"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在consumer中创建一个类，声明队列和交换机</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Fanout类型交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span>&#123;    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;itcast.fanout&quot;</span>);    &#125;</span><br><span class="line">    <span class="comment">// 队列1，绑定交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue1</span><span class="params">()</span>&#123;    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue1&quot;</span>);    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1</span><span class="params">(Queue fanoutQueue1, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 队列2，绑定交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue2</span><span class="params">()</span>&#123;    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue2&quot;</span>);    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2</span><span class="params">(Queue fanoutQueue2, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>消息发送<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在publisher服务的SpringAmqpTest类中添加测试方法</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFanoutExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;itcast.fanout&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, everyone!&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送到交换机</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>消息接收<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在consumer服务的SpringRabbitListener中添加两个方法，作为消费者</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue1</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue2</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="5-Direct"><a href="#5-Direct" class="headerlink" title="5. Direct"></a>5. Direct</h4><p>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。<br>在Direct模型下：</p>
<ul>
<li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>BindingKey</code>（路由key）</li>
<li>消息的发送方在 向 Exchange发送消息时，必须指定消息的 <code>RoutingKey</code>。</li>
<li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>RoutingKey</code>进行判断，只有队列的<code>Bindingkey</code>与消息的 <code>Routingkey</code>完全一致，才会接收到消息</li>
<li>一个队列可以有多个BindingKey。如果多个队列具有相同的RoutingKey，则与Fanout功能类似(可以模拟广播)<br><img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717170223317.png?raw=true"></li>
</ul>
<ol>
<li>基于注解声明队列和交换机<br>基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。<br>在consumer的SpringRabbitListener中添加两个消费者，同时基于注解 <code>@RabbitListener</code> 来声明队列和交换机：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消费者1+队列+交换机+BindingKey</span></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到direct.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消费者2+队列+交换机+BindingKey</span></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到direct.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>消息发送<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendDirectExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;itcast.direct&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息，携带 RoutingKey</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;red&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="6-Topic"><a href="#6-Topic" class="headerlink" title="6.Topic"></a>6.Topic</h4><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候使用通配符！<br><code>Routingkey</code> 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code><br>通配符规则：<code>#</code>：匹配一个或多个词；<code>*</code>：匹配不多不少恰好1个词<br>举例：<code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code>；<code>item.*</code>：只能匹配<code>item.spu</code>  ​<br><img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20210717170705380.png?raw=true"><br>解释：</p>
<ul>
<li>Queue1：绑定的是<code>china.#</code> ，因此凡是以 <code>china.</code>开头的<code>routing key</code> 都会被匹配到。包括china.news和china.weather</li>
<li>Queue2：绑定的是<code>#.news</code> ，因此凡是以 <code>.news</code>结尾的 <code>routing key</code> 都会被匹配。包括china.news和japan.news</li>
</ul>
<ol>
<li>消息发送<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;china.news&quot;</span>, message);</span><br></pre></td></tr></table></figure></li>
<li>消息接收<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;china.#&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br></pre></td></tr></table></figure></li>
<li>总结<br> 描述下Direct交换机与Topic交换机的差异？<ul>
<li>Topic交换机接收的消息RoutingKey必须是多个单词，以 <code>.</code> 分割</li>
<li>Topic交换机与队列绑定时的bindingKey可以指定通配符</li>
<li><code>#</code>：代表0个或多个词</li>
<li><code>*</code>：代表1个词</li>
</ul>
</li>
</ol>
<h4 id="7-消息转换器"><a href="#7-消息转换器" class="headerlink" title="7.消息转换器"></a>7.消息转换器</h4><p>之前说过，Spring会把你发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。</p>
<p><img src="https://github.com/leo710aka/bk/blob/main/rabbitmq/assets/image-20200525170410401.png?raw=true" alt="image-20200525170410401"></p>
<p>只不过，默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：</p>
<ul>
<li>数据体积过大</li>
<li>有安全漏洞</li>
<li>可读性差</li>
</ul>
<p>显然，JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。</p>
<p>在publisher和consumer两个服务中都引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置消息转换器。在启动类中添加一个Bean即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">jsonMessageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/11/RabbitMQ/" data-id="cm0cja96i000gm4v5ha7mg6ch" data-title="RabbitMQ" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-SpringCloud" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/07/SpringCloud/" class="article-date">
  <time class="dt-published" datetime="2024-01-07T02:58:11.000Z" itemprop="datePublished">2024-01-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/07/SpringCloud/">SpringCloud</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>单体架构</strong>：将业务的所有功能集中在一个项目中开发，打成一个包部署。优点：架构简单、部署成本低。缺点：耦合度高，扩展性差，适合小型项目。例如:学生管理系统<br><strong>分布式架构</strong>：根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务。松耦合，扩展性好，但架构复杂，难度大。适合大型互联网项目，例如:京东、淘宝<br>分布式架构的要考虑的问题有：服务拆分粒度如何？服务集群地址如何维护？服务之间如何实现远程调用？服务健康状态如何感知？<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/3.png?raw=true?raw=true" width="500" height="200"> </p>
<h2 id="微服务：一种良好的分布式架构方案。"><a href="#微服务：一种良好的分布式架构方案。" class="headerlink" title="微服务：一种良好的分布式架构方案。"></a>微服务：一种良好的分布式架构方案。</h2><ul>
<li>优点：拆分粒度更小、服务更独立、耦合度更低。缺点：架构非常复杂，运维、监控、部署难度提高</li>
<li>微服务特点：<ul>
<li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责，避免重复业务开发；每个服务单元都可以独立开发、部署、扩展和管理。这些服务单元相互协作，通过网络进行通信，通常使用轻量级的通信机制（如HTTP或消息队列）进行交互。使得应用程序更具弹性、可扩展性和灵活性，同时也有利于团队之间的独立开发和部署。</li>
<li>面向服务：微服务对外暴露业务接口，供其他微服务使用。</li>
<li>自治：团队独立、技术独立、数据独立、部署独立，不同微服务都应该有自己的数据库。</li>
<li>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题。<img src="https://github.com/leo710aka/bk/blob/main/springcloud/1.png?raw=true?raw=true" width="700" height="200"> 
再加上服务异常定位、节点状态监控、自动化部署
<img src="https://github.com/leo710aka/bk/blob/main/springcloud/2.png?raw=true?raw=true" width="700" height="200"></li>
</ul>
</li>
</ul>
<p>微服务这种方案需要技术框架来落地，全球的互联网公司都在积极尝试自己的微服务落地技术。在国内最知名的就是SpringCloud和阿里巴巴的Dubbo（升级SpringCloudAlibaba（实现了SpringCloud接口，是SpringCloud的一部分））微服务技术对比：<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/4.png?raw=true?raw=true" width="700" height="200"><br>企业中常见的四种需求：<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/5.png?raw=true?raw=true" width="700" height="200"> </p>
<hr>

<h2 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h2><p>SpringCloud 是一个基于 Spring Boot 的开源框架，旨在简化构建分布式系统中的微服务架构。它提供了一系列工具和库，用于实现微服务架构中常见的模式和功能，如服务发现、负载均衡、配置管理、断路器模式、消息总线等。<br>SpringCloud 集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验:<img src="https://github.com/leo710aka/bk/blob/main/springcloud/6.png?raw=true" width="600" height="200"><br>对于 SpringBoot 的版本要求 <img src="https://github.com/leo710aka/bk/blob/main/springcloud/8.png?raw=true" width="600" height="200">  </p>
<ul>
<li>服务拆分<ul>
<li>微服务需要根据业务模块拆分，做到单一职责，避免重复业务开发；</li>
<li>微服务可以将业务暴露为接口，供其他微服务使用。</li>
<li>不同微服务都应该有自己的数据库。</li>
</ul>
</li>
<li>项目结构<ul>
<li>两种工程结构<ul>
<li>独立 Project：？？</li>
<li>Maven 聚合：每个微服务作为 主Project 中的一个模块 Module，分别独立打包部署运行，只不过代码放在一个 Project</li>
</ul>
</li>
<li>cloud-demo：父工程，管理依赖<ul>
<li>order-service：订单微服务，负责订单相关业务</li>
<li>user-service：用户微服务，负责用户相关业务</li>
<li>在每个模块的 application.yaml 配置该微服务名字、端口号、数据库、日志位置、、</li>
<li>要求：订单微服务和用户微服务都必须有各自的数据库，相互独立；订单服务和用户服务都对外暴露Restful的接口；订单服务如果需要查询用户信息，只能调用用户服务的Restful接口，不能查询用户数据库  <img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210713211009593.png?raw=true" width="200" height="200"></li>
</ul>
</li>
</ul>
</li>
<li>远程调用<ul>
<li>物理上两个微服务隔离，无法查询各自数据库，但网络上微服务相通</li>
<li>在一个微服务中，通过java代码发送 http 请求，使用另一个微服务的接口以获取其数据库中的数据</li>
<li>在一个微服务的启动类（本身也是配置类）中注册 RestTemplate，配置成 Bean；</li>
<li>在 service 中注入 restTemplate（建议使用构造函数），通过 getForObject(“url”) 发送http请求，将返回的 json 数据转换为制定对象类型</li>
</ul>
</li>
</ul>
<h3 id="Eureka-服务注册中心（白雪）"><a href="#Eureka-服务注册中心（白雪）" class="headerlink" title="Eureka 服务注册中心（白雪）"></a>Eureka 服务注册中心（白雪）</h3><ul>
<li>在 Eureka 架构中，微服务角色有两类:<ul>
<li>EurekaServer:服务端，注册中心。记录服务信息、心跳监控</li>
<li>EurekaClient:客户端<ul>
<li>Provider:服务提供者，例如案例中的 user-service，注册自己的信息到 EurekaServer，每隔30秒向EurekaServer发送心跳</li>
<li>consumer:服务消费者，例如案例中的 order-service，根据服务名称从 EurekaServer 拉取服务列表，基于服务列表做负载均衡，选中一个微服务后发起远程调用</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://github.com/leo710aka/bk/blob/main/springcloud/7.png?raw=true?raw=true" width="500" height="200">  

<ul>
<li>Eureka的作用<ul>
<li>消费者该如何获取服务提供者具体信息? 服务提供者启动时向 eureka 注册自己的信息，eureka 保存这些信息，消费者根据服务名称向 eureka 拉取提供者信息</li>
<li>如果有多个服务提供者，消费者该如何选择? 服务消费者利用负载均衡算法，从服务列表中挑选一个</li>
<li>消费者如何感知服务提供者健康状态? 服务提供者会每隔30秒向 EurekaServer 发送心跳请求，报告健康状态 eureka 会更新记录服务列表信息，心跳不正常会被剔除，消费者就可以拉取到最新的信息</li>
</ul>
</li>
<li>Eureka 服务搭建：Eruka 自己就是一个微服务。新建项目，引入 eureka-server 依赖；编写启动类，添加 @EnableEurekaServer 注解；添加 application.yml，添加配置</li>
<li>Eureka 服务注册：把一个微服务注册到 EurekaServer。<ol>
<li>微服务项目引入 eureka-client 依赖，</li>
<li>在 application.yml 编写依赖：name、url…</li>
</ol>
</li>
<li>Eureka 服务发现：<br>  服务拉取是（服务A）基于（服务B）服务名称获取（服务B多个实例）服务列表，然后在对服务列表做负载均衡<ol>
<li>修改 orderService（服务B）的代码，修改访问的 userService 的url路径，用服务名代替ip、端口，消除硬编码:  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span><span class="string">&quot;http://userservice/user/&quot;</span> + order.getUserId();</span><br></pre></td></tr></table></figure></li>
<li>在 order-service 项目（服务B）的启动类 OrderApplication中 的 RestTemplate 添加负载均衡注解  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="Ribbon-负载均衡（白雪）"><a href="#Ribbon-负载均衡（白雪）" class="headerlink" title="Ribbon 负载均衡（白雪）"></a>Ribbon 负载均衡（白雪）</h2><ul>
<li>负载均衡原理<ul>
<li>加了 @LoadBalanced 注解的RestTemplate，发送的请求将会被 Ribbon 拦截（SpringCloudRibbon的底层采用了一个拦截器），对地址做了修改，处理后发送 HTTP 请求<br>  基本流程如下：<ul>
<li>拦截我们的RestTemplate请求<a target="_blank" rel="noopener" href="http://userservice/user/1">http://userservice/user/1</a></li>
<li>RibbonLoadBalancerClient会从请求url中获取服务名称，也就是user-service</li>
<li>DynamicServerListLoadBalancer根据user-service到eureka拉取服务列表</li>
<li>eureka返回列表，localhost:8081、localhost:8082</li>
<li>IRule利用内置负载均衡规则，从列表中选择一个，例如localhost:8081</li>
<li>RibbonLoadBalancerClient修改请求地址，用localhost:8081替代userservice，得到<a target="_blank" rel="noopener" href="http://localhost:8081/user/1%EF%BC%8C">http://localhost:8081/user/1，</a> 发起真实请求  <img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210713224724673.png?raw=true" width="500" height="200"></li>
</ul>
</li>
</ul>
</li>
<li>负载均衡策略IRule<ul>
<li>IRule 接口：决定了负载均衡的策略，每一个子接口都是一种规则，轮询、随机、、、 通过定义 IRule 实现可以修改负载均衡策略</li>
<li>负载均衡策略：负载均衡的规则都定义在IRule接口中，而IRule有很多不同的实现类：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210713225653000.png?raw=true" width="500" height="200"><table>
<thead>
<tr>
<th><strong>内置负载均衡规则类</strong></th>
<th><strong>规则描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>RoundRobinRule</td>
<td>简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td>
</tr>
<tr>
<td>AvailabilityFilteringRule</td>
<td>对以下两种服务器进行忽略：   （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。  （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的<clientName>.<clientConfigNameSpace>.ActiveConnectionsLimit属性进行配置。</td>
</tr>
<tr>
<td>WeightedResponseTimeRule</td>
<td>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td>
</tr>
<tr>
<td><strong>ZoneAvoidanceRule</strong>【默认】</td>
<td>以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做<strong>轮询</strong>。</td>
</tr>
<tr>
<td>BestAvailableRule</td>
<td>忽略那些短路的服务器，并选择并发数较低的服务器。</td>
</tr>
<tr>
<td>RandomRule</td>
<td>随机选择一个可用的服务器。</td>
</tr>
<tr>
<td>RetryRule</td>
<td>重试机制的选择逻辑</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li>自定义负载均衡策略<ol>
<li>代码方式：在order-service中的OrderApplication类中，定义一个新的IRule：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">randomRule</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则：  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">userservice:</span> <span class="comment"># 给某个微服务配置负载均衡规则，这里是userservice服务</span></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span> <span class="comment"># 负载均衡规则 </span></span><br></pre></td></tr></table></figure></li>
<li><strong>注意</strong>，一般用默认的负载均衡规则，不做修改。</li>
</ol>
</li>
<li>饥饿加载<ul>
<li>Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line"><span class="attr">eager-load:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">clients:</span> <span class="string">userservice</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>

<h2 id="Nacos注册中心【8848】"><a href="#Nacos注册中心【8848】" class="headerlink" title="Nacos注册中心【8848】"></a>Nacos注册中心【8848】</h2><ul>
<li><strong>Nacos</strong> 是阿里巴巴的产品，现在是 SpringCloud 中的一个组件。相比 Eureka 功能更加丰富，在国内受欢迎程度较高。</li>
<li><strong>Nacos服务搭建：</strong>下载安装包，解压，在 D:\nacos-server-1.4.1\bin 目录下cmd运行指令: <code>startup.cmd -m standalone</code><br>浏览器打开 <a target="_blank" rel="noopener" href="http://xxxx:8848/nacos/index.html#/login%EF%BC%8C%E8%BE%93%E5%85%A5%E8%B4%A6%E5%8F%B7/%E5%AF%86%E7%A0%81%EF%BC%9Anacos">http://xxxx:8848/nacos/index.html#/login，输入账号/密码：nacos</a></li>
</ul>
<h4 id="1-Nacos服务注册或发现"><a href="#1-Nacos服务注册或发现" class="headerlink" title="1. Nacos服务注册或发现"></a>1. Nacos服务注册或发现</h4><p>父工程添加 spring-cloud-alibaba 依赖；微服务项目引入 nacos.discovery 依赖，yml 配置 nacos 地址 spring.cloudnacos.server-addr<br>Nacos 是 SpringCloudAlibaba 的组件，而 SpringCloudAlibaba 也遵循 SpringCloud 中定义的服务注册、服务发现规范。因此使用 Nacos 和使用 Eureka 对于微服务来说，并没有太大区别。</p>
<ol>
<li>引入依赖：<br>在cloud-demo父工程的pom文件中的<code>&lt;dependencyManagement&gt;</code>中引入SpringCloudAlibaba的依赖；<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
然后在子微服务 user-service 和 order-service 中的pom文件中引入nacos-discovery依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>配置nacos地址：在子微服务 user-service 和 order-service 的 application.yml 中添加 nacos 地址：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">    <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br></pre></td></tr></table></figure></li>
<li>重启微服务后，登录nacos管理页面<a target="_blank" rel="noopener" href="http://10.195.138.48:8848/nacos/index.html#/">http://10.195.138.48:8848/nacos/index.html#/</a> ,可以看到微服务信息 <img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210713231439607.png?raw=true" width="600" height="200">  </li>
<li>服务发现：消费者需要连接nacos以拉取和订阅服务，因此服务发现的前两步与服务注册是一样（引入nacos-discovery依赖和配置nacos地址），后面再加上服务调用即可<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DiscoveryClient discoveryclient;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlecartItems</span><span class="params">(List&lt;CartVO&gt; vos)</span> &#123;</span><br><span class="line">  <span class="comment">// 1.根据服务名称，拉取服务的实例列表</span></span><br><span class="line">  List&lt;ServiceInstance&gt; instances = discoveryclient.getInstances(<span class="string">&quot;item-service&quot;</span>);</span><br><span class="line">  <span class="comment">// 2.负藏均衡，随机挑选一个实例</span></span><br><span class="line">  <span class="type">ServiceInstance</span> <span class="variable">instance</span> <span class="operator">=</span> instances.get(RandomUtil.randomInt(instances.size()));</span><br><span class="line">  <span class="comment">// 3.获取实例的TP和端口</span></span><br><span class="line">  URI uri= instance.getUri();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="2-Nacos服务分级存储"><a href="#2-Nacos服务分级存储" class="headerlink" title="2. Nacos服务分级存储"></a>2. <strong>Nacos服务分级存储</strong></h4><p>一个<strong>服务</strong>可以有多个<strong>实例</strong>，例如我们的user-service，可以有：127.0.0.1:8081，127.0.0.1:8082，127.0.0.1:8083<br>假如这些实例分布于全国各地的不同机房，例如：127.0.0.1:8081在上海机房，127.0.0.1:8082在上海机房，127.0.0.1:8083在杭州机房。    Nacos就将同一机房内的实例 划分为一个<strong>集群</strong>。</p>
<ul>
<li>也就是说，user-service是服务，一个服务可以包含多个集群，如杭州、上海，每个集群下可以有多个实例，形成分级模型：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210713232522531.png?raw=true" width="600" height="200"><br>微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210713232658928.png?raw=true" width="600" height="200">  </li>
<li>配置集群：修改user-service的application.yml文件，添加集群配置：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">    <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">    <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span> <span class="comment"># 集群名称</span></span><br></pre></td></tr></table></figure></li>
<li>同集群优先的负载均衡：默认的<code>ZoneAvoidanceRule</code>并不能实现根据同集群优先来实现负载均衡。因此Nacos中提供了一个<code>NacosRule</code>的实现，可以优先从同集群中挑选实例。<br>修改order-service的application.yml文件，修改负载均衡规则：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">userservice:</span></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class="comment"># 负载均衡规则 </span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-权重配置："><a href="#3-权重配置：" class="headerlink" title="3. 权重配置："></a>3. <strong>权重配置：</strong></h4><p>默认情况下NacosRule是同集群内随机挑选，不会考虑机器的性能问题。因此，Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高。<br>在nacos控制台，找到user-service的实例列表，点击编辑，在弹出的窗口修改权重：（<strong>注意</strong>：权重为0，则该实例永远不会被访问）<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210713235133225.png?raw=true"><br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210713235235219.png?raw=true" width="300" height="200"> </p>
<h4 id="4-环境隔离："><a href="#4-环境隔离：" class="headerlink" title="4. 环境隔离："></a>4. <strong>环境隔离</strong>：</h4><p>Nacos提供了namespace来实现环境隔离功能（比如把一些功能紧密的服务隔离在一起，不能被另一些服务访问）</p>
<ul>
<li>nacos中可以有多个namespace</li>
<li>namespace下可以有group、service等</li>
<li>不同namespace之间相互隔离，例如不同namespace的服务互相不可见<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210714000101516.png?raw=true" width="400" height="200"></li>
</ul>
<ol>
<li>创建namespace：默认情况下，所有service、data、group都在同一个namespace，名为public：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210714000414781.png?raw=true" width="300" height="200"> 
我们可以点击页面新增按钮，添加一个namespace；然后，填写表单，创建一个新的namespace：
<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210714000505928.png?raw=true" width="300" height="200"> </li>
<li>给微服务配置namespace：只能通过修改配置来实现。例如，修改order-service的application.yml文件：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">    <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">    <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">492a7d5d-237b-46a1-a99a-fa8e98e4b0f9</span> <span class="comment"># 命名空间，填ID</span></span><br></pre></td></tr></table></figure>
重启order-service后，访问控制台，可以看到下面的结果：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210714000830703.png?raw=true" width="600" height="200"> 
此时访问order-service，因为namespace不同，会导致找不到userservice，控制台会报错：
<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210714000941256.png?raw=true" width="600" height="200"></li>
</ol>
<h4 id="5-Nacos与Eureka的区别"><a href="#5-Nacos与Eureka的区别" class="headerlink" title="5. Nacos与Eureka的区别"></a>5. Nacos与Eureka的区别</h4><p>Nacos和Eureka整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异：<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets/image-20210714001728017.png?raw=true" width="500" height="200"> </p>
<ul>
<li>Nacos与eureka的共同点<ul>
<li>都支持服务注册和服务拉取</li>
<li>都支持服务提供者心跳方式做健康检测</li>
</ul>
</li>
<li>Nacos与Eureka的区别<ul>
<li>Nacos的服务实例分为两种类型：<ul>
<li>临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。</li>
<li>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。<br>  配置一个服务实例为永久实例：  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">    <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">ephemeral:</span> <span class="literal">false</span> <span class="comment"># 设置为非临时实例</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li>
<li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li>
<li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li>
<li>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</li>
</ul>
</li>
</ul>
<h4 id="6-Nacos配置管理："><a href="#6-Nacos配置管理：" class="headerlink" title="6. Nacos配置管理："></a>6. <strong>Nacos配置管理</strong>：</h4><p>Nacos除了可以做注册中心，同样可以做配置管理来使用。</p>
<ul>
<li><strong>统一配置管理</strong><br>当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。我们需要一种统一配置管理方案，可以集中管理所有实例的配置。<br>Nacos一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新。(不用重启服务就能更新)  <img src="https://github.com/leo710aka/bk/blob/main/springcloud/9.png?raw=true" width="500" height="200"> <ol>
<li>在nacos中添加配置文件<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714164742924.png?raw=true" width="500" height="200">   <img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714164856664.png?raw=true" width="500" height="200"> <blockquote>
<p>注意：项目的核心配置，需要热更新的配置才有放到nacos管理的必要。基本不会变更的一些配置还是保存在微服务本地比较好。</p>
</blockquote>
</li>
<li>从微服务拉取配置：微服务要拉取nacos中管理的配置，并且与本地的application.yml配置合并，才能完成项目启动。 但如果尚未读取application.yml，又如何得知nacos地址呢？<br>因此spring引入了一种新的配置文件：bootstrap.yaml文件，会在application.yml之前被读取，流程如下：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/L0iFYNF.png?raw=true"><br>首先，在user-service服务中，引入nacos-config的客户端依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos配置管理依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
然后，在user-service中添加一个bootstrap.yaml文件，内容如下：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userservice</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment">#开发环境，这里是dev </span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># Nacos地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 文件后缀名</span></span><br></pre></td></tr></table></figure>
这里会根据spring.cloud.nacos.server-addr获取nacos地址，再根据<br><code>$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</code>作为文件id，来读取配置。本例中，就是去读取<code>userservice-dev.yaml</code>：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714170845901.png?raw=true" width="500" height="200"><br>读取nacos配置：在user-service中的UserController中添加业务逻辑，读取pattern.dateformat配置<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714170337448.png?raw=true" width="500" height="200"></li>
</ol>
</li>
<li><strong>配置热更新</strong><br>我们最终的目的，是修改nacos中的配置后，微服务中无需重启即可让配置生效，也就是<strong>配置热更新</strong>。可以使用两种方式：<ol>
<li>方式一：在 @Value 注入的变量所在类上添加注解 @RefreshScope：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714171036335.png?raw=true" width="500" height="200"> </li>
<li>方式二：使用 @ConfigurationProperties 注解代替 @Value 注解。<br>在 user-service 服务中，添加一个类，读取 patterrn.dateformat 属性：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.user.config;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;pattern&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PatternProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String dateformat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在 UserController 中使用这个类代替 @Value：<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714171316124.png?raw=true"></li>
</ol>
</li>
<li><strong>配置共享</strong><br>其实微服务启动时，会去nacos读取多个配置文件，例如：<ul>
<li><code>[spring.application.name]-[spring.profiles.active].yaml</code>，例如：userservice-dev.yaml</li>
<li><code>[spring.application.name].yaml</code>，例如：userservice.yaml<br>而<code>[spring.application.name].yaml</code>不包含环境，因此可以被多个环境共享。下面我们通过案例来测试配置共享：</li>
</ul>
<ol>
<li>添加一个环境共享配置：我们在nacos中添加一个userservice.yaml文件：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714173233650.png?raw=true" width="400" height="200"> </li>
<li>在user-service中读取共享配置<!-- 
在user-service服务中，修改PatternProperties类，读取新添加的属性：
![image-20210714173324231](https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714173324231.png?raw=true)
在user-service服务中，修改UserController，添加一个方法：
![image-20210714173721309](https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714173721309.png?raw=true)
 --></li>
<li>运行两个UserApplication，使用不同的profile<br>？？<!-- 
修改UserApplication2这个启动项，改变其profile值：
![image-20210714173538538](https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714173538538.png?raw=true)
![image-20210714173519963](https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714173519963.png?raw=true)
这样，UserApplication(8081)使用的profile是dev，UserApplication2(8082)使用的profile是test。
启动UserApplication和UserApplication2
访问http://localhost:8081/user/prop，结果：
![image-20210714174313344](https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714174313344.png?raw=true)
访问http://localhost:8082/user/prop，结果：
![image-20210714174424818](https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714174424818.png?raw=true)
可以看出来，不管是dev，还是test环境，都读取到了envSharedValue这个属性的值。 --></li>
<li>配置共享的优先级<br>当nacos、服务本地同时出现相同属性时，优先级有高低之分：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714174623557.png?raw=true" width="500" height="200"></li>
</ol>
</li>
<li><strong>搭建Nacos集群</strong><br>企业生产中强调“高可用”，Nacos 生产环境下一定要部署为集群状态，部署方式参考课前资料中的文档：nacos集群搭建.md</li>
</ul>
<hr>

<h2 id="Feign-远程调用"><a href="#Feign-远程调用" class="headerlink" title="Feign 远程调用"></a>Feign 远程调用</h2><p>Feign是一个声明式的http客户端，其作用就是帮助我们优雅的实现http请求的发送；<br>解决从前利用 RestTemplate 发起远程调用代码中的问题：1、代码可读性差，编程体验不统一；2、参数复杂URL难以维护<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714174814204.png?raw=true" width="600" height="200"><br><strong>OpenFeign</strong>是一个声明式的http客户端，是SpringCloud在Eureka公司开源的Feign基础上改造而来。其作用就是基于SpringMVC的常见注解，帮我们优雅的实现http请求的发送.</p>
<h4 id="1-Feign替代RestTemplate"><a href="#1-Feign替代RestTemplate" class="headerlink" title="1. Feign替代RestTemplate"></a>1. Feign替代RestTemplate</h4><ol>
<li>引入依赖：在order-service服务的pom文件中引入feign的依赖：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 负载均衡？？ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalance<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>添加注解：在order-service的启动类添加 <code>@EnableFeignClients</code>注解 开启Feign的功能：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714175102524.png?raw=true" width="500" height="200"> </li>
<li>编写Feign的客户端：在order-service中新建一个接口，添加 <code>@FeignClient</code>注解，内容如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;userservice&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这个客户端主要是基于SpringMVC的注解来声明远程调用的信息，比如：服务名称：userservice，请求方式：GET，请求路径：&#x2F;user&#x2F;{id}，请求参数：Long id，返回值类型：User。这样，当服务调用者需要调用服务提供者时，只需要通过Feign客户端调用接口方法即可，Feign会根据注解信息自动发起HTTP请求并处理响应，而无需使用 RestTemplate。<br><strong>Feign的client是写在服务调用者模块中，用于定义如何调用服务提供者的接口，而服务提供者模块则负责提供具体的业务逻辑和处理请求。</strong> </li>
<li>测试：修改order-service中的OrderService类中的queryOrderById方法，使用Feign客户端代替RestTemplate：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714175415087.png?raw=true" width="500" height="200"></li>
</ol>
<h4 id="2-日志？？"><a href="#2-日志？？" class="headerlink" title="2. 日志？？"></a>2. 日志？？</h4><p>Feign可以支持很多的自定义配置，如下表所示：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>feign.Logger.Level</strong></td>
<td>修改日志级别</td>
<td>包含四种不同的级别：NONE、BASIC、HEADERS、FULL</td>
</tr>
<tr>
<td>feign.codec.Decoder</td>
<td>响应结果的解析器</td>
<td>http远程调用的结果做解析，例如解析json字符串为java对象</td>
</tr>
<tr>
<td>feign.codec.Encoder</td>
<td>请求参数编码</td>
<td>将请求参数编码，便于通过http请求发送</td>
</tr>
<tr>
<td>feign. Contract</td>
<td>支持的注解格式</td>
<td>默认是SpringMVC的注？</td>
</tr>
<tr>
<td>feign. Retryer</td>
<td>失败重试机制</td>
<td>请求失败的重试机制，默认是没有，不过会使用Ribbon的重试</td>
</tr>
</tbody></table>
<p>一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的@Bean覆盖默认Bean即可。<br>自定义配置的两种方法：</p>
<ol>
<li>配置文件方式：基于配置文件修改feign的日志级别可以针对单个服务，也可以针对所有服务：</li>
<li>Java代码方式：也可以基于Java代码来修改日志级别，先声明一个类，然后声明一个Logger.Level的对象<br>如果要<strong>全局生效</strong>，将其放到启动类的@EnableFeignClients这个注解中；如果是<strong>局部生效</strong>，则把它放到对应的@FeignClient这个注解中</li>
</ol>
<h4 id="3-Feign使用优化"><a href="#3-Feign使用优化" class="headerlink" title="3. Feign使用优化"></a>3. Feign使用优化</h4><p>Feign 是一个声明式客户端，只是把声明变成 http 请求，底层还是发http请求，依赖于其它的框架。<br>其底层客户端实现包括 URLConnection：默认实现，不支持连接池；Apache HttpClient：支持连接池；OKHttp：支持连接池。因此提高Feign的性能主要手段就是使用<strong>连接池</strong>代替默认的URLConnection。用Apache的HttpClient来演示：</p>
<ul>
<li>引入依赖：在order-service的pom文件中引入Apache的HttpClient依赖：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--httpClient的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>配置连接池：在order-service的application.yml中添加配置：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span> <span class="comment"># default全局的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">BASIC</span> <span class="comment"># 日志级别，BASIC就是基本的请求和响应信息</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启feign对HttpClient的支持</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">200</span> <span class="comment"># 最大的连接数</span></span><br><span class="line">    <span class="attr">max-connections-per-route:</span> <span class="number">50</span> <span class="comment"># 每个路径的最大连接数</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-最佳实践"><a href="#4-最佳实践" class="headerlink" title="4. 最佳实践"></a>4. 最佳实践</h4><p>所谓最近实践，就是使用过程中总结的经验，最好的一种使用方式。<br>如果一个微服务需要重复被其他微服务调用(消费)，那么每个消费者都要重复编写一个 client。有没有办法简化这种重复的代码编写呢？</p>
<!-- 1. **继承方式：**一样的代码可以通过继承来共享：
  * 定义一个API接口，利用定义方法，并基于SpringMVC注解做声明。
  * Feign客户端和Controller都集成改接口
  ![](https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714190640857.png?raw=true)
  优点：简单，实现了代码共享
  缺点：服务提供方、服务消费方紧耦合，参数列表中的注解映射并不会继承，因此Controller中必须再次声明方法、参数列表、注解 -->
<ol>
<li>从一个微服务中拆出一个模块，将Feign的Client、接口有关的POJO、默认的Feign配置都放到这个模块中，供给所有消费者使用<br>例如，将UserClient、User、Feign的默认配置都抽取到一个feign-api包中，所有其他微服务需要消费该微服务时，引用该包的依赖，即可直接使用。<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714214041796.png?raw=true"></li>
<li>将所有的微服务中的 dto、client、config 统一放在一个模块中，供给所有消费者使用。<br>junbo-api也是如此？？！！</li>
</ol>
<hr>


<h2 id="Gateway-服务网关"><a href="#Gateway-服务网关" class="headerlink" title="Gateway 服务网关"></a>Gateway 服务网关</h2><p>Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。</p>
<h4 id="1-为什么需要网关"><a href="#1-为什么需要网关" class="headerlink" title="1. 为什么需要网关"></a>1. 为什么需要网关</h4><p>Gateway网关是我们服务的守门神，所有微服务的统一入口。前端只需要知道网关的端口，发送请求就行了。<br>架构图：<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714210131152.png?raw=true" width="600" height="200"> </p>
<p>网关的<strong>核心功能特性</strong>：</p>
<ul>
<li><strong>权限控制</strong>：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</li>
<li><strong>路由和负载均衡</strong>：一切请求都必须先经过gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。</li>
<li><strong>限流</strong>：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</li>
</ul>
<p>在SpringCloud中网关的实现包括两种：gateway、zuul</p>
<ul>
<li>Zuul是基于Servlet的实现，属于阻塞式编程。</li>
<li>SpringCloudGateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</li>
</ul>
<h4 id="2-gateway快速入门"><a href="#2-gateway快速入门" class="headerlink" title="2. gateway快速入门"></a>2. gateway快速入门</h4><ol>
<li>创建 SpringBoot 工程 gateway 服务，引入网关依赖<!-- 创建服务：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714210919458.png?raw=true" width="700" height="200"> 
引入依赖： -->
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--网关--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--nacos服务发现依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>编写启动类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GatewayApplication</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		SpringApplication.run(GatewayApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编写基础配置和路由规则：<br>创建application.yml文件，内容如下：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span> <span class="comment"># 网关端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span> <span class="comment"># 网关路由配置</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span>      <span class="comment"># 1. 路由id，自定义，只要唯一即可</span></span><br><span class="line">          <span class="comment"># uri: http://127.0.. # 2. 路由的目标地址 http 就是固定地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userservice</span> <span class="comment">#    lb(loadbalance) 就是负载均衡，后面跟服务名称</span></span><br><span class="line">          <span class="attr">predicates:</span>           <span class="comment"># 3. 路由断言(可多条)，判断请求是否符合路由规则的条件</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span>     <span class="comment">#    按照路径匹配，只要以/user/开头就符合要求</span></span><br><span class="line">          <span class="attr">filters:</span>              <span class="comment"># 4. 路由过滤器，，</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">order-service</span>     <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
我们将符合<code>Path</code>规则的一切请求，都代理到<code>uri</code>参数指定的地址。本例中，我们将 <code>/user/**</code>开头的请求，代理到<code>lb://userservice</code>，lb是负载均衡，根据服务名拉取服务列表，实现负载均衡。<!-- 4. 启动网关服务进行测试
重启网关，访问http://localhost:10010/user/1时， 符合`/user/**`规则，请求转发到uri：http://userservice/user/1， 得到了结果：
![](https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714211908341.png?raw=true) --></li>
<li>网关路由的流程图<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714211742956.png?raw=true"></li>
</ol>
<h4 id="3-断言工厂"><a href="#3-断言工厂" class="headerlink" title="3. 断言工厂"></a>3. 断言工厂</h4><p>我们在配置文件中写的断言规则只是字符串，这些字符串会被Predicate Factory读取并处理，转变为路由判断的条件<br>例如Path&#x3D;&#x2F;user&#x2F;**是按照路径匹配，这个规则是由 <code>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory</code>类来处理的，像这样的断言工厂在SpringCloudGateway还有十几个:</p>
<table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>说明</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td>After</td>
<td>是某个时间点后的请求</td>
<td>-  After&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver]</td>
</tr>
<tr>
<td>Before</td>
<td>是某个时间点之前的请求</td>
<td>-  Before&#x3D;2031-04-13T15:14:47.433+08:00[Asia&#x2F;Shanghai]</td>
</tr>
<tr>
<td>Between</td>
<td>是某两个时间点之前的请求</td>
<td>-  Between&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver],  2037-01-21T17:42:47.789-07:00[America&#x2F;Denver]</td>
</tr>
<tr>
<td>Cookie</td>
<td>请求必须包含某些cookie</td>
<td>- Cookie&#x3D;chocolate, ch.p</td>
</tr>
<tr>
<td>Header</td>
<td>请求必须包含某些header</td>
<td>- Header&#x3D;X-Request-Id, \d+</td>
</tr>
<tr>
<td>Host</td>
<td>请求必须是访问某个host（域名）</td>
<td>-  Host&#x3D;<strong>.somehost.org,</strong>.anotherhost.org</td>
</tr>
<tr>
<td>Method</td>
<td>请求方式必须是指定方式</td>
<td>- Method&#x3D;GET,POST</td>
</tr>
<tr>
<td>Path</td>
<td>请求路径必须符合指定规则</td>
<td>- Path&#x3D;&#x2F;red&#x2F;{segment},&#x2F;blue&#x2F;**</td>
</tr>
<tr>
<td>Query</td>
<td>请求参数必须包含指定参数</td>
<td>- Query&#x3D;name, Jack或者-  Query&#x3D;name</td>
</tr>
<tr>
<td>RemoteAddr</td>
<td>请求者的ip必须是指定范围</td>
<td>- RemoteAddr&#x3D;192.168.1.1&#x2F;24</td>
</tr>
<tr>
<td>Weight</td>
<td>权重处理</td>
<td></td>
</tr>
</tbody></table>
<h4 id="4-过滤器工厂"><a href="#4-过滤器工厂" class="headerlink" title="4. 过滤器工厂"></a>4. 过滤器工厂</h4><p>GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理：<br><img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714212312871.png?raw=true" width="700" height="200"> </p>
<ul>
<li><strong>路由过滤器的种类</strong>：Spring提供了31种不同的路由过滤器工厂。例如：<table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>AddRequestHeader</td>
<td>给当前请求添加一个请求头</td>
</tr>
<tr>
<td>RemoveRequestHeader</td>
<td>移除请求中的一个请求头</td>
</tr>
<tr>
<td>AddResponseHeader</td>
<td>给响应结果中添加一个响应头</td>
</tr>
<tr>
<td>RemoveResponseHeader</td>
<td>从响应结果中移除有一个响应头</td>
</tr>
<tr>
<td>RequestRateLimiter</td>
<td>限制请求的流量</td>
</tr>
</tbody></table>
</li>
<li><strong>请求头过滤器</strong>：以AddRequestHeader 为例来讲解。<blockquote>
<p><strong>需求</strong>：给所有进入userservice的请求添加一个请求头：Truth&#x3D;itcast is freaking awesome!  </p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只需要修改gateway服务的application.yml文件，添加路由过滤即可</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> <span class="comment"># 当前过滤器写在userservice路由下，因此仅仅对访问userservice的请求有效</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://userservice</span> </span><br><span class="line">        <span class="attr">predicates:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/user/**</span> </span><br><span class="line">        <span class="attr">filters:</span> <span class="comment"># 过滤器</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=Truth,</span> <span class="string">Itcast</span> <span class="string">is</span> <span class="string">freaking</span> <span class="string">awesome!</span> <span class="comment"># 添加请求头</span></span><br></pre></td></tr></table></figure></li>
<li><strong>默认过滤器</strong>：如果要对所有的路由都生效，则可以将过滤器工厂写到default下。格式如下：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> </span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://userservice</span> </span><br><span class="line">        <span class="attr">predicates:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/user/**</span></span><br><span class="line">      <span class="attr">default-filters:</span> <span class="comment"># 默认过滤项</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">AddRequestHeader=Truth,</span> <span class="string">Itcast</span> <span class="string">is</span> <span class="string">freaking</span> <span class="string">awesome!</span> </span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="5-全局过滤器"><a href="#5-全局过滤器" class="headerlink" title="5. 全局过滤器"></a>5. 全局过滤器</h4><ol>
<li>全局过滤器作用<br>  上一节学习的过滤器，网关提供了31种，但每一种过滤器的作用都是固定的。如果我们希望拦截请求，做自己的业务逻辑则没办法实现。全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样。区别在于GatewayFilter通过配置定义，处理逻辑是固定的；而GlobalFilter的逻辑需要自己写代码实现。<br>  定义方式是实现GlobalFilter接口。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  处理当前请求，有必要的话通过&#123;<span class="doctag">@link</span> GatewayFilterChain&#125;将请求交给下一个过滤器处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange 请求上下文，里面可以获取Request、Response等信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chain 用来把请求委托给下一个过滤器 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> Mono&lt;Void&gt;&#125; 返回标示当前过滤器业务结束</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  在filter中编写自定义逻辑，可以实现下列功能：<strong>登录状态判断、权限校验、请求限流</strong>等</li>
<li>自定义全局过滤器<br>  <strong>需求：</strong>定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：（如果同时满足则放行，否则拦截）<br>  1、参数中是否有authorization，<br>  2、authorization参数值是否为admin<br>  <strong>实现：</strong>在gateway中定义一个过滤器：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order(-1)</span> <span class="comment">// 过滤器优先级</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizeFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取请求参数</span></span><br><span class="line">        MultiValueMap&lt;String, String&gt; params = exchange.getRequest().getQueryParams();</span><br><span class="line">        <span class="comment">// 2.获取authorization参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">auth</span> <span class="operator">=</span> params.getFirst(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.校验</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(auth)) &#123;</span><br><span class="line">            <span class="comment">// 放行</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.拦截</span></span><br><span class="line">        <span class="comment">// 4.1.禁止访问，设置状态码</span></span><br><span class="line">        exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);</span><br><span class="line">        <span class="comment">// 4.2.结束处理</span></span><br><span class="line">        <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>过滤器执行顺序<br>  请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter<br>  请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器： <img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714214228409.png?raw=true"></li>
</ol>
<ul>
<li>排序的规则是什么呢？<ul>
<li>每一个过滤器都必须指定一个int类型的order值，<strong>order值越小，优先级越高，执行顺序越靠前</strong>。</li>
<li>GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定</li>
<li>路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增。</li>
<li>当过滤器的order值一样时，会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行。<!-- 详细内容，可以查看源码：
`org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator#getFilters()`方法是先加载defaultFilters，然后再加载某个route的filters，然后合并。
`org.springframework.cloud.gateway.handler.FilteringWebHandler#handle()`方法会加载全局过滤器，与前面的过滤器合并后根据order排序，组织过滤器链 --></li>
</ul>
</li>
</ul>
<h4 id="6-跨域问题"><a href="#6-跨域问题" class="headerlink" title="6. 跨域问题"></a>6. 跨域问题</h4><ol>
<li><strong>什么是跨域问题</strong>：<br>域名不一致就是跨域，主要包括：域名不同： <a target="_blank" rel="noopener" href="http://www.taobao.com/">www.taobao.com</a> 和 <a target="_blank" rel="noopener" href="http://www.taobao.org/">www.taobao.org</a> 和 <a target="_blank" rel="noopener" href="http://www.jd.com;/">www.jd.com；</a> 域名相同，端口不同：localhost:8080 和 localhost:8081<br>跨域问题：浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题<br>解决方案：CORS <a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2016/04/cors.html">https://www.ruanyifeng.com/blog/2016/04/cors.html</a></li>
<li><strong>模拟跨域问题</strong><br>找到课前资料的页面文件：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714215713563.png?raw=true"><br>放入tomcat或者nginx这样的web服务器中，启动并访问。<br>可以在浏览器控制台看到下面的错误：<img src="https://github.com/leo710aka/bk/blob/main/springcloud/assets2/image-20210714215832675.png?raw=true"><br>从localhost:8090访问localhost:10010，端口不同，显然是跨域的请求。</li>
<li><strong>解决跨域问题</strong>：在gateway服务的application.yml文件中，添加下面的配置：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="comment"># ？？</span></span><br><span class="line">      <span class="attr">globalcors:</span> <span class="comment"># 全局的跨域处理</span></span><br><span class="line">        <span class="attr">add-to-simple-url-handler-mapping:</span> <span class="literal">true</span> <span class="comment"># 解决options请求被拦截问题</span></span><br><span class="line">        <span class="attr">corsConfigurations:</span></span><br><span class="line">          <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span></span><br><span class="line">            <span class="attr">allowedOrigins:</span> <span class="comment"># 允许哪些网站的跨域请求 </span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://localhost:8090&quot;</span></span><br><span class="line">            <span class="attr">allowedMethods:</span> <span class="comment"># 允许的跨域ajax的请求方式</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;GET&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;POST&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;DELETE&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;PUT&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;OPTIONS&quot;</span></span><br><span class="line">            <span class="attr">allowedHeaders:</span> <span class="string">&quot;*&quot;</span> <span class="comment"># 允许在请求中携带的头信息</span></span><br><span class="line">            <span class="attr">allowCredentials:</span> <span class="literal">true</span> <span class="comment"># 是否允许携带cookie</span></span><br><span class="line">            <span class="attr">maxAge:</span> <span class="number">360000</span> <span class="comment"># 这次跨域检测的有效期</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>

<h2 id="Sentinel-服务保护"><a href="#Sentinel-服务保护" class="headerlink" title="Sentinel 服务保护"></a>Sentinel 服务保护</h2><ul>
<li>雪崩：微服务调用链路中的某个服务故障，引起整个链路中的所有微服务都不可用，这就是雪崩。<ul>
<li>雪崩问题产生的原因是什么?<br>微服务相互调用，服务提供者出现故障或阻塞。<br>服务调用者没有做好异常处理，导致自身故障<br>调用链中的所有服务级联失败，导致整个集群故障<img src="https://github.com/leo710aka/bk/blob/main/springcloud/10.png?raw=true?raw=true" width="300" height="200"></li>
<li>解决问题的思路有哪些?<br>尽量避免服务出现故障或阻塞：保证代码的健壮性; 保证网络畅通; 能应对较高的并发请求;<br>服务调用者做好远程调用异常的后备方案，避免故障扩散</li>
<li>解决雪崩问题的常见方案有哪些?<br>请尔限流：限制流量在服务可以处理的范围，避免因突发流量丽故障<br>线程隔离：控制业务可用的线程数量，将故障隔离在一定范围<br>失败处理：（熔断的一部分）定义fallback逻辑，让业务失败时不再抛出异常，而是走fallback逻辑<br>服务熔断：将异常比例过高的接口断开，拒绝所有请求，直接走fallback</li>
<li>技术实现<br>现常用 Sentinel，功能更加强大；Hystrix 支持 SpringCloud 2020前的版本<img src="https://github.com/leo710aka/bk/blob/main/springcloud/11.png?raw=true?raw=true" width="700" height="200"></li>
</ul>
</li>
</ul>
<hr> 

<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/list/watchlater?oid=961238101&bvid=BV1kH4y1S7wz&spm_id_from=333.999.top_right_bar_window_view_later.content.click&p=46">https://www.bilibili.com/list/watchlater?oid=961238101&amp;bvid=BV1kH4y1S7wz&amp;spm_id_from=333.999.top_right_bar_window_view_later.content.click&amp;p=46</a></p>
<hr>

<h2 id="RabbitMQ-消息队列【5672】"><a href="#RabbitMQ-消息队列【5672】" class="headerlink" title="RabbitMQ 消息队列【5672】"></a>RabbitMQ 消息队列【5672】</h2><p><a target="_blank" rel="noopener" href="https://leo710aka.github.io/2024/01/11/RabbitMQ/">https://leo710aka.github.io/2024/01/11/RabbitMQ/</a></p>
<hr>

<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p><a target="_blank" rel="noopener" href="http://localhost:4000/2023/04/14/Docker/">http://localhost:4000/2023/04/14/Docker/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/07/SpringCloud/" data-id="cm0cja96l000km4v5b28b5fgf" data-title="SpringCloud" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-骏伯Junbo" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/04/%E9%AA%8F%E4%BC%AFJunbo/" class="article-date">
  <time class="dt-published" datetime="2024-01-04T02:58:11.000Z" itemprop="datePublished">2024-01-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/04/%E9%AA%8F%E4%BC%AFJunbo/">骏 伯 Junbo</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>使命</strong>：让移动互联网营销简单高效</p>
<p><strong>价值观</strong>：创造价值，分享价值</p>
<p><strong>愿景</strong>：做最受信赖的移动互联网营销服务商</p>
<hr>

<h2 id="学习-junbo-demo"><a href="#学习-junbo-demo" class="headerlink" title="学习 junbo-demo"></a>学习 junbo-demo</h2><p>开发工具：IDEA 2022.3.3<br>常用插件：阿里巴巴编码规约（Alibaba Java Coding Guidelines）, File-&gt;Settings-&gt;Plugins-&gt;Browse repositories-&gt;输入英文名称-&gt;install<br>开发环境：jdk1.8.0_202，Gradle 6.0</p>
<hr>

<h2 id="蔡枫-的2023年终总结"><a href="#蔡枫-的2023年终总结" class="headerlink" title="蔡枫 的2023年终总结"></a>蔡枫 的2023年终总结</h2><ul>
<li><p>回顾2023，你印象最深刻的2-3个 高光时刻 是什么？</p>
<ol>
<li><p>愿意去了解，理解新事物的时候，从电影和音乐等感受乐趣，共情与哲思</p>
</li>
<li><p>准备一年拿到奖学金，重修两门课程高分通过</p>
</li>
<li><p>通过面试，进入骏伯，一定多向同事们学习</p>
</li>
</ol>
</li>
<li><p>回顾2023，你印象最深刻的2-3个 艰难时刻 是什么？</p>
<ol>
<li><p>放弃考研和出国，感觉是当下比较好的决定</p>
</li>
<li><p>想到家里情况是多么窘迫的时刻</p>
</li>
<li><p>发现脱发症状的时候</p>
</li>
</ol>
</li>
<li><p>目标A：准备就业</p>
<p>  大概是八月份，打消了考研以及留学的念头后，由于有Java开发的经验，自然往这个方向准备就业。<br>  要学习的内容特别多，原以为有基础便能用三个月左右准备好，事实上即使每天都在尽力填充自己，如此半年后还剩下许多没准备好的，更别说要能够在面试时从容对答。但是并不焦虑，只要做好规划，继续学下去，有限的内容总是能够准备完成的，剩下就是准备和面对不喜欢的面试环节。<br>  2024年1月4日，我通过了骏伯的面试，岗位是Java开发实习生。面试中，我提到希望接触一些高并发、分布式这样的复杂场景中的“高大上”的问题。进入公司两周，我了解到在实际工作中更多的是在不断地解决需求，跟团队成员协作对接，真正重要的是要有解决实际问题的能力。<br>  每次向导师提问的时候，他的分享毫无保留，各位同事都是我学习的对象。未来的日子，我将尽全力完成每个安排到的任务，提升编码能力，为公司创造价值。</p>
</li>
</ul>
<hr>

<h2 id="2024-01-10"><a href="#2024-01-10" class="headerlink" title="2024.01.10"></a>2024.01.10</h2><ul>
<li><p><strong>模块 服务</strong>？一个服务占用一个端口， 在 .gradle 配置<br>{<br>  demo-api: 服务化接口定义项目<br>  demo-service: 服务化实现项目<br>}<br>api 接口与实现 分离，<br>UserApi接口上加 @FeignClient， 请求均分发送到多台服务器上<br>spring注入 与 单例模式。。</p>
</li>
<li><p>敏捷开发：一种应对快速变化需求的一种软件开发能力。相对于”非敏捷”，更强调程序员团队与业务专家之间的紧密协作、面对面的沟通(认为比书面的文档更有效)、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好地适应需求变化的代码编写和团队组织方法，也更注重做为软件开发中人的作用。</p>
</li>
</ul>
<h2 id="01-18"><a href="#01-18" class="headerlink" title="01.18"></a>01.18</h2><ul>
<li><p>使用不同的窗口打开一个项目下的不同服务、、</p>
</li>
<li><p>使用 IDEA -&gt; Run&#x2F;Debug Configuration -&gt; Shorten command line 选项用于指定是否<strong>缩短命令行</strong>，以提高可读性或管理性，其中 None 表示不缩短，Classpath File 表示通过类路径文件缩短。<br>Java 源代码被编译成字节码文件（.class 文件）。字节码文件在 Java 虚拟机（JVM）上运行。运行时配置参数通过命令行或配置文件传递给 JVM 和应用程序。运行时参数包括类路径、系统属性、环境变量、应用程序参数等，用于影响应用程序在运行时的行为。</p>
</li>
<li><p>DevOps 懂技术的运维？ <a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%BE%8E/36%20DevOps%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%88%B0%E5%BA%95%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88%E4%BA%8B%E6%83%85%EF%BC%9F.md">https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%BE%8E/36%20DevOps%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%88%B0%E5%BA%95%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88%E4%BA%8B%E6%83%85%EF%BC%9F.md</a><br>DevOps 可以理解为一种开发和运维一起紧密协作的工作方式，从而可以更快更可靠地构建、测试和发布软件。DevOps 的主要原则就是自动化、信息透明可测量、构建协作文化。<br>DevOps 工程师，要做的事情就是帮助团队来实践 DevOps 的工作方式。具体可以帮助团队：建立基于持续集成和持续交付工作流程；建立基于日志的监控报警的系统，以及故障响应的流程；构建基于云计算和虚拟化技术的基础设施；形成 DevOps 的文化。DevOps 工程师做的事情，就是帮助团队基于 DevOps 原则来做事，让团队形成紧密协作的工作方式，更快更可靠的构建、测试和发布软件。</p>
</li>
</ul>
<h2 id="01-23"><a href="#01-23" class="headerlink" title="01.23"></a>01.23</h2><ul>
<li><p>Jedis 和 RedisTemplate有什么区别？<br>Jedis 是 Redis 的官方 Java 客户端，直接使用 Redis 的命令进行操作。它提供了比较底层的 API，需要手动管理连接、序列化等。RedisTemplate 是 Spring Data Redis 提供的 Redis 客户端，它在 Jedis 的基础上进行了封装，提供了更高层次的抽象和更多的功能。<br>如果你在使用 Spring 项目，并且希望更方便地集成 Redis，并提供更高层次的抽象和功能，那么推荐使用 RedisTemplate。如果你对 Redis 的命令较为了解，或者需要更底层的操作，那么 Jedis 可能更适合你。</p>
</li>
<li><p>SpringBoot实体类 DO 和 BO</p>
<ol>
<li><strong>DO（Data Object）：</strong>通常表示数据库中的数据实体，对应数据库表的结构。它主要用于数据存储和数据库操作，包含与数据库表字段一一对应的属性。DO 类的命名一般以 “DO” 为后缀，例如 <code>UserDO</code>，<code>OrderDO</code>。类中通常包含与数据库表字段对应的成员变量、getter 和 setter 方法。它不应包含业务逻辑，主要负责数据的持久化和映射。</li>
<li><strong>BO（Business Object）：</strong>通常表示业务层的业务实体，主要用于封装业务逻辑。BO 类一般包含与业务逻辑相关的属性和方法，与具体的数据存储形式无关。包含了一些业务逻辑的操作，比如计算、验证等。它不应直接与数据库进行交互，而是通过调用 Service 层或 DAO 层的方法实现数据的获取和存储。</li>
<li>在 Spring Boot 中，DO和 BO是一些常见的命名规范，用于表示在不同层次中使用的实体类。这些命名规范有助于代码的清晰性和可维护性。在业务逻辑层中，可以通过转换工具或框架进行 DO 和 BO 之间的转换，以完成数据的传递和处理。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用实例BO对象生成DO对象</span></span><br><span class="line"><span class="type">OrderDO</span> <span class="variable">orderDO</span> <span class="operator">=</span> BeanMapperUtil.map(orderBO, OrderDO.class);</span><br></pre></td></tr></table></figure>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">map</span><span class="params">(Object sourceObject, Class&lt;T&gt; destObjectclazz)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sourceObject == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">T</span> <span class="variable">destObject</span> <span class="operator">=</span> BeanUtils.instantiateClass(destObjectclazz);</span><br><span class="line">    <span class="comment">// 对象映射： 通过 copyProperties 方法，将源对象的属性值复制到目标对象中</span></span><br><span class="line">    copyProperties(sourceObject, destObject, <span class="literal">null</span>, (String[]) <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> destObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="01-30"><a href="#01-30" class="headerlink" title="01.30"></a>01.30</h2><p>App拉新业务，增加白名单功能</p>
<!-- - 业务：当新接入一个客户或者媒体时，需要对整条链路进行验证，确保数据是能够正常传递的。媒体广告投放后台有一个联调功能，通过联调功能，能够指定媒体给特定一台手机发送测试广告，用户再点击广告可以触发一条广告点击数据，并发送到我方拉新业务系统，我方可以通过页面功能查到该广告点击数据的状态。如果该点击数据成功发给客户，说明链路一（媒体到客户）是通的，则可以使用我方业务系统页面功能手动触发一条转化数据，发给媒体，如果能发送成功，则说明整条链路是通的，则验证通过。
- 问题：使用联调功能，媒体给我方发送的广告点击数据，我们会做一些拦截处理，有时候不会将它们发给客户，这就使得没法进行下一步转化回传的动作，从而无法完成媒体的联调。一个典型的拦截处理的案例是，对于某些客户，我方在发送点击数据给对方时，需要调用客户的接口进行确认，判断当前用户是否是客户的目标用户，如果不是，则不发送点击数据给客户，这样的拦截称之为RTA拦截。拦截率由客户决定的，并且可能会很高，业务方用来联调的手机基本都被拦截了，从而无法完成联调。
handle 拦截，其实就是修改某些字段的状态，以在之后判定为某种情况而进行某种行为
- 解决：添加白名单，如果业务方用来测试的手机设备号在白名单内，则不进行拦截。
- 代码介绍
仓库地址：http://git.gzjunbo.net/junbo/junbo-newenergy.git， 基于master分支创建一个自己的开发分支develop-caif
两个服务：newenergy-web-admin、newenergybg-service，前者提供了一个接收点击数据的接口，在收到点击数据以后，会将其通过feign转发给newenergybg-service服务进行处理（注册中心为eureka）。
接口对应的方法是：ConvTraceWebApi.send（newenergy-web-admin），它会调用newenergybg-service服务的ConvTraceApiImpl.upload方法，再通过MediaDataForwardProducer.produce方法，将其发送到Kafka消息队列，再由MediaDataForwardServiceImpl.consumeKafka方法进行消费，最终进入核心的业务处理逻辑方法，即MediaDataForwardServiceImpl.upload方法，我们需要修改的RTA拦截部分的代码就在这里面。
- upload方法的内部处理逻辑如下：
参数前置处理（initPreValidate）（一些通用逻辑，比如点击数据ID、时间字段的初始化）。
参数校验（isValid）（校验点击数据是否有效，如果无效则不发给客户，比如媒体可能会将用户曝光数据发过来，此时不需要发给客户）。
参数后置处理（initPostValidate）（一些带有复杂业务逻辑的处理，比如RTA拦截）。
将校验通过的点击数据发给客户（transferToCustomer）。
保存数据到数据库/缓存（save）。
我们需要修改的RTA拦截部分的代码在参数后置处理部分，具体方法是YoudaoMediaActionDataHandler.handle。
- YoudaoMediaActionDataHandler.handle类内部处理逻辑
媒体发给我方的数据可能不止用户点击数据，还包括了广告曝光数据（即用户只要看了广告，媒体就会通知我们），这类数据我们是不需要发给客户的，因此需要设置状态为NON_CLICK_NOT_TRANSFER_TO_CUSTOMER，后续代码流程识别出此状态后，不会将该数据发给客户。
走RTA拦截，有一些前置条件，包括①业务方指定了客户点击监测链接ID为RTA链接（客户的点击监测链接是客户提供过来用于接收我方点击数据的接口）（RTA链接是一个标记，标识当前点击数据发给客户前，要先调用客户的RTA接口过滤一道，最终只发送客户需要的用户）②如果当前数据类型为曝光，且曝光总数与点击总数的比例小于requestRate（默认为4:1）
对于满足前置条件的数据，则发起RTA请求，将结果记录下来（结果指的是客户是否接受当前用户，即是否参竞-isParticipated），用于业务方后续使用
如果客户不接受当前用户，则设置状态RTA_EXCLUDED，后续代码流程识别出此状态后，不会将该数据发给客户。（添加白名单后，如果客户不接受当前用户，不设置状态RTA_EXCLUDED，此时后续流程会正常将该数据发给客户） -->


<h2 id="02-20"><a href="#02-20" class="headerlink" title="02.20"></a>02.20</h2><p>需求：开发媒体上报规则报表的分页查询接口</p>
<!-- * 需求原型：https://axhub.im/pro/62d03dd7790d2dd4/#g=1&p=%E5%AA%92%E4%BD%93%E4%B8%8A%E6%8A%A5%E8%A7%84%E5%88%99%E6%8A%A5%E8%A1%A8
* 拉一个develop-caif分支，后续代码开发在此分支上进行，分支对应整个项目，其中包括了后面涉及到的所有微服务
* 数据库建表
* 使用junboGenerator插件生成表结构对应的MyBatis代码（DO, BO, Mapper文件），用于操作数据库。修改 /resources/generator/generatorConfig.xml 文件，运行插件： Gradle -> newenerge-soa -> Tasks -> junbo -> junboGenerater，配置新表（注意，此时需要将其他表的配置项注释掉），后续插件执行时会根据数据库表结构生成相应的Java代码（DO、Mapper等等），将代码文件放到特定的文件目录下。
config.xml 中有两类列属性需要特殊标记，一类是id，一类是枚举字段（在数据库里可能是int，而在java中是enum，此时插件默认无法将这两个类型对应，需要覆盖掉插件的默认行为，手动进行转换）
* 实现分页功能，大致步骤包括：
①【newenergy-api】定义XXXApi接口及page方法
②【newenergybg-service】定义XXXService接口及page方法
③【newenergybg-service】定义XXXApiImpl类（Controller），实现XXXApi接口及page方法，通过调用XXXService完成分页查询数据的操作
④【newenergybg-service】定义XXXServiceImpl类，实现XXXService接口及page方法，通过MyBatis分页插件及XXXMapper的查询方法，完成数据的分页查询。
⑤【newenergy-api】发布XXXApi：修改版本号（xx.snapshot），发布新的jar包（包含新的XXXApi接口）到 Maven 仓库；Gradle -> newenergy-api -> Tasks -> publishing -> publish 
⑥【newenergy-web-admin】引入最新的XXXApi：更新maven，依赖新版本jar包，以使用新的XXXApi接口
⑦【newenergy-web-admin】定义XXXWebApi类及page方法（Controller），通过XXXApi的page方法，完成数据的分页查询。
* 服务关系：
【newenergy-api】：定义接口信息，同时被【newenergybg-service】和【newenergy-web-admin】依赖
【newenergybg-service】是【newenergy-api】的实现，实际的服务端；
【newenergy-web-admin】接收前端请求（防止暴露实际服务端），从 maven 获取 jar 包反射获取接口和实体类信息。
* 参数信息：
Api方法中：XXXRequest、XXXResponse
业务层：XXXBO
持久层：直接与数据库交互 XXXDO
实际上，由于需要返回的数据是由多表查询而来，任一 BO 或 DO 都没法涵盖所有属性字段。所以新增一个 分页查询entity类 ConvCallbackRuleDailyReportPageItem，要在 mapper.xml 里修改 resultMap 中查询数据与返回值的对应关系，在后续数据转换的过程中主要前后类的字段的对应。
* 【集成测试】本地启动newenergybg-service服务和newenergy-web-admin服务，通过postman调用接口进行测试，期望结果是，查出来的结果与数据库中的数据一致。
实际请求发送流程为：前端客户端程序发起请求 ->【newenergy-web-admin】XXXWebApi.page -> 【newenergybg-service】XXXApiImpl.page -> 【newenergybg-service】XXXServiceImpl.page -> 【newenergybg-service】 XXXMapper.selectByExample
测试方法：打断点，观察获取和处理的数据从 mapper->serviceImpl->apiImpl 中的变化，注意数据转换过程
使用 postman 给本地服务发送请求，如 localhost:1087/service/conv-callback-rule-daily-report/page，在 Body 携带 raw 的 json 数据
* 提交代码到远程仓库develop-caif分支
* 在 Yapi 编写接口文档 -->

<h2 id="02-22"><a href="#02-22" class="headerlink" title="02.22"></a>02.22</h2><ul>
<li>YY yy &#x3D; BeanMapperUtil.map(xx, YY.class); 从xx复制属性值而来生成YY类型的实例yy</li>
<li>List<ConvCallbackRuleDailyReportResponse> list &#x3D; page.getList().stream().map(this::toResponse).collect(Collectors.toList());<br>  Java中的Stream API 是一种用于处理集合数据的强大工具，在 Java 8 中引入，它允许我们以声明性方式处理数据集合（即你可以描述你想要做什么，而不是描述如何去做）,它使得集合操作更加简洁、易读和高效。<ul>
<li>创建 Stream：你可以从集合（如 List、Set 等）创建 Stream，或者从数组创建。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>);  </span><br><span class="line">Stream&lt;String&gt; stream = list.stream();  </span><br><span class="line"><span class="comment">// 或者直接从数组创建  </span></span><br><span class="line">Stream&lt;String&gt; arrayStream = Arrays.stream(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>&#125;);</span><br></pre></td></tr></table></figure></li>
<li>中间操作：是返回新 Stream 的操作，它们可以链接起来形成一个处理链。常见的中间操作有 filter、map、sorted 等。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>);  </span><br><span class="line">    List&lt;String&gt; result = list.stream()  </span><br><span class="line">                        .filter(s -&gt; s.matches(<span class="string">&quot;[a-c]+&quot;</span>))  <span class="comment">// 过滤出以 a-c 开头的字符串  </span></span><br><span class="line">                        .map(String::toUpperCase)         <span class="comment">// 将字符串转换为大写  </span></span><br><span class="line">                        .sorted()                          <span class="comment">// 对字符串进行排序  </span></span><br><span class="line">                        .collect(Collectors.toList());     <span class="comment">// 收集到新的 List 中  </span></span><br></pre></td></tr></table></figure></li>
<li>终端操作：结束 Stream 处理并返回结果。常见的终端操作有 forEach、reduce、collect 等。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>);  </span><br><span class="line"><span class="comment">// 使用 forEach 遍历 Stream  </span></span><br><span class="line">list.stream().forEach(System.out::println);  </span><br><span class="line"><span class="comment">// 使用 reduce 对 Stream 中的元素进行归约操作，例如求和  </span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> list.stream().mapToInt(Integer::parseInt).sum();  </span><br><span class="line">System.out.println(sum);  <span class="comment">// 输出：6（&#x27;a&#x27;、&#x27;b&#x27;、&#x27;c&#x27;、&#x27;d&#x27; 的 ASCII 码之和）  </span></span><br><span class="line"><span class="comment">// 使用 collect 将 Stream 中的元素收集到新的集合中  </span></span><br><span class="line">List&lt;String&gt; collectedList = list.stream().collect(Collectors.toList());  </span><br><span class="line">System.out.println(collectedList);  <span class="comment">// 输出：[a, b, c, d]</span></span><br></pre></td></tr></table></figure></li>
<li>并行 Stream：Java Stream API 还支持并行处理，这可以充分利用多核处理器的优势，提高处理速度。要创建一个并行 Stream，你可以使用 parallelStream() 方法。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>);  </span><br><span class="line"><span class="comment">// 使用 parallelStream 创建并行 Stream  </span></span><br><span class="line">List&lt;String&gt; collectedList = list.parallelStream().collect(Collectors.toList());  </span><br><span class="line">System.out.println(collectedList);  <span class="comment">// 输出：[a, b, c, d]</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>在Java中，Stream流和序列化是两个不同的概念，但它们在某些场景下可以相互关联。<ul>
<li>Stream流是Java 8引入的一个新特性，它允许我们以声明性方式处理数据集合。Stream API提供了一种高效且简洁的方式来处理数据，例如过滤、映射、排序和聚合等操作。Stream流主要关注的是数据的处理和转换，而不是数据的存储或传输。</li>
<li>序列化（Serialization）则是将对象的状态转换为字节流的过程，以便可以将这些字节流持久化保存或通过网络传输到其他位置。序列化允许我们将对象的状态保存起来，然后在需要时恢复对象的状态。Java提供了ObjectOutputStream和ObjectInputStream类来进行对象的序列化和反序列化。</li>
<li>虽然Stream流和序列化是两个不同的概念，但它们在某些情况下可以相互结合使用。例如，当我们需要将一个对象的状态通过网络传输到另一个位置时，我们可以先将对象序列化为字节流，然后使用Stream流来处理和转换这些字节流。在接收端，我们可以使用Stream流来读取字节流，并使用反序列化来恢复对象的状态。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/04/%E9%AA%8F%E4%BC%AFJunbo/" data-id="cm0cja96r000vm4v5ccit90gl" data-title="骏 伯 Junbo" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-春招2024" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/10/20/%E6%98%A5%E6%8B%9B2024/" class="article-date">
  <time class="dt-published" datetime="2023-10-20T03:11:00.000Z" itemprop="datePublished">2023-10-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/10/20/%E6%98%A5%E6%8B%9B2024/">春 招 2024</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <img src="https://github.com/leo710aka/bk/blob/main/CV2024.png?raw=true" width="550" height="300" alt="">

<h2 id="教育经历"><a href="#教育经历" class="headerlink" title="教育经历"></a>教育经历</h2><p><strong>GPA: 3.31</strong>(<em>3.34</em>)<sup>2020.09 - 2024.07</sup>  <a href="mailto:&#50;&#x30;&#x32;&#48;&#51;&#x30;&#52;&#52;&#48;&#48;&#x31;&#48;&#x40;&#109;&#97;&#x69;&#108;&#46;&#115;&#x63;&#x75;&#116;&#46;&#x65;&#100;&#117;&#x2e;&#99;&#x6e;">&#50;&#x30;&#x32;&#48;&#51;&#x30;&#52;&#52;&#48;&#48;&#x31;&#48;&#x40;&#109;&#97;&#x69;&#108;&#46;&#115;&#x63;&#x75;&#116;&#46;&#x65;&#100;&#117;&#x2e;&#99;&#x6e;</a><br><strong>主修课程：</strong>数据结构(90), 计算机网络(84), 数据库(87), 操作系统, C++(94), Java<br><strong>在校经历：</strong>曾获学校与企业奖学金, “三好学生”等荣誉，发表 EI 会议论文一篇。曾加入学院青马工程班学习，担任华工青年志愿者指导中心宣传部副部长，有丰富的志愿活动和学生组织经历。<br><strong>语言技能：</strong>CET-6 <em><strong>486</strong></em> (2022.06) CET4：530(2021.06)<br><strong>荣誉奖项：</strong>五粮液优秀学生奖学金 (2023.10)，华南理工大学三等奖学金 (2022.09)，广东省第十一届大运会“优秀志愿者” (2022.06)<br>2022—2023学年度 “三好学生”×，校级“优秀公益组织骨干”，”青马工程”班优秀学员<br>2021—2022学年度 “三好学生”，“两优两红优秀共青团员”<br><strong>Publications：</strong><br>[1] Feng Cai, Jingxu Peng, Peng Zhou, “Current Study on Image Restoration Leveraging CNNs and GANs”, <strong>2024.02.14</strong>, 2023 International Conference on Data Science, Advanced Algorithm and Intelligent Computing (DAI 2023)<br>近年来，图像恢复技术中CNN和GAN应用广泛。DnCNN模型通过残差和批量归一化有效去噪地震图像。SRGAN使用GAN和感知损失函数提高图像质量。Constrained-DnCNN模型进一步优化地震数据解读。CR-SRGAN专注于文物超分辨率和颜色恢复，采用特殊的训练数据集。DCGAN结合CNN和GAN特点，展现出在特征提取和适应数据分布方面的优势，是图像恢复领域的有前景研究方向。 <a target="_blank" rel="noopener" href="https://www.atlantis-press.com/proceedings/dai-23/125998064">https://www.atlantis-press.com/proceedings/dai-23/125998064</a> </p>
<h2 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h2><h4 id="Java-后端方向："><a href="#Java-后端方向：" class="headerlink" title="Java 后端方向："></a>Java 后端方向：</h4><ul>
<li>熟练掌握 Java 基础，集合等相关知识，了解常见的设计模式。</li>
<li>熟悉 JVM 的垃圾回收机制、类加载机制及 Java 的内存区域。</li>
<li>熟悉 Java 并发编程，掌握JUC中常用的工具类，如 ConcurrentHashMap 等，熟悉多线程，线程池，Java 内存模型。</li>
<li>熟悉 OSI 七层模型和 TCP&#x2F; IP 四层体系分层结构，掌握常见网络协议，如 HTTP&#x2F; HTTPS、TCP、UDP、DNS等。</li>
<li>熟练使用 MySQL 数据库，熟悉 MySQL 索引、事务、存储引擎、锁机制。</li>
<li>熟悉操作系统的进程通信、死锁、内存管理等知识。了解Linux 常用命令。</li>
<li>熟悉 Redis 数据类型使用场景和内部实现，熟悉持久化和过期淘汰策略，熟悉缓存高并发场景。</li>
<li>熟悉 RabbitMq 的使用，了解消息可靠性的保证、死信队列、延时队列等，了解 Kafka 的基本使用</li>
<li>熟练使用 Spring Boot、Spring、MybatisPlus 等常用框架，熟悉 Spring IOC 、AOP 原理，了解 Nacos 、Zookeeper 等常见组件。</li>
<li>了解 SpringCloud 常用的微服务组件及其使用;如NacosRibbonFeign、HystrixGateway等</li>
<li>数据结构：了解常见数据结构如数组、链表、栈、队列、二叉树等;熟悉常用算法如双指针、递归、排序算法等</li>
</ul>
<h2 id="实习经历"><a href="#实习经历" class="headerlink" title="实习经历"></a>实习经历</h2><ul>
<li><p><strong>广州骏伯网络科技有限公司</strong>_Java开发实习生_2024年01月~至今_广州</p>
<ul>
<li>主要工作：<ul>
<li>参与用户拉新系统的开发。当用户点击我方投放的广告后，将消息推送到拉新系统的 mq 队列中，我方作为消息的消费者进行消息拦截和转发。通过 Kafka 进行削峰处理，避免 QPS 过高导致的系统负担。</li>
<li>开发白名单功能。在消息转发的过程中，先从本地缓存及 Redis 中查看白名单数据，未命中则调用相关接口拦截非目标用户。在白名单中添加我发的测试手机设备号，从而在投放新的广告后进行联调测试。</li>
<li>参与内部报表平台的开发。根据产品原型图设计数据库表，开发报表数据的分页查询接口。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>广东创世科技有限公司</strong>__Java开发实习生__2023.03-2023.05__广州<br>牙医星球小程序：负责”个人中心”部分接口以及相关数据库字段的设计，实现了在线视频的弹幕功能。<br>广东省青少年科技创客大赛系统：参与了该在线编程竞赛平台的学生端功能开发。在已有项目的基础上，编写完善了学生登录、编程题判题等方面的代码。熟悉了团队开发流程以及 git 的日常开发使用。</p>
</li>
<li><p><strong>中国电信股份有限公司东莞分公司</strong>__IT开发工程师__2023.07-2023.08__东莞<br>参与电信AI知识库的建设，打造电信业务专家水平的对话机器人。负责测试本地知识库，完善知识云文档，以及收集资料供大语言模型进行训练。此外，接触了开源项目，学习了深度学习框架。</p>
</li>
</ul>
<h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2><h4 id="“校跑跑”校园代拿平台"><a href="#“校跑跑”校园代拿平台" class="headerlink" title="“校跑跑”校园代拿平台"></a>“校跑跑”校园代拿平台</h4><ul>
<li>项目描述：”校跑跑”平台是一款致力于解决大学校园内代拿服务需求的创新型应用，提供方便快捷的外卖、快递、文件等代拿业务，同时确保支付双方的信用和流程的可跟踪。</li>
<li>主要工作：<ul>
<li>在任务发布模块，通过产品原型总结出代拿服务任务模型，并使用双值枚举的方式对类型、数量、状态等进行存储。</li>
<li>在任务列表模块，实现了多筛选和多排序条件下的动态分页列表查询。</li>
<li>使用数据库悲观锁，解决同一跑腿任务的超卖订单问题，实现抢单唯一。 </li>
<li>为代拿双方的陌生人服务安全性，对每个状态进行流水记录。流程状态切换中实现了照片上传的可靠性，为了节省服务器带宽，使用腾讯云 COS 直传方案，提供预签名给前端，保障了 COS 的安全性。</li>
<li>在接单前，需要接单人支付押金，实现跑腿人押金的支付、押金退还的事务处理。</li>
</ul>
</li>
</ul>
<h4 id="高校闲置资源交易系统"><a href="#高校闲置资源交易系统" class="headerlink" title="高校闲置资源交易系统"></a>高校闲置资源交易系统</h4><ul>
<li>系统架构：SpringCloud + SpringBoot + Nacos + Redis + MySQL</li>
<li>项目描述：系统采用微服务架构，旨在为消费者提供一站式商品交易平台。通过细致的业务划分，系统分为用户模块、商品模块、购物车模块与支付模块，确保每个模块服务的高效、可维护、可扩展。</li>
<li>主要工作：<ul>
<li>使用 Nacos 实现服务注册，消费者服务通过 Nacos 拉取和订阅服务。</li>
<li>引入 Redis 数据库，优化项目中登录验证码的使用，对需要频繁访问的数据进行缓存。</li>
<li>使用 Gateway 及拦截器实现了登录信息校验，避免各微服务中的代码重复。</li>
<li>通过 Sentinel 完成系统限流熔断功能，防止服务故障后影响整个系统运行。</li>
</ul>
</li>
</ul>
<!-- #### 尚医疗、、、

* 项目架构：SpringBoot、SpringCloud、Nacos、Gateway、Feign、MyBatis-Plus、Redis、RabbitMQ、Nginx、微信三方登录、EasyExcel、阿里云SMS
* 项目简介：尚医疗平台是一款互联网在线预约挂号平台，以互联网手段连接医院、医生和患者,为用户实现网上就能轻松的预约挂号，缓解看病难、挂号难的就医难题。
* 项目主要由后台管理系统和前台用户系统2大部分组成。
1.后台管理部分核心模块: 医院设置管理、数据字典、用户管理、订单管理、统计管理以及权限控制等功能。
2.用户前台使用部分的核心模块： 医院列表展示、医院科室详情展示、用户手机号或微信登录、用户实名认证、就诊人管理、预约挂号以及就医提醒等功能。


#### 手写Spring、、、
项目名称：手写 Spring
项目架构：Spring Framework
项目描述：Spring 是 Java 应用编程开发中，非常常用的技术框架。在 Spring 框架下，其他的组件都需要进行扩展依赖注入到 Spring 容器进行统一管理。同时日常的开发中，80%的问题场景，都需要调试到 Spring 的源码才能更好的解决，为此深度学习 Spring 源码非常有必要。
个人收获：
首先对 Spring 源码的学习，是 Spring 对整个 Bean 对象声明周期所需节点的拆解，把一个对象细化到这样的一个程度，才能让我们在使用 Spring 的时候，基于对外暴露的接口和类，更好的扩展各个功能节点。
掌握了最重要的模板模式，Spring Bean 周期容器的使用，就是流程复杂的大模板，通过模板定义了全系的调用结构。这样的设计也为我以后在开发业务代码时候提供了参考建议，为我们自身复杂的业务定义出模板结构。
分治、抽象、知识，Spring 源码中，有非常多的接口的实现、抽象类的定义、功能类的继承，这是非常重要的设计手段，因为它可以让我们的代码具有立体化，分层化，把各个职责放到不同的类维护可以让以后的迭代成本更低。
细节的学习，Spring 源码中有非常多的技术细节，尤其是像Event事件设计、Aware依赖倒置、AOP切面实现、Bean循环依赖等，都是在特定复杂场景中优秀的设计方案。这些设计模式、设计原则，都可以指导业务代码开发。 -->


<h4 id="牛客论坛（-高校就业信息分享平台）"><a href="#牛客论坛（-高校就业信息分享平台）" class="headerlink" title="牛客论坛（-&gt; 高校就业信息分享平台）"></a>牛客论坛（-&gt; 高校就业信息分享平台）</h4><ul>
<li>项目描述：一个基本功能完整的论坛项目。主要功能有: 基于邮件激活的注册方式，区别登陆状态为游客或已登录用户展示不同界面与功能。支持用户上传头像，实现了发布帖子、评论帖子、发送私信与过滤敏感词等功能，以及点赞，关注与系统通知功能。<br>项⽬构建在 Spring Boot + SSM 框架之上，并统⼀的进⾏了状态管理、事务管理、异常处理。<br>（项目是一个以就业信息分享为基点的信息分享平台，在平台上学生可进行就业信息或者学习资源的分享，增加学习就业信息的获取渠道，例如，发布帖子，发布招聘信息，学生间可以互相关注，私信来互相分享资源。）</li>
<li>核心功能:<br>1、用户模块：使用 Spring Email 辅助发送注册激活邮件，并且使用 Interceptor 拦截器赋予不同类型的用户权限，解决http无状态带来的缺陷问题，保护需登录才能查看的资源。<br>2、内容模块：使用 Spring AOP 面向切面编程思想统一记录日志；数据库连接使用 Mybatis 框架来完成，实现SQL语句和代码的分离，解除了SQL语句与代码的耦合。<br>3、通知模块：使用 Kafka 消息队列构建异步消息系统，实现点赞关注与通知（系统）间削峰。</li>
<li>项目优化:<br>1、引入 Redis 数据库，优化项目中 Session 的使用并利用 Redis 实现点赞和关注功能。<br>2、使用 Caffeine + Redis 实现两级缓存，优化了热门帖子的访问。（借用 Jmeter 工具测试吞提升20倍）<br>(使用 Spring Security 提高系统的安全性，防CSRF攻击；使用拦截器解决登录状态剧新及频繁刷新问题)</li>
<li>组价描述：<ul>
<li>项⽬构建在 Spring Boot + SSM 框架之上，并统⼀的进⾏了状态管理、事务管理、异常处理；</li>
<li>利⽤ Redis 实现了点赞和关注功能，单机可达5000TPS；（对频繁需要访问的数据，如用户基本信息使用Redis作为本地缓存，提高服务器性能。采用事务管理保证数据的正确，采用“先更新数据库，再删除缓存”策略保证数据库与缓存数据的一致性；）</li>
<li>利⽤ Kafka 实现了异步的站内通知，单机可达7000TPS；（在用户被点赞、评论、关注后，放入异步队列，以系统通知的方式推送给用户）</li>
<li>利⽤ ElasticSearch 实现了全⽂搜索功能，可准确匹配搜索结果，并⾼亮显示关键词；</li>
<li>利⽤ Caffeine + Redis 实现了两级缓存，并优化了热⻔帖⼦的访问，单机可达8000QPS。</li>
<li>利⽤ Spring Security 实现了权限控制，实现了多重⻆⾊、URL级别的权限管理；</li>
<li>利⽤ HyperLogLog、Bitmap 分别实现了 UV、 DAU 的统计功能，100万⽤户数据只需*M内存空间；</li>
<li>利⽤ Quartz 实现了任务调度功能，并实现了定时计算帖⼦分数、定时清理垃圾⽂件等功n能；</li>
<li>利⽤ Actuator 对应⽤的 Bean 、缓存、⽇志、路径等多个维度进⾏了监控，并通过⾃定义的端点对数据库连接进⾏了监控。</li>
</ul>
</li>
</ul>
<h2 id="社团-组织经历"><a href="#社团-组织经历" class="headerlink" title="社团&#x2F;组织经历"></a>社团&#x2F;组织经历</h2><ul>
<li><strong>华南理工大学青年志愿者指导中心</strong>  <em>宣传部 副部长</em> 2022.04-2023.04<br>1.承接中心的摄影任务，组织志愿活动的现场拍摄，负责培养部门成员的基本摄影能力；<br>2.协助完成中心公众号推文制作，宣传大运会、广州马拉松、志愿一条街等活动中的志愿服务工作；<br>3.负责部门的内建工作，营造良好氛围。</li>
</ul>
<h2 id="个人陈述-个人优势"><a href="#个人陈述-个人优势" class="headerlink" title="个人陈述&#x2F;个人优势"></a>个人陈述&#x2F;个人优势</h2><ol>
<li>本科就读于华南理工大学网络工程专业，曾获学校与企业奖学金，三好学生等荣誉，以共同第一作者发表 EI 会议论文一篇；（曾加入学院青马工程班学习，担任华工青年志愿者指导中心宣传部副部长，有丰富的志愿活动和学生组织经历；）</li>
<li>熟悉 Java 开发，能够熟练使用 Spring Boot、Spring、Mybatis 等常用框架，有着坚实的专业知识和实践经验；大学期间，我参与了多个项目或实习，不仅深入了解了软件开发流程，还培养了问题解决的能力和团队协作技巧； </li>
<li>我对信息科技领域充满热情，对新技术和趋势保持关注，有较强的自我学习能力。希望能在企业数字化转型中，应用技术来推动创新和提高效率。</li>
</ol>
<h2 id="应聘理由"><a href="#应聘理由" class="headerlink" title="应聘理由"></a>应聘理由</h2><p>我对Java后端和软件开发有着坚实的专业知识和实践经验。在大学期间，我参与了多个项目或实习，不仅深入了解了软件开发流程，还培养了问题解决的能力和团队协作技巧。<br>东莞银行一直以来都在金融科技方面取得了卓越的成就，我渴望加入这个充满活力和创新的团队，共同推动银行业务的数字化转型。我相信自己的技术背景和对金融领域的热情将使我成为东莞银行信息科技团队的有力资产。</p>
<ol>
<li>个人优势：<br>作为一个经验丰富的Java软件开发者，我在面向对象编程、分布式系统设计以及大规模数据处理方面具备深厚的技术功底。我在之前的项目中，成功地设计和实施了高性能的、可扩展的Java应用程序，这使我对云核心网线Java软件开发的挑战充满信心。我的解决问题的能力以及对新技术的快速学习适应能力，将使我能够在贵公司的项目中迅速融入并取得成绩。</li>
<li>选择行业：<br>我一直对云计算和核心网络领域保持浓厚的兴趣，深知这是当今数字化时代的基础。贵公司在云核心网线方面的领先地位以及对新技术的持续投资，使我对能够参与并推动这个领域的发展充满憧憬。我渴望加入贵公司，通过亲身参与和贡献，不断提升自身技术水平，同时为公司在行业内的创新发展贡献力量。</li>
<li>商业价值：<br>我深刻理解软件开发不仅仅是技术问题，更是在商业环境中为客户提供切实解决方案的过程。我注重将技术与商业需求相结合，通过深入了解客户需求，迅速响应市场变化，为公司创造有价值的产品。我相信我的经验和技能将有助于提高贵公司的竞争力，实现商业和技术的双赢。</li>
</ol>
<h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><p>入学以来，我始终保持着积极向上的态度，希望在各方面都能够取得进步。在这段充实的时光里，我探索了知识的广度和深度，结识了众多志同道合的朋友，培养了坚韧的意志力，以及树立了对未来充满信心的决心。<br>未来的日子里，我将继续发扬个人优点，脚踏实地，真诚做人，潜心做事，不断地提高自己，为社会作出更大的贡献！</p>
<ol>
<li>思想上：我热爱祖国，积极学习党的理论，加入了学院青马工程班学习，努力成为一名合格的入党积极分子。我热心公益服务，在校青志宣传部担任副部长，为志愿精神在校园中的传递而努力。也在各项活动中积极参与志愿者工作，帮助有需要的人。</li>
<li>学习上：我能够比较自觉和广泛地学习专业知识，勤奋刻苦，在各科目中都取得了不错的成绩，获得校级奖学金两次。我参与到前沿的科研项目中，以共同第一作者发表一篇国际会议论文。</li>
<li>课余生活中，我也积极参与了各种文体活动。我乐于与人沟通，把握团队合作的机会，在学习与人协作的过程中，我的沟通和协调能力得到了不断加强。我也积极参与到课外实践中，完成了三段企业实习。这不仅锻炼了我的专业技能，更在团队协作的过程中，培养了实际解决问题的能力。同时，我也在不断思考未来的职业发展和目标，努力打下一个好的基础。</li>
</ol>
<hr>

<h2 id="2024春招"><a href="#2024春招" class="headerlink" title="2024春招"></a>2024春招</h2><ul>
<li>乐刻运动<ul>
<li>一面 3.17<br>  java锁，，rentanlock<br>  HashMap如何处理10w条插入？为什么大小是2的指数？一开始就要创建大容量；方便在计算插入下标时与数组大小或运算<br>  jvm组成？？老年代，GC，回收期？？<br>  new一个对象的过程、、<br>  mq消息确认？事务本地回滚？？channel<br>  redis多路查询为什么这么快？？过期了怎么办？手动设置一个迭代中不过期？？<br>  mysql查询优化<br>  面试官：把基础搞好，在实践中运用</li>
</ul>
</li>
<li>卓望数码<ul>
<li>一面 3.18<br>  多态、、线程创建方法，区别，，工厂模式&#x2F;抽象工厂模式？？<br>  ACID、、<strong>D是永久性！！</strong>索引，最左匹配？<br>  IO，如何读取一个不知道类型的文件A数据到文件B中？buffer，inputstream？？<br>  sentinel流控，，<br>  远程debug？？IntelliJ IDEA 中”Run” 菜单”Edit Configurations”配置远程调试，填写调试服务器的主机名&#x2F;IP 和端口号，然后启动远程调试会话，设置断点和调试；<br>  面试官：动手能力不太行，基础知识不深入</li>
</ul>
</li>
<li>小鹏汽车<ul>
<li>一面 3.20<br>  最有收获的项目、、项目几个模块、、<br>  抢单悲观锁实现、、<br>  支付怎么做的、、微信支付？？<br>  实习做了什么？拉新具体做了啥？<br>  kafka消息顺序？<br>  mysql隔离等级，，<br>  jvm内存区域几个部分？<br>  springboot特点？<br>  spring bean依赖项目还能启动吗？<br>  OSI七层、、<strong>5.会话层、、6. 表示层</strong></li>
</ul>
</li>
<li>新凯来<ul>
<li>技术面 3.21（通过）<br>  实习工作、、没讲清楚<br>  收获了什么、、mq的使用，kafka技术选型<br>  项目复杂度、、创业项目，量级小<br>  lc1023</li>
<li>性格测评重测：<strong>不够积极</strong></li>
</ul>
</li>
<li>4399游戏<ul>
<li>一面 3.21<br>  具体怎么熟悉了团队开发流程、、<br>  实习工作、、消息拦截逻辑，消息参数与枚举值比对，equals？？<br>  非法字检查？微信小程序接口、前缀树？？    BST、、<br>  网络知识学习：实现弹幕功能用了websocket，还可以用什么别的方法？TCP，Redis？？<br>  TCP编程？socket聊天室？？<br>  对这份工作有什么期待、、</li>
</ul>
</li>
<li>TPlink联洲<ul>
<li>机考算法：1、最长回文子串 java11?? 2、lc1114按序打印</li>
<li>一面 3.21<br>  TCP&#x2F;UDP，MySQL索引，synorized与lock，实现hashmap、、尾插法的好处，spring设计模式，<strong>动态代理</strong>、、jdk，cglib<br>  实习：如何拦截<br>  项目：本地缓存与Redis不同步<br>  有没有offer！？</li>
<li>二面 3.26<br>  实习、、拦截，可以用spring的设计模式或者技术吗？？策略模式，aop非业务，，<br>  白名单过期时间，量很大用布隆过滤器的缺点、、<br>  kafak架构，如何实现高吞吐量，前后吞吐量2000qps-&gt;200kbs<br>  项目、、不感兴趣，要说设计还是亮点？<br>  retranlock，可重入锁，，<br>  mysql、、隔离等级，索引优化，查看索引的使用 explain？？ mvcc？？ </li>
<li>终面 3.27<br>  论文、考研、父母工作、数学挂科、实习、、<br>  项目：腾讯云 COS 部署，校内创业团队人数（产品经理 2、前端1~2、后端核心2迭代有空来、、），使用springcloud框架为什么还用nacos，sentinel？？</li>
<li>终面-已进入人才库 4.25</li>
</ul>
</li>
<li>广州农商银行（英才计划）<ul>
<li>面试 3.27 放弃</li>
</ul>
</li>
<li>经纬恒润<ul>
<li>面试 3.29<br>  实习、、kafka选型、其他mq了解吗、白名单缓存一致性<br>  反射、泛型、mysql索引失效，in？？设计模式<br>  事务的使用、事务传播、、spring拦截器，过滤器、、gateway路由，断言<br>  智力：八个球，其中一个比较重，其余质量相同，如何用天平秤两次找出较重的球？</li>
</ul>
</li>
<li>多益网络（-&gt; CPP游戏引擎研发）<ul>
<li>面试 4.3<br>  最有挑战的项目？？难点？？<br>  团队有几个人，工作流程，如何协调（接口文档？）和前端沟通？？<br>  java的优缺点，垃圾回收算法，链表与数组，浅拷贝与深拷贝<br>  线程安全，如何保证（乐观锁，悲观锁），线程与进程<br>  静态绑定，动态绑定，编译时多态，运行时多态<br>  面向对象的三个特点、、<strong>为什么需要继承和多态？？</strong><br>  Redis作缓存的缺点与解决方法<br>  介绍框架：spring、springboot、mybatis<br>  如何学习的？看视频+chatgpt发文、、有没有使用搜索引擎？google、stackflow？？<br>  玩什么游戏？我的世界，根据三维坐标保存每一个格子的类型，那么要用三维数组表示整个空间，如何优化存储方式？？百度实景地图的原理？？</li>
<li>hr面 4.10<br>  薪资？20k，18k，如何得出这个薪资的？<br>  什么时候来实习？实习-&gt;试用-&gt;正式<br>  秋招，春招offer情况，考研，每段实习时间都不长<br>  了解岗位要求，转cpp吗？入门语言<br>  了解公司业务吗？玩网页游戏少<br>  工作时长996+周末半天，学习时间<br>  籍贯，家庭，接受广东外工作地点，对象<br>  父母怎么看待你找工作？如何评价父亲？</li>
<li>未录用</li>
</ul>
</li>
<li>招商银行·招银网络科技<ul>
<li>测评 北森测评<ol>
<li>语言理解：直接看题，提炼几条关键逻辑，再看题目</li>
<li>图表分析：先看题目，再看图</li>
<li>图形推理：找规律、、叠加，合并消除，各类图形总数、、</li>
<li>性格测评：最符合&#x2F;最不符合</li>
</ol>
</li>
<li>机考 4.1</li>
<li>一面 4.7<br>  String比较可以用 &#x3D;&#x3D; 吗？Arraylist.remove() 报什么错？HashMap键可以null？<br>  jvm内存区域、如何写一个程序让方法区oom<br>  线程安全问题、<strong>synorized和reentrantlock的本质区别，底层实现？？</strong>cas存在什么问题？？<br>  数据库acid，索引是什么<br>  tcp三次握手的本质、http的组成，http头有什么部分<br>  十万个数取最大10个、二分排序</li>
<li>综面 4.16<br>  技术：项目，商城redis的使用，redis客户端？？<br>  hr：挂科原因，，最大的缺点？？实习长短、项目时间重合，实习目的（项目缺人&#x2F;应届生招聘），如何评审，上线时间紧张怎么办？<br>  <strong>考研！！</strong>没考，找工作确实比较晚，技术栈：七月份开始学，秋招技术不足，春招积累面试经验后通过<br>  反问：招聘流程，工作时长</li>
<li>未通过</li>
</ul>
</li>
<li>中国平安·平安寿险<ul>
<li>面试 4.8<br>  项目介绍很烂。。同一时间代拿任务发布量级很大的情况下怎么动态分页查询？？<br>  实习：拦截具体工作是什么？媒体-&gt;拉新，调接口？？拉新-&gt;APP后台，发http请求，rpc？？整个拦截流程，流stream？？kafka重复消费，redis标识符，消息量很大？？报表具体有什么字段，如何设置的？？</li>
</ul>
</li>
<li>深圳农商银行（信息技术岗）<ul>
<li>面试 4.8<br>  实习：kafka如何知道通道、、git怎么用分支的<br>  项目：如何过滤非法字？乐观、悲观锁，锁升级，MySQL事务，@transaction失效？为什么用nacos？限流和熔断？？项目部署，linux文件中查找？？<br>  hr：为什么放弃考研？家庭情况？为什么匹配银行岗位？女朋友？</li>
<li><strong>offer 4.23</strong></li>
</ul>
</li>
<li>万得wind<ul>
<li>面试 4.9<br>  kafka怎么实现限流的<br>  任务发布到发布客户端，重复刷新查mysql？？一百个人抢单，请求直接到数据库吗？？nacos如何实现服务注册，<br>  多态，<strong>接口与抽象类</strong>，有用过吗？？设计模式，哪里体现了多态，单例模式，，</li>
</ul>
</li>
<li>TPlink普联<ul>
<li>面试 4.10<br>  校跑跑：与实习时间重叠（非全职，有需求就去），redis非重复支付，抢单为什么不用缓存层？商城redis使用<br>  实习：kafka怎么限流，，考虑不使用kafka优化？？延时双删？？<br>  synchronized的底层实现，<strong>jvm堆结构、gc、类加载机制</strong>，mysql的b+树索引结构+查询优化，mysql优化（数据库结构+具体使用中的sql优化）</li>
<li>二面 4.18<br>  秋招情况，offer情况，实习，项目</li>
<li>座谈 5.14</li>
<li>offer 5.15</li>
</ul>
</li>
<li>58同城<ul>
<li>面试 4.11<br>  动态代理，线程状态、生命周期，<strong>线程池</strong>，Reentrantlock底层，信号?<br>  redis数据类型，zset有什么应用<br>  GC算法，<strong>G1和CMS</strong>的区别，内存泄露和内存溢出<br>  springboot特点，自己写一个starter， MyBatis中#和$的区别<br>  ConcurrentHashMap1.7，ArrayList扩容<br>  MySQL日志，二阶段提交<br>  面试官一直试图找到亮点、、</li>
</ul>
</li>
<li>Shopee虾皮<ul>
<li>面试 4.13<br>  拉新系统框架，难点，广告重复点击<br>  kafka架构，消息重复消费，redis删除策略<br>  lc239</li>
</ul>
</li>
<li>北森云计算（-&gt; C# 北京&#x2F;成都）<ul>
<li>面试 4.17<br>  白名单作用，key-value怎么设置？？<br>  kafka消费模式？？使用场景<br>  redis基本类型，使用场景<br>  CPU 飙高系统反应慢怎么排查？<br>  互斥锁，线程池、删除策略？<br>  接口与抽象类，值和引用，Array和ArrayList<br>  <strong>Ioc容器</strong>及使用，设计模式，工厂模式的使用<br>  学习路线，职业规划</li>
</ul>
</li>
<li>Boss直聘<ul>
<li>面试 4.18<br>  拉新系统解决痛点，<strong>拦截逻辑</strong>？？kafka重复消费，同时重复消费？？本地缓存caffeine<br>  跑腿抢单悲观锁，为什么不用乐观锁？如何优化，加缓存层？？<br>  互斥锁选型、reentranlock底层原理？怎么实现公平锁？？<br>  平时如何学习？博客，技术论坛？<br>  微服务调用，轮询？？</li>
</ul>
</li>
<li>阿里-银泰<ul>
<li>面试 4.19<br>  kafka组成，选型，消息丢失？redis为什么这么快？<br>  <strong>sentinel</strong>服务治理，使用场景，自己设计一个组件统计各个微服务的qps<br>  mysql索引建立与使用，关系型与非关系型，索引中的节点上是什么？？</li>
</ul>
</li>
<li>美团·优选<ul>
<li>面试 4.22<br>  kafka消息堆积？？白名单二级缓存解决了什么问题？本地、redis、数据库同步？？<br>  报表是在查出a表后分页再联合查b表，还是a,b表联合查询后再分页？<br>  抢单乐观锁实现，reentrantlock底层，<strong>可重入？？</strong>集群部署下分布式事务？？退款事务，先退款先流水？？<br>  hashset的value存了什么？线程池加入线程使用空闲线程？联合索引怎么创建的？浏览器输入url的流程用到什么协议？操作系统与java线程的联系？</li>
</ul>
</li>
<li>比亚迪<ul>
<li>面试 4.24 放弃</li>
</ul>
</li>
<li>途牛旅游网<ul>
<li>面试 4.24<br>  jvm类加载过程，双亲加载机制<br>  hashmap原理，大小为2^n：hash值与数组大小与运算<br>  redis<strong>缓存击穿，缓存穿透</strong>，分布式锁<br>  SpringAOP、spring循环依赖、事务传播，sql优化</li>
</ul>
</li>
<li>宇量晟<ul>
<li>背景：华为＋国资？？半导体</li>
<li>面试 4.26<br>  岗位：在线系统用c&#x2F;cpp，离线系统用python，需要转语言<br>  c指针，智能指针，内存管理，多线程与多进程，二叉树&#x2F;红黑树<br>  算法：判断点在三角形内，句子翻转单词不翻转</li>
<li>测评 4.29<br>  <em>要前后一致，然后要表现的乐观积极，团队合作，不能选带领导意愿的选项？不一定要讨好型，也可以硬气一点？？</em></li>
<li>综面 5.18 放弃</li>
</ul>
</li>
<li>灵动科技<ul>
<li>AI赛道创业公司？<ul>
<li>初创公司：与大厂精细化的分工相比，初创公司开发岗位需要承担的工作可能更加复杂，缺少完善的培养机制和技术积累；需要更多的自我学习和解决问题的能力，锻炼的机会多，发展更灵活，有创新的机会，与公司共同成长。。</li>
<li>AI思考：外部（未来趋势，AI一方面在各行业普及，一方面使用门槛降低。。虽然算法研究岗位少，但是也存在很多AI应用岗位），内部（大学期间对AI热情很高，到老师实验室学习（自学经典AI课程），在东莞电信实习也参与了对话机器人项目（了解开源对话大模型），参加夏令营研究项目。。）</li>
<li>岗位认识：这是一家AISaaS公司，专注于打造全球商业市场的通用人工智能应用软件平台，我们正在深圳寻求一位热情目具有技术潜力的应届毕业生后端工程师，作为后端工程师，您将使用大模型和先进技术，开发和实施可扩展和稳健的软件解决方案。一方面，我对AI算法和大模型有基本了解，一方面我掌握Java开发、、</li>
<li>产品了解：GPT-4驱动的翻译软件？？出海业务？利用人工智能进行翻译、本地化和全球扩张</li>
<li>反问：作为创业公司，为什么不请经验丰富的工程师，而是应届生？我的情况：六月才能实习，已签三方</li>
</ul>
</li>
<li>初面 4.30<br>  美团毛利润计算：支出，收入？？<br>  明确：对您公司的岗位有强烈的倾向，收到offer可以立刻入职（非实习），对薪资要求不高（15k）</li>
</ul>
</li>
<li>中国平安·平安金服<ul>
<li>初面 4.30<br>  最左索引底层原理（聚集索引？？），b+索引与哈希索引，原子类？？，https，对称加密<br>  感觉你面试经验挺多的？？</li>
</ul>
</li>
<li>realme真我<ul>
<li>面试 5.7<br>  重载与重写，http头内容，死锁，缓存类型和理解<br>  redis数据类型，集群部署，数据一致性，场景：查一个字符串类型数据为什么花了5s？<br>  数据库索引失效情况<br>  毕设做的什么。。</li>
</ul>
</li>
<li>交通银行<ul>
<li>面试 5.9<br>  项目，spring，依赖注入，单例，手撕：链表中是否有环？</li>
</ul>
</li>
<li>美的·软件工程院<ul>
<li>一面 5.10<br>  logn曲线，快速排序为什么不稳定<br>  可重复读底层原理，mvcc，Redis分布式锁</li>
<li>二面 5.10<br>  三个优点，举例勤奋</li>
<li>hr面 5.11<br>  部门（软件工程院办公系统）业务（办公系统）双休（保证？？）<br>  基本工资（12^12+12^3^绩效）五险一金（比例？？）餐补（每日20）房补（租房900&#x2F;月）</li>
<li><strong>offer 5.14</strong></li>
<li>入职 7.8</li>
</ul>
</li>
<li>东方财富<ul>
<li>一面 5.13<br>  缓存与数据库的一致性，微服务架构，服务治理</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>投递：官网（使用内推码），Boss直聘（快速筛选简历），宣讲（甚至直通面试）</li>
<li>前期：中厂刷经验，了解面试流程以及各部分常考题，掌握八股，熟悉个人实习和项目描述</li>
<li>后期：大厂过不去，小厂捡漏，虽然八股基本覆盖还需深挖项目和实习中的每一个步骤，了解场景解决方法和项目优化方案</li>
<li>改进：前期浪费了很多中小厂机会，白给厂没把握住（挂科+终面出错），大厂能力不足，最好一定要参加秋招。。。</li>
</ul>
<hr>

<h1 id="签约"><a href="#签约" class="headerlink" title="签约"></a>签约</h1><ul>
<li>流程：签三方（- 毁约）- 入职报道 - 签劳动协议（三方失效）- 试用期 - 转正</li>
<li>文件<ul>
<li>毕业生推荐表：一份原件，毁约后要取回</li>
<li>毕业生就业协议：即三方，一次毁约机会</li>
<li>两方协议：约束小</li>
</ul>
</li>
<li>违约（一次机会）<ul>
<li>提交违约申请书：本人签字，无需提供原单位解约函，每月的10号、20号、30号之前交给辅导员</li>
<li>违约申请通过：名单见“就业在线”<a target="_blank" rel="noopener" href="https://jyzx.scut.edu.cn/">https://jyzx.scut.edu.cn/</a></li>
<li>原单位解约流程：1、手写并签名书面违约申请。2、违约金。获得原单位解约函。</li>
<li>提交“新单位盖章的违约申请表”和“原单位解约函”给学校，审核通过后生成新就业协议书，与新单位签订三方。</li>
</ul>
</li>
<li>应届毕业生<ul>
<li>择业期：应届生身份通常可以保留两年。</li>
<li>失效：一旦就业或缴纳社保，应届毕业生身份即失效。</li>
<li>好处：银行、国企校园招聘优先，落户政策好.</li>
</ul>
</li>
<li>户口<ul>
<li>户口未迁来学校的毕业生，如户口需迁往工作单位的按户籍所在地公安机关的管理规定办理。</li>
<li>不同的城市和地区有不同的落户政策，对于高校研究生毕业后的落户条件、流程和所需材料都可能有不同的规定。一些城市可能会对应届毕业生提供更为宽松的落户政策。</li>
<li>户口保留：如果暂时没有找到合适的工作或者希望继续深造，可以选择将户口保留在原学校或原籍。在保留期间，需要注意保管好自己的户口页和相关证明材料，以备将来使用。</li>
</ul>
</li>
<li>毕业去向登记与档案信息填报<ul>
<li>档案整理：家庭情况、学习成绩、政治思想表现、身体状况等</li>
<li>档案转递：按“广东大学生就业创业”小程序填写地址转递，一般于2024年7月中下旬开始寄送</li>
<li>通过“广东大学生就业创业”小程序签订就业协议书且回传审核完成的，就业信息同步至“毕业去向登记”和“初始档案信息”模块</li>
</ul>
</li>
<li>社保公积金<ul>
<li>五险：即社保，养老、医疗、生育、工伤、失业保险，每月缴，公司缴大头个人缴小头，通常按国家及当地标准缴纳</li>
<li>一金：即住房公积金，按 “个人月薪&#x2F;当地平均居民收入” 为缴纳基数</li>
<li>到手工资 &#x3D; 税前年包 - 税款 - 五险一金（个人缴纳部分）<table>
<thead>
<tr>
<th>内容</th>
<th>个人缴纳比例</th>
<th>单位缴纳比例</th>
<th>作用</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>养老保险</td>
<td>8%</td>
<td>20%</td>
<td>累计交满15年，退休后终身享受养老金</td>
<td>能中断没有影响</td>
</tr>
<tr>
<td>医疗保险</td>
<td>2%</td>
<td>10%</td>
<td>医疗报销50%以上退休后享受医保待遇特点</td>
<td>中断3个月以上失效</td>
</tr>
<tr>
<td>生育保险</td>
<td>0%</td>
<td>0.8%</td>
<td>生育后资料给单位，报销相关费用</td>
<td>生育津贴个人不能微纳</td>
</tr>
<tr>
<td>工伤保险</td>
<td>0%</td>
<td>0.2~1.4%</td>
<td>工伤时获得医疗费用，保工作期间和下班途中</td>
<td>工伤保险个人不能缴纳</td>
</tr>
<tr>
<td>失业保险</td>
<td>1%</td>
<td>2%</td>
<td>缴费满1年，失业后按照缴费年限领取失业保险金，主动辞职的不可以领取</td>
<td>失业保险个人不能缴纳</td>
</tr>
<tr>
<td>住房公积金</td>
<td>5~12%</td>
<td>5~12%</td>
<td>租房、买房、装修房都可使用，特别是贷款买房利率低</td>
<td>可断缴(影响贷款)，可提取&#x2F;异地转移</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/10/20/%E6%98%A5%E6%8B%9B2024/" data-id="cm0cja96r000sm4v5cjvs3iyt" data-title="春 招 2024" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-面试_个人" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/10/13/%E9%9D%A2%E8%AF%95_%E4%B8%AA%E4%BA%BA/" class="article-date">
  <time class="dt-published" datetime="2023-10-13T03:11:00.000Z" itemprop="datePublished">2023-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/10/13/%E9%9D%A2%E8%AF%95_%E4%B8%AA%E4%BA%BA/">面 逝 | 个人</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="个人"><a href="#个人" class="headerlink" title="个人"></a>个人</h2><ul>
<li><p><strong>自我介绍</strong><br>1、面试官您好，我是蔡枫，本科就读于华南理工大学计算机学院<br>2、在校期间，我学习 Java 开发技术与相关组件，也跟着学校的创业团队的开发了一些项目<br>3、有几段实习经历，让我对团队中的开发流程有了一定的了解，并且也参与到了实际业务代码的编写<br>4、我与您公司岗位比较匹配：中台数据转发、、银行数字化转型、、<br>5、我的求职动机：挑战性，成长，机会，，自己清晰的职业规划，表示愿意长期从事这个岗位，，</p>
</li>
<li><p>自我推荐。<br>我觉得我对所从事的每一个项目都很努力、负责、勤勉。我在努力成为一个能够不惧解决困难和能够持续学习的人。</p>
</li>
<li><p>校园经历？</p>
<ul>
<li>大学里最大的收获：在母校的关怀中茁壮成长，敢于尝试，从课内学习、科研、项目经验都积累了，，（因为学校鼓励我们敢于尝试，又会包容我们犯错，激励我们成长）</li>
<li>重来一次哪方面可以做的更好：多融入社会，多尝试新东西，把技能学的更加深入、、</li>
<li>挂科：确实挂了数学，主要原因是刚入学没有适应大学的这种学习模式（上课没学进去，课后也没补上来，或者说不知道如何自学）后面的课程我虽然有的在课上没学到什么，但是课后会主动地通过网络课程、技术网站等方式增进了解，也是增强了信息查找和自我学习的能力、、</li>
<li>参加了什么比赛，实验室项目？<br>  参加过学院的acm竞赛，，到老师的实验室学习过，参与过一些科研学习的项目，发布过一篇论文。我积极参与实践，有一些项目开发经验，有三段实习经历。。。</li>
<li>你的论文？<br>  我参加了一个“深度学习-图像处理”项目。五周的时间里，通过导师的授课讲解与指导，我拓展了该领域的专业知识，接着着手阅读文献和动手做实验。之后，我便与小组成员紧密合作，从主题确定，到文献的深入研读，完成论文写作，最终也发表了一篇论文。主要是希望接触学习人工智能这一块的知识（在学校没有机会和资源，，，）</li>
<li>说一下你的社团活动？<br>  我在华工青年志愿者指导中心宣传部担任了为期一年的（副）部长，这将我的摄影能力和对志愿服务的热情结合起来。我多次承担志愿活动现场的拍摄任务，用相机展现志愿者们的奉献精神，通过青志公众号推文等形式在校园中传播志愿精神。</li>
</ul>
</li>
<li><p><strong>你对本公司的情况了解吗？为什么选择我们公司？</strong><br>1、对公司的了解：、、（行业的前景+公司的规模+公司在行业中的地位+特色产品）<br>2、自己跟岗位的匹配：、、（结合岗位要求+自我经历）<br>3、符合自己的职业规划：、、</p>
</li>
<li><p>了解 Java 后端开发这个行业岗位吗？是否符合期许？<br>我认为 Java 后端开发是一个非常有挑战性的领域，开发能够为人们的生活带来便利的软件，对我来说是有趣的。在互联网企业应用广泛，有活力，发展前景好？？<br>Java 作为一门强大而灵活的编程语言，具有广泛的应用领域，尤其在企业级应用开发中表现出色。<br>我在大学期间学习和做项目的过程中接触到了Java编程，并且在后来的时间加强了对相关技术的学习。我期望能够在一个具有挑战性、创新性和学习机会的团队中工作，我也希望自己能成为一个能够解决困难和不断学习的人。Java开发是一个不错的领域。</p>
</li>
<li><p>“想到一个什么样的平台发展？”<br>我希望能够在一个具有挑战性的环境中工作，可以让我不断学习和提升自己。<br>我注意到贵公司在（行业&#x2F;领域）取得了显著的成就，我相信我的Java开发技能可以在这里发挥出色的作用，我认为通过在这样一个领先的平台上工作，我将有机会为公司的发展和创新做出贡献，与公司一起成长。</p>
</li>
<li><p>“对于第一份工作，你更看重什么？”</p>
<ol>
<li><strong>技术挑战和学习机会：</strong> 对技术挑战有热情，渴望学习新技术。希望这份工作能够提供丰富的项目经验，快速成长、、</li>
<li><strong>导师与团队：</strong> 当然我希望积累团队协作、项目开发的经历，与不同的人合作，分享知识并共同解决问题。对我的职业生涯进行规划、、</li>
<li><strong>公司文化和价值观：</strong> 强调你对公司文化和价值观的认同。你可以说你更看重一份工作能够与你的价值观相符，让你在一个积极、支持性的工作环境中工作。</li>
</ol>
</li>
<li><p>认为怎样是好的开发工程师？<br>1.技术深度和广度：了解Java语言的方方面面，包括基础语法、多线程、IO等，熟悉常用的框架和工具。以及其他相关技术<br>2.问题解决能力：具有良好的问题解决能力。能够独立分析问题、理解需求、提出解决方案，并快速有效地实现。<br>3.代码质量：写出高质量的、可维护的代码。注重代码规范、模块化和可测试性。<br>4.团队协作：良好的团队协作能力是软件开发中至关重要的一环。有效沟通、分享知识，并能够与团队成员协作解决问题。<br>5.持续学习：技术日新月异，一个好的开发者应该保持持续学习的习惯，关注新技术的发展，随时准备适应行业的变化。<br>6.创新思维：善于提出新的、创造性的解决方案，对于提升产品和团队的效率具有积极的作用。<br>7.用户导向：理解产品和项目的业务需求，站在用户的角度思考问题，以用户体验为中心。</p>
</li>
</ul>
<hr>

<h2 id="实习（骏伯）"><a href="#实习（骏伯）" class="headerlink" title="实习（骏伯）"></a>实习（骏伯）</h2><ul>
<li><p>广州骏伯网络？<br>使命：让移动互联网营销简单高效; 价值观：创造价值，分享价值; 愿景：做最受信赖的移动互联网营销服务商;<br>产品研发中心 - 应用开发部-基础建设组 - Java开发实习生 - 2024.1.8 ~ 4.12</p>
</li>
<li><p><strong>介绍一下实习经历、、</strong></p>
<ul>
<li>岗位职责：互联网营销行业公司，主要接触了公司核心的拉新系统的迭代开发，另外独立开发了公司内部的报表平台的接口</li>
<li>一个项目：其中拉新系统让我印象深刻、、<ul>
<li>项目是什么：拉新指的是给例如 APP 拉取新的用户，实现方法是 我发根据 APP 的要求投放广告到如 抖音 等媒体平台，那么就会产生广告的曝光、用户点击等数据消息，需要转发给 APP 端。我方的拉新系统就在消息转发过程中，进行一个消息拦截的工作。具体来说，消息会先发送到我方拉新系统的mq，一方面进行了kbs的削峰，然后根据需求和策略进行拦截处理，最后才转发给 APP，，</li>
<li>简化版（非技术介绍）：我方投放广告，接收“上游”的数据，感觉业务逻辑拦截以及一系列处理后，转发到“下游”；一方面进行了前后行为解耦，一方面削峰处理，为客户提供合适的数据；</li>
<li>为何这样做：这样，就给企业提供了符合要求的消息数据，我方获得收益</li>
<li>负责的工作：就是参与拉新系统的迭代开发，我负责数据拦截这一部分，具体来说实现了白名单功能，，</li>
<li>有什么成果：，，实现联调，，节约成本</li>
<li>最大的收获：</li>
<li>最大的成果：</li>
<li>重来会改变：</li>
</ul>
</li>
</ul>
</li>
<li><p>拦截到底做了什么？？</p>
<ul>
<li>通过 stream() 调用一系列方法：<ul>
<li>参数前置处理（initPreValidate）（一些通用逻辑，比如点击数据ID、时间字段的初始化）。</li>
<li>参数校验（isValid）（校验点击数据是否有效，如果无效则不发给客户，比如媒体可能会将用户曝光数据发过来，此时不需要发给客户）。</li>
<li>参数后置处理（initPostValidate）（一些带有复杂业务逻辑的处理，比如RTA拦截）。</li>
<li>将校验通过的点击数据发给客户（transferToCustomer），http请求。</li>
<li>保存数据到数据库&#x2F;缓存（save）。  <img src="https://github.com/leo710aka/bk/blob/main/job18.png?raw=true" width="550" height="300" alt=""></li>
</ul>
</li>
<li>内部处理逻辑（在initPostValidate部分，进行RTA拦截）<ul>
<li>拦截指什么：设置状态为 NON_CLICK_NOT_TRANSFER_TO_CUSTOMER，后续代码流程识别出此状态后，不会将该数据发给客户。</li>
<li>拦截逻辑：<ul>
<li>校验点击数据是否有效，如果无效则不发给客户，比如媒体可能会将用户曝光数据发过来，此时不需要发给客户</li>
<li>RTA拦截：对于某些客户，我方在发送点击数据给对方时，需要调用客户的接口进行确认，判断当前用户是否是客户的目标用户，如果不是，则不发送点击数据给客户。则设置状态RTA_EXCLUDED，后续代码流程识别出此状态后，不会将该数据发给客户。</li>
<li>走RTA拦截，有一些前置条件，包括：<br>  1、业务方指定了客户点击监测链接ID为RTA链接（客户的点击监测链接是客户提供过来用于接收我方点击数据的接口）（RTA链接是一个标记，标识当前点击数据发给客户前，要先调用客户的RTA接口过滤一道，最终只发送客户需要的用户）<br>  2、如果当前数据类型为曝光，且曝光总数与点击总数的比例小于requestRate（默认为4:1）<br>  对于满足前置条件的数据，则发起RTA请求，将结果记录下来（结果指的是客户是否接受当前用户，即是否参竞-isParticipated），用于业务方后续使用</li>
<li>白名单：为实现整个转发过程的联调，不拦截内部测试设备号（可能遭到rta拦截），即使客户不接受当前用户（内部测试手机），不设置状态RTA_EXCLUDED，此时后续流程会正常将该数据发给客户</li>
</ul>
</li>
</ul>
</li>
<li>可以用spring的设计模式或者技术吗？？？<ul>
<li>策略模式，</li>
<li>aop非业务，，暴露接口给监控系统</li>
</ul>
</li>
</ul>
</li>
<li><p>kafka 架构？kafka 如何实现高性能，高吞吐量？kafka 消费模式？如何不消费重复数据，顺序消费数据？如何不丢失数据？kafka内部是怎么实现限流的？、、、</p>
</li>
<li><p>你们项目中为什么要用消息队列？ MQ 的作用是什么？</p>
<ul>
<li>【异步】拉新系统接收媒体数据存放于 kafka，再消费即拦截处理后才转发，涉及io、阻断、调用客户接口、数据库、、</li>
<li>【削峰】接口接收2000qps的请求，以 200kbs 消费 mq中的数据，解决系统前后处理能力不一致的问题</li>
</ul>
</li>
<li><p>不使用kafka，如何优化消息前后处理速度不一致的问题？</p>
<ol>
<li>异步处理：将消息的后续处理逻辑设计成异步执行，可以使用 Java 中的线程池或者异步任务（CompletableFuture）来实现。<ul>
<li>使用线程池：用<code>ThreadPoolExecutor</code>或者<code>ExecutorService</code>来创建线程池，然后将需要异步执行的任务提交到线程池中。线程池会自动管理线程的创建、执行和销毁，可以有效地减少线程的创建和销毁开销。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>); <span class="comment">// 创建固定大小的线程池</span></span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 异步执行的操作，例如IO操作、数据库操作等</span></span><br><span class="line">&#125;);</span><br><span class="line">executor.shutdown(); <span class="comment">// 关闭线程池</span></span><br></pre></td></tr></table></figure></li>
<li>使用异步框架：有些框架提供了异步执行的支持，例如Spring框架的<code>@Async</code>注解。通过在方法上添加<code>@Async</code>注解，可以将方法变成异步执行的方法。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 异步执行的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>批量处理：将一批消息聚合在一起批量处理，而不是单个消息逐一处理。这样可以减少处理的次数和开销。</li>
<li>并发处理：考虑使用多线程或者并发框架来提高处理效率。注意处理任务的并发性要合理控制，避免因并发导致的资源竞争和数据一致性问题。</li>
</ol>
</li>
<li><p>白名单功能如何实现？</p>
<ul>
<li>白名单使用逻辑：1、先查看是否在白名单中（认为是目标用户）2、若不在白名单中，再调用户提供的接口进行RTA拦截（目标用户判断）</li>
<li>如何使用：直接查本地缓存caffeine的白名单，<strong>因此，必须保证本地缓存与Redis数据的一致性！！（事实上有20min延误）</strong></li>
<li>白名单在Redis中的保存形式：一个 Set<String></li>
<li>白名单如何维护：需要新增时(上线前)手动Postman调接口，使用 SADD 命令向 Set 中添加一个或多个成员（事实上在数据库中保存了完整的精准的数据，需要时从数据库中同步）  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SADD whitelist member1 member2 member3  <span class="comment"># 白名单的 key-value</span></span><br></pre></td></tr></table></figure></li>
<li>Redis 数据何时过期？可以调用 Redis 的 EXPIRE 命令为单个键（Key）或整个 Set 设置过期时间，也可以通过 SETEX 命令一次性设置键的值和过期时间以确保设置值和过期时间的原子性。  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPIRE myset 60         <span class="comment"># 设置 myset 整个 Set 结构的过期时间为 60 秒</span></span><br><span class="line">EXPIRE myset:value1 60  <span class="comment"># 设置 myset 中的 value1 元素的过期时间为 60 秒</span></span><br></pre></td></tr></table></figure></li>
<li><strong>Redis-MySQL-caffeine数据一致</strong>：Redis 提供了键过期时的通知功能，可以通过配置 Redis 的 notify-keyspace-events 参数来开启过期事件通知。在 Redis 配置文件中设置 notify-keyspace-events Ex，表示开启键过期事件通知。<br>  <em><strong>设置redis数据过期时长为20分钟，到期后，会触发数据库查询，同时会将数据加载到本地缓存中，用于接下来一个20分钟；</strong></em></li>
</ul>
</li>
<li><p>为什么需要Redis+caffeine二级缓存？</p>
<ol>
<li>关系数据库(Mysql)数据最终存储在磁盘上，每次读取会因为磁盘本身的IO影响读取速度，所以考虑Redis这种内存缓存。</li>
<li>内存缓存(Redis)确实能够很大程度的提高查询速度，但也许避免同一查询大量的并发查询，也会有明显的网络IO上的消耗。</li>
<li>那我们针对这种查询非常频繁的数据(热点key)，可以考虑存到应用内缓存如caffeine，当应用内缓存有符合条件的数据时，就可以直接使用而不用通过网络到redis中去获取；另外我个人认为，可能对于一些“常规业务无关”的数据，也可以放在本地缓存，避免对Redis查询、、</li>
</ol>
</li>
<li><p>本地缓存与Redis不同步、、</p>
<ol>
<li>延时双删：参考redis与mysql缓存一直方法，先删除 Redis存数，再更新 MySql，延迟几百毫秒除 Redis存数据，这样就算在更新 MySql时，有其他线程读了Mysql，把老数据读到了 Redis中，那么也会被制除掉，从而把数据保持一致 </li>
<li><strong>定时刷新</strong>：设置redis数据过期时长为20分钟，到期后，会触发数据库查询，同时会将数据加载到本地缓存中，用于接下来一个20分钟</li>
<li><strong>异步更新</strong>：在应用中实现异步更新机制，当 Redis 中的数据发生变化时，异步地更新 Caffeine 本地缓存中的数据。可以使用消息队列或者异步任务来处理更新操作，确保更新操作不影响应用的正常运行。</li>
<li>手动更新：更新 Redis 缓存后，由业务代码手动触发本地缓存的更新操作。</li>
</ol>
</li>
<li><p>如何保持Redis与数据库一致？</p>
<ul>
<li>延时双删：对于读数据，我会选择旁路缓存策略，如果 cache 不命中，会从 db 加载数据到 cache。对于写数据，我会选择更新 db 后，再删除缓存。</li>
<li>针对删除缓存异常的情况，我还会对 key 设置过期时间兜底，只要过期时间一到，过期的 key 就会被删除了。</li>
<li>除此之外，还有两种方式应对删除缓存失败的情况，都是异步操作：<ul>
<li>消息队列：重试缓存的删除<br>  我们可以引入消息队列，将第二个操作（删除缓存）要操作的数据加入到消息队列，由消费者来操作数据。<br>  如果应用删除缓存失败，可以从消息队列中重新读取数据，然后再次删除缓存，这个就是重试机制。当然，如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。如果删除缓存成功，就要把数据从消息队列中移除，避免重复操作，否则就继续重试。</li>
<li>Canal+MQ：订阅 MySQL binlog再操作缓存<br>  订阅 MySQL binlog，再操作缓存「先更新数据库，再删缓存」的策略的第一步是更新数据库，那么更新数据库成功，就会产生一条变更日志，记录在 binlog 里。<br>  于是我们就可以通过订阅 binlog 日志，拿到具体要操作的数据，然后再执行缓存删除，阿里巴巴开源的 Canal 中间件就是基于这个实现的。<br>  Canal 模拟 MySQL 主从复制的交互协议，把自己伪装成一个 MySQL 的从节点，向 MySQL 主节点发送 dump 请求，MySQL 收到请求后，就会开始推送 Binlog 给 Canal，Canal 解析 Binlog 字节流之后，转换为便于读取的结构化数据，供下游程序订阅使用。</li>
</ul>
</li>
</ul>
</li>
<li><p>报表平台的开发流程？</p>
<ul>
<li>根据产品原型图设计数据库表，主键自增，，</li>
<li>使用junboGenerator插件生成表结构对应的MyBatis代码（DO, BO, Mapper文件），用于操作数据库。</li>
<li>实现分页功能，大致步骤包括：<br>  ①【newenergy-api】定义XXXApi接口及page方法<br>  ②【newenergybg-service】定义XXXService接口及page方法<br>  ③【newenergybg-service】定义XXXApiImpl类（Controller），实现XXXApi接口及page方法，通过调用XXXService完成分页查询数据的操作<br>  ④【newenergybg-service】定义XXXServiceImpl类，实现XXXService接口及page方法，通过MyBatis分页插件及XXXMapper的查询方法，完成分页查询。<br>  ⑤【newenergy-api】发布XXXApi：修改版本号（xx.snapshot），发布新的jar包（包含新的XXXApi接口）到 Maven 仓库；<br>  ⑥【newenergy-web-admin】引入最新的XXXApi：更新maven，依赖新版本jar包，以使用新的XXXApi接口<br>  ⑦【newenergy-web-admin】定义XXXWebApi类及page方法（Controller），通过XXXApi的page方法，完成分页查询。</li>
<li>SOA架构，服务关系：<br>  【newenergy-api】：定义接口信息，同时被【newenergybg-service】和【newenergy-web-admin】依赖<br>  【newenergybg-service】是【newenergy-api】的实现，实际的服务端；<br>  【newenergy-web-admin】接收前端请求（防止暴露实际服务端），从 maven 获取 jar 包反射获取接口和实体类信息。<br>  实际请求发送流程为：前端客户端程序发起请求 -&gt;【newenergy-web-admin】XXXWebApi.page -&gt; 【newenergybg-service】XXXApiImpl.page -&gt; 【newenergybg-service】XXXServiceImpl.page -&gt; 【newenergybg-service】 XXXMapper.selectByExample</li>
<li>参数信息：<br>  Api方法中：XXXRequest、XXXResponse，在【newenergy-web-admin】XXXWebApi.page方法上加了 @JunboResponse，，，<br>  分页查询entity类：由于需要返回的数据是由多表查询而来，任一 BO 或 DO 都没法涵盖所有属性字段。所以新增一个 类 ConvCallbackRuleDailyReportPageItem，要在 mapper.xml 里修改 resultMap 中查询数据与返回值的对应关系，在后续数据转换的过程中主要前后类的字段的对应。</li>
<li>集成测试：本地启动newenergybg-service服务和newenergy-web-admin服务，通过postman调用接口进行测试，期望结果是，查出来的结果与数据库中的数据一致。</li>
<li>协同开发：git</li>
</ul>
</li>
<li><p>分页查询细节、、</p>
<ul>
<li>先到 “a表” 获取第i到第i+size行的“广告报表数据”（广告id，报表数据类型，时间，，），再根据“广告id”到 “b表” 关联查询该广告的详细信息（客户方，创建时间，，）</li>
<li>SQL：<code>select * from a left join b on a.id = b.id limit 9, 10 where a.id &lt; 10</code><ol>
<li>执行 FROM 和 LEFT JOIN 操作，将表 a 和表 b 进行关联查询。</li>
<li>然后根据 WHERE 条件进行过滤，筛选出 a 表中 id 小于 10 的数据。</li>
<li>最后应用 LIMIT 9, 10，表示从第 9 行开始，获取 10 行数据，即获取 id 小于 10 的数据中的第 10 ~ 19 行数据。</li>
</ol>
</li>
<li>优化：在查出表 a 的数据后先进行分页（使用子查询或者临时表来实现）再对表 b 进行关联查询。好处在于：减少不必要的数据传输和处理，提高查询效率和性能。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.<span class="operator">*</span>, b.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> a <span class="keyword">WHERE</span> id <span class="operator">&lt;</span> <span class="number">10</span> LIMIT <span class="number">9</span>, <span class="number">10</span>) <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> b <span class="keyword">ON</span> a.id <span class="operator">=</span> b.id;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>为什么不考虑转正？</strong><br>应届生自然想去大平台，渴望挑战性和创新性的项目，，骏伯是一个比较小的公司，业务是互联网营销行业的，可能就会缺少一些技术积累，，，</p>
</li>
<li><p>遇到了什么困难？<br>环境架构都已经配好并且部署在在线环境中，对组件的使用也封装好了，难的难在对实际业务的理解<br>我个人开发中遇到的crud不难。比较麻烦的是理解公司的开发模式？？使用插件生成BO, DO, Mapper,, </p>
</li>
<li><p>工作中学习到了些什么？和同事沟通了什么？<br>工作方面：熟悉团队开发流程（敏捷开发，需求澄清和故事点评估）, k8s，掌握git的开发使用，单元测试？？<br>技术方面：mq的选型与使用、枚举类型直接对应数据库的INTEGER??配置、SOA架构、、（高版本Java的特性（虚拟线程、模式匹配、lambda、ZGC、GraalVM-aot），高并发-&gt;NIO、协程、虚拟线程，单元测试）</p>
</li>
<li><p>如何保证代码质量？<br>单元测试？？+测试</p>
</li>
<li><p>在项目开发中，什么时候让你感到获得了成就感？<br>1.<strong>项目完成阶段：</strong> 成功地完成一个项目的不同阶段或整个项目时，会带来成就感。2.<strong>解决难题：</strong> 遇到复杂的技术难题，经过努力和钻研后成功解决，这种时刻会让你感到非常有成就感，特别是那些曾经让你感到困扰的问题。3.<strong>用户满意。</strong> 4.<strong>团队协作：</strong> 项目中的团队合作是一个重要的方面。当你与团队成员协同工作，成功地推动项目的进展，共同克服了困难，整个团队的成功会带来强烈的成就感。5.<strong>学到新知识：</strong> 在项目中学到新技术、工具或方法，应用这些知识解决实际问题，这种学习和应用的过程本身就是一种成就感。6.<strong>项目的成功实施：</strong> 当项目成功实施，交付给用户并产生了积极的影响时，你会感到自己的努力和贡献是有意义的。7.<strong>持续改进：</strong> 成功地推动了项目的持续改进，通过引入新的工程实践、工具或流程，使项目更加高效和可维护。</p>
</li>
</ul>
<h2 id="实习（创世）"><a href="#实习（创世）" class="headerlink" title="实习（创世）"></a>实习（创世）</h2><ul>
<li><p>“牙医星球”小程序，做了什么？</p>
<ol>
<li>接口设计？<br>  根据用户提供的功能清单和产品原型图，结合已有的数据库表字段，尝试设计了小程序“个人中心”部分的接口以及相关的数据库字段设计。<br>  例如，根据用户id查询和修改用户信息，分页查询用户在这个小程序上报名的课程列表，查询用户学习在线课程的记录。<br>  同时，也设计了在线课程学习记录表，按照用户id分区创建不同的线上课学习记录表，避免把所有用户的学习记录放到一张表中。其中“连续学习天数”这个字段，放到了user_info表中作为用户属性字段；同时在user_info表中增加了一个“最近学习日期”，在更新“连续学习天数”时可根据“最近学习日期”判断是否连续，同时将“最近学习日期”更新。</li>
<li>视频弹幕功能？<br>  使用 WebSocket 协议，在一个持久连接上进行全双工通信，实现客户端和服务器之间的实时通信。与传统的HTTP通信相比，减少了网络开销和延迟。<br>  使用 ws 实现实时弹幕的功能：客户端与服务端建立 ws 连接后，使用 WebSocket包中的Session类保存与这个客户端的连接会话，根据ws 连接中携带的用户的connectionId，将这个session保存在静态的线程安全的ConcurrentHashMap中，同时在redis中创建&#x2F;刷新该用户信息；当服务端收到客户端通过ws连接发送的消息时，从reids中找到所有 最近70s内创建&#x2F;刷新的 用户连接的connectionId，在Map中找到对应的session，给用户端发送这条新弹幕，同时刷新redis中的用户信息。<br>  第一次接触http以外的协议，websocket协议是http的升级，服务端接口使用的是@ServerEndpoint(“&#x2F;“)获取连接信息。对于获取connectionId这个请求，应该在ws连接之前发生，所以使用一个controller实现获取connectionId请求，随后客户端使用js代码调用ws接口，建立ws连接。在开发过程中，发现有关弹幕的service类无法在ws接口中正确注入，所以建议把（通过mybatis）保存弹幕信息到数据库这个行为也分开在controller中实现，点击“发送弹幕”后，先调用controller保存弹幕信息，然后调用ws接口实现实时弹幕。</li>
</ol>
</li>
<li><p>编程平台项目，做了什么？</p>
<ol>
<li>项目整体情况：一个在线少儿编程竞赛平台，学生登录平台，在竞赛时间内获取试题，答题和提交。构建在SSM + SpringBoot上，有统一的返回结果格式 JsonResult，统一的成功&#x2F;失败返回码。</li>
<li>学生登录：<ul>
<li>生成图像验证码uuid：UUID生成验证码唯一标识 uuid，Hutool 库生成一个圆形验证码。将 uuid 和 验证码的base64编码 返还前端。将验证码标识和验证码内容以键值对的形式（uuid，code）存储到 Redis中，有效期为60秒。</li>
<li>发生短信验证码sendsms：同时以 JsonResult给前端返回该手机号下的所有学生账号（以label、value形式，返回数组 List&lt;Map&lt;String, Object&gt;&gt; stu）因为一个家长的手机号可对应多个孩子的学生账号</li>
<li>登录：使用手机号+学生姓名+密码登录。验证密码是否正确（base64编码+md5加密【不可逆】后，与数据库中存的密码去除头四个尾两个字符后比较），验证码uuid是否存在（返还给前端的标识）且正确（用户输入的验证码），</li>
<li>修改密码：一系列的判断，提交是否为null或空、账号是否存在、新密码是否满足给定的正则格式，接着要与数据库中的原密码（可）和同一登录账号下其他学生密码（不可）判断是否重复。用户输入的密码存入数据库，要经过：base64加密，和项目密钥连接后进行 MD5哈希加密，再通过randomTest.getRandomStr()随机增加到前4个字符和后2个字符。</li>
</ul>
</li>
<li>编程题判题：<ul>
<li>@Transactional(rollbackFor &#x3D; Exception.class) 声明事务，将提交编译题方法 <code>getCompileAnswer</code>包裹在一个数据库事务中，抛异常后回滚。</li>
<li>判断学生id存在，是否在比赛时间，是否已提前交卷（有scoreRecord记录）</li>
<li>使用 restTemplate给布置在服务器上的”判题机”发生编程题判题请求，返回判题结果</li>
<li>如果没有提交记录，新增compileAnswer，判断剩余提交次数；如果此次提交编程题成绩大于原纪录中的，更新记录</li>
<li>返回前端：（success: ; resultCode: ; resultMsg: ; data:通过样例数，平均时间，平均内存）</li>
</ul>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>与产品经理，前端沟通？<br>原来使用coding代码协同和项目管理，在蓝湖放了原型设计，通过微信沟通。后面统一改用飞书。<br>先开一个项目启动会，确定如静态页面，接口开放，前后端连接调试的进度，时间管理。。？？<br>开发过程里，我通过看产品原型进行理解，结合项目代码和文档理解，开发接口时与前端对接。。。</p>
</li>
<li><p>你遇到的最大的挑战是什么？怎么解决的？<br>一开始的时候，我虽然有ssm，mybatis基础，但是等于一些注解，方法还是一知半解，而且没有看过项目代码，不会看接口文档，没用过git等，，一整个就是非常无从下手。后来就是硬着把需求相关的代码看完，每个小细节都自己查方法或者问同事，从最简单的一个需求开始一个个解决，测试，提交，逐渐上手。当然后面也把缺的技术补上了。<br>（技术上遇到的困难，应该就是复杂的业务逻辑吧，如编程题判题）</p>
</li>
</ul>
<hr>

<h2 id="项目1（跑个腿）"><a href="#项目1（跑个腿）" class="headerlink" title="项目1（跑个腿）"></a>项目1（跑个腿）</h2><ul>
<li><p>“校跑跑”校园代拿平台 <a target="_blank" rel="noopener" href="https://www.naoffer.com/course/class/302">https://www.naoffer.com/course/class/302</a></p>
<ul>
<li>项目描述：”校跑跑”平台是一款致力于解决大学校园内代拿服务需求的创新型应用，提供方便快捷的外卖、快递、文件等代拿业务，同时确保支付双方的信用和流程的可跟踪</li>
<li>主要工作：<ul>
<li>在任务发布模块，通过产品原型总结出代拿服务任务模型，并使用双值枚举的方式对类型、数量、状态等进行存储。</li>
<li>在任务列表模块，实现了多筛选和多排序条件下的动态分页列表查询。</li>
<li>使用数据库悲观锁，解决同一跑腿任务的超卖订单问题，实现抢单唯一。</li>
<li>为代拿双方的陌生人服务安全性，对每个状态进行流水记录。流程状态切换中实现了照片上传的可靠性，为了节省服务器带宽，使用腾讯云 COS 直传方案，提供预签名给前端，保障了 COS 的安全性。</li>
<li>在接单前，需要接单人支付押金，实现押金支付、押金退还的事务处理。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>介绍一下跑腿项目！！</strong></p>
<ul>
<li>“校跑跑”是我们学校创业团队做的一个项目，后续会上线运营。它是根据校园中的真实的外卖、文件等物品代拿需求而设计的，另外同学看到送货路线与自己顺路可以顺手接单跑腿。同学们在平台上发布订单，接单，支付，同时能够确保支付双方的信用和流程的可跟踪、、</li>
<li>我参与了项目中几个模块的后端开发。（考虑到校园内用户量和流量量级不大，使用的是单体架构，对于存在的订单超卖等一些场景问题，参考了一些别的项目中的做法）；我做的模块里面难点比较多的：<ul>
<li>一个是跑腿任务的发布模块，这个模块一是要对信息进行非法过滤，另一个也要基于redis实现非重复支付的方案</li>
<li>然后在详情模块，针对学生代拿需求比较聚集如午饭的情况，会导致多个人同时抢列表的第一个，导致出现并发问题，我这里使用了悲观锁来解决</li>
<li>另外，要在配送过程中，如何去保证双方陌生人的信用安全？比如说在取货的时候，怎么能够知道是跑腿人去拿的货？而不是别人拿着这个验证码去拿到货，或者是说物品送到了，但是说没送到，或者、、<br>  我们采用的是基于拍照确定地点的方式，比如他到现场，拍照上传，我们才给他公开取货码，他必须在五分钟之内取货，再拍照片，进行验证、、那这个地方就会产生很多的图片，传统的直传方案，会对服务器带宽造成很大的影响，所以项目采用了阿里云或者腾讯云的直传方案，解决了有效性和跨域的签名</li>
<li>第四个押金模块就可以不说了。事务。。</li>
</ul>
</li>
</ul>
</li>
<li><p>你做过最有挑战的项目？难点是、、</p>
<ul>
<li>S：背景    - T：任务    - A：举措    - R：结果</li>
</ul>
</li>
<li><p>项目背景</p>
<ul>
<li>我参与学校创业团队（非全职，有需求就去）的商业项目，目前还未（准备在南航）上线运营，产品需求真实，产品业务做的都是核心的（而一般的实习都是打杂）</li>
<li>需求分析：发单人懒的动弹，需要校内代拿服务；接单人查看送达地点与宿舍很近，回宿舍路上顺便接个单</li>
<li>竞品差别：美团跑腿是根据点到点距离计算费用，我们是根据校内距离不重要，是点到面或者是点到线，也就是这个学生的终点附近的也可以顺手去送，所以可以实现单价比较便宜，一单正常是两块钱</li>
<li>项目架构：单体项目 SpringBoot + Maven</li>
<li>四大模块：跑腿需求发布、跑腿抢单和列表、双方状态和安全、押金和微信支付</li>
<li>产品规划：1、目前是第一版，极小版本上线，核心发布功能、接单功能、押金功能；2、双方信用和评价体系上线；3、集中引用第三方方案(即货物送达方+已经智能货柜)、盗窃监控</li>
<li>团队成员：产品经理*2，后端^3，前端^2</li>
</ul>
</li>
<li><p>一、跑腿需求发布模块</p>
<ul>
<li>产品原型（图）</li>
<li>数据库设计<br>  订单id、发布人id、取货地点、收货地点、货物种类、货物重量、期望送达时间（datetime）、费用、订单状态、创建时间、修改时间  <img src="https://leo710aka.github.io/bk/job17.png" width="550" height="300" alt=""></li>
<li>亮点难点<ol>
<li>(小亮点): 物品信息非法关键字过滤<br>  提交时，使用小程序的过滤接口，对发起人的物品信息要素进行非法关键字过滤，并对手机号和“微信”“vx”等字眼进行正则查验，防止后序跑腿双方私下沟通，</li>
<li>(小亮点): 分类等信息使用双重枚举<br>  对送货的类型、重量等固定有限项要素，要用多值举的方式实现，方便在前端接口和数据库里以字典id类型进行插入，前端传过来的url中携带的是id值（如1：食品、2：文件、、）而不是易错的字符串类型</li>
<li>(大亮点): 后端防止重复提交(一个用户下了多次单)<br>  (1) 目前是单机项目：在提交接口，使用并发方法(sychronized方法)，使用redis随机Key来进行验证(前端生成随机key)<br>  在下单页面加载时，在后端生成一个唯一的标识符（例如 UUID）作为订单提交的唯一标识符，将这个一次性的标识符存到 Redis。当用户点击提交订单时，在后端根据用户提交的标识符从 Redis 中获取对应的标识符。如果获取到了，则是首次提交，处理后返回提交成功，并且删除redis中的标识符；如果未获取到，则表示是重复提交。<br>  (2) 后序推广到更多高校，变成分布式环境时，考虑升级到redis分布式锁</li>
</ol>
</li>
</ul>
</li>
<li><p>防止重复提交的逻辑：<br>在下单页面加载时，后端生成一个UUID作为订单提交的唯一标识符，将这个一次性的标识符存到 Redis。当用户点击提交订单时，根据用户提交的标识符从 Redis 中获取对应的标识符。如果获取到了，则是首次提交，处理后返回提交成功，并且从Redis中删除；如果未获取到，则表示是重复提交。</p>
</li>
<li><p>二、跑腿抢单和动态列表模块</p>
<ul>
<li>产品原型<br>  查看跑腿订单详细信息后点击“立即接单”，抢单后才可查看发布人信息（电话，取货码（在安全模块处理），备注）<br>  跑腿动态列表通过排序、筛选，展现跑腿订单（接单人可以将自己宿舍作为收货地址进行筛选）</li>
<li>业务逻辑<ol>
<li>跑腿任务详情模块目前只做展示和下单，接单过程不在本模块。需要提供任务详情展示接口和抢单接口</li>
<li>列表模块需要考虑多条件动态排序、筛选，实现分页接口</li>
<li>抢单跑腿详情和订单支付的逻辑<br>  跑腿详情状态有：1 等待抢单； 2 已被抢； 3 已确认(抢单后需要手动确定或取消，如果1分钟内不取消，自动变成确认)；4 超时费单<br>  (1) 某一用户点击抢单时，需要判断是否是1和2的状态，这两个状态都可以触发排队60s流程<br>  (2) 如果是1，则用户抢单成功，这个时间详情状态变为2，其它用户只能等待60s(60S退出的时候，再做一次(1)r的逻辑)<br>  (3) 如果(2)用户取消订单，则状态变成1<br>  (4) 如果支付成功，则其它用户不能进入流程，已在流程中的依然等待<br>  (5) 20分钟未支付的逻辑需要定时任务触发，详情变成1</li>
</ol>
</li>
<li>亮点难点<ol>
<li>在抢单模块，因为学生代拿时间集中，会造成同一任务的超卖订单，项目使用悲观锁解决（小规模并发）问题<br>  并使用60s倒计时的方案，实现并发抢、已抢但放弃的场景</li>
<li>本模块多处使用定时任务(quartz schedule)更改订单状态，比如1分钟内自动确认和超时废单等</li>
<li>在列表模块，因为校内多地点的选择场景，实现多筛选、多排序下的动态分页接口<br>  3.1排序项:最新(默认)、按金额从大到小<br>  3.2筛选项:多地点、重量、送达时间、类型、数量</li>
</ol>
</li>
</ul>
</li>
<li><p>乐观锁与悲观锁的区别？怎么用？</p>
<ul>
<li>悲观锁：认为资源一定存在竞争，加悲观锁，具备阻塞特性，以保证多事务对统一数据的访问的安全性；<ul>
<li>在并发量不大且冲突频率较低的情况下是有效的，悲观锁可以提供更加稳定和可靠的数据操作保护，提供较为简单和直接的控制方式；尽管乐观锁在并发量较小且冲突频率不高的情况下具有优势，但在数据修改频率较高、竞争激烈的情况下，悲观锁通常更加高效；</li>
<li>但是如果并发量很高或者冲突频率很高，则可能会导致性能问题和系统的阻塞。</li>
<li>使用方法：<ol>
<li>查询订单信息并加锁：在抢单逻辑中，首先要查询订单信息并加锁，防止其他用户同时抢单。读和写是在同一步，查询并加排他锁，确保其他事务无法修改这些数据，直到当前事务提交或回滚。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> id <span class="operator">=</span> ? <span class="keyword">AND</span> status <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>) <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure></li>
<li>更新订单状态：如果查询到符合条件的订单，就可以更新订单状态并完成抢单操作，示例代码如下：  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> orders <span class="keyword">SET</span> status <span class="operator">=</span> <span class="number">2</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> ?;</span><br></pre></td></tr></table></figure></li>
<li>提交事务：完成操作后，需要<code>COMMIT;</code>提交事务来释放锁并保证数据的一致性</li>
<li>？？处理超时情况：针对20分钟未支付的逻辑，可以使用定时任务来触发查询并加锁，然后更新订单状态为1（等待抢单状态）。</li>
</ol>
</li>
</ul>
</li>
<li>乐观锁：认为大部分情况不存在竞争，不加锁（不阻塞），使用版本号version判断是否修改（修改数据同时修改version）<ul>
<li>在并发量大的时候，悲观锁用不了，可以考虑用乐观锁；CAS，MVCC是乐观锁的实现</li>
<li>实现方法：<ol>
<li>版本号字段实现乐观锁：在数据库表中增加一个版本号（version）字段，数据类型通常选择整数。每次更新数据时，将版本号加一。在更新数据时，通过比较当前查询到的版本号与更新时的版本号来判断是否更新成功。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orders (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    order_id <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">UNIQUE</span>,</span><br><span class="line">    version <span class="type">INT</span>,</span><br><span class="line">    <span class="comment">-- Other columns</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新订单方法，使用乐观锁</span></span><br><span class="line"><span class="keyword">UPDATE</span> orders </span><br><span class="line"><span class="keyword">SET</span> version <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span> </span><br><span class="line"><span class="keyword">WHERE</span> order_id <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span> <span class="keyword">AND</span> version <span class="operator">=</span> current_version;</span><br></pre></td></tr></table></figure></li>
<li>时间戳字段实现乐观锁：与之类似</li>
<li>注意事项：<ul>
<li>在使用乐观锁时，需要保证更新操作的原子性，通常可以使用数据库事务来确保。</li>
<li>在比较版本号或者时间戳时，可以通过数据库的原子性操作来实现，例如使用 <code>WHERE</code> 子句中的条件来比较版本号或者时间戳。</li>
<li>当更新操作失败时，可以根据具体业务需求选择重试更新操作或者抛出乐观锁异常供上层处理。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>跑腿抢单的请求是直达数据库吗？可以优化吗？</p>
<ul>
<li>是的。我们项目是第一版，目标也只是在南航一所学校先试点运营，用户量很小，每一个订单的抢单并发 评估过 1s不过超过5人。所以直接使用数据库锁方案。所以我们测试人员只给业务case,完全不做压力测试。</li>
<li>在量级很大的情况下，使用数据库的悲观锁来实现抢单唯一可能会导致性能问题和系统瓶颈。优化方案：<ol>
<li>锁优化：尽量缩短悲观锁的持有时间，只在必要的操作时使用锁，然后尽快释放锁，可以使用事务管理来确保在合适的时候释放锁。尽量减少锁的粒度，比如只针对需要保护的数据进行锁定，而不是整个表或整个数据库。使用乐观锁。</li>
<li>使用缓存：对于频繁读取的数据，可以考虑使用缓存来减轻数据库压力，提高响应速度。</li>
<li>异步处理：对于一些非实时性要求较低的操作，可以考虑使用异步处理方式，将任务放入消息队列或异步任务队列中处理，减少对数据库的直接访问。</li>
<li>分布式架构：如果系统规模非常大并且需要处理大量并发请求，可以考虑使用分布式架构；1、微服务架构：将系统拆分出抢单微服务； 2、负载均衡：将请求分散到多个节点上处理，从而减轻单个节点的压力；3、分布式数据库：分担数据库的读写压力，提高数据库的处理能力和容量；4、分布式锁：确保在分布式环境下，同时只有一个节点（或者说一个进程）能够获取到锁，从而保证对共享资源的操作是互斥的，避免出现数据不一致或者并发冲突的情况。</li>
</ol>
</li>
</ul>
</li>
<li><p>三、跑腿双方状态与安全保障</p>
<ul>
<li>模块说明：本模块是指在跑腿人接单后整体送货流程的状态变化，即针对任务详情状态的”进行中”，进一步扩展细化。包括发布人和接单人双方。</li>
<li>发布人和跑腿人的状态：其中234属于一个阶段，567属于一个阶段<ol>
<li>任务已被接单</li>
<li>物品已被取到</li>
<li>物品未正常取到(物品损坏、没有该商品、取货人故意没取)</li>
<li>物品已损坏(取货和过程中，结束)</li>
<li>物品已通知送达(跑腿人状态)</li>
<li>物品确认收到</li>
<li>物品未确认收到</li>
<li>物品确认有问题(破损等)</li>
<li>任务正常结束<br>  另外，本模块进行最基本的流程安全保障，即在送货人在取货和收货环节拍照确认;发布人在收货环节当面确认(后序加入可选收货码)。</li>
</ol>
</li>
<li>确保跑腿人到达取货位置，才能显示取货码，防止每三方恶意盗窃，通过”拍照上传” + “5分钟之内上传取货拍照”的双重验证 (实际上，产品角度还有两个后期更可靠的方案，1是所有地点接入地图，以位置距离确认 2是商家可变二维码)</li>
<li>亮点难点<ol>
<li>在用户跑单时，通过拍照上传（获取取货码） + 5分钟之内上传取货拍照 的双重验证，保证取货码不被第三方获取。<br>  同时该方案造成大量图片的上传，为缓解服务器带宽压力，使用腾讯云C0S直传来代替传统的后端上传的流程</li>
<li>用户跑单会在双方产生将近10种状态，以送单人的角度设计状态的分类</li>
</ol>
</li>
</ul>
</li>
<li><p>腾讯云COS的参数是怎么配置的？<br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/document/practice/436/9067">https://cloud.tencent.com/document/practice/436/9067</a></p>
</li>
<li><p>图片直传那一块具体做了什么？<br>就是后端，使用的官方SDK，针对前端指定的cos文件夹 和指定的文件名，进行临时权限签名的生成， 同时也保证其它人和文件没有权限直传 保证cos安全性。</p>
</li>
<li><p>四、押金和钱包事务模块</p>
<ul>
<li>模块说明：因为业务上与钱的流水关系很大，需要单独分离是钱包模块，可以是记录流水、以及押金和收入的提现、发起人的退款记录等</li>
<li>亮点难点<br>  1 押金的退还属于原路退回，主要接入对应支付渠道的退款接口，但是核心是退款流程分为两部分，一是退款成功，二是押金流水变更，两个阶段存在原子性，因为这部分业务，属于较低频型业务，所以使用事务方案，而不是补偿方案。<br>  2 提现需要使用另外的支付宝公对私打款接口，在收取10%的平台费用后(不做个税扣除)，进行批量打款。打款不做强可靠性，用户对提现和退款 不像支付要求那么高</li>
</ul>
</li>
<li><p>？？？押金退款的事务？ </p>
<ul>
<li>押金的原路退回可能会破坏退款流水和押金流水的原子性，两个步骤必须一起进行，属于最常见的事务场景 1 退款流水状态变成“已退款” 2 押金退款接口返回成功<br>  接口肯定得有返回值  正常逻辑不要总想着加异常 就算有可能出现异常 在service方法级别 一般都是内部处理 不抛出？？<br>  能不能理解为退款是调接口实现，押金流水是数据库操作？？？事务逻辑如下：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefundService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CrudService crudService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = &#123;RefundException.class, CrudException.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refundAndChangeFlow</span><span class="params">()</span> <span class="keyword">throws</span> RefundException, CrudException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            crudService.changeFlow(); <span class="comment">// ！！先调用流水变更的业务逻辑</span></span><br><span class="line">            退款(); <span class="comment">// 这里是退款的业务逻辑，需要根据具体情况实现</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RefundException e) &#123;</span><br><span class="line">            退款撤销();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CrudException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>升级成分布式、、</p>
<ul>
<li>实现：把单体架构中的service调用变成了微服务的rpc调用，代码层面区别不大</li>
<li>难点：就是要解决网络的不可靠性。分布式架构无非就是把进程内调用变成进程间调用，跨网络、跨节点的网络调用在时间足够长、流量足够大的情况下，就要考虑网络超时的问题，设置超时时间，避免整个系统被拖挂。<ul>
<li>读请求，超时重试</li>
<li>写请求，分布式事务</li>
</ul>
</li>
<li>其他挑战：服务治理（服务发现，服务集群，负载均衡，优雅启停，熔断降级），<strong>数据一致性问题</strong>（对于开发更重要）</li>
</ul>
</li>
<li><p>数据一致性</p>
<ul>
<li>缓存与数据库：异步化</li>
<li>分布式事务</li>
</ul>
</li>
</ul>
<h2 id="项目2（黑马商城-牛客论坛）"><a href="#项目2（黑马商城-牛客论坛）" class="headerlink" title="项目2（黑马商城+牛客论坛）"></a>项目2（黑马商城+牛客论坛）</h2><ul>
<li><p><strong>高校闲置资源交易系统</strong></p>
<ul>
<li>系统架构：SpringCloud + SpringBoot + Nacos + Redis + MySQL</li>
<li>项目描述：系统采用微服务架构，旨在为消费者提供一站式商品交易平台。通过细致的业务划分，系统分为用户模块、商品模块、购物车模块与支付模块，确保每个模块服务的高效、可维护、可扩展。</li>
<li>主要工作：<ul>
<li>使用 Nacos 实现服务注册，消费者服务通过 Nacos 拉取和订阅服务。</li>
<li>引入 Redis 数据库，优化项目中登录验证码的使用，对需要频繁访问的数据进行缓存。</li>
<li>使用 Gateway 及拦截器实现了登录信息校验，避免各微服务中的代码重复。</li>
<li>通过 Sentinel 完成系统限流熔断功能，防止服务故障后影响整个系统运行。</li>
</ul>
</li>
</ul>
</li>
<li><p>单体架构改为微服务架构（分布式架构的一种实现）<br>微服务架构，是服务化思想指导下的一套最佳实践架构方案。服务化，就是把单体架构中的功能模块拆分为多个独立项目。<br>优点：粒度低、团队自治、服务自治</p>
</li>
<li><p>登录的流程，登录状态的检验？？<br>提交登录表单，登录请求 controller —&gt; sevice —&gt; Dao，查询、校验用户信息，生成jwt（用jwtTool生成token），返回登录信息和jwt（或登录失败信息），提示登录成功（失败）。登录成功后，用户在发送请求时（如购物车），在请求头中携带 Authorization（即jwt）</p>
</li>
<li><p>用户登录。。redis怎么用的？</p>
<ol>
<li>？？？Redis 结合 Gateway 完成登录校验（直接拦截后调用 jwtTool 验证不就行了）</li>
<li>使用Redis缓存用户信息：将user缓存到Redis中，获取user时，先从Redis获取。取不到时，则从数据库中查询，再缓存到Redis中。因为很多界面都要用到user信息，并发时，频繁的访问数据库，会导致数据库崩溃。变更数据库时，先更新数据库，再清空缓存；</li>
<li>？？？使用Redis缓存验证码：原本添加到session中，减轻服务器压力。将验证码存到Redis中，方便查询检验；<br>  当⽤户点击刷新验证码时，服务端⾸先给当前需要登陆的游客，设置⼀个随机字符串(kaptchaOwner)，⽤于标识当前这个游客，然后将随机字符串存⼊到cookie中，返回给浏览器，然后服务端的redis保存 “key:随机字符串,value:验证码”。接着⽤户输⼊⽤户名，密码，验证码，再次点击登陆时，服务端会从cookie中拿到kaptchaOwner,通过它，可以从Redis中得到正确的验证码，然后与⽤户输⼊的验证码做⽐较，看是否⼀致。<br>  验证码需要频繁的访问与刷新，对性能要求很高；验证码不需要永久存储，通常在很短的时间内就会失效；分布式部署时，存在session共享问题；</li>
</ol>
</li>
<li><p>Nacos 服务发现</p>
<ul>
<li>消费者需要连接nacos以拉取和订阅服务，因此服务发现的前两步与服务注册是一样（引入nacos-discovery依赖和配置nacos地址），后面再加上服务调用即可  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DiscoveryClient discoveryclient;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlecartItems</span><span class="params">(List&lt;CartVO&gt; vos)</span> &#123;</span><br><span class="line"><span class="comment">// 根据服务名称拉取实例列表，负藏均衡挑选一个实例</span></span><br><span class="line">List&lt;ServiceInstance&gt; instances = discoveryclient.getInstances(<span class="string">&quot;item-service&quot;</span>);</span><br><span class="line"><span class="type">ServiceInstance</span> <span class="variable">instance</span> <span class="operator">=</span> instances.get(RandomUtil.randomInt(instances.size()));</span><br><span class="line"><span class="comment">// 获取实例的TP和端口</span></span><br><span class="line">URI uri= instance.getUri();</span><br><span class="line"><span class="comment">// ...发送请求</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Nacos 配置管理。<br>当微服务部署的实例越来越多，业务配置如 JDBC、日志、openfeign 时常变动，逐个修改微服务配置就会让人抓狂。<br>Nacos实现配置共享，配置热更新，动态路由<br><a target="_blank" rel="noopener" href="https://www.bilibili.com/list/watchlater?oid=961238101&bvid=BV1kH4y1S7wz&spm_id_from=333.1007.top_right_bar_window_view_later.content.click&p=34">https://www.bilibili.com/list/watchlater?oid=961238101&amp;bvid=BV1kH4y1S7wz&amp;spm_id_from=333.1007.top_right_bar_window_view_later.content.click&amp;p=34</a></p>
</li>
<li><p>OpenFeign </p>
<ul>
<li>？？</li>
<li>最佳实践</li>
</ul>
</li>
<li><p>网关 Gateway</p>
<ul>
<li>application.yml 配置；  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">routes:</span> <span class="comment"># 网关路由配置</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span>    <span class="comment"># 1. 路由id，自定义，只要唯一即可</span></span><br><span class="line">        <span class="comment"># uri: http://127.0.. # 2. 路由的目标地址 http 就是固定地址</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://userservice</span> <span class="comment">#    lb(loadbalance) 就是负载均衡，后面跟服务名称</span></span><br><span class="line">        <span class="attr">predicates:</span>           <span class="comment"># 3. 路由断言(可多条)，判断请求是否符合路由规则的条件</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span>   <span class="comment">#    按照路径匹配，只要以/user/开头就符合要求</span></span><br><span class="line">        <span class="attr">filters:</span>              <span class="comment"># 4. 路由过滤器，，</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">order-service</span>   <span class="comment"># ...</span></span><br><span class="line">        <span class="comment"># ...                        </span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>网关登录校验。</p>
<ul>
<li>基于jwt实现登录校验<ul>
<li>hmall.jks：密钥文件，加密存储</li>
<li>application.yml：配置文件，配置密钥文件目录、别名、解析密钥文件的密码、、excludePath（不用登录校验的路径）</li>
<li>JwtPropertities：加载 jw t属性配置的类</li>
<li>AuthPropertities：加载 excludePath 属性配置的类</li>
<li>SecurityConfig：加载jwt配置后，真正读取文件生成密钥的类，类本身声明为一个 @Bean；过程为注入配置，获取密钥工厂，读取密钥对</li>
<li>JwtTool：jwt工具类，接收用户id与时间生成jwt密钥、解析token</li>
</ul>
</li>
<li>各模块校验：登录在user模块，验证成功后得到token，后续使用每个微服务（购物车、下单，，）时，如果都要都要进行检验，会造成重复代码以及重复发送jwt秘钥造成泄露风险，，所以，在网关中，转发请求给微服务之前，进行jwt登录校验  <img src="https://leo710aka.github.io/bk/job10.png" width="550" height="300" alt=""></li>
</ul>
</li>
</ul>
<ol>
<li><p>如何登录校验？<br> 具体来说，要定义一个（自定义）过滤器，放在pre阶段；在过滤器中实现校验业务逻辑，校验通过后才会向下执行（下面的过滤器），最后由 Netty 路由过滤器转发给微服务</p>
 <img src="https://leo710aka.github.io/bk/job11.png" width="650" height="300" alt="">
 全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与路由过滤器GatewayFilter的作用一样。
 区别在于GatewayFilter通过配置定义，可以自由的指定作用的范围，配置自定义参数，使用灵活，但处理逻辑是固定的，难以自定义GatewayFilter；
 而GlobalFilter可以自己写代码实现，实现需要的业务逻辑，需要自定义过滤器时大多会选择 GlobalFilter。<img src="https://leo710aka.github.io/bk/job12.png" width="550" height="300" alt="">
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthGlobalFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 @RequiredArgsConstructor 后自动使用构造器注入下面成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AuthProperties authProperties;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JwtTool jwtTool;</span><br><span class="line"></span><br><span class="line">    @0verride</span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取请求</span></span><br><span class="line">        <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">        <span class="comment">// 2.判断是否需要做登录拦截（使用 AntPathMatcher 匹配 authProperties 中的路径）</span></span><br><span class="line">        <span class="keyword">if</span>(isExclude(request.getPath().tostring()))&#123;</span><br><span class="line">            <span class="comment">// 放行（如 /user/login）</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.获取token</span></span><br><span class="line">        <span class="type">string</span> <span class="variable">token</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        List&lt;string&gt; headers = request.getHeaders().get(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(headers != <span class="literal">null</span> &amp;&amp; !headers.isEmpty())&#123;</span><br><span class="line">            token= headers.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.校验并解新token</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            userId = jwtTool.parseToken(token);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(UnauthorizedException e) &#123;</span><br><span class="line">            <span class="comment">// 拦裁，设置响应状态码为401（只是抛异常的话响应500，看不出具体错误）</span></span><br><span class="line">            <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">            response.setstatusCode(Httpstatus.UNAUTHORIZED);</span><br><span class="line">            <span class="keyword">return</span> response.setcomplete(); <span class="comment">// 结束</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// TODO 5.传递用户信息</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 6.放行</span></span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isExclude</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @0verride</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//过滤器执行领序，信越小，优先级越高</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 </li>
<li><p>如何将用户信息传递给微服务？<br> 对于单体架构系统，所有功能在部署在一个tomcat上，一个tomcat内部不同线程之间共享ThreadLocal；对于微服务架构，网关本身就是一个微服务，和其他微服务要通过 HTTP请求传递信息，把用户信息放在请求头中不会对业务造成影响，后续从请求头中取出用户信息、、<br> 修改gateway模块中的登录校验拦截器，在校验成功后保存用户到下游请求的请求头中，使用ServerWebExchange类提供的API：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5.传递用户信息</span></span><br><span class="line"><span class="type">String</span> <span class="variable">userInfo</span> <span class="operator">=</span> userId.tostring();</span><br><span class="line"><span class="type">ServerWebExchange</span> <span class="variable">swe</span> <span class="operator">=</span> exchange.mutate().</span><br><span class="line">    request(builder -&gt; builder.header(<span class="string">&quot;user-info&quot;</span>, userInfo))</span><br><span class="line">    .build();</span><br><span class="line"><span class="comment">// 6.放行修改后的请求头(到下面过滤器链)</span></span><br><span class="line"><span class="keyword">return</span> chain.filter(swe);</span><br></pre></td></tr></table></figure>
<p> 在后续的微服务中，通过拦截器，从请求头中获取登录凭证，进行登录校验，并保存在 ThreadLocal；<br> 由于每个微服务都可能有获取登录用户的需求，因此我们直接在hm-common模块定义拦截器，这样微服务只需要引入依赖即可生效，无需重复编写。</p>
 <img src="https://leo710aka.github.io/bk/job13.png" width="550" height="300" alt="">
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 springmvc 拦截器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfoInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpservletRequest request, HttpservletResponse response, obiect handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.获取登录用户信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userInfo</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;user-info&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.判断是否获取了用户，如果有，存入ThreadLocal</span></span><br><span class="line">        <span class="keyword">if</span>(Strutil.isNotBlank(userInfo)) &#123;</span><br><span class="line">            UserContext.setUser(Long.ValueOf(userInfo));   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpservletRequest request, HttpservletResponse response, 0bject handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 清理用户</span></span><br><span class="line">        UserContext.removeUser();</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编写 springmvc 配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 防止网关微服务加载此配置</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DispatcherServlet.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    @0verride</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123; </span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">UserInfoInterceptor</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 最后，修改每个微服务的配置扫描文件，使其能够扫描到 hm-common模块中定义的 UserInfoInterceptor 拦截器；
 注意：网关微服务不能引用 hm-common模块中的 拦截器，因为网关的底层不是 SpringMVC 实现的，无法加载SpringMVC拦截器的功能，会报错；    
 </li>
<li><p>如何在微服务间传递信息？<br> 微服务项目中的很多业务要多个微服务共同合作完成，而这个过程中也需要传递登录用户信息；<br> 方法同样是把用户信息保存到请求头，发送 Http请求。不同的是微服务之间发送请求通过 Openfeign，而网关发送请求是通过其内部的 http 请求方式（netty过滤器路由分发），，</p>
 <img src="https://leo710aka.github.io/bk/job14.png" width="650" height="300" alt=""></li>
</ol>
<ul>
<li><p>拦截器（Interceptor），，<br>？？<br>目的：让未登录用户不能访问某些页面<br>原理：在方法前标注自定义注解，拦截所有的请求，只处理带有该注解的方法。<br>拦截器：1.自定义拦截器 2.配置拦截器<br>首先验证用户（preHandle方法），如果用户存在，则在本次请求中持有用户，放进hostHolder里<br>经过controller后，返回到拦截器，拦截器再将用户信息存入model。<br>自定义拦截器需要实现HandlerInterceptor，然后重写preHandle（controller前执行）,postHandle（controller后执行）,以及afterCompletion（模板解析后执行）<br>配置拦截器：需要实现WebMvcConfigurer接口，然后重写addInterceptors方法，排除拦截静态页面。</p>
</li>
<li><p>ThreadLocal（线程安全）<br>从上面的代码可以看出，ThreadLocal  set赋值的时候首先会获取当前线程thread,并获取thread线程中的ThreadLocalMap属性。如果map属性不为空，则直接更新value值，如果map为空，则实例化threadLocalMap,并将value值初始化<br>ThreadLocalMap是ThreadLocal的内部静态类，而它的构成主要是用Entry来保存数据 ，而且还是继承的弱引用。在Entry内部使用ThreadLocal作为key，使用我们设置的value作为value。<br>通过当前线程对象的getMap()方法获取ThreadMap对象 然后将当前ThreadLocal对象作为key值存入map 这能保证线程内的资源共享而不同线程之间独立</p>
</li>
</ul>
<ul>
<li>Sentinel</li>
</ul>
<p>，，</p>
<h2 id="项目系统（牛客论坛）"><a href="#项目系统（牛客论坛）" class="headerlink" title="项目系统（牛客论坛）"></a>项目系统（牛客论坛）</h2><ul>
<li><strong>论坛系统项目</strong>（高校信息平台。。。）<ul>
<li>项目描述：一个基本功能完整的论坛项目。主要功能有：基于邮件激活的注册方式，区别登陆状态为游客或已登录用户展示不同界面与功能。支持用户上传头像，实现了发布、评论帖子，发送私信等功能，以及点赞，关注与系统通知功能。<br>  项⽬构建在 Spring Boot + SSM 框架之上，并统⼀的进⾏了状态管理、事务管理、异常处理。</li>
<li>核心功能与项目优化：<ul>
<li>使用 Spring Email 辅助发送注册激活邮件，并且使用 Interceptor 拦截器赋予不同类型的用户权限，解决 http 无状态带来的缺陷问题，保护需登录才能查看的资源。</li>
<li>使用 Spring AOP 面向切面编程思想统一记录日志；</li>
<li>引入 Redis 数据库，优化项目中 Session 的使用并利用 Redis 实现点赞和关注功能。</li>
<li>使用 Kafka 消息队列构建异步消息系统，实现点赞关注与通知间削峰。</li>
<li>使用 Caffeine + Redis 实现两级缓存，优化了热门帖子的访问。</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://leo710aka.github.io/bk/job1.png" width="750" height="300" alt="">

<ul>
<li>介绍项目<ol>
<li>梳理系统的项目背景以及整个系统架构设计与运转流程</li>
<li>技术上的亮点:”我在处理数据的过程中，实现了数据的一致性和可靠性，做到了数据零丢失”、“项目引入了规则引擎，其中解决了xxx的业务问题，使得工作效率极大提升”… 等等</li>
<li>业务上的亮点:”实现了业务隔离，不同类型之间的业务互不干扰，从原来的xxx提升到了、”参考自某平台的xx功XXx”能，从零开始实现了业务，使得平台收益增加了xxx”.. 等等</li>
<li>梳理项目还可提升的地方：无论是提高性能，还是提高工作效率，总会有的。这时候如果能吹下自己对比过某某公司的同类型系统，借鉴了某某某优点，基于目前自身的业务觉得还有哪里可以继续优化</li>
</ol>
</li>
</ul>
<hr>


<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul>
<li><p>排列组合（C上n下m，A上n下m）</p>
<ul>
<li><code>A上n下m</code>是排列，有顺序，表示m是起点（逐个减1，n是个数），从m中按顺序取n个数<br>  Amn &#x3D; m x(m-1)x(m-2)x(m-3)x … x(m-n+1)；例如：A74&#x3D; 8x7x6x5</li>
<li><code>C上n下m</code>是组合，无顺序，表示从m中选出n个<br>  Cmn &#x3D; Amn &#x2F; Ann； 例如： C84 &#x3D; A84 &#x2F; A44 &#x3D; （8x7x6x5）&#x2F;(4x3x2x1)</li>
</ul>
</li>
<li><p>5万人进行年龄排序<br>“使用快速排序算法来进行年龄排序，它的时间复杂度通常为O(n log n)。<br>我会首先将人口数据存储在一个数组中，然后根据每个人的年龄进行排序。在排序的过程中，我会使用递归来不断地划分数组，并交换元素的位置，直到整个数组按照年龄有序。如果数据量较大，我也可以考虑一些优化策略，比如随机化快速排序来避免最坏情况的发生，或者利用多线程来加速排序过程。最后，我会对排序后的结果进行验证，确保排序是准确的。”</p>
</li>
<li><p>智力题：25匹马选前3名，有5条赛道<br>将25匹马分成 A、B、C、D、E 5组，每组进行组内比赛，假设每组的排名就是A1&gt;A2&gt;A3&gt;A4&gt;A5（以A组为例），这里比赛5次<br>第6次，每组的第一名进行比赛，可以找出最快的马，这里假设A1&gt;B1&gt;C1&gt;D1&gt;E1，D1，E1肯定进不了前3，直接排除掉 D、E 两组<br>第7次，A2 A3 B1 B2 C1 比赛，可以找出第二、第三名。所以最少比赛需要7次</p>
</li>
<li><p>？？？智力题：1000瓶酒，其中只有1瓶毒酒，10只小白鼠，如何1轮测试出来毒酒是哪一瓶？<br>用小白鼠喝这瓶酒or不喝这评酒分别用1、0表示。可以凑出1024种组合，大于1000种，所以可以给1000瓶酒按照这种方式编号。<br>需要十只老鼠，如果按顺序编号，ABCDEFGHIJ分别代表从低位到高位每一个位。 每只老鼠对应一个二进制位，如果该位上的数字为1，则给老鼠喝瓶里的药。<br>然后用对应的2进制码的方式给10只小白鼠喝酒，过一段时间之后。通过观察小白鼠是哪些编号死亡，哪些编号存活，可以分别用1和0表示，然后凑出来的2进制转10进制就是答案。</p>
</li>
<li><p>智力题：绳子两头烧<br>现有若干不均匀的绳子，烧完这根绳子需要一个小时，问如何准确计时15分钟，30分钟，45分钟，75分钟。。。<br>15：对折之后两头烧(要求对折之后绑的够紧，否则看45分钟解法)<br>30：两头烧<br>45：两根，一根两头烧一根一头烧，两头烧完过了30分钟，立即将第二根另一头点燃，到烧完又过15分钟，加起来45分钟<br>75：&#x3D;30+45</p>
</li>
</ul>
<hr>

<h2 id="反问"><a href="#反问" class="headerlink" title="反问"></a>反问</h2><ul>
<li><p>一面最后的时候，面试官一般会问：你有什么要问我的吗？这个时候不要乱问，你可以问以下几个问题：</p>
<ol>
<li>你们部门在做些什么？主要业务是什么？如果自己很荣幸的能够进入贵部门会负责些什么？<br>  因为面试者就是这个部门的，通过他的回答，你也能够了解到这个部门正在做的产品和使用的技术。</li>
<li>岗位的发展情况、、如果我有幸应聘成功，公司对我会有哪些期望呢，</li>
<li>您认为我在哪些方面还存在着不足？<br>  这是一个很巧妙的问题，因为它可以从侧面反映出你这次面试的结果。如果面试官带有指导性的回答出了你的不足，你需要补充的知识点，这样就代表你这次面试差不多了，应该是能好好准备二面了；如果面试官直言不讳的说你很差或者基础太弱这样的话，你也就知道凉凉了。</li>
<li>请问面试官对自己职业规划的建议？<br>  面试官大概率是技术大佬或者工作过几年的前辈了，在社会上摸爬滚打了几年，知道的肯定比在校生多。这个问题既表达了对面试官身份的认可，也表现出求职者对当前这份工作得在意程度，并且还能得到技术大佬的分享，怎么看都不是亏本的买卖。</li>
<li>这个岗位所在的的团队是什么氛围？我这个比较外向（千万要说自己外向，不要说自己内向，原因不必多说了吧）</li>
</ol>
</li>
<li><p>关于公司，岗位有什么想问的？<br>1.<strong>关于公司：</strong>“公司的核心价值观是什么？” “能否分享一下公司的发展战略和未来规划？” “公司的文化是怎样的？”<br>2.<strong>关于团队和领导：</strong> “我将会与哪些团队成员合作？” “对于这个岗位，我将直接报告给谁？””团队的工作氛围是怎样的？”<br>3.<strong>关于岗位：</strong> “这个岗位的主要职责是什么？绩效评估标准？”  “在这个岗位上，有没有机会进行培训和专业发展？”<br>4.<strong>关于工作环境：</strong>“公司对于员工的工作生活平衡看法？公司的灵活工作政策？” “关于工作场所和设施有什么特别的安排？”<br>5.<strong>关于发展机会：</strong> “公司是否鼓励内部晋升和职业发展？”  “可以谈谈员工在公司成长的例子吗？”<br>6.<strong>关于期望：</strong>“对于这个职位，你们期望新员工在短期和长期内能够做到什么？” “公司对于创新和改进有怎样的期望？”<br>7.<strong>关于团队协作：</strong>“在团队中如何促进协作和团队精神？”  “有没有定期的团队活动或培训？”<br>8.<strong>关于招聘流程：</strong>“对于这个岗位的招聘流程是怎样的？”  “预计多久会有关于我的招聘决定？”</p>
</li>
<li><p>？？你如何评价我们的面试过程？<br>1、<strong>积极、建设性的角度</strong>：强调你对面试过程的积极印象，比如面试官的专业性、问题的多样性和挑战性等。表达感激之情，感谢他们给予的机会并展现出你对公司或团队的兴趣。<br>2、<strong>注意事项和改进建议</strong>：提及你认为面试过程中可能的改进点，但要以建设性的方式提出，不要过于批评或负面。例如，可以提议增加某些技术领域的深入问题，或者更多关于公司文化和团队合作的问题，以更好地了解公司的工作环境。</p>
</li>
<li><p>？？有什么要分享给面试官的？<br>1.、<strong>展示你的准备和兴趣</strong>：提到你在公司产品、服务、项目方面的研究和了解，表现出你对公司的热情和积极性。说明你对该公司的价值观、愿景或在该领域的兴趣，并解释为什么你认为你的技能和经验与公司的需求相匹配。<br>2、<strong>自我评价和亮点</strong>：强调你认为自己最突出的技能、经验或个人特质，并解释为什么这些对公司或团队会有价值。提供具体的案例或经验，展示你的领导能力、团队合作精神、解决问题的能力等方面的优势。<br>3、<strong>职业发展展望</strong>：谈论你对未来职业发展的期望，并说明你希望在该公司或类似领域发展自己的职业生涯。表现出你对个人成长和对公司做出贡献的愿望。</p>
</li>
</ul>
<hr>


<h2 id="HR-面"><a href="#HR-面" class="headerlink" title="HR 面"></a>HR 面</h2><ul>
<li><p><strong>对公司文化的理解和价值观的认同</strong></p>
<ul>
<li>先去了解一下公司的文化和公司的优势之处，这样在被问到为什么选择本公司的时候能够把自己对公司的了解和优势说出来，体现自己的诚意</li>
<li>华为：”我对华为的文化印象深刻，特别是关于坚持自主创新、追求卓越和不断学习的价值观。我接受的教育，使我深刻理解和认同华为一贯的追求卓越的精神。我认为，华为强调的团队协作和开放式沟通也非常符合我的工作风格。我期待能够在这样一个注重技术创新和全球合作的公司中发展自己的职业生涯。”</li>
<li>腾讯：”我对腾讯的文化深感兴奋，尤其是关于用户至上、创新驱动和团队合作的价值观。在我之前的项目中，我注重倾听用户反馈，并通过创新的方式解决问题，这与腾讯强调用户体验和创新的文化非常契合。我也非常欣赏腾讯在团队协作方面的努力，我认为一个团结协作的团队是实现伟大目标的关键。因此，我相信我的工作风格和价值观与腾讯的文化非常匹配，我渴望能够为腾讯的发展贡献力量。”</li>
<li>感觉您这边平台大，技术积累多，项目挑战多，能力提升多</li>
</ul>
</li>
<li><p>你对加班的看法？<br>如果是工作需要我会义不容辞加班。我现在单身，没有任何家庭负担，可以全身心的投入工作。但同时，我也会提高工作效率，减少不必要的加班</p>
</li>
<li><p>你对薪资的要求？<br>①：“我对工资没有硬性要求。我相信贵公司在处理我的问题上会友善合理。我注重的是找对工作机会，所以只要条件公平，我则不会计较太多<br>②：我作为一个科班出身，具备比较完备的工作技能的人，我相信自己能为公司带来价值。。因此，我希望公司能根据我的情况和市场标准的水平，给我合理的薪水。<br>③：如果你必须自己说出具体数目，请不要说一个宽泛的范围，那样你将只能得到最低限度的数字。最好给出一个具体的数字，这样表明你已经对当今的人才市场作了调查，知道像自己这样学历的雇员有什么样的价值。</p>
</li>
<li><p><strong>眼下你生活中最重要的是什么？未来几年的规划是什么？</strong><br>对我来说，能在这个领域找到工作是最重要的。<br>规划好职业生涯，与同事们很好地合作。我希望能充分展示我在这个行业的能力和智慧。</p>
</li>
<li><p>说说你对行业、技术发展趋势的看法？<br>？？？<br>回答提示：企业对这个问题很感兴趣，只有有备而来的求职者能够过关。求职者可以直接在网上查找对你所申请的行业部门的信息，只有深入了解才能产生独特的见解。企业认为最聪明的求职者是对所面试的公司预先了解很多，包括公司各个部门，发展情况，在面试回答问题的时候可以提到所了解的情况，企业欢迎进入企业的人是“知己”，而不是“盲人”。</p>
</li>
<li><p><strong>职业发展规划？</strong><br>T型人才，一方面在技术领域深挖，一方面对整个产品的端到端有一个了解、、</p>
</li>
<li><p>请用三个词描述您的性格特点<br><strong>诚实，勤奋，谦虚。</strong>在学习知识和与人交往的过程中，我始终保持坦诚和真实，对自己和他人负责。面对生活中的挑战，我积极看待并勤奋努力，相信努力终会有所回报。谦虚让我保持谦逊和虚心，愿意倾听他人意见并不断学习成长。</p>
</li>
<li><p>举例说明你的勤奋。。<br>我详细安排毕业设计开发进度，一周内每天熬夜到3点。。<br>我想说的是很多时候即使早已做好安排，到头来还是因为各种情况不得不赶进度，重要的是能够在需要时赶好进度的能力。。</p>
</li>
<li><p>你身边的人如何评价你？<br>他们说我是一个诚实、学习和工作努力、负责任的人。我一旦答应别人的事情，就一定会负责到底，否则我不会轻易许诺。<br>以及我是一个比较随和的人，与不同的人都可以友好相处，在与人相处时，我总是能站在别人的角度考虑问题。</p>
</li>
<li><p><strong>你的优点和缺点。</strong></p>
<ul>
<li>我是一个诚实，比较勤奋和乐观的人。我的适应能力比较强，喜欢向他人学习，也愿意帮助他人。在以往的实习、项目中，能够很快适应团队开发流程。我相信在经过一段时间的培训及项目实战后，能够在这份工作中取得成功。</li>
<li>我缺乏工作经验。。<ul>
<li>在之前的实习过程中只是参与了开发这一环节，没有跨部门合作、与不同岗位的同事深度交流的经验。</li>
<li>有点强迫症，会对任务的细节核对多遍，比如发邮件，填资料的时候必须要重复检查，把信息正着反着过一遍，这样虽然有点浪费时间，但就基本不会出什么差错了；</li>
<li>另外就是有点钻牛角尖，在学习新的知识时有个点花了很长时间都没弄懂，会比较泄气。后来发现可以把不懂的先放着，等学了别的知识，再返回来看这个知识点就触类旁通了；我目前也很习惯使用chatgpt进行学习，通过提问快速发散知识点，建立联系。</li>
</ul>
</li>
</ul>
</li>
<li><p>高中到大学以来，最大的挫折。<br>高中以来一直遭到失败，学业、社团、人际交往，，一度让我十分沮丧，但也是我思考了很多的一段时间，，我渐渐了解：失败是人生的常态。<br>我很庆幸一次次经历失败的过程中，我都还是选择了再努力一下，也许就有改变呢，往往最后问题都能够解决了，，<br>最重要的，我学会在任何情况下保持冷静，，在未来，在大学面对各种压力时，都可以比较体面地应对了，并且思考如何做得更好、、</p>
</li>
<li><p>学习方法。<br>某一个点：根据需求针对性的官方文档，，查技术论坛、、<br>某一领域：(看B站视频 ×) 在有了大致了解后，使用chatgpt，不断提问、发散，把知识点都连接起来</p>
</li>
<li><p>最近看了什么书？读了什么开源库？<br>？？？没看。</p>
</li>
<li><p><strong>考研弃考？秋招0 offer？空白期？</strong><br>没考研！！找工作比较晚（因为有java基础和项目经验、、）并且夏令营，毕业实习占用了很多时间，，<br>秋招期间，我一直学习java技术栈，（没把握所以）没怎么投简历，，后面我为了丰富自己对开发的了解，也在12月底找了一份实习做到现在了。。目前不考虑考研<br>春招期间，，，</p>
</li>
<li><p>表现<strong>抗压能力以及处理意外情况的能力</strong>。</p>
<ol>
<li>分享一件你觉得压力比较大的事？你的压力从何来？你是如何克服他的？<br>  ？？1.适应压力，有压力动力更足。2.会合理安排时间，取得工作效率很好的平衡</li>
<li>你长这么大以来遭受过的最大挫折是什么？你是如何克服它的？<br>  ？？</li>
<li>二十多年来，你取得的最大成就是什么？<br>  ？？</li>
<li>你通过多年努力获得的一项技能是什么？你是如何学习从而获得这项技能的，做了哪些工作去改善、精进这项技能？<br>  ？？<br>  学会面对任何困难保持冷静。从上学时突然被点名发言、突然被委任参加一个比赛，到现在做项目时面对需求从头开始学习新的技术，我发现在面对困难时，有效的方法就是冷静分析局势，以及最重要的是尽早的着手做。这样即使最后无法完成，也有所收获。</li>
</ol>
</li>
<li><p>你能使组里气氛活跃，并且易于<strong>沟通</strong>吗？<br>我会尽力，和团队中的成员沟通，向他们发问、学习。因为在团队里工作最重要的一件事就是集思广益，而不要只是一个人闷头单干。沟通是很重要的，不仅可以提高工作质量和效率，也可以产生活力。</p>
</li>
<li><p>如何处理与同事在工作中意见的不和？与上级意见冲突？<br>我要以更清楚和文明的方式提出我的看法，使对方了解我的观点。<br>我会尊重上级，上级一般更有经验，思考更全面，要通过积极沟通找到一个更合适的解决方法。</p>
</li>
<li><p>在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？<br>原则上我会尊重和服从领导的工作安排；同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法；<br>如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作；<br>还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见；如领导仍固执己见，我会毫不犹豫地再向上级领导反映。</p>
</li>
<li><p>工作中你难以和同事、上司相处，你该怎么办？<br>我会服从领导的指挥，配合同事的工作。<br>我会从自身找原因，仔细分析是不是自己工作做得不好让领导不满意，同事看不惯。还要看看是不是为人处世方面做得不好。如果是这样的话 我会努力改正。<br>如果我找不到原因，我会找机会跟他们沟通，请他们指出我的不足。有问题就及时改正。<br>作为优秀的员工，应该时刻以大局为重，即使在一段时间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看见我在努力，总有一天会对我微笑的！</p>
</li>
<li><p>偶像？企业家？<br>梅西？除了足球方面的，他有着世界上最宝贵的天赋，谦逊。他沉默地担下所有责任，用实际行动回复质疑和诋毁，以及他个人和职业生涯中的种种挫折，共同让他成长为了这个世界上最坚强的人。<br>任正非？？一位民族企业家，经历了苦难的人，实干家，尊重教师和科学家。。他的企业即使在最艰难的时刻，也坚持研发投入，有着向上的风气。</p>
</li>
<li><p>如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？<br>？？<br>如果你确实热爱这个职业，那你就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距；<br>你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。</p>
</li>
<li><p>如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？<br>我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法去弥补或挽回经济损失。<br>如果我无能力负责，希望单位帮助解决；<br>分清责任，各负其责，如果是我的责任，我甘愿受罚；如果是一个我负责的团队中别人的失误，作为一个团队，需要互相提携共同完成工作，安慰同事并帮助同事查找原因总结经验。<br>总结经验教训，一个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中吸取经验教训，并在今后的工作中避免发生同类的错误。检讨自己的工作方法、分析问题的深度和力度是否不够，以致出现了本可以避免的错误。</p>
</li>
<li><p>如果你在这次考试中没有被录用，你怎么打算？<br>第一：要敢于面对,面对这次失败不气馁,接受已经失去了这次机会就不会回头这个现实,从心理意志和精神上体现出对这次失败的抵抗力。要有自信,相信自己经历了这次之后经过努力一定能行.能够超越自我；<br>第二：善于反思,对于这次面试经验要认真总结,思考剖析,能够从自身的角度找差距。正确对待自己,实事求是地评价自己,辩证的看待自己的长短得失,做一个明白人；<br>第三：走出阴影,要克服这一次失败带给自己的心理压力,时刻牢记自己弱点,防患于未然,加强学习,提高自身素质；<br>第四：认真工作,回到原单位岗位上后,要实实在在、踏踏实实地工作,三十六行,行行出状元,争取在本岗位上做出一定的成绩；<br>第五：再接再厉,成为一名架构师一直是我的梦想,以后如果有机会我仍然后再次参加竞争。</p>
</li>
<li><p>谈谈你对跳槽的看法？<br>正常的”跳槽”能促进人才合理流动，应该支持；<br>频繁的跳槽对单位和个人双方都不利，应该反对。</p>
</li>
<li><p>你能为我们公司带来什么呢？<br>假如你可以的话，试着告诉他们你可以减低他们的费用——“我已经接受过惠普公司一段时间的培训，立刻就可以上岗工作”。<br>企业很想知道未来的员工能为企业做什么，求职者应再次重复自己的优势，然后说：“就我的能力，我可以做一个优秀的员工在组织中发挥能力，给组织带来高效率和更多的收益”。企业喜欢求职者就申请的职位表明自己的能力，比如申请营销之类的职位，可以说：“我可以开发大量的新客户，同时，对老客户做更全面周到的服务，开发老客户的新需求和消费。”等等。</p>
</li>
<li><p>你的业余爱好是什么？<br>我喜欢足球，我享受和我的队友一起拼尽全力，互相信任，无论输赢一起共进退。在足球比赛中，一个团队的成功不仅仅取决于个别球员的技术水平，更重要的是整个团队的协同合作、沟通和相互理解。（回答提示：找一些富于团体合作精神的）</p>
</li>
<li><p>最喜欢的十本书？</p>
<ol>
<li>《三体》- 刘慈欣</li>
<li>《活着》- 余华</li>
<li>《围城》- 钱钟书</li>
<li>《1984》- 乔治·奥威尔</li>
<li>《动物农场》- 乔治·奥威尔</li>
<li>《白夜行》- 东野圭吾</li>
<li>《窗边的小豆豆》- 黑柳彻子</li>
<li>《苏菲的世界》- 乔斯坦·贾德</li>
<li>《水浒传》- 施耐庵</li>
<li>《红楼梦》- 曹雪芹</li>
</ol>
</li>
<li><p>作为被面试者给我打一下分<br>“我认为在这次面试中，我有机会深入了解公司，并且很高兴能够分享我的经验和能力。<br>面试官提出的问题涉及到我的专业领域和与公司文化相关的方面，这让我感到这次面试非常有价值。我觉得这是一个很好的机会，展示了我与公司的匹配度，同时也让我更深入地了解了贵公司的期望和文化。<br>我期待着有机会为公司做出积极的贡献，如果有进一步的机会，我将非常愿意深入探讨我如何能够在公司中蓬勃发展。”<br>（回答提示：试着列出四个优点和一个非常非常非常小的缺点，，可以抱怨一下设施，没有明确责任人的缺点是不会有人介意的）</p>
</li>
<li><p>喜欢这份工作的哪一点？<br>？？？<br>在回答面试官这个问题时可不能太直接就把自己心理的话说出来，尤其是薪资方面的问题，不过一些无伤大雅的回答是不错的考虑，如交通方便，工作性质及内容颇能符合自己的兴趣等等都是不错的答案，不过如果这时自己能仔细思考出这份工作的与众不同之处，相信在面试上会大大加分。</p>
</li>
<li><p>说说你的家庭。<br>（企业不喜欢探究个人隐私，而是要了解家庭背景对求职者的塑造和影响。企业希望听到的重点也在于家庭对求职者的积极影响。企业最喜欢听到的是：）<br>我的家庭一向很和睦，虽然我的父亲和母亲都是普通人，但是从小，我就看到父母为了家庭起早贪黑，每天勤劳工作，他的行动无形中培养了我认真负责的态度和勤劳的精神。他们也教育我对人诚实、友善，要乐于助人。</p>
</li>
<li><p>就你申请的这个职位，你认为你还欠缺什么？<br>回答建议（仅供参考）：企业喜欢问求职者弱点，但精明的求职者一般不直接回答。他们希望看到这样的求职者：继续重复自己的优势，然后说：“对于这个职位和我的能力来说，我相信自己是可以胜任的，只是缺乏经验，这个问题我想我可以进入公司以后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。”<br>企业喜欢能够巧妙地躲过难题的求职者。</p>
</li>
<li><p>你欣赏哪种性格的人？<br>诚实、不死板而且容易相处的人、有”实际行动”的人。</p>
</li>
<li><p>你通常如何处理別人的批评？<br>沈默是金。不必说什么，否则情况更糟，不过我会接受建设性的批评； 我会等大家冷靜下来再讨论。</p>
</li>
<li><p>你怎样对待自己的失敗？<br>我们大家生来都不是十全十美的，我相信我有第二个机会改正我的错误。</p>
</li>
<li><p>你和别人发生过争执吗？你是怎样解决的？<br>（千万不要说任何人的过错。应知成功解决矛盾是一个协作团体中成员所必备的能力。考官希望看到你是成熟且乐于奉献的。他们通过这个问题了解你的成熟度和处世能力。）<br>在没有外界干涉的情况下，通过妥协的方式解决。</p>
</li>
<li><p>为了做好你工作份外之事，你该怎样获得他人的支持和帮助？<br>？？？</p>
</li>
<li><p>项目中遇到困难，你怎么办？怎么回答<br>？？？<br>第一种这个要找项目负责人商量、甚至要找产品&#x2F;运行或其他甲方沟通、<br>第二种普遍技术难点的话、参考资料或者和项目负责人商量看看怎么办、<br>第三种的话、先自己查资料试着解决、不行就找人其他资讯、、</p>
</li>
<li><p>意向城市，人生发展（以提高自己为主，强化学习，找到一个好的环境）</p>
</li>
<li><p><strong>压薪</strong>：如果工资达不到您的预期，还来吗？<br>1、感谢hr在面试这几轮的工作和时间<br>2、我感觉其实很适合这个岗位了（我就是公司需要的人，不要压我工资完成你的kpi<br>3、不管结果如何，希望您能够再帮我争取一下（我也和，，打打招呼，表达诚意，不让您这边为难？<br>不直接回答，只表达希望hr能帮我争取，不保证接不接offer？？</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/10/13/%E9%9D%A2%E8%AF%95_%E4%B8%AA%E4%BA%BA/" data-id="cm0cja96s000xm4v5eqmi7yj7" data-title="面 逝 | 个人" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2046/12/">December 2046</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2046/12/30/nice-photo/">Nice Photo</a>
          </li>
        
          <li>
            <a href="/2024/08/27/Guitar/">guitar 🎸</a>
          </li>
        
          <li>
            <a href="/2024/08/18/%E4%BF%9D%E9%99%A9/">保 险</a>
          </li>
        
          <li>
            <a href="/2024/07/07/%E7%BE%8E%E7%9A%84Midea/">美 的 Midea</a>
          </li>
        
          <li>
            <a href="/2024/05/01/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/">毕 业 设 计</a>
          </li>
        
          <li>
            <a href="/2024/01/11/RabbitMQ/">RabbitMQ</a>
          </li>
        
          <li>
            <a href="/2024/01/07/SpringCloud/">SpringCloud</a>
          </li>
        
          <li>
            <a href="/2024/01/04/%E9%AA%8F%E4%BC%AFJunbo/">骏 伯 Junbo</a>
          </li>
        
          <li>
            <a href="/2023/10/20/%E6%98%A5%E6%8B%9B2024/">春 招 2024</a>
          </li>
        
          <li>
            <a href="/2023/10/13/%E9%9D%A2%E8%AF%95_%E4%B8%AA%E4%BA%BA/">面 逝 | 个人</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 fengcai<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>