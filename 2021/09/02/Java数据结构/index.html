<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Java 数据结构 | Qué miras Bobo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="数组数组是一种连续存储线性结构，数组尺寸不能改变。元素类型相同，大小相等，通过使用整型索引值来访问他们的元素。数组是多维的。数组能够容纳基本数据类型（int、char等）或者对象引用（如类对象）。数组的优点：存取速度快数组的缺点：事先必须知道数组的长度、插入删除元素很慢、空间通常有限制、需要大块连续内存块、插入删除元素的效率很低Java没有指针，同时也不对程序员暴露其元素的地址，寻址操作完全交给虚">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 数据结构">
<meta property="og:url" content="http://example.com/2021/09/02/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="Qué miras Bobo">
<meta property="og:description" content="数组数组是一种连续存储线性结构，数组尺寸不能改变。元素类型相同，大小相等，通过使用整型索引值来访问他们的元素。数组是多维的。数组能够容纳基本数据类型（int、char等）或者对象引用（如类对象）。数组的优点：存取速度快数组的缺点：事先必须知道数组的长度、插入删除元素很慢、空间通常有限制、需要大块连续内存块、插入删除元素的效率很低Java没有指针，同时也不对程序员暴露其元素的地址，寻址操作完全交给虚">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://pdai.tech/images/alg/alg-tree-14.png">
<meta property="og:image" content="https://pdai.tech/images/alg/alg-tree-13.png">
<meta property="og:image" content="https://pdai.tech/images/alg/alg-tree-15.png">
<meta property="og:image" content="https://pdai.tech/images/alg/alg-tree-16.png">
<meta property="og:image" content="https://leo710aka.github.io/bk/b-tree.png">
<meta property="og:image" content="https://leo710aka.github.io/bk/b+tree.png">
<meta property="og:image" content="https://pdai.tech/images/alg/alg-graph-store-1.png">
<meta property="og:image" content="https://pdai.tech/images/alg/alg-graph-store-2.png">
<meta property="og:image" content="https://pdai.tech/images/alg/alg-graph-store-3.jpg">
<meta property="og:image" content="https://pdai.tech/images/alg/alg-graph-store-4.jpg">
<meta property="og:image" content="https://pdai.tech/images/alg/alg-sort-overview-1.png">
<meta property="og:image" content="https://github.com/leo710aka/bk/blob/main/HeapSort.png?raw=true">
<meta property="article:published_time" content="2021-09-02T03:49:42.000Z">
<meta property="article:modified_time" content="2024-04-26T06:18:47.518Z">
<meta property="article:author" content="fengcai">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pdai.tech/images/alg/alg-tree-14.png">
  
    <link rel="alternate" href="/atom.xml" title="Qué miras Bobo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="https://github.com/leo710aka/bk/blob/main/DT1.jpg?raw=true">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Qué miras Bobo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Java数据结构" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/02/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date">
  <time class="dt-published" datetime="2021-09-02T03:49:42.000Z" itemprop="datePublished">2021-09-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Java 数据结构
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><strong>数组</strong>是一种连续存储线性结构，数组尺寸不能改变。元素类型相同，大小相等，通过使用整型索引值来访问他们的元素。数组是多维的。数组能够容纳基本数据类型（int、char等）或者对象引用（如类对象）。<br><strong>数组的优点</strong>：存取速度快<br><strong>数组的缺点</strong>：事先必须知道数组的长度、插入删除元素很慢、空间通常有限制、需要大块连续内存块、插入删除元素的效率很低<br>Java没有指针，同时也不对程序员暴露其元素的地址，寻址操作完全交给虚拟机。所以看不到每个元素的地址情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers;                               <span class="comment">// 声明一个 int 数组</span></span><br><span class="line">numbers = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];                        <span class="comment">// 初始化一个长度为 5 的 int 数组</span></span><br><span class="line"><span class="type">int</span>[] values = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;              <span class="comment">// 声明并初始化一个 int 数组</span></span><br><span class="line">... <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, j&#125;;                  <span class="comment">// 在方法中返回数组[i, j]</span></span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> arr.length;                     <span class="comment">// 获取数组的长度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> arr[<span class="number">1</span>];                          <span class="comment">// 获取索引为 1 的元素</span></span><br><span class="line"><span class="type">int</span>[][] twoDimArray = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">4</span>];         <span class="comment">// 创建一个 3x4 的二维数组</span></span><br><span class="line"><span class="type">int</span>[][] twodimArray = &#123;&#123;<span class="number">1</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">5</span>&#125;&#125;;   <span class="comment">// 声明并初始化一个 二维 int 数组</span></span><br><span class="line"><span class="type">int</span>[][][] threeDimArray = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">4</span>][<span class="number">2</span>];  <span class="comment">// 创建一个 3x4x2 的三维数组</span></span><br><span class="line">System.out.println(twoDimArray[<span class="number">0</span>]);          <span class="comment">// [I@7852e922：16进制数值，不是真正的地址，是处理后的</span></span><br></pre></td></tr></table></figure>
<p><code>int[] numbers;</code> 只是声明了一个名为 numbers 的整数数组的引用，它并没有创建数组对象，并没有分配内存或存储数据。<br><code>int[] numbers = new int[5];</code> 在这里，new int[5] 表示创建一个能够存储 5 个整数的整型数组，并将该数组的引用赋给 numbers 变量。这是一个基本的数组类型，而不是 Arrays、ArrayList 或 Vector 对象。<br>数组是基本的数据结构，而 Arrays 和 ArrayList 是 Java 中的类，提供了用于操作和管理数组的方法。</p>
<h4 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h4><p><code>Arrays 类</code>是 Java API 中的一个工具类，它提供了一系列静态方法来操作数组，比如排序、搜索、比较等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">Arrays.fill(arr, <span class="number">10</span>);                           <span class="comment">//  fill()：将数组的所有元素设置为指定值。</span></span><br><span class="line">String[] array = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(array);       <span class="comment">//  asList()：将数组转换为 `List`。</span></span><br><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">Arrays.sort(numbers);                           <span class="comment">//  sort()：对数组进行排序。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(numbers, <span class="number">3</span>);    <span class="comment">//  binarySearch()：在排序数组中执行二分查找。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Arrays.toString(numbers);          <span class="comment">//  toString()：将数组转换为字符串表示形式。</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEqual</span> <span class="operator">=</span> Arrays.equals(arr, numbers);  <span class="comment">//  equals()：比较两个数组是否相等。</span></span><br><span class="line"><span class="type">int</span>[] copy1 = Arrays.copyOf(arr, sou.length);   <span class="comment">//  copyOf：复制数组或复制数组的指定范围。</span></span><br><span class="line"><span class="type">int</span>[] copy2 = Arrays.copyOfRange(arr, <span class="number">2</span>, <span class="number">4</span>);    <span class="comment">//  copyOfRange()：复制数组或复制数组的指定范围。</span></span><br></pre></td></tr></table></figure>

<h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p><code>Vector</code> 是一个同步的动态数组类，类似于 <code>ArrayList</code>，可以自动增长和缩小以容纳对象。<br><strong>ArrayList 和 Vector 都是动态数组实现的集合</strong>，而 <code>Arrays</code> 类主要用于数组的各种操作。<br><code>Vector</code> 是线程安全的（是同步的），而 <code>Arrays</code> 不是（没有提供同步）。<code>Vector</code> 在对集合进行操作时会进行同步，适用于多线程环境。单线程环境下，推荐使用 <code>ArrayList</code> 而不是 <code>Vector</code>，因为 <code>ArrayList</code> 不是同步的，性能更高。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt;String&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();            <span class="comment">// 创建 Vector</span></span><br><span class="line">vector.add(<span class="string">&quot;Element 1&quot;</span>);                           <span class="comment">// 添加元素</span></span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> vector.size();                          <span class="comment">// 获取 Vector 的大小</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> vector.isEmpty();                <span class="comment">// 检查 Vector 是否为空</span></span><br><span class="line"><span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> vector.get(<span class="number">0</span>);                    <span class="comment">// 访问 Vector 中的元素：获取索引为0的元素</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> vector.indexOf(<span class="string">&quot;Element 2&quot;</span>);           <span class="comment">// 查找元素在 Vector 中的位置</span></span><br><span class="line">vector.remove(<span class="number">1</span>);                                  <span class="comment">// 删除 Vector 中的元素：删除索引为1的元素</span></span><br><span class="line"><span class="keyword">for</span> (String element : vector) &#123; ...&#125;               <span class="comment">// 遍历 Vector 中的元素</span></span><br></pre></td></tr></table></figure>

<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>ArrayList是基于<strong>动态数组</strong>实现的，可以自动扩容。（动态数组是一种数据结构，而非类，是一种具有自动扩容能力的数组）<br>它支持快速随机访问元素，但在插入和删除元素时可能会比较耗时。适用于需要随机访问元素、按索引查找和遍历集合的场景。<br>1、<code>add(E e)</code>：在尾部添加元素。<br>2、<code>get(int index)</code>：获取指定位置的元素。<br>3、<code>set(int index, E element)</code>：用于替换指定索引处的元素。<br>4、<code>remove(int index)</code>：移除指定位置的元素。<br>5、<code>size()</code>：返回集合大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; cur = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();                        <span class="comment">// 一维动态数组</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();    <span class="comment">// 二维动态数组</span></span><br><span class="line">ans.get(i).set(j, ans.get(i).get(j) + ans.get(i-<span class="number">1</span>).get(j));  <span class="comment">// 二维数组读写</span></span><br></pre></td></tr></table></figure>

<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList是基于<strong>双向链表</strong>实现的，每个节点都存储了对前一个和后一个元素的引用。它在插入和删除元素时效率较高，但在随机访问元素时效率较低。LinkedList适用于需要频繁的插入、删除操作的场景。<br>1、<code>add(E e)</code>：在尾部添加元素。<br>2、<code>addFirst(E e)</code>：在头部添加元素。<br>3、<code>get(int index)</code>：获取指定位置的元素。<br>4、<code>remove(int index)</code>：移除指定位置的元素。<br>5、<code>size()</code>：返回集合大小。</p>
<hr>


<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><strong>链表</strong>由一个节点序列组成，每个节点包含数据和指向下一个节点的引用。n个节点离散分配，每个节点只有一个前驱节点和一个后续节点，首节点没有前驱节点，尾节点没有后续节点。当你创建一个链表时，你持有的引用实际上指向链表中第一个节点的地址，也就是头节点。头节点存储了链表的起始地址，通过这个地址可以访问整个链表。<br><strong>链表优点</strong>：空间没有限制、插入删除元素很快。<strong>链表缺点</strong>：存取速度很慢</p>
<h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p>单链表的每个节点包含两个部分：数据和指向下一个节点的引用。第一个节点称为头节点，最后一个节点的下一个节点为空<code>null</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;   <span class="comment">// Java中单链表的节点（Node）通常会被定义为一个内部类。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> data;  <span class="comment">// 数据域</span></span><br><span class="line">    <span class="keyword">public</span> Node next; <span class="comment">// 指针域，指向下一个节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123;    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;        <span class="built_in">this</span>.data = data;    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data, Node next)</span> &#123;        <span class="built_in">this</span>.data = data;        <span class="built_in">this</span>.next = next;    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="comment">// 添加新节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(data);</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            head = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">while</span> (current.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current.next = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他操作（删除节点、查找节点等）可以根据需要实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>双向链表</strong> 中的每个节点都有两个指针：一个指向前一个节点，一个指向后一个节点。双向链表允许在节点之间双向遍历。<br>将两种(双向&#x2F;单向)链表的最后一个结点指向第一个结点从而实现 <strong>循环链表</strong>，能通过任何一个节点找到其他所有的节点。</p>
<hr>


<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。哈希表使用 <strong>O(N)</strong> 空间复杂度存储数据，并且以 <strong>O(1)</strong> 时间复杂度求解问题。</p>
<ul>
<li>构造散列函数的方法有：<ol>
<li>直接定址法： 取关键字或关键字的某个线性函数值为散列地址。即：h(key) &#x3D; key 或 h(key) &#x3D; a * key + b，其中 a，b 为常数</li>
<li>数字分析法</li>
<li>平方取值法： 取关键字平方后的中间几位为散列地址。</li>
<li>折叠法： 将关键字分割成位数相同的几部分，然后取这几部分的叠加和作为散列地址。</li>
<li>除留余数法： 取关键字被某个不大于散列表表长 m 的数 p 除后所得的余数为散列地址，即： h(key) &#x3D; key MOD p p ≤ m</li>
<li>随机数法： 选择一个随机函数，取关键字的随机函数值为它的散列地址，即： h(key) &#x3D; random(key)</li>
</ol>
</li>
</ul>
<p>使用了散列表的集合有map和set；</p>
<ul>
<li><strong>HashSet</strong> 用于存储一个集合，可以查找元素是否在集合中。<br>但是，如果元素有穷，并且范围不大，那么可以用一个布尔数组来存储一个元素是否存在，就足够了。</li>
<li><strong>HashMap</strong> 主要用于映射关系，从而把两个元素联系起来。HashMap 也可以用来对元素进行计数统计，此时键为元素，值为计数。和 HashSet 类似，如果元素有穷并且范围不大，可以用整型数组来进行统计。</li>
</ul>
<h4 id="HashMap-常用方法"><a href="#HashMap-常用方法" class="headerlink" title="HashMap 常用方法"></a>HashMap 常用方法</h4><p><code>put(key, value)</code>：将指定的键值对添加到哈希表中；如果该键已存在于 HashMap 中，则其旧值会被新值替换。<br><code>get(key)</code>：根据键获取对应的值。<br><code>containsKey(key)</code>：检查哈希表中是否包含指定的键。<code>containsValue(value)</code>：检查哈希表中是否包含指定的值。<br><code>remove(key)</code>：根据键移除键值对。<br><code>size()</code>：返回哈希表中键值对的数量。<br><code>isEmpty()</code>：检查哈希表是否为空。<br><code>keySet()</code>：返回哈希表中所有键的集合。<code>values()</code>：返回哈希表中所有值的集合。<code>entrySet()</code>：返回键值对的集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line">Map&lt;String, Integer&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  <span class="comment">// 创建一个HashMap</span></span><br><span class="line">hashMap.put(<span class="string">&quot;Three&quot;</span>, <span class="number">3</span>);  hashMap.remove(<span class="string">&quot;Three&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!hashMap.containsKey(<span class="string">&quot;Three&quot;</span>))  hashMap.put(<span class="string">&quot;Three&quot;</span>, <span class="number">3</span>); </span><br><span class="line"><span class="comment">// 遍历kv：2种方法</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : hashMap.entrySet()) &#123;  </span><br><span class="line">    System.out.println(<span class="string">&quot;Key: &quot;</span> + entry.getKey() + <span class="string">&quot;, Value: &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(String s : hashMap.keySet()) System.out.println(<span class="string">&quot;Key: &quot;</span> + s + <span class="string">&quot;, Value: &quot;</span> + hashMap.get(s));</span><br></pre></td></tr></table></figure>

<h4 id="HashSet-常用方法"><a href="#HashSet-常用方法" class="headerlink" title="HashSet 常用方法"></a>HashSet 常用方法</h4><p><code>add(E e)</code>: 向集合中添加元素。<code>addAll(Collection&lt;? extends E&gt; c)</code>: 将另一个集合的所有元素添加到当前集合。<br><code>remove(Object o)</code>: 移除指定的元素。<code>removeAll(Collection&lt;?&gt; c)</code>: 移除当前集合中包含在指定集合中的所有元素。<br><code>contains(Object o)</code>: 判断集合中是否包含指定元素。containsAll(Collection&lt;?&gt; c): 判断集合是否包含指定集合中的所有元素。<br><code>size()</code>: 返回集合的大小（元素个数）。<br><code>isEmpty()</code>: 判断集合是否为空。<br><code>clear()</code>: 清空集合中的所有元素。<br><code>iterator()</code>: 返回用于遍历集合的迭代器。</p>
<hr>


<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><strong>String</strong> 内部使用 char 数组存储数据。该数组被声明为 final，因此它不可被继承，初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 <strong>不可变</strong>。String 是一个类，而不是基本数据类型或容器。表示的是一个字符序列。<br>字符串是一个<strong>引用类型</strong>，因此在创建 String 对象时，实际上是在内存中分配了一块存储空间来存储字符串的值。(字符串常量池，堆，栈，</p>
<ul>
<li><strong>获取字符串信息</strong>：<br><code>length()</code>：返回字符串的长度。<br><code>charAt(int index)</code>：返回指定索引处的字符。<br><code>substring(int beginIndex)</code>：返回从 beginIndex 开始到字符串末尾的子字符串。<br><code>substring(int beginIndex, int endIndex)</code>：返回从 beginIndex 到 endIndex（不含）之间的子字符串</li>
<li><strong>字符串拼接</strong>：直接使用 <code>+</code> 运算符，或 <code>concat(String str)</code>：将指定字符串 str 连接到原字符串的末尾。<br>String 不可变，+&#x3D; 操作符或 concat()实际上创建了一个新的字符串对象，该对象包含 字符串值修改后的内容，然后将其分配给了原 str变量，使 str 引用了新的字符串对象，而原始的空字符串对象仍然存在，没有被修改。</li>
<li><strong>字符串查找和比较</strong>：<br><code>indexOf(String str)</code>：返回指定子字符串 str 在主字符串中第一次出现的位置。<code>lastIndexOf()</code>：返回最后一次..<br><code>equals(Object another)</code>：比较两个字符串是否相等。<code>equalsIgnoreCase()</code>：忽略大小写比较..。</li>
<li><strong>字符串转换</strong>：<br><code>toLowerCase()</code>：将字符串转换为小写，<code>toUpperCase()</code>：转大写。对于字符，有 <code>Character.toLowerCase()</code> 方法；<br><code>trim()</code>：去除字符串首尾的空格。</li>
<li><strong>切割字符串：</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;Hello world! This is a Java example.&quot;</span>;</span><br><span class="line"><span class="comment">// split() 方法根据匹配给定的正则表达式来拆分字符串。(注意判断结果可能是空字符串)</span></span><br><span class="line"><span class="comment">// 注意：`.`、`$`、`|` 和 `*` 等转义字符，必须得加 \\。多个分隔符，可以用 | 作为连字符。</span></span><br><span class="line"><span class="comment">// 使用空格切割字符串: \\s+ 表示一个或多个空格</span></span><br><span class="line">String[] words = text.split(<span class="string">&quot;\\s+&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><strong>字符串替换</strong>：<br><code>replace(char oldChar, char newChar)</code>：将字符串中的 <code>oldChar</code> 替换为 <code>newChar</code>。<br><code>replaceAll(String regex, String replace)</code>：使用新字符串<code>replace</code>替换所有与 <code>regex</code>匹配的字符串。<br><code>replaceFirst(String regex, String replacement)</code>：替换第一个匹配的字符串。</li>
<li><strong>字符串翻转</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">original</span> <span class="operator">=</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">reversed</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(original).reverse();</span><br><span class="line"><span class="type">String</span> <span class="variable">reversedString</span> <span class="operator">=</span> reversed.toString();</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>

<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p>数组和链表都是线性存储结构的基础，栈和队列都是线性存储结构的应用</p>
<h3 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h3><p>栈是一种后进先出（LIFO，Last-In-First-Out）的数据结构。在Java中，可以使用 <code>java.util.Stack</code> 类实现栈的功能，也可以使用 <code>Deque</code> 接口（比如 <code>ArrayDeque</code> 或 <code>LinkedList</code>）来模拟栈的行为。<br>Java 中，Stack 类实际上继承自 Vector 类。Vector 类实现了一个动态数组，而 Stack 在 Vector 的基础上提供了栈的常见操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">stack.push(<span class="number">10</span>);                       <span class="comment">// push(E item)：将元素压入栈顶。</span></span><br><span class="line">stack.push(<span class="number">20</span>); </span><br><span class="line">System.out.println(stack.pop());      <span class="comment">// pop()：移除并返回栈顶元素。输出 30</span></span><br><span class="line">System.out.println(stack.peek());     <span class="comment">// peek()：返回但不移除栈顶元素。输出 20</span></span><br><span class="line">System.out.println(stack.isEmpty());  <span class="comment">// isEmpty()：检查队列是否为空。输出 false</span></span><br></pre></td></tr></table></figure>

<h3 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h3><p>队列是一种先进先出（FIFO，First-In-First-Out）的数据结构。在Java中，可以使用 <code>java.util.Queue</code> 接口和它的实现类来实现队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">queue.offer(<span class="number">10</span>);                        <span class="comment">// offer(E e)：将元素插入队列。</span></span><br><span class="line">queue.offer(<span class="number">20</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> que.size();                 <span class="comment">// 队列的大小</span></span><br><span class="line">System.out.println(queue.poll());       <span class="comment">// poll()：移除并返回队列头部的元素。输出 10</span></span><br><span class="line">System.out.println(queue.peek());       <span class="comment">// peek()：返回但不移除队列头部的元素。输出 20</span></span><br><span class="line">System.out.println(queue.isEmpty());    <span class="comment">// isEmpty()：检查队列是否为空。输出 false</span></span><br></pre></td></tr></table></figure>

<p>双向队列 (Deque, “double ended queue”)，它可以从队列的两端添加和删除元素。Java的java.util包提供了<code>ArrayDeque</code>和<code>LinkedList</code>两种实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;String&gt;();  </span><br><span class="line"><span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">    stack.pollFirst();      <span class="comment">// 前出</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    stack.offerLast(name);  <span class="comment">// 后入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优先级队列 (PriorityQueue), 是一个无界队列，它使用元素的自然顺序或者构造队列时提供的Comparator对元素进行排序。PriorityQueue不允许使用null元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个基于自然顺序的优先级队列  </span></span><br><span class="line">PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();  </span><br><span class="line"><span class="comment">// 添加元素  </span></span><br><span class="line">queue.add(<span class="number">3</span>);  </span><br><span class="line">queue.add(<span class="number">1</span>);  </span><br><span class="line">queue.add(<span class="number">4</span>);  </span><br><span class="line"><span class="type">int</span> <span class="variable">removed</span> <span class="operator">=</span> queue.poll();  <span class="comment">// 取出并删除队列中的最小元素 </span></span><br><span class="line">System.out.println(queue);   <span class="comment">// 输出队列：3, 4  </span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个基于自定义Comparator的优先级队列  </span></span><br><span class="line">PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.comparingInt(Math::abs));  </span><br><span class="line"><span class="comment">// 添加元素  </span></span><br><span class="line">queue.add(-<span class="number">3</span>);  </span><br><span class="line">queue.add(-<span class="number">1</span>);  </span><br><span class="line">queue.add(<span class="number">4</span>);  </span><br><span class="line">queue.add(-<span class="number">2</span>);  </span><br><span class="line">System.out.println(queue);  <span class="comment">// 输出队列：1, 2, 3, 4，因为它们的绝对值从小到大排列  </span></span><br></pre></td></tr></table></figure>
<br>

<hr>

<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>树：它是n(n&gt;&#x3D;0)个节点的有限集。n&#x3D;0时为空树。n&gt;0时，有限集的元素构成一个具有层次感的数据结构。<br>区别于线性表一对一的元素关系，树中的节点是一对多的关系。树具有以下特点:<br>1、n&gt;0时，根节点是唯一的，不可能存在多个根节点。<br>2、每个节点有零个至多个子节点；除了根节点外，每个节点有且仅有一个父节点。根节点没有父节点。</p>
<ol>
<li>基本概念：<ul>
<li>子树: 除了根节点外，每个子节点都可以分为多个不相交的子树。</li>
<li>孩子与双亲: 若一个结点有子树，那么该结点称为子树根的”双亲”，子树的根是该结点的”孩子”。</li>
<li>兄弟: 具有相同双亲的节点互为兄弟。</li>
<li>节点的度: 一个节点拥有子树的数目。</li>
<li>叶子: 没有子树，也即是度为0的节点。</li>
<li>分支节点: 除了叶子节点之外的节点，也即是度不为0的节点。</li>
<li>内部节点: 除了根节点之外的分支节点。</li>
<li>层次: 根节点为第一层，其余节点的层次等于其双亲节点的层次加1.</li>
<li>树的高度: 也称为树的深度，树中节点的最大层次。</li>
<li>有序树: 树中节点各子树之间的次序是重要的，不可以随意交换位置。</li>
<li>无序树: 树种节点各子树之间的次序是不重要的。可以随意交换位置。</li>
<li>森林: 0或多棵互不相交的树的集合。</li>
</ul>
</li>
<li>二叉树：最多有两棵子树的树被称为二叉树<ul>
<li>满二叉树: 二叉树中所有非叶子结点的度都是2，且叶子结点都在同一层次上</li>
<li>完全二叉树: 如果一个二叉树与满二叉树前m个节点的结构相同，这样的二叉树被称为完全二叉树</li>
<li>插入</li>
<li>删除</li>
<li>遍历：前序遍历、中序遍历、后序遍历</li>
<li>搜索</li>
</ul>
</li>
<li>动态查找树<ul>
<li><strong>二叉搜索树 BST</strong><ul>
<li>指一棵空树或者具有下列性质的二叉树：若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；任意节点的左、右子树也分别为二叉查找树；没有键值相等的节点。</li>
<li>二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低为 O(logn) 。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、多重集、关联数组等。</li>
</ul>
</li>
<li><strong>二叉平衡树 AVL</strong><ul>
<li>含有相同节点的二叉查找树可以有不同的形态，而二叉查找树的平均查找长度与树的深度有关，所以需要找出一个查找平均长度最小的一棵，那就是平衡二叉树</li>
<li>具有以下性质：要么是棵空树，要么其根节点左右子树的深度之差的绝对值不超过1；其左右子树也都是平衡二叉树；二叉树节点的平衡因子定义为该节点的左子树的深度减去右子树的深度。则AVL的所有节点的平衡因子只可能是-1,0,1。</li>
</ul>
</li>
<li><strong>红黑树</strong><ul>
<li>红黑树也是一种自平衡的二叉查找树，它在每个节点增加了一个存储位记录节点的颜色，可以是RED,也可以是BLACK;通过任意一条从根到叶子简单路径上颜色的约束，红黑树保证最长路径不超过最短路径的二倍，因而近似平衡。</li>
<li>特征：1、每个结点要么是红的要么是黑的。(红或黑)  2、根结点是黑的。(根黑)  3、每个叶结点(叶结点即指树尾端NIL指针或NULL结点)都是黑的。(叶黑)  4、如果一个结点是红的，那么它的两个儿子都是黑的。(红子黑) 5、对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。(路径下黑相同)</li>
<li>红黑树与AVL树的比较<br>  1.AVL树的时间复杂度虽然优于红黑树，但是对于现在的计算机，cpu太快，可以忽略性能差异<br>  2.红黑树的插入删除比AVL树更便于控制操作<br>  3.红黑树整体性能略优于AVL树(红黑树旋转情况少于AVL树)  <img src="https://pdai.tech/images/alg/alg-tree-14.png" width="400" height="300" alt=""></li>
<li>用法最广：Java ConcurrentHashMap &amp; TreeMap；C++ STL: map &amp; set；linux进程调度Completely Fair Scheduler,用红黑树管理进程控制块；epoll在内核中的实现，用红黑树管理事件块；nginx中，用红黑树管理timer等</li>
</ul>
</li>
<li>哈夫曼树：哈夫曼又称最优二叉树。是一种带权路径长度最短的二叉树，一般可以按下面步骤构建:        <img src="https://pdai.tech/images/alg/alg-tree-13.png" width="400" height="300" alt=""><ul>
<li>（1）将所有左，右子树都为空的作为根节点。（2）在森林中选出两棵根节点的权值最小的树作为一棵新树的左，右子树，置新树的附加根节点的权值为其左，右子树上根节点的权值之和。注意，左子树的权值应小于右子树的。（3）从森林中删除这两棵树，同时把新树加入到森林中。</li>
<li>（4）重复（2）（3）步骤，直到森林中只有一棵树为止，此树便是哈夫曼树。</li>
</ul>
</li>
</ul>
</li>
<li>多路查找树<ul>
<li><strong>B 树</strong>：是一种自平衡的树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一种自平衡的m阶树，与自平衡二叉查找树不同，B树适用于读写相对大的数据块的存储系统。<ul>
<li>根结点至少有两个子女。</li>
<li>每个中间节点都包含k-1个元素和k个孩子，其中 m&#x2F;2 &lt;&#x3D; k &lt;&#x3D; m</li>
<li>每一个叶子节点都包含k-1个元素，其中 m&#x2F;2 &lt;&#x3D; k &lt;&#x3D; m</li>
<li>所有的叶子结点都位于同一层。</li>
<li>每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。<br> B-Tree中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个3阶的B-Tree: <img src="https://pdai.tech/images/alg/alg-tree-15.png" width="600" height="300" alt=""></li>
</ul>
</li>
<li><strong>B+ 树</strong>：B+ 树是一种树数据结构，通常用于关系型数据库(如Mysql)和操作系统的文件系统中。<ul>
<li>B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。自底向上插入，与二叉树相反。</li>
<li>在B树基础上，为叶子结点增加链表指针(B树+叶子有序链表)，所有关键字都在叶子结点 中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中。</li>
<li>b+树的非叶子节点不保存数据，只保存子树的临界值(最大或者最小)，所以同样大小的节点，b+树相对于b树能够有更多的分支，使得这棵树更加矮胖，查询时做的IO操作次数也更少。<br>  将上一节中的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示:  <img src="https://pdai.tech/images/alg/alg-tree-16.png" width="600" height="300" alt=""></li>
</ul>
</li>
<li>B* 树</li>
<li>R 树：R树是用来做空间数据存储的树状数据结构。例如给地理位置，矩形和多边形这类多维数据建立索引。</li>
</ul>
</li>
</ol>
<h3 id="避免孤立的学习知识点，要关联学习。"><a href="#避免孤立的学习知识点，要关联学习。" class="headerlink" title="避免孤立的学习知识点，要关联学习。"></a>避免孤立的学习知识点，要关联学习。</h3><p>比如实际应用当中，我们经常使用的是查找和排序操作，这在我们的各种管理系统、数据库系统、操作系统等当中，十分常用，我们通过这个线索将知识点串联起来：<br><code>数组</code>的下标寻址十分迅速，但计算机的内存是有限的，故数组的长度也是有限的；而且无序数组的查找最坏情况需要遍历整个数组；后来人们提出了<code>二分查找</code>，要求数组的构造一定有序，二分法查找解决了普通数组查找复杂度过高的问题。任何一种数组无法解决的问题就是插入、删除操作比较复杂，因此，在一个增删查改比较频繁的数据结构中，数组不会被优先考虑<br><code>普通链表</code>由于它的结构特点被证明根本不适合进行查找<br><code>哈希表</code>是数组和链表的折中，同时它的设计依赖散列函数的设计，数组不能无限长、链表也不适合查找，所以也不适合大规模的查找 ??? ???<br><code>二叉查找树</code>因为可能退化成链表，同样不适合进行查找<br><code>AVL树</code>是为了解决可能退化成链表问题，但是AVL树的旋转过程非常麻烦，因此插入和删除很慢，也就是构建AVL树比较麻烦<br><code>红黑树</code>是平衡二叉树和AVL树的折中，是比较合适的。集合类中的Map、关联数组具有较高的查询效率，它们的底层实现就是红黑树。<br><code>多路查找树</code> 是大规模数据存储中，实现索引查询这样一个实际背景下，树节点存储的元素数量是有限的(如果元素数量非常多的话，查找就退化成节点内部的线性查找了)，这样导致二叉查找树结构由于树的深度过大而造成磁盘I&#x2F;O读写过于频繁，进而导致查询效率低下。<br><code>B树</code>与自平衡二叉查找树不同，B树适用于读写相对大的数据块的存储系统，例如磁盘。它的应用是文件系统及部分非关系型数据库索引。<br><code>B+树</code>在B树基础上，为叶子结点增加链表指针(B树+叶子有序链表)，所有关键字都在叶子结点 中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中。通常用于关系型数据库(如Mysql)和操作系统的文件系统中。<br><code>B* 树</code>是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针, 在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1&#x2F;2提高到2&#x2F;3。<br><code>R树</code>是用来做空间数据存储的树状数据结构。例如给地理位置，矩形和多边形这类多维数据建立索引。Trie树是自然语言处理中最常用的数据结构，很多字符串处理任务都会用到。<br><code>Trie树</code>本身是一种有限状态自动机，还有很多变体。什么模式匹配、正则表达式，都与这有关。与树类似，用于处理字符串相关的问题时非常高效,它可以实现快速检索，常用于字典中的单词查询，搜索引擎的自动补全甚至 IP 路由。下图展示了“top”, “thus”和“their”三个单词在前缀树中如何存储的：<br><strong>针对大量数据，如果在内存中作业优先考虑红黑树(map,set之类多为RB-tree实现)，如果在硬盘中作业优先考虑B系列树</strong></p>
<p>各树详解：<a target="_blank" rel="noopener" href="https://pdai.tech/md/algorithm/alg-basic-tree-search.html">https://pdai.tech/md/algorithm/alg-basic-tree-search.html</a></p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>在Java中，二叉树是一种常见的树形数据结构，每个节点最多有两个子节点，分别为左子节点和右子节点。二叉树的节点类似于一个结构体，包含了数据、左子节点和右子节点的引用。以下是一个简单的二叉树的实现示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123;   <span class="built_in">this</span>.val = val;    <span class="built_in">this</span>.left = <span class="literal">null</span>;    <span class="built_in">this</span>.right = <span class="literal">null</span>;   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode root;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BinaryTree</span><span class="params">()</span> &#123;    root = <span class="literal">null</span>;   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        root = insertRec(root, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">insertRec</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (val &lt; root.val) &#123;</span><br><span class="line">            root.left = insertRec(root.left, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root.val) &#123;</span><br><span class="line">            root.right = insertRec(root.right, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他操作（搜索节点、删除节点等）可以根据需要实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><ul>
<li>红黑树的特性<br>（1）每个节点或者是黑色，或者是红色。<br>（2）根节点是黑色。<br>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL 或NULL)的叶子节点！ ]<br>（4）如果一个节点是红色的，则它的子节点必须是黑色的。<br>（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</li>
<li>左旋<br>对 x 进行左旋，意味着，将“x 的右孩子”设为“x 的父亲节点”；即，将 x 变成了一个左节点(x成了为 z 的左孩子)！因此，左旋中的“左”，意味着“被旋转的节点将变成一个左节点”。 </li>
<li>右旋<br>对 x 进行右旋，意味着，将“x 的左孩子”设为“x 的父亲节点”；即，将 x 变成了一个右节点(x成了为 y 的右孩子)！因此，右旋中的“右”，意味着“被旋转的节点将变成一个右节点”。 </li>
<li>添加<br>第一步: 将红黑树当作一颗二叉查找树，将节点插入。<br>第二步：将插入的节点着色为”红色”。<br>根据被插入节点的父节点的情况，可以将”当节点 z 被着色为红色节点，并插入二叉树”划分为三种情况来处理。<br>① 情况说明：被插入的节点是根节点。处理方法：直接把此节点涂为黑色。<br>② 情况说明：被插入的节点的父节点是黑色。处理方法：什么也不需要做。节点被插入后，仍然是红黑树。<br>③ 情况说明：被插入的节点的父节点是红色。这种情况下，被插入节点是一定存在非空祖父节点的；进一步的讲，被插入节点也一定存在叔叔节点(即使叔叔节点为空，我们也视之为存在，空节点本身就是黑色节点)。理解这点之后，我们依据”叔叔节点的情况”，将这种情况进一步划分为 3种情况(Case)<br>，，，<br>第三步: 通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。 </li>
<li>删除<br>第一步：将红黑树当作一颗二叉查找树，将节点删除。这和”删除常规二叉查找树中删除节点的方法是一样的”。分 3 种情况：<br>① 被删除节点没有儿子，即为叶节点。那么，直接将该节点删除就 OK 了。<br>② 被删除节点只有一个儿子。那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置。<br>③ 被删除节点有两个儿子。那么，先找出它的后继节点；然后把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。<br>第二步：通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。 因为”第一步”中删除节点之后，可能会违背红黑树的特性。所以需要通过”旋转和重新着色”来修正该树，使之重新成为一棵红黑树。<br>选择重着色 3 种情况。<br>① 情况说明： x 是“红+黑”节点。处理方法：直接把 x 设为黑色，结束。此时红黑树性质全部恢复。<br>② 情况说明： x 是“黑+黑”节点，且 x 是根。处理方法：什么都不做，结束。此时红黑树性质全部恢复。<br>③ 情况说明： x 是“黑+黑”节点，且 x 不是根。处理方法：这种情况又可以划分为 4 种子情况。这 4 种子情况如下表所示：<br>，，，，</li>
</ul>
<h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>B-tree 又叫平衡多路查找树。一棵 m 阶的 B-tree (m 叉树)的特性如下（其中 ceil(x)是一个取上限的函数） ：</p>
<ol>
<li>树中每个结点至多有 m 个孩子；</li>
<li>除根结点和叶子结点外，其它每个结点至少有有 ceil(m &#x2F; 2)个孩子；</li>
<li>若根结点不是叶子结点，则至少有 2 个孩子（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）；</li>
<li>所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部结点或查询失败的结点，实际上这些结点不存在，指向这些结点的指针都为 null)；</li>
<li>每个非终端结点中包含有 n 个关键字信息： (n， P0， K1， P1， K2， P2， ……， Kn， Pn)。其中：<ul>
<li>Ki (i&#x3D;1…n)为关键字，且关键字按顺序排序 K(i-1)&lt; Ki。</li>
<li>Pi 为指向子树根的接点，且指针 P(i-1)指向子树种所有结点的关键字均小于 Ki，但都大于 K(i-1)。</li>
<li>关键字的个数 n 必须满足： ceil(m &#x2F; 2)-1 &lt;&#x3D; n &lt;&#x3D; m-1。<img src="https://leo710aka.github.io/bk/b-tree.png" width="650" height="300" alt=""></li>
</ul>
</li>
</ol>
<p>一棵 m 阶的 B+tree 和 m 阶的 B-tree 的差异在于：</p>
<ol>
<li>有 n 棵子树的结点中含有 n 个关键字； (B-tree 是 n 棵子树有 n-1 个关键字)</li>
<li>所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (B-tree 的叶子节点并没有包括全部需要查找的信息)</li>
<li>所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。(B-tree 的非终节点也包含需要查找的有效信息)<img src="https://leo710aka.github.io/bk/b+tree.png" width="650" height="300" alt=""></li>
</ol>
<h3 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h3><p>位图的原理就是用一个 bit 来标识一个数字是否存在，采用一个 bit 来存储一个数据，所以这样可以大大的节省空间。 bitmap 是很常用的数据结构， 比如用于 Bloom Filter 中；用于无重复整数的排序等等。 bitmap 通常基于数组来实现，数组中每个元素可以看成是一系列二进制数，所有元素组成更大的二进制集合。</p>
<hr>

<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>图(Graph)是由顶点和连接顶点的边构成的离散结构。图是最灵活的数据结构之一，很多问题都可以使用图模型进行建模求解。<br>理解：图基础，图的遍历，最小生成树(Prim &amp; Kruskal)，最短路径(Dijkstra &amp; Frolyd)，拓扑排序(Topological sort)，AOE &amp; 关键路径等。</p>
<ul>
<li>图的定义：图是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为: G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。和线性表，树的差异:<ul>
<li>线性表中我们把数据元素叫元素，树中将数据元素叫结点，在图中数据元素，我们则称之为顶点(Vertex)。</li>
<li>线性表可以没有元素，称为空表；树中可以没有节点，称为空树；但是，在图中不允许没有顶点(有穷非空性)。</li>
<li>线性表中的各元素是线性关系，树中的各元素是层次关系，而图中各顶点的关系是用边来表示(边集可以为空)</li>
</ul>
</li>
<li>相关术语<ul>
<li>顶点的度：顶点Vi的度(Degree)是指在图中与Vi相关联的边的条数。对于有向图来说，有入度(In-degree)和出度(Out-degree)之分，有向图顶点的度等于该顶点的入度和出度之和。</li>
<li>邻接：若无向图中的两个顶点V1和V2存在一条边(V1,V2)，则称顶点V1和V2邻接(Adjacent)；若有向图中存在一条边&lt;V3,V2&gt;，则称顶点V3与顶点V2邻接，且是V3邻接到V2或V2邻接直V3；</li>
<li>路径：在无向图中，若从顶点Vi出发有一组边可到达顶点Vj，则称该顶点序列为从顶点Vi到顶点Vj的路径(Path)。</li>
<li>连通：若从Vi到Vj有路径可通，则称顶点Vi和顶点Vj是连通(Connected)的。</li>
<li>权(Weight)：有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做权(Weight)。</li>
</ul>
</li>
<li>类型<ul>
<li>无向图：如果图中任意两个顶点之间的边都是无向边(没有方向的边)，则称该图为无向图。边使用小括号“()”表示;如 (V1,V2);</li>
<li>有向图：如果图中任意两个顶点之间的边都是有向边(有方向的边)，则称该图为有向图。边使用尖括号“&lt;&gt;”表示;如 &lt;V1,V2&gt;</li>
<li>无向完全图: 在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。(有(n*(n-1))&#x2F;2条边)</li>
<li>有向完全图: 在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。(含有n个顶点的有向完全图有n*(n-1)条边)</li>
</ul>
</li>
<li>图的存储结构<ul>
<li>邻接矩阵表示法：用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组(称为邻接矩阵)存储图中的边或弧的信息。  <img src="https://pdai.tech/images/alg/alg-graph-store-1.png" width="400" height="300" alt="">
  <img src="https://pdai.tech/images/alg/alg-graph-store-2.png" width="400" height="300" alt="">
  不足: 由于存在n个顶点的图需要n*n个数组元素进行存储，当图为稀疏图时，使用邻接矩阵存储方法将会出现大量0元素，这会造成极大的空间浪费。这时，可以考虑使用邻接表表示法来存储图中的数据</li>
<li>邻接表表示法：邻接表由表头节点和表节点两部分组成，图中每个顶点均对应一个存储在数组中的表头节点。如果这个表头节点所对应的顶点存在邻接节点，则把邻接节点依次存放于表头节点所指向的单向链表中。  <img src="https://pdai.tech/images/alg/alg-graph-store-3.jpg" width="400" height="300" alt="">
  <img src="https://pdai.tech/images/alg/alg-graph-store-4.jpg" width="400" height="300" alt=""></li>
</ul>
</li>
</ul>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>深度优先搜索: 假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。显然，深度优先搜索是一个递归的过程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vexnode *g[], <span class="type">int</span> v1)</span> </span>&#123;</span><br><span class="line">    stack&lt;vexnode*&gt; stk;</span><br><span class="line">    stk.<span class="built_in">push</span>(g[v1]);</span><br><span class="line">    g[v1]-&gt;visited = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        vexnode *cur = stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; cur-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (vexnode *neighbor : cur-&gt;neighbors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!neighbor-&gt;visited) &#123;</span><br><span class="line">                neighbor-&gt;visited = <span class="literal">true</span>;</span><br><span class="line">                stk.<span class="built_in">push</span>(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>广度优先搜索算法(Breadth First Search)，又称为”宽度优先搜索”或”横向优先搜索”。<br>它的思想是: 从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。<br>换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1,2…的顶点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vexnode *g[], <span class="type">int</span> v1)</span> </span>&#123;</span><br><span class="line">    queue&lt;vexnode*&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(g[v1]);</span><br><span class="line">    g[v1]-&gt;visited = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        vexnode *cur = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; cur-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (vexnode *neighbor : cur-&gt;neighbors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!neighbor-&gt;visited) &#123;</span><br><span class="line">                neighbor-&gt;visited = <span class="literal">true</span>;</span><br><span class="line">                que.<span class="built_in">push</span>(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DFS &amp; BFS 实现 <a target="_blank" rel="noopener" href="https://pdai.tech/md/algorithm/alg-basic-graph-bfs-dfs.html">https://pdai.tech/md/algorithm/alg-basic-graph-bfs-dfs.html</a></p>
<hr>

<h1 id="ACM模式Java输入"><a href="#ACM模式Java输入" class="headerlink" title="ACM模式Java输入"></a>ACM模式Java输入</h1><p>核心代码模式下不用考虑输入输出的问题，只需要根据所给函数框架写中间逻辑代码。但是在ACM模式下要，即函数的输入是从控制台键入的几行数据，而输出是直接将结果打印到控制台。<br>nextInt()：直至读取到空格或回车之后结束本次的int值；<br>next()：直至读取到空格或回车之后结束本次的String值，不可读取回车；<br>nextLine()：直至读取到换行符（回车）之后结束本次读取的String，可读取回车（空值）</p>
<h4 id="单个输入"><a href="#单个输入" class="headerlink" title="单个输入"></a>单个输入</h4><p>有的函数输入很简单，就是一个数，或者一个字符串，或者一行数中间用空格隔开，这种输入很简单，处理方法如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 读取输入的一个整型</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="comment">// 如果输入的是double类型</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> sc.nextDouble();</span><br><span class="line">        <span class="comment">// 如果输入的是一个字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sc.next(); </span><br><span class="line">        <span class="comment">// 读取的是一整行</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">l</span> <span class="operator">=</span> sc.nextLine(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="一行输入"><a href="#一行输入" class="headerlink" title="一行输入"></a>一行输入</h4><p>如果输入的是一行数据，中间用空格隔开，比如输入的是2 3 4</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> sc.nextInt();  <span class="comment">// 接收第1个数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> sc.nextInt();	<span class="comment">// 接收第2个数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> sc.nextInt();	<span class="comment">// 接收第3个数</span></span><br></pre></td></tr></table></figure>
<p>有时候输入不是空格分隔，而是逗号分割的，比如输入的是1,2,3,4,5，并假设我们需要用数组接收，可以这么操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="comment">//以字符串形式作为输入</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.next();</span><br><span class="line"><span class="comment">//通过分隔符将其转为字符串数组</span></span><br><span class="line">String[] arr = str.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"><span class="comment">//初始化一个整数数组</span></span><br><span class="line"><span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line"><span class="comment">//给整数数组赋值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">    nums[j] = Integer.parseInt(arr[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多行输入"><a href="#多行输入" class="headerlink" title="多行输入"></a>多行输入</h4><p>一共输入两行，第一行表示第二行有多少个数，比如第一行为4，第二行为0 2 3 4。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="comment">// 第一行的数表示第二行有多少个数，即数组的长度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    nums[i] = sc.nextInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="持续输入"><a href="#持续输入" class="headerlink" title="持续输入"></a>持续输入</h4><p>如果题目中没有明说一次给几个输入，为了保险可以直接无脑用 while(sc.hasNext()) {} 包括起来，一直等待输入，除非终止程序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">    <span class="comment">// 多个输入都需要经过相同的逻辑判断然后在输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Acm模式输出"><a href="#Acm模式输出" class="headerlink" title="Acm模式输出"></a>Acm模式输出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.print();   <span class="comment">// 用于打印不带换行符的内容到控制台</span></span><br><span class="line">System.out.println(); <span class="comment">// 用于打印带换行符的内容到控制台，打印完后会换行</span></span><br><span class="line">System.out.format();  <span class="comment">// 用于格式化输出，可以通过格式化字符串来指定输出的格式</span></span><br><span class="line">System.out.printf();  <span class="comment">// 也用于格式化输出，但是使用更简单，格式化字符串以及对应的参数放在一起即可</span></span><br><span class="line">System.out.println(<span class="string">&quot;Hello&quot;</span> + <span class="string">&quot;, &quot;</span> + <span class="string">&quot;world&quot;</span> + <span class="string">&quot;!&quot;</span>); <span class="comment">// 字符串连接可以直接用 + 号：&quot;Hello, world!&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 规格化的输出：</span></span><br><span class="line"><span class="comment">// `#` 表示如果该位置有数字则显示，否则不显示；`0` 表示该位置无论是否有数字都显示，如果没有数字则显示 `0`；</span></span><br><span class="line"><span class="type">DecimalFormat</span> <span class="variable">fd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;#.00#&quot;</span>);</span><br><span class="line"><span class="type">DecimalFormat</span> <span class="variable">gd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;0.000&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;x =&quot;</span> + fd.format(x)); <span class="comment">// `.00#` 表示保留两位小数并四舍五入；x = 12.3456， fd.format(x) 输出的结果是 12.35</span></span><br><span class="line">System.out.println(<span class="string">&quot;x =&quot;</span> + gd.format(x)); <span class="comment">// `0.000` 表示保留三位小数四舍五入； x = 12.3456， gd.format(x) 输出的结果是 12.346</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二进制字符串输出：</span></span><br><span class="line"><span class="type">String</span> <span class="variable">binaryString</span> <span class="operator">=</span> Integer.toBinaryString(<span class="number">42</span>); <span class="comment">// 将整数转换为二进制字符串</span></span><br><span class="line">System.out.println(<span class="string">&quot;Binary representation of &quot;</span> + number + <span class="string">&quot; is: &quot;</span> + binaryString);</span><br></pre></td></tr></table></figure>

<h3 id="日期处理"><a href="#日期处理" class="headerlink" title="日期处理"></a>日期处理</h3><p>SimpleDateFormat 用于日期格式化和解析，可以将日期对象格式化为指定的字符串，也可以将特定格式的字符串解析为日期对象。</p>
<ol>
<li>格式化日期为字符串：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">formattedDate</span> <span class="operator">=</span> sdf.format(now);</span><br></pre></td></tr></table></figure></li>
<li>解析字符串为日期：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">dateString</span> <span class="operator">=</span> <span class="string">&quot;2024-03-02 15:30:00&quot;</span>;</span><br><span class="line"><span class="type">Date</span> <span class="variable">parsedDate</span> <span class="operator">=</span> sdf.parse(dateString);</span><br><span class="line">System.out.println(<span class="string">&quot;Parsed Date: &quot;</span> + parsedDate);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><p>我们读取 <code>a.txt</code> 和 <code>b.txt</code> 中的内容，并将其写入到 <code>c.txt</code> 中。然后，我们统计总行数并在第一行写入总行数。<br>请注意，在写入总行数之前需要先将文件关闭并重新打开以实现在文件的开头插入内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileCopyWithLineCount</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">reader1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">reader2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;b.txt&quot;</span>));</span><br><span class="line">            <span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;c.txt&quot;</span>))</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 读取第一个文件并写入到输出文件</span></span><br><span class="line">            String line;</span><br><span class="line">            <span class="type">int</span> <span class="variable">totalCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((line = reader1.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                writer.write(line);</span><br><span class="line">                writer.newLine();</span><br><span class="line">                totalCount++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取第二个文件并写入到输出文件</span></span><br><span class="line">            <span class="keyword">while</span> ((line = reader2.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                writer.write(line);</span><br><span class="line">                writer.newLine();</span><br><span class="line">                totalCount++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在第一行写入总行数</span></span><br><span class="line">            writer.flush();</span><br><span class="line">            writer.close();</span><br><span class="line">            <span class="type">BufferedWriter</span> <span class="variable">writer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;c.txt&quot;</span>, <span class="literal">true</span>));</span><br><span class="line">            writer2.write(<span class="string">&quot;Total Lines: &quot;</span> + totalCount);</span><br><span class="line">            writer2.newLine();</span><br><span class="line">            writer2.flush();</span><br><span class="line">            writer2.close();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;内容已成功从 &quot;</span> + <span class="string">&quot;a.txt&quot;</span> + <span class="string">&quot; 和 &quot;</span> + <span class="string">&quot;b.txt&quot;</span> + <span class="string">&quot; 读取并写入 &quot;</span> + <span class="string">&quot;c.txt&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;发生IO异常: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<hr>

<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>Java 中的位运算是对二进制数据进行操作的一种方式，常用的位运算符有以下几种：</p>
<ol>
<li><p><strong>按位与（&amp;）</strong>：两个位都为 1 时，结果为 1；否则为 0。例如：<code>1010 &amp; 1100 = 1000</code>。</p>
</li>
<li><p><strong>按位或（|）</strong>：两个位中至少有一个为 1 时，结果为 1；否则为 0。例如：<code>1010 | 1100 = 1110</code>。</p>
</li>
<li><p><strong>按位异或（^）</strong>：两个位相同为 0，不同为 1。例如：<code>1010 ^ 1100 = 0110</code>。</p>
</li>
<li><p><strong>按位取反（~）</strong>：对一个二进制数的每个位取反，0 变为 1，1 变为 0。例如：<code>~1010 = 0101</code>。</p>
</li>
<li><p><strong>左移（&lt;&lt;）</strong>：将一个数的所有位向左移动指定的位数，右侧空出的位用 0 填充。例如：<code>1010 &lt;&lt; 2 = 101000</code>。</p>
</li>
<li><p><strong>右移（&gt;&gt;）</strong>：将一个数的所有位向右移动指定的位数，左侧空出的位用符号位填充（正数用 0，负数用 1）。例如：<code>1010 &gt;&gt; 2 = 10</code>。</p>
</li>
<li><p><strong>无符号右移（&gt;&gt;&gt;）</strong>：将一个数的所有位向右移动指定的位数，左侧空出的位用 0 填充。例如：<code>1010 &gt;&gt;&gt; 2 = 10</code>。</p>
</li>
</ol>
<hr>

<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><ul>
<li>时间复杂度是一种用来衡量算法运行时间与输入规模之间关系的概念。它不是用来精确测量程序运行时间的，而是描述在输入规模变化时，算法运行时间的增长趋势。</li>
<li>大O表示上界，当用它作为算法的最坏情况运行时间的上界，就是对任意数据输入的运行时间的上界。<br>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!)</li>
</ul>
<h2 id="♥常见排序算法知识体系详解♥"><a href="#♥常见排序算法知识体系详解♥" class="headerlink" title="♥常见排序算法知识体系详解♥"></a>♥常见排序算法知识体系详解♥</h2><p>A. 重点理解几个排序之间的对比，时间和空间复杂度，以及应用。PS：越简单越要提高认知效率，做到战略上藐视战术上重视。<br>B. 具体分析各种排序及其复杂度，查漏补缺；在综合复杂度及稳定性情况下，通常希尔, 快排和 归并需要重点掌握。<br>稳定性：指相等元素的相对顺序在排序前后是否保持不变。稳定性在某些应用场景中很重要，例如在对相同优先级的任务进行排序时，保持原始顺序可确保任务的处理顺序不被打乱。<br><img src="https://pdai.tech/images/alg/alg-sort-overview-1.png"><br><a target="_blank" rel="noopener" href="https://leo710aka.github.io/2020/09/09/5%20%E7%B4%A2%E5%BC%95_%E6%8E%92%E5%BA%8F_/">https://leo710aka.github.io/2020/09/09/5%20%E7%B4%A2%E5%BC%95_%E6%8E%92%E5%BA%8F_/</a></p>
<ul>
<li><p>冒泡排序(Bubble Sort)<br>它是一种较简单的排序算法。它会遍历若干次要排序的数列，每次遍历时，它都会从前往后依次的比较相邻两个数的大小；如果前者比后者大，则交换它们的位置。这样，一次遍历之后，最大的元素就在数列的末尾！采用相同的方法再次遍历时，第二大的元素就被排列在最大元素之前。重复此操作，直到整个数列都有序为止</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort1</span><span class="params">(<span class="type">int</span> [] a, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)&#123;<span class="comment">//表示 n 次排序过程。</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;n-i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j-<span class="number">1</span>] &gt; a[j])&#123;<span class="comment">//前面的数字大于后面的数字就交换</span></span><br><span class="line">                <span class="comment">//交换 a[j-1]和 a[j]</span></span><br><span class="line">                <span class="type">int</span> temp;</span><br><span class="line">                temp = a[j-<span class="number">1</span>];</span><br><span class="line">                a[j-<span class="number">1</span>] = a[j];</span><br><span class="line">                a[j]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入排序(Insertion Sort)<br>基本思想是: 把n个待排序的元素看成为一个有序表和一个无序表。开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次可完成排序过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> arr[])</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 插入的数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">insertVal</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        <span class="comment">// 被插入的位置(准备和前一个数比较)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果插入的数比被插入的数小</span></span><br><span class="line">        <span class="keyword">while</span>(index &gt;= <span class="number">0</span> &amp;&amp; insertVal &lt; arr[index]) &#123;</span><br><span class="line">            <span class="comment">// 将把 arr[index] 向后移动</span></span><br><span class="line">            arr[index+<span class="number">1</span>] = arr[index];</span><br><span class="line">            <span class="comment">// 让 index 向前移动</span></span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把插入的数放入合适位置</span></span><br><span class="line">        arr[index+<span class="number">1</span>] = insertVal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>选择排序(Selection sort)<br>基本思想是: 首先在未排序的数列中找到最小(or最大)元素，然后将其存放到数列的起始位置；接着，再从剩余未排序的元素中继续寻找最小(or最大)元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectionSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123; </span><br><span class="line">		<span class="type">int</span> minIndex = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;len; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(a[j] &lt; a[minIndex]) &#123;</span><br><span class="line">				minIndex = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">swap</span>(a[i], a[minIndex]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>快速排序(Quick Sort)<br>采用分治的思想，将一个数组分成两个子数组，然后递归地对子数组进行排序。它选择一个元素作为”pivot”（基准），并将数组中小于基准的元素放在基准的左边，大于基准的元素放在基准的右边，然后对左右子数组进行递归排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt;= high) <span class="keyword">return</span>; <span class="comment">// 边界条件判断</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> low;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> high;</span><br><span class="line">    <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> nums[low];</span><br><span class="line">    <span class="keyword">while</span> (end &gt; start) &#123;</span><br><span class="line">        <span class="keyword">while</span> (end &gt; start &amp;&amp; nums[end] &gt;= key) &#123;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end &gt; start) &#123;</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (end &gt; start &amp;&amp; nums[start] &lt;= key) &#123;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end &gt; start) &#123;</span><br><span class="line">            nums[end] = nums[start];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[start] = key; <span class="comment">// 基准值放回合适位置</span></span><br><span class="line">    quickSort(nums, low, start - <span class="number">1</span>); <span class="comment">// 左边序列递归排序</span></span><br><span class="line">    quickSort(nums, start + <span class="number">1</span>, high); <span class="comment">// 右边序列递归排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>希尔排序(Shell Sort)：实质上是一种分组插入方法。<br>它的基本思想是: 对于n个待排序的数列，取一个小于n的整数gap(gap被称为步长)将待排序元素分成若干个组子序列，所有距离为gap的倍数的记录放在同一个组中；然后，对各组内的元素进行直接插入排序。 这一趟排序完成之后，每一个组的元素都是有序的。然后减小gap的值，并重复执行上述的分组和排序。重复这样的操作，当gap&#x3D;1时，整个数列就是有序的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dk</span> <span class="operator">=</span> a.length/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>( dk &gt;= <span class="number">1</span> )&#123;</span><br><span class="line">        ShellInsertSort(a, dk);</span><br><span class="line">        dk = dk/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ShellInsertSort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> dk)</span> &#123;</span><br><span class="line">    <span class="comment">//类似插入排序，只是插入排序增量是 1，这里增量是 dk,把 1 换成 dk 就可以了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=dk;i&lt;a.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;a[i-dk])&#123;</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="type">int</span> x=a[i];<span class="comment">//x 为待插入元素</span></span><br><span class="line">            a[i]=a[i-dk];</span><br><span class="line">            <span class="keyword">for</span>(j=i-dk; j&gt;=<span class="number">0</span> &amp;&amp; x&lt;a[j];j=j-dk)&#123;</span><br><span class="line">                <span class="comment">//通过循环，逐个后移一位找到要插入的位置。</span></span><br><span class="line">                a[j+dk]=a[j];</span><br><span class="line">            &#125;</span><br><span class="line">            a[j+dk]=x;<span class="comment">//插入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="堆排序-Heap-Sort"><a href="#堆排序-Heap-Sort" class="headerlink" title="堆排序(Heap Sort)"></a>堆排序(Heap Sort)</h3><ul>
<li><p>堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。<br>它具有 O(n log n) 的时间复杂度，并且是原地排序算法（不需要额外的空间）。堆排序分为两个阶段：建堆和排序。</p>
<ol>
<li><strong>建堆（Heapify）</strong>：<ul>
<li>将待排序数组视为完全二叉树，从最后一个非叶子节点开始，依次向上进行调整，使得每个节点都满足堆的性质（最大堆或最小堆）。</li>
<li>对于最大堆，父节点的值大于或等于子节点的值；对于最小堆，父节点的值小于或等于子节点的值。</li>
<li>建堆过程可以通过自上而下的调整（向下调整）或自下而上的调整（向上调整）来实现。</li>
</ul>
</li>
<li><strong>排序</strong>：<ul>
<li>将堆顶元素（根节点）与最后一个元素交换，并将最后一个元素移出堆（视为已排序部分）。</li>
<li>对剩余的元素重新进行堆调整，使得剩余元素重新构成堆。</li>
<li>重复上述步骤，直到所有元素都被移出堆，完成排序。</li>
</ul>
</li>
</ol>
</li>
<li><p>下面是堆排序的详细步骤：</p>
<ol>
<li>将待排序数组构建成一个最大堆（或最小堆），即建堆过程。可以选择自上而下的调整（向下调整）或自下而上的调整（向上调整）来实现。</li>
<li>从最后一个非叶子节点开始，依次向前对每个节点进行堆调整，使得当前节点及其子树满足堆的性质。</li>
<li>交换堆顶元素（根节点）和最后一个元素，并将最后一个元素移出堆（视为已排序部分）。</li>
<li>对剩余的元素重新进行堆调整，使得剩余元素重新构成堆。</li>
<li>重复步骤3和步骤4，直到所有元素都被移出堆，完成排序。<img src="https://github.com/leo710aka/bk/blob/main/HeapSort.png?raw=true" width="500" height="200" alt=""></li>
</ol>
</li>
<li> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AdjustDwon</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> size, <span class="type">int</span> parent)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (child &lt; size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child + <span class="number">1</span> &lt; size &amp;&amp; a[child + <span class="number">1</span>] &gt; a[child]) &#123;</span><br><span class="line">            ++child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[child] &gt; a[parent]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[child], a[parent]);</span><br><span class="line">            parent = child;</span><br><span class="line">            child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = (n - <span class="number">1</span> - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">AdjustDwon</span>(a, n, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> end = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (end &gt; <span class="number">0</span>)	&#123;</span><br><span class="line">        <span class="built_in">swap</span>(a[<span class="number">0</span>], a[end]);</span><br><span class="line">        <span class="built_in">AdjustDwon</span>(a, end, <span class="number">0</span>);</span><br><span class="line">        --end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>桶排序：原理很简单，将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bucketSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">        min = Math.min(min, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建桶</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">bucketNum</span> <span class="operator">=</span> (max - min) / arr.length + <span class="number">1</span>;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(bucketNum);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bucketNum; i++)&#123;</span><br><span class="line">        bucketArr.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将每个元素放入桶</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (arr[i] - min) / (arr.length);</span><br><span class="line">        bucketArr.get(num).add(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对每个桶进行排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bucketArr.size(); i++)&#123;</span><br><span class="line">        Collections.sort(bucketArr.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>归并排序算法：采用分治的思想将一个大问题分割成多个小问题来解决。<br>具体来说，归并排序的过程包括分割、排序和合并三个步骤。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n1 = mid - left + <span class="number">1</span>, n2 = right - mid;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftArr</span><span class="params">(n1)</span>, <span class="title">rightArr</span><span class="params">(n2)</span></span>;                        <span class="comment">// 创建临时数组来存储左右两部分的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; i++)  leftArr[i] = arr[left + i];     <span class="comment">// 将数据复制到临时数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n2; i++)  rightArr[i] = arr[mid + <span class="number">1</span> + i];    </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = left;                                   <span class="comment">// 合并两个临时数组</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftArr[i] &lt;= rightArr[j]) arr[k++] = leftArr[i++];  </span><br><span class="line">        <span class="keyword">else</span> arr[k++] = rightArr[j++]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1)  arr[k++] = leftArr[i++];                      <span class="comment">// 处理剩余元素</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; n2)  arr[k++] = rightArr[j++];  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;           <span class="comment">// 归并排序主函数</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">mergeSort</span>(arr, left, mid);                                <span class="comment">// 分割左右两部分</span></span><br><span class="line">        <span class="built_in">mergeSort</span>(arr, mid + <span class="number">1</span>, right); </span><br><span class="line">        <span class="built_in">merge</span>(arr, left, mid, right);                             <span class="comment">// 合并已排序的两部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基数排序<br>基本思想是: 将整数按位数切割成不同的数字，然后按每个位数分别比较。具体做法是: 将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">radixSort</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[]=&#123;<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>,<span class="number">13</span>,<span class="number">27</span>,<span class="number">49</span>,<span class="number">78</span>,<span class="number">34</span>,<span class="number">12</span>,<span class="number">64</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">62</span>,<span class="number">99</span>,<span class="number">98</span>,<span class="number">54</span>,<span class="number">101</span>,<span class="number">56</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">15</span>,<span class="number">35</span>,<span class="number">2</span> <span class="number">5</span>,<span class="number">53</span>,<span class="number">51</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">radixSort</span><span class="params">()</span>&#123;</span><br><span class="line">        sort(a);</span><br><span class="line">        <span class="keyword">for</span>(inti=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            System.out.println(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] array)</span>&#123;</span><br><span class="line">        <span class="comment">//首先确定排序的趟数;</span></span><br><span class="line">        <span class="type">int</span> max=array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(inti=<span class="number">1</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]&gt;max)&#123;</span><br><span class="line">                max=array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> time=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//判断位数;</span></span><br><span class="line">        <span class="keyword">while</span>(max&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            max/=<span class="number">10</span>;</span><br><span class="line">            time++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//建立 10 个队列;</span></span><br><span class="line">        List&lt;ArrayList&gt; queue=newArrayList&lt;ArrayList&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt;queue1=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            queue.add(queue1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行 time 次分配和收集;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;time;i++)&#123;</span><br><span class="line">            <span class="comment">//分配数组元素;</span></span><br><span class="line">            <span class="keyword">for</span>(intj=<span class="number">0</span>;j&lt;array.length;j++)&#123;</span><br><span class="line">                <span class="comment">//得到数字的第 time+1 位数;</span></span><br><span class="line">                <span class="type">int</span> x=array[j]%(<span class="type">int</span>)Math.pow(<span class="number">10</span>,i+<span class="number">1</span>)/(<span class="type">int</span>)Math.pow(<span class="number">10</span>, i);</span><br><span class="line">                ArrayList&lt;Integer&gt;queue2=queue.get(x);</span><br><span class="line">                queue2.add(array[j]);</span><br><span class="line">                queue.set(x, queue2);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> count=<span class="number">0</span>;<span class="comment">//元素计数器;</span></span><br><span class="line">                <span class="comment">//收集队列元素;</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">10</span>;k++)&#123;</span><br><span class="line">                <span class="keyword">while</span>(queue.get(k).size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    ArrayList&lt;Integer&gt;queue3=queue.get(k);</span><br><span class="line">                    array[count]=queue3.get(<span class="number">0</span>);</span><br><span class="line">                    queue3.remove(<span class="number">0</span>);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/02/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" data-id="clyekw3a1000btwv5dv7z2l9a" data-title="Java 数据结构" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/09/03/Java%E5%AE%B9%E5%99%A8/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Java 容器
        
      </div>
    </a>
  
  
    <a href="/2021/09/01/Java%E5%9F%BA%E7%A1%80/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Java 基础</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2046/12/">December 2046</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2046/12/30/nice-photo/">Nice Photo</a>
          </li>
        
          <li>
            <a href="/2024/07/07/%E7%BE%8E%E7%9A%84Midea/">美 的 Midea</a>
          </li>
        
          <li>
            <a href="/2024/05/01/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/">毕 业 设 计</a>
          </li>
        
          <li>
            <a href="/2024/01/11/RabbitMQ/">RabbitMQ</a>
          </li>
        
          <li>
            <a href="/2024/01/07/SpringCloud/">SpringCloud</a>
          </li>
        
          <li>
            <a href="/2024/01/04/%E9%AA%8F%E4%BC%AFJunbo/">骏 伯 Junbo</a>
          </li>
        
          <li>
            <a href="/2023/10/20/%E6%98%A5%E6%8B%9B2024/">春 招 2024</a>
          </li>
        
          <li>
            <a href="/2023/10/13/%E9%9D%A2%E8%AF%95_%E4%B8%AA%E4%BA%BA/">面 逝 | 个人</a>
          </li>
        
          <li>
            <a href="/2023/10/12/%E9%9D%A2%E8%AF%95_Java/">面 逝 | Java</a>
          </li>
        
          <li>
            <a href="/2023/10/11/%E9%9D%A2%E8%AF%95_%E7%BB%84%E4%BB%B6/">面 逝 | 组件</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 fengcai<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>