<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>JVM | Qué miras Bobo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="JVM (Java虚拟机)本质上是一个计算机程序，他的职责是运行 Java字节码文件，解释为对应OS的机器指令。JVM 包含内存管理、解释执行虚拟机指令、即时编译三大功能。常见的JVM有HotSpot、GraalVM、OpenJ9等，另外DragonWell龙井JDK也提供了一款功能增强版的JVM。其中使用最广泛的是HotSpot。 JVM 跨平台原理 本质是不同操作系统上提供了不同的JVM。（下">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM">
<meta property="og:url" content="http://example.com/2021/09/04/JVM/index.html">
<meta property="og:site_name" content="Qué miras Bobo">
<meta property="og:description" content="JVM (Java虚拟机)本质上是一个计算机程序，他的职责是运行 Java字节码文件，解释为对应OS的机器指令。JVM 包含内存管理、解释执行虚拟机指令、即时编译三大功能。常见的JVM有HotSpot、GraalVM、OpenJ9等，另外DragonWell龙井JDK也提供了一款功能增强版的JVM。其中使用最广泛的是HotSpot。 JVM 跨平台原理 本质是不同操作系统上提供了不同的JVM。（下">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://github.com/leo710aka/bk/blob/main/jvm.png?raw=true">
<meta property="og:image" content="https://pdai.tech/images/jvm/java-jvm-overview.png">
<meta property="og:image" content="https://pdai.tech/images/jvm/java_jvm_classload_2.png">
<meta property="og:image" content="https://pdai.tech/images/jvm/java_jvm_classload_1.png">
<meta property="og:image" content="https://github.com/leo710aka/bk/blob/main/jvm7.png?raw=true">
<meta property="og:image" content="https://github.com/leo710aka/bk/blob/main/jvm2.png?raw=true">
<meta property="og:image" content="https://github.com/leo710aka/bk/blob/main/jvm4.png?raw=true">
<meta property="og:image" content="https://github.com/leo710aka/bk/blob/main/jvm5.png?raw=true">
<meta property="og:image" content="https://pdai.tech/images/jvm/jvm/0082zybply1gc8tjehg8bj318m0lbtbu.jpg">
<meta property="og:image" content="https://github.com/leo710aka/bk/blob/main/jvm6.png?raw=true">
<meta property="og:image" content="https://github.com/leo710aka/bk/blob/main/jvm9.png?raw=true">
<meta property="og:image" content="https://github.com/leo710aka/bk/blob/main/jvm8.png?raw=true">
<meta property="og:image" content="https://github.com/leo710aka/bk/blob/main/jvm10.png?raw=true">
<meta property="og:image" content="https://github.com/leo710aka/bk/blob/main/jvm11.png?raw=true">
<meta property="og:image" content="https://github.com/leo710aka/bk/blob/main/jvm12.png?raw=true">
<meta property="og:image" content="https://github.com/leo710aka/bk/blob/main/jvm13.png?raw=true">
<meta property="og:image" content="https://github.com/leo710aka/bk/blob/main/jvm15.png?raw=true">
<meta property="og:image" content="https://pdai.tech/images/jvm/jvm-overview.png">
<meta property="article:published_time" content="2021-09-04T03:49:42.000Z">
<meta property="article:modified_time" content="2024-02-14T16:16:22.335Z">
<meta property="article:author" content="fengcai">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/leo710aka/bk/blob/main/jvm.png?raw=true">
  
    <link rel="alternate" href="/atom.xml" title="Qué miras Bobo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="https://github.com/leo710aka/bk/blob/main/DT1.jpg?raw=true">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Qué miras Bobo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-JVM" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/04/JVM/" class="article-date">
  <time class="dt-published" datetime="2021-09-04T03:49:42.000Z" itemprop="datePublished">2021-09-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      JVM
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>JVM (Java虚拟机)本质上是一个计算机程序，他的职责是运行 Java字节码文件，解释为对应OS的机器指令。<br>JVM 包含内存管理、解释执行虚拟机指令、即时编译三大功能。<br>常见的JVM有HotSpot、GraalVM、OpenJ9等，另外DragonWell龙井JDK也提供了一款功能增强版的JVM。其中使用最广泛的是HotSpot。</p>
<h3 id="JVM-跨平台原理"><a href="#JVM-跨平台原理" class="headerlink" title="JVM 跨平台原理"></a>JVM 跨平台原理</h3><ul>
<li>本质是不同操作系统上提供了不同的JVM。（下载<code>JDK/JRE</code> for Linux&#x2F;Windows…）</li>
<li>Java 代码“一次编写，到处执行”，其实是指由<code>.java</code>文件编译来的<code>.class</code>字节码文件（高级语言java –&gt; <code>javac</code>编译 –&gt; 字节码(提升程序运行的效率，跨平台运行)）能够通过不同操作系统上的 JVM 解释为该操作系统的机器指令。</li>
<li>JVM 也不再只支持Java，由此衍生出了许多基于JVM的编程语言，如Groovy, Scala, Koltin等等。</li>
</ul>
<h2 id="JVM-知识要点"><a href="#JVM-知识要点" class="headerlink" title="JVM 知识要点"></a>JVM 知识要点</h2><img src="https://github.com/leo710aka/bk/blob/main/jvm.png?raw=true" width="500" height="200" alt=""> 
1. 类加载器：将class字节码文件中的内容加载到内存中。
2. 运行时数据区域：负责管理JVM 使用到的内存，比如创建对象和销毁对象。
3. 执行引擎：将字节码文件中的指令解释成机器码，同时使用即时编译器优化性能，用gc回收内存。
4. 本地接口：调用本地已经编译好的方法（不在字节码文件中）比如虚拟机中提供的cpp方法。

<p><img src="https://pdai.tech/images/jvm/java-jvm-overview.png"></p>
<hr>

<h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1><ul>
<li><code>类的生命周期：加载，连接，初始化，使用，卸载</code></li>
<li>其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。<br>在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定(也成为动态绑定或晚期绑定)。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。<br><img src="https://pdai.tech/images/jvm/java_jvm_classload_2.png"></li>
</ul>
<ol>
<li><strong>类的加载</strong>：查找并加载类的二进制数据<ul>
<li><strong>类加载器</strong>通过一个类的全限定名来获取其定义的二进制字节流。可以使用Java代码拓展的不同的渠道。</li>
<li>JVM 将字节码中的信息保存到内存的<strong>方法区</strong>（虚拟概念）</li>
<li>生成一个InstanceKlass对象（c++编写），保存类的所有信息，里边还包含实现特定功能比如多态的信息。</li>
<li>在Java堆中生成一个代表这个类的java.lang.Class对象（包含字段比InstanceKlass中的少，控制访问范围和保证安全性），作用是在Java代码中去获取类的信息（反射），以及存储静态字段的数据（JDK8后） <img src="https://pdai.tech/images/jvm/java_jvm_classload_1.png" width="500" height="200" alt="">
 加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。
 类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误(LinkageError错误)如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</li>
<li>加载.class文件的方式：从本地系统中直接加载、通过网络下载.class文件、从zip，jar等归档文件中加载.class文件、从专有数据库中提取.class文件、将Java源文件动态编译为.class文件</li>
</ul>
</li>
<li><strong>连接</strong><ul>
<li><em>2.1 <strong>验证</strong></em>: 确保被加载的类的正确性。验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。<ul>
<li><code>文件格式验证</code>: 验证字节流是否符合<strong>Class文件格式</strong>的规范；例如: 是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内（不能高于环境jdk版本）、常量池中的常量是否有不被支持的类型。</li>
<li><code>元数据验证</code>: 对<strong>字节码描述的信息进行语义</strong>分析(注意: 对比javac编译阶段的语义分析)，以保证其描述的信息符合Java语言规范的要求；例如: 这个类是否有父类，除了java.lang.Object之外。</li>
<li><code>字节码验证</code>: 通过数据流和控制流分析，确定<strong>程序语义</strong>是合法的、符合逻辑的。</li>
<li><code>符号引用验证</code>: 确保解析动作能正确执行。</li>
</ul>
</li>
<li><em>2.2 <strong>准备</strong></em>: 为类的<strong>静态变量</strong>分配内存，并将其初始化为默认值。这些内存都将在方法区中分配。<ul>
<li>这时进行内存分配的仅包括类变量(<strong>static</strong>)，而不包括实例变量，实例变量在对象实例化时随着对象一块分配在Java堆</li>
<li>这里所设置的初始值通常情况下是数据类型默认的零值(如0、0L、null、false等)，而不是被在Java代码中被显式地赋予的值。 假设一个类变量的定义为: public static int value &#x3D; 3；那么变量value在准备阶段过后的初始值为0，而非3，因为这时候尚未开始执行任何Java方法，把value赋值为3的动作将在初始化阶段才会执行。</li>
<li>对于同时被<code>static和final</code>修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，系统不会为其赋予默认零值。</li>
<li>对基本数据类型来说，对于类变量(static)和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值.而局部变量使用前必须显式地为其赋值，否则编译时不通过。</li>
<li>对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。</li>
</ul>
</li>
<li><em>2.3 <strong>解析</strong></em>: 把类中的<strong>符号引用</strong>（在字节码文件中使用编号来访问常量池中内容）转换为<strong>直接引用</strong>（符号-&gt;内存地址）<br> 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li>
</ul>
</li>
<li><strong>初始化</strong>：为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。<ul>
<li>在Java中对类变量进行初始值设定有两种方式: 声明类变量是指定初始值、使用静态代码块为类变量指定初始值</li>
<li>JVM初始化步骤<ul>
<li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li>
<li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li>
<li>假如类中有初始化语句，则系统依次执行这些初始化语句</li>
</ul>
</li>
<li>类初始化时机: 只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下:<ul>
<li>创建类的实例，也就是new的方式</li>
<li>访问某个类或接口的静态变量（注意final修饰且等号右边是常量的变量不会触发初始化）或者对该静态变量赋值</li>
<li>调用类的静态方法、执行Main方法的当前类</li>
<li>反射(如Class.forName(“com.pdai.jvm.Test”))</li>
<li>初始化某个类的子类，则其父类也会被初始化</li>
<li>Java虚拟机启动时被标明为启动类的类(Java Test)，直接使用java.exe命令来运行某个主类</li>
</ul>
</li>
</ul>
</li>
<li><strong>使用</strong><br> （即程序员工作阶段）类访问方法区内的数据结构的接口， 对象是Heap区的数据。</li>
<li><strong>卸载</strong><ul>
<li>Java虚拟机将结束生命周期的几种情况：<ul>
<li>执行了System.exit()方法</li>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>

<h1 id="JVM-类加载"><a href="#JVM-类加载" class="headerlink" title="JVM 类加载"></a>JVM 类加载</h1><p>【<font color= "#87CEFA"> <strong>类的生命周期的加载，连接，初始化阶段</strong> </font>】</p>
<h3 id="类字节码详解"><a href="#类字节码详解" class="headerlink" title="类字节码详解"></a>类字节码详解</h3><p>源代码通过编译器编译为字节码，再通过类加载子系统进行加载到JVM中运行；<br>字节码文件中保存了源代码编译之后的内容，以<strong>二进制</strong>的方式存储，无法直接用记事本打开阅读；<br>常用工具：对于本地&#x2F;服务器上的字节码文件：javap；<strong>jclasslib</strong>，有idea插件版本，在代码编译（构建项目）后实时看到字节码文件内容。<br>对于运行中的程序：<strong>Arthas</strong> 是一款线上监控诊断产品，通过全局视角实时查看应用load、内存、gc、线程的状态信息，并能在不修改应用代码的情况下，对业务问题进行诊断，大大提升线上问题排查效率。（jar包，使用<code>java -jar</code>启动 Arthas包）服务器上文件使用javap命令直接查看，也可以通过arthas的dump命令导出字节码文件再查看本地文件。还可以使用jad命令反编译出源代码。</p>
<ol>
<li>基础信息：<strong>magic魔数</strong>（Java文件头 <code>CAFEBABE</code>，软件通过文件头来校验文件的类型，而非文件扩展名），<strong>主副版本号</strong>（指编译字节码文件的JDK版本号(如主版本号52对应JDK8，减44) 用于判断当前字节码的版本与运行时的JDK是否兼容(低版本JDK不能运行高版本字节码)冲突时建议降低第三方依赖的版本号），<strong>访问标识</strong>（public，final等等），<strong>父类和接口</strong></li>
<li><strong>常量池：</strong>避免相同内容重复定义，节省空间。保存了字符串常量、类或接口名、字段名主要在字节码指令中使用。<br>常量池中的数据都有一个编号，编号从1开始。在字段或者字节码指令中通过编号可以快速的找到对应的数据。<br>字节码指令中通过编号引用到常量池的过程称之为符号引用。</li>
<li>字段：当前类或接口声明的字段信息</li>
<li><strong>方法：</strong>当前类或接口声明的方法信息，为<strong>字节码指令</strong>（在操作数栈和局部变量表上执行 iconst，istore，iload，iinc等指令，i++和++i区别就在指令iinc和iload的顺序颠倒）<br><code>main方法</code>：Java类的main方法是程序的入口点。在字节码文件中，这通常表示为public static void main(String[] args)方法。Java虚拟机（JVM）将通过public static void main(String[] args)方法来执行程序。字节码指令会调用这个方法，并它将启动程序的执行。<br><code>init方法</code>：类的构造函数，用于创建类的实例。在字节码文件中，<init>方法是类的构造函数，用于初始化新对象的状态。这个方法通常是由invokespecial指令调用的，用于初始化新对象。<br><code>clinit方法</code>：类的类构造函数，也称为静态初始化方法。这个方法用于执行类的静态初始化代码块。在字节码文件中，<clinit>方法通常由clinit指令表示。这个方法用于执行类级别的静态初始化操作<br><code>Code属性</code>：每个方法都有一个Code属性，其中包含了该方法的字节码指令，也就是方法体的实际执行代码</li>
<li>属性：类的属性，比如源码的文件名，内部类的列表等<img src="https://github.com/leo710aka/bk/blob/main/jvm7.png?raw=true" width="700" height="300" alt=""></li>
</ol>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>类加载器(ClassLoader)负责在类加载过程中的字节码获取并加载到内存这一部分。通过加载字节码数据放入内存转换成byte[]（只负责这一部分），接下来调用虚拟机底层方法将byte[]转换成方法区和堆中的数据。<br>站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：</p>
<ul>
<li><code>启动类加载器</code>: Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库(如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载)。启动类加载器是无法被Java程序直接引用的，无法直接通过代码查看，程序员难以直接调试。<br>它使用C++实现(这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的)，是虚拟机自身的一部分；所有其他的类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</li>
<li><code>扩展类加载器</code>: Extension ClassLoader，该加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库(如javax.*开头的类)，开发者可以直接使用扩展类加载器。</li>
<li><code>应用程序类加载器</code>: Application ClassLoader，该类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径(ClassPath)所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。<img src="https://github.com/leo710aka/bk/blob/main/jvm2.png?raw=true" width="600" height="200" alt=""></li>
</ul>
<p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入<code>自定义的类加载器</code>。<br>因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点: 1. 在执行非置信代码之前，自动验证数字签名。2. 动态地创建符合用户特定需要的定制化构建类。 3.从特定的场所取得java class，例如数据库中和网络中。<br><code>URLClassLoader</code>： 这是一个常见的用户自定义类加载器，可以从指定的URL加载类。在很多情况下，当需要从外部加载一些类或JAR文件时，使用URLClassLoader是比较方便的。URLClassLoader是Application ClassLoader的子类加载器。</p>
<h3 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h3><ul>
<li><code>全盘负责</code>，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li>
<li><code>父类委托</code>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li>
<li><code>缓存机制</code> ，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</li>
<li><code>双亲委派机制</code>，如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去<br>完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</li>
<li>在Java中如何使用代码的方式去主动加载一个类呢?<br>方式1：使用Class.forName方法，使用当前类的类加载器去加载指定的类<br>方式2：获取到类加载器，通过类加载器的loadClass方法指定某个类加载器加载</li>
</ul>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>由于Java虚拟机中有多个类加载器，双亲委派机制的核心是解决一个类到底由谁加载的问题。<br>双亲委派机制指的是：当一个类加载器接收到加载类的任务时，会自底向上查找是否（被这个类加载器）加载过，再由顶向下（如果位于这个类加载器的加载目录中）进行加载。<br>双亲委派机制的好处有两点: 第一是避免恶意代码替换JDK中的核心类库，确保的完整性和安全性；二是避免一个类重复地被加载<br><img src="https://github.com/leo710aka/bk/blob/main/jvm4.png?raw=true" width="600" height="200" alt=""></p>
<h3 id="打破双亲委派机制："><a href="#打破双亲委派机制：" class="headerlink" title="打破双亲委派机制："></a>打破双亲委派机制：</h3><ol>
<li><strong>自定义类加载器</strong><br>通常情况下，我们都是直接使用系统类加载器。但有时，我们也需要自定义类加载器。比如 应用通过网络传输 Java 类的字节码，为保证安全性经过了加密处理，这时系统类加载器就无法对其进行加载；Tomcat通过自定义类加载器实现应用之间类隔离；<br>自定义类加载器一般都是继承自 <code>ClassLoader</code> 类，重写 <code>findClass</code>方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">byte</span>[] classData = loadClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="literal">null</span>) &#123;  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);  <span class="comment">// 连接阶段</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] loadClassData(String className) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> root + File.separatorChar</span><br><span class="line">                + className.replace(<span class="string">&#x27;.&#x27;</span>, File.separatorChar) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">ins</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName);</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">bufferSize</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[bufferSize];</span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((length = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="type">MyClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>();</span><br><span class="line">        classLoader.setRoot(<span class="string">&quot;D:\\temp&quot;</span>);</span><br><span class="line">        Class&lt;?&gt; testClass = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            testClass = classLoader.loadClass(<span class="string">&quot;com.pdai.jvm.classloader.Test2&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> testClass.newInstance();</span><br><span class="line">            System.out.println(object.getClass().getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> () &#123;...        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>线程上下文类加载器</strong> ？？？实际上没打破。。？**?????????**<br>大量应用在 java底层，比如JDBC和JNDI等</li>
<li>Osgi框架的类加载器<br>历史上Osgi框架实现了一套新的类加载器机制，允许同级之间委托进行类的加载；还使用类加载器实现热部署功能。</li>
</ol>
<h3 id="JDK8-后的类加载器"><a href="#JDK8-后的类加载器" class="headerlink" title="JDK8 后的类加载器"></a>JDK8 后的类加载器</h3><p>由于JDK9引入了module的概念，类加载器在设计上发生了很多变化。</p>
<ol>
<li>启动类加载器使用<strong>Java编写</strong>，位于jdk.internal.loader.ClassLoaders类中Java中的BootClassLoader继承自BuiltinClassLoader实现从模块中找到要加载的字节码资源文件.启动类加载器依然无法通过java代码获取到，返回的仍然是null，保持了统一。</li>
<li>扩展类加载器被替换成了<strong>平台类加载器</strong>(Platform Class Loader)<br>平台类加载器遵循模块化方式加载字节码文件，所以继承关系从URLClassLoader变成了BuiltinClassLoader，BuiltinClassLoader实现了从模块中加载字节码文件。平台类加载器的存在更多的是为了与老版本的设计方案兼容，自身没有特殊的逻辑</li>
</ol>
<hr>

<h1 id="JVM-内存结构"><a href="#JVM-内存结构" class="headerlink" title="JVM 内存结构"></a>JVM 内存结构</h1><p>Java 虚拟机在运行Java程序过程中管理的内存区域，称之为运行时数据区。<strong>！！注意不要和Java内存模型混淆了，，</strong><br><img src="https://github.com/leo710aka/bk/blob/main/jvm5.png?raw=true" width="700" height="300" alt=""><br>Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程一一对应的数据区域会随着线程开始和结束而创建和销毁。【 <font color= "#87CEFA"> <strong>类的生命周期的使用，卸载阶段</strong>？</font>】<br>线程私有：程序计数器、虚拟机栈、本地方法区<br>线程共享：堆、方法区，堆外内存（Java7的永久代或JDK8的元空间、代码缓存）</p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器(Program Counter Register)也叫PC寄存器，每个线程会通过程序计数器记录当前要执行的的字节码指令的内存地址。<br>它是一块很小的固定大小的内存空间，不会发生内存溢出 <code>&quot;OutOfMemoryError&quot;</code>。</p>
<ol>
<li>在代码执行过程中，程序计数器会记录下一行字节码指令的地址。执行完当前指令之后，虚拟机的执行引擎根据程序计数器执行下一行指令。程序计数器可以控制程序指令的进行，实现分支、跳转、异常等逻辑。</li>
<li>在多线程执行情况下，CPU会不停的做任务切换，这导致经常中断或恢复。JVM 需要通过程序计数器记录 CPU 切换前解释执行到那一句指令并继续解释运行。每个线程都有它自己的程序计数器，独立计算，不会互相影响。</li>
</ol>
<h2 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h2><ul>
<li>早期也叫 Java 栈。每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame），对应着一次次 Java 方法调用，是线程私有的，生命周期和线程一致。<br>作用：<strong>主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</strong></li>
<li>JVM栈 采用栈的数据结构来管理方法调用中的基本数据，先进后出，每一个方法的调用使用一个<strong>栈帧</strong>(Stack Frame)来保存。<br>IDEA 在 debug 时候，可以在 debug 窗口看到 Frames 中各种方法的压栈和出栈情况<img src="https://pdai.tech/images/jvm/jvm/0082zybply1gc8tjehg8bj318m0lbtbu.jpg" width="700" height="300" alt=""></li>
<li><strong>栈帧</strong>的组成<ul>
<li><strong>局部变量表</strong>：在运行过程中存放所以的局部变量，包括实例方法的this对象，方法的参数，方法体中声明的局部变量<ul>
<li>编译成字节码文件时就可以确定局部变量表的内容，包含局部变量的编号、生效范围等；<br>  局部变量表数据在 <em>字节码文件 - 方法 - Code - LocalVariableTable</em> 查看。</li>
<li>实际在栈帧中，局部变量表是一个数组，数组中每一个位置为<strong>槽</strong>(slot)，long和double类型占两个槽，其他类型占一个。</li>
<li>实例方法中的序号为0的位置存放的是this，指的是当前调用方法的对象，运行时会在内存中存放实例对象的地址。</li>
<li>方法参数也会保存在局部变量表中，其顺序与方法中参数定义的顺序一致局部变量表  <img src="https://github.com/leo710aka/bk/blob/main/jvm6.png?raw=true" width="700" height="300" alt=""></li>
</ul>
</li>
<li><strong>操作数栈</strong>：JVM在执行指令的过程中用来存放临时数据的一块区域。主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间<ul>
<li>它是一种栈式的数据结构，如果一条指令将一个值压入操作数栈，则后面的指令可以弹出并使用该值。</li>
<li>在编译期就可以确定操作数栈的最大深度，从而在执行时正确的分配内存大小</li>
</ul>
</li>
<li><strong>帧数据</strong><ul>
<li>动态链接：当前类的字节码指令引用了其他类的属性或者方法时，需要将符号引用(编号)转换成对应的运行时常量池中的内存地址。动态链接就保存了编号到运行时常量池的内存地址的映射关系。</li>
<li>方法出口：方法出口指的是方法在正确或者异常结束时，当前栈帧会被弹出，同时程序计数器应该指向上一个栈帧中的下一条指令的地址。所以在当前栈帧中，需要存储此方法出口的地址。</li>
<li>异常表的引用：异常表存放代码中异常的处理信息，包含了try代码块和catch代码块执行后跳转到的字节码指令位置</li>
</ul>
</li>
</ul>
</li>
<li>栈内存溢出：一个线程的Java 虚拟机栈中，如果栈帧过多，占用内存超过栈内存可分配的最大大小就会出现内存溢出，出现<code>StackOverflowError</code>错误<ul>
<li>如果我们不指定栈的大小，JVM 将创建一个具有默认大小的栈。大小取决于操作系统和计算机的体系结构，windows(64位)下的JDK8测试最小值为180k，最大值为1024m</li>
<li>要修改Java虚拟机栈的大小，可以使用虚拟机参数 -Xss。一般情况下，工作中即便使用了递归进行操作，栈的深度最多也只能到几百,不会出现栈的溢出。所以此参数可以手动指定为 -Xss256k 节省内存。</li>
</ul>
</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><ul>
<li>Java虚拟机栈存储了Java方法调用时的栈帧，而本地方法栈存储的是（c++编写的）native本地方法（如文件IO操作）的栈帧.</li>
<li>在Hotspot虚拟机中，Java虚拟机栈和本地方法栈实现上使用了同一个栈空间。本地方法栈会在栈内存上生成一个栈帧，临时保存方法的参数，同时方便出现异常时也把本地方法的栈信息打印出来</li>
</ul>
<h2 id="栈是运行时的单位，而堆是存储的单位"><a href="#栈是运行时的单位，而堆是存储的单位" class="headerlink" title="**栈是运行时的单位，而堆是存储的单位**"></a><code>**栈是运行时的单位，而堆是存储的单位**</code></h2><p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪。</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>一般Java程序中堆内存是空间最大的一块内存区域。<strong>创建出来的对象</strong>都存在于堆上，并且在栈上保存一个<strong>对象的引用</strong>（在堆上的地址）。<br>达到上限之后，就会抛出 <code>OutofMemory</code>错误。<br>栈上的局部变量表中，可以存放堆上对象的引用。静态变量也可以存放堆对象的引用，通过静态变量就可以实现对象在线程之间共享。</p>
<ul>
<li>堆内存中有三个值，used 指的是当前已使用的堆内存，total 是JVM已分配的可用堆内存，max 是JVM可以分配的最大堆内存。total 不足时，JVM会继续分配内存给堆，total 值增大但最多只能与 max 相等。</li>
<li>max 默认是系统内存的 1&#x2F;4，total 默认是系统内存的 1&#x2F;64。实际使用中一般都需要设置这两个值。<br>Java服务端程序开发时，建议将 <strong>-Xmx</strong>（max最大值）和 <strong>-Xms</strong>（初始的total）设置为相同的值，避免再次申请内存。</li>
</ul>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><ul>
<li>方法区是存放基础信息的位置，线程共享，主要包括三部分；<ul>
<li><strong>类的元信息</strong>：类的基本信息 (元信息)，一般称之为InstanceKlass对象。在类的加载阶段完成.  <img src="https://github.com/leo710aka/bk/blob/main/jvm9.png?raw=true" width="600" height="300" alt=""></li>
<li><strong>运行时常量池</strong>：放的是字节码中的常量池内容。字节码文件中通过编号查表的方式找到常量，这种常量池称为静态常量池。当常量池加载到内存中之后，可以通过内存地址快速的定位到常量池中的内容，这种常量池称为运行时常量池</li>
<li><strong>字符串常量池</strong>：字符串常量池存储在代码中定义的常量字符串内容。比如String s2 &#x3D; “abc” 的 “abc”即 s2这个字符串常量就会被放入字符串常量池（而String s1 &#x3D; new String(“abc”) 中的 s1这个对象会被放入堆内存）</li>
</ul>
</li>
<li>方法区是《Java虚拟机规范》中设计的<em><strong>虚拟概念</strong></em>，每款Java虚拟机在实现上都各不相同。Hotspot设计如下<ul>
<li>JDK7及之前的版本将方法区存放在<strong>堆区域中的</strong><code>永久代</code>空间，堆的大小由虚拟机参数来控制。</li>
<li>JDK8及之后的版本将方法区存放在<code>元空间</code>中，元空间位于OS维护的<strong>直接内存中</strong>，默认在不超过OS承受的上限可以一直分配</li>
<li>！！ JDK6中字符串常量池在方法区（永久代）中，永久代在堆中；JDK7中从字符串常量池永久代中移出，仍在堆中；而JDK8后方法区（永久代-&gt;元空间）从堆中移出，字符串常量池仍在堆中<img src="https://github.com/leo710aka/bk/blob/main/jvm8.png?raw=true" width="700" height="300" alt=""></li>
</ul>
</li>
</ul>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存(Direct Memory)并不在《Java虚拟机规范》中存在，所以并不属于Java运行时的内存区域.</p>
<ul>
<li>在JDK1.4中引入了NIO机制，使用了直接内存，主要为了解决以下两个问题:<br>1、Java堆中的对象如果不再使用要回收，回收时会影响对象的创建和使用。<br>2、I0操作比如读文件，需要先把文件读入直接内存(缓冲区)再把数据复制到Java堆中现在直接放入直接内存即可，同时Java堆上维护直接内存的引用，减少了数据复制的开销。写文件也是类似的思路.</li>
<li>要创建直接内存上的数据，可以使用ByteBuffer。语法: ByteBuffer directBuffer &#x3D; ByteBuffer.allocateDirect(size);<br>注意事项: arthas的memory命令可以查看直接内存大小，属性名direct。</li>
</ul>
<hr>


<h1 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h1><p>？？<br>？</p>
<hr>

<h1 id="JVM-GC-垃圾回收"><a href="#JVM-GC-垃圾回收" class="headerlink" title="JVM GC 垃圾回收"></a>JVM GC 垃圾回收</h1><p>在C&#x2F;C++这类没有自动垃圾回收机制的语言中，一个对象如果不再使用，需要手动释放，否则就会出现<code>内存泄漏</code>。内存泄漏指的是不再使用的对象在系统中未被回收，内存泄漏的积累可能会导致<code>内存溢出</code>。<br>Java中为了简化对象的释放，引入了自动的<code>垃圾回收</code> (Garbage Collection 简称 GC) 机制。【 <font color= "#87CEFA"> <strong>类的生命周期的卸载阶段</strong> ？？</font>】<br>线程不共享的部分，都是伴随着线程的创建而创建，线程的销毁而销毁。而方法的栈帧在执行完方法之后就会自动弹出栈并释放掉对应的内存。所以只用考虑线程不共享部分。JVM GC主要负责对<strong>堆上</strong>的内存进行回收。</p>
<h2 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h2><p>方法区中能回收的内容主要就是不再使用的类.判定一个类可以被卸载。需要同时满足下面三个条件<br>1、此类所有实例对象都已经被回收，在堆中不存在任何该类的实例对象以及子类对象。<br>2、加载该类的类加载器已经被回收<br>3、该类对应的java.lang.Class 对象没有在任何地方被引用<br>开发中此类场景一般很少出现，主要在如 OSGi、JSP 的热部署等应用场景中。</p>
<h2 id="堆的回收"><a href="#堆的回收" class="headerlink" title="堆的回收"></a>堆的回收</h2><p>如何判断堆上的对象可以回收? Java中的对象是否能被回收，是根据对象是否被引用来决定的。引用说明该对象还在使用，不允许被回收。<br><img src="https://github.com/leo710aka/bk/blob/main/jvm10.png?raw=true" width="700" height="300" alt=""></p>
<p>常见的有两种判断方法:引用计数法和可达性分析法。</p>
<ul>
<li><strong>引用计数法</strong>：会为每个对象维护一个引用计数器，当对象被引用时加1，取消引用时减1.<ul>
<li>优点是实现简单，C++中的智能指针就采用了引用计数法</li>
<li>缺点主要有两点: 1.每次引用和取消引用都需要维护计数器，对系统性能会有一定的影响 2.存在循环引用问题，所谓循环引用就是当A引用B，B同时引用A时会出现对象无法回收的问题</li>
</ul>
</li>
<li><strong>可达性分析算法</strong>：Java使用的是可达性分析算法来判断对象是否可以被回收。可达性分析将对象分为两类:垃圾回收的根对象GRoot)和普通对象，对象与对象之间存在引用关系。如果其（反向？引用）到某个GC Root对象是可达的，对象就不可被回收。<ul>
<li>四大类 GCRoot 对象<ul>
<li>线程Thread对象（放在堆中，指向对应的栈）  <img src="https://github.com/leo710aka/bk/blob/main/jvm11.png?raw=true" width="700" height="300" alt=""></li>
<li>系统类加载器加载的java.lang.Class对象，引用类中的静态变量  ???、，，？？  <img src="https://github.com/leo710aka/bk/blob/main/jvm12.png?raw=true" width="700" height="300" alt=""></li>
<li>监视器对象，用来保存同步锁 synchronized关键字持有的对象</li>
<li>本地方法调用时使用的全局对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="五种引用"><a href="#五种引用" class="headerlink" title="五种引用"></a>五种引用</h3><ul>
<li><strong>强引用</strong>：可达性算法中描述的一般指的是强引用，即是GCRoot对象对普通对象有引用关系，只要关系存在普通对象就不会被回收。</li>
<li><strong>软引用</strong>：相对于强引用是一种比较弱的引用关系<ul>
<li>如果一个对象只有软引用关联到它，当程序内存不足时，就会将软引用中的数据进行回收。</li>
<li>软引用常用于缓存中（提高效率，不影响可用性）</li>
<li>在JDK 1.2版之后提供了sftReference类来实现软引用。软引用的执行过程如下：<br>  1.将对象使用软引用包装起来，new SoftReference&lt;对象类型&gt;(对象)<br>  2.内存不足时，虚拟机尝试进行垃圾回收。<br>  3.如果垃圾回收仍不能解决内存不足的问题，回收软引用中的对象<br>  4.如果依然内存不足，抛出OutofMemory异常  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>];    <span class="comment">// 建立数组（强引用对象？？                </span></span><br><span class="line">SoftReference&lt;<span class="type">byte</span>[]&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;<span class="type">byte</span>[]&gt;(bytes);  <span class="comment">// 建立软引用</span></span><br><span class="line">bytes = <span class="literal">null</span>;                                  <span class="comment">// 释放强引用</span></span><br><span class="line">System.out.println(softReference.get());       <span class="comment">// ：[B@2503dbd3</span></span><br><span class="line"><span class="type">byte</span>[] bytes2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>];   <span class="comment">// 内存不足，释放软引用对象</span></span><br><span class="line">System.out.printIn(softReference.get());       <span class="comment">// ：null</span></span><br><span class="line"><span class="type">byte</span>[] bytes2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>];   <span class="comment">// ：直接抛OutofMemory异常</span></span><br></pre></td></tr></table></figure></li>
<li><strong>？？？软引用队列</strong>：软引用中的对象如果在内存不足时回收，SoftReference对象本身也需要被回收。如何知道哪些SoftReference对象需要回收呢? SoftReference提供了一套队列机制:1、软引用创建时，通过构造器传入引用队列2、在软引用中包含的对象被回收时，该软引用对象会被放入引用队列3通过代码遍历引用队列，将SoftReference的强引用删除</li>
</ul>
</li>
<li><strong>弱引用</strong>：弱引用的整体机制和软引用基本一致，区别在于弱引用包含的对象在垃圾回收时不管内存够不够都会直接被回收<br>在JDK1.2版之后提供了WeakReference类来实现弱引用，弱引用主要在ThreadLocal中使用。<br>弱引用对象本身也可以使用引用队列进行回收。</li>
<li><strong>虚引用</strong>：虚引用也叫幽灵引用&#x2F;幻影引用，不能通过虚引用对象获取到包含的对象。虚引用唯一的用途是当对象被垃圾回收器回收时可以接收到对应的通知。Java中使用PhantomReference实现了虚引用，直接内存中为了及时知道直接内存对象不再使用，从而回收内存，使用了虚引用来实现。</li>
<li><strong>终结器引用</strong>：指的是在对象需要被回收时，对象将会被放置在Finalizer类中的引用队列中，并在稍后由一条由FinalizerThread线程从队列中获取对象，然后执行对象的finalize方法。在这个过程中可以在finalize方法中再将自身对象使用强引用关联上，但是不建议这样做，如果耗时过长会影响其他对象的回收。</li>
</ul>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><ul>
<li>垃圾回收要做的有两件事：1、找到内存中存活的对象； 2、释放不再存活对象的内存，使得程序能再次利用这部分空间</li>
<li>三种评价标准：堆使用效率、吞吐量，以及最大停时间不可兼得。<br>一般来说，堆内存越大，最大暂停时间就越长。想要减少最大暂停时间，就会降低吞吐量。不同的垃圾回收算法，适用不同的场景。</li>
<li>标记清除算法<ul>
<li>核心思想：1.标记阶段，将所有存活的对象进行标记。Java中使用可达性分析算法，从GC Root开始通过引用链遍历出所有存活对象。 2.清除阶段，从内存中删除没有被标记也就是非存活对象</li>
<li>优点：实现简单，只需要在第一阶段给每个对象维护标志位，第二阶段删除对象即可。</li>
<li>缺点：1.碎片化问题由于内存是连续的，所以在对象被删除之后，内存中会出现很多细小的可用内存单元。如果我们需要的是一个比较大的空间，很有可能这些内存单元的大小过小无法进行分配  2.分配速度慢。由于内存碎片的存在，需要维护一个空闲链表，极有可能发生每次需要遍历到链表的最后才能获得合适的内存空间。</li>
</ul>
</li>
<li>复制算法<ul>
<li>核心思想: 1.准备两块空间From空间和To空间，每次在对象分配阶段，只能使用其中一块空间 (From空间)   2.在垃圾回收GC阶段，将From中存活对象复制到To空间。  3.将两块空间的From和To名字互换</li>
<li>优点：吞吐量高、不会发生碎片化</li>
<li>缺点：内存使用效率低，每次只能让一半的内存空间来为创建对象使用</li>
</ul>
</li>
<li>标记整理算法：也叫标记压缩算法，是对标记清理算法中容易产生内存碎片问题的一种解决方案.<ul>
<li>核心思想：1.标记阶段，将所有存活的对象进行标记。Java中使用可达性分析算法，从GC Root开始通过引用链遍历出所有存活对象  2.整理阶段，将存活对象移动到堆的一端。清理掉存活对象的内存空间</li>
<li>优点：内存使用效率高，不会发生碎片化</li>
<li>缺点：整理阶段的效率不高</li>
</ul>
</li>
</ul>
<h3 id="分代垃圾回收算法"><a href="#分代垃圾回收算法" class="headerlink" title="分代垃圾回收算法"></a>分代垃圾回收算法</h3><ul>
<li><strong>分代垃圾回收算法</strong>(GenerationalGC)：将上述描述的垃圾回收算法组合进行使用，<ul>
<li>它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法</li>
<li>一般将堆分为新生代和老年代。新生代使用: 复制算法；老年代使用: 标记清除 或者 标记整理 算法</li>
<li>将新生代划分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。</li>
<li>HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间不够用，此时需要依赖于老年代进行分配担保，即借用老年代的空间存储放不下的对象。</li>
<li>系统中的大部分对象，都是创建出来之后很快就不再使用可以被回收，比如用户获取订单数据，订单数据返回给用户之后就可以释放了。 老年代中会存放长期存活的对象，比如Spring的大部分bean对象，在程序启动之后就不会被回收了。<br>  在虚拟机的默认设置中，新生代大小要远小于老年代的大小。  <img src="https://github.com/leo710aka/bk/blob/main/jvm13.png?raw=true" width="550" height="300" alt=""></li>
<li>分代GC算法将堆分成年轻代和老年代主要原因有：<br>  1、可以通过调整年轻代和老年代的比例来适应不同型的应用程序，提高内存的利用率和性能。  2、新生代和老年代使用不同的垃圾回收算法，新生一般选择复制算法，老年代可以选择标记-清除和标记-整理算法，由程序员来选择灵活度较高。 3、分代的设计中允许只回收新生代 (minor gc)，如果能满足对象分配的要求就不需要对整个堆进行回收(fullgc),STW时间就会减少</li>
</ul>
</li>
<li><strong>内存分配策略</strong><ol>
<li>分代回收时，创建出来的对象，首先会被放入Eden伊甸园区。随着对象在Eden区越来越多，如果Eden区满，新创建的对象已经无法放入，就会触发年轻代的GC，称为Minor GC或者Young GC<br>  大对象直接进入老年代：大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。<br>  -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免 Eden 和 Survivor 区之间的大量内存复制。</li>
<li>Minor GC 会把需要 eden中和 From需要回收的对象回收，把没有回收的对象放入To区。接下来，S0会变成To区，S1变成From区。当eden区满时再往里放入对象，依然会发生Minor GC此时会回收eden区和S1(from)中的对象，并把eden和from区中剩余的对象放入SO。 ！！如果to区满了，会将没有回收的对象放入老年代。<br>  注意:每次Minor GC中都会为对象记录他的年龄，初始值为0，每次GC完加1。</li>
<li>长期存活的对象进入老年代：为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。-XX:MaxTenuringThreshold 用来定义年龄阈值。<br>  动态对象年龄判定：虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，，，</li>
<li>当老年代中空间不足，无法放入新的对象时，先尝试minor gc（因为存在直接从 eden区放如老年代的情况）。如果还是不足，就会触发Full GC，Full GC会对整个堆进行垃圾回收。如果Full GC依然无法回收掉老年代的对象，那么当对象继续放入老年代时，就会抛出OutofMemory异常。</li>
<li>空间分配担保：在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。<br>  如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC。</li>
</ol>
</li>
<li>Full GC 的触发条件<br>对于 Minor GC，其触发条件非常简单：当 Eden 空间满时就将触发一次。而 Full GC 则相对复杂，有以下条件：<br>1.调用 System.gc()  2. 老年代空间不足  3. 空间分配担保失败  4. JDK 1.7及以前的永久代空间不足在   5. Concurrent Mode Failure</li>
<li><strong>内存回收策略</strong><br>  Minor GC、Major GC、Full GC<br>  JVM 在进行 GC 时，并非每次都对堆内存(新生代、老年代，方法区)区域一起回收的，大部分时候回收的都是指新生代。针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大类: 部分收集 (Partial GC)，整收集(Full GC)。<ul>
<li>部分收集: 不是完整收集整个 Java 堆的垃圾收集。其中又分为:<ol>
<li>新生代收集 (Minor GC&#x2F;Young GC) : 只是新生代的垃圾收集。 </li>
<li>老年代收集 (Major GC&#x2F;Old GC) : 只是老年代的垃圾收集<br>  目前，只有 CMS GC 会有单独收集老年代的行为。很多时候 Major GC 会和 Full GC 混合使用，需要具体分辨是老年代回收还是整堆回收</li>
<li>混合收集 (Mixed GC) : 收集整个新生代以及部分老年代的垃圾收集；目前只有 G1 GC 会有这种行为</li>
</ol>
</li>
<li>整堆收集 (Full GC) : 收集整个 Java 堆和方法区的垃圾</li>
</ul>
</li>
</ul>
<h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p>垃圾回收器是垃圾回收算法的具体实现<br>由于垃圾回收器分为年轻代和老年代，除了G1之外其他垃圾回收器必须成对组合进行使用。<br><img src="https://github.com/leo710aka/bk/blob/main/jvm15.png?raw=true" width="700" height="300" alt=""></p>
<ul>
<li><strong>Serial + Serial Old 收集器</strong><table>
<thead>
<tr>
<th></th>
<th>Serial</th>
<th>Serial Old</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>单线程串行回收年轻代的垃圾回收器</td>
<td>Serial垃圾回收器老年代版本，采用单线程串行回收</td>
</tr>
<tr>
<td></td>
<td>年轻代，复制算法</td>
<td>老年代，标记-整理算法</td>
</tr>
<tr>
<td>优点</td>
<td>单CPU处理器下吞吐量非常出色</td>
<td></td>
</tr>
<tr>
<td>缺点</td>
<td>多CPU下吞吐量不如其他垃圾回收器，堆如果偏大会让用户线程处于长时间的等待</td>
<td></td>
</tr>
<tr>
<td>适用场景</td>
<td>Java编写的客户端程序或者硬件配置有限的场景</td>
<td>与Serial垃圾回收器搭配使用或者在CMS特殊情况下使用</td>
</tr>
</tbody></table>
</li>
<li><strong>ParNew + CMS 收集器</strong><table>
<thead>
<tr>
<th></th>
<th>ParNew</th>
<th>CMS</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>本质上是对Serial在多CPU下的优化，使用多线程进行垃圾回收</td>
<td>关注的是系统的暂停时间。允许用户线程和垃圾回收线程在某些步骤中同时执行，减少了用户线程的等待时间。</td>
</tr>
<tr>
<td>参数</td>
<td>-XX:+UseParNewGC 新生代使用ParNew，回收器老年代使用串行回收器</td>
<td>XX:+UseConcMarkSweepGC</td>
</tr>
<tr>
<td></td>
<td>年轻代，复制算法</td>
<td>老年代，标记-清除算法</td>
</tr>
<tr>
<td>优点</td>
<td>多CPU处理器下停顿时间较短</td>
<td>系统由于垃圾回收出现的停顿时间较短，用户体验好</td>
</tr>
<tr>
<td>缺点</td>
<td>吞吐量和停顿时间不如G1，所以在JDK9之后不建议使用</td>
<td>1、内存碎片问题 2、退化问题 3、浮动垃圾问题</td>
</tr>
<tr>
<td>适用场景</td>
<td>Java编写的客户端程序或者硬件配置有限的场景</td>
<td>大型的互联网系统中用户请求数据量大、频率高的场景，比如订单接口、商品接口等</td>
</tr>
</tbody></table>
</li>
<li><strong>ParNew + CMS 收集器</strong><table>
<thead>
<tr>
<th></th>
<th>Parallel Scavenge</th>
<th>Parallel Old</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>JDK8默认的年轻代垃圾回收器多线程并行回收，关注的是系统的吞吐量。具备自动调整堆内存大小的特点</td>
<td>是为Parallel Scavenge收集器设计的老年代版本，利用多线程并发收集。</td>
</tr>
<tr>
<td>参数</td>
<td></td>
<td>-XX:+UseParallelGC 或-XX:+UseParallelOldGC，可以使用Parallel Scavenge + Parallel Old这种组合</td>
</tr>
<tr>
<td></td>
<td>年轻代，复制算法</td>
<td>老年代，标记-整理算法</td>
</tr>
<tr>
<td>优点</td>
<td>吞吐量高，而目手动可控为了提高吞吐量，虚拟机会动态调整堆的参数</td>
<td>并发收集，在多核CPU下效率较高</td>
</tr>
<tr>
<td>缺点</td>
<td>不能保证单次的停顿时间</td>
<td>暂停时间会比较长</td>
</tr>
<tr>
<td>适用场景</td>
<td>后台任务，不需要与用户交互，并且容易产生大量的对象。比如:大数据的处理，大文件导出</td>
<td>与Parallel Scavenge配套使用</td>
</tr>
</tbody></table>
</li>
<li>垃圾回收器的组合关系虽然很多，但是针对几个特定的版本，比较好的组合选择如下:<br>JDK8及之前：ParNew + CMS (关注暂停时间)、Parallel Scavenge + Parallel Old (关注吞吐量)、不建议 G1(较大堆并且关注暂停时间)<br>JDK9之后：G1 (默认)</li>
</ul>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><ul>
<li>它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。使命是未来可以替换掉 CMS 收集器。<br>G1 将 Parallel Scavenge与 CMS的优点融合：1.支持巨大的堆空间回收，并有较高的吞吐量。2.支持多CPU并行垃圾回收 3.允许用户设置最大暂停时间。</li>
<li>G1 把堆划分成多个大小相等的独立区域(Region)，新生代和老年代不再物理隔离，可以直接对新生代和老年代一起回收。</li>
<li>G1垃圾回收有两种方式：1、年轻代回收 (Young GC)  2、混合回收(Mixed GC)<ul>
<li>年轻代回收：回收Eden区和Survivor区中不用的对象。会导致STW，G1中可以通过参数设置每次垃圾回收时的最大暂停时间毫秒数，G1垃圾回收器会尽可能地XX:MaxGCPauseMillis&#x3D;n (默认200) 保证暂停时间。</li>
<li>混合回收分为：初始标记 (initial mark) 、并发标记 (concurrent mark)、最终标记(remark或者FinalizeMarking)、并发清理 (cleanup) ；G1对老年代的清理会选择存活度最低的区域来进行回收，这样可以保证回收效率最高，这也是G1(Garbagefirst)名称的由来。</li>
<li>注意:如果清理过程中发现没有足够的空Region存放转移的对象，会出现Full GC。单线程执行标记-整理算法此时会导致用户线程的暂停。所以尽量保证应该用的堆内存有一定多余的空间。</li>
</ul>
</li>
<li><strong>G1 执行流程</strong><br>1、新创建的对象会存放在Eden区。当G1判新年轻代区不足(max默认60%)，无法分配对象时需要回收时会执行Young GC<br>2、标记出Eden和Survivor区域中的存活对象<br>3、根据配置的最大暂停时间选择某些区域将存活对象复制到一个新的Survivor区中(年龄+1)，清空这些区域<br>4、后续Young GC时与之前相同，只不过Survivor区中存活对象会被搬运到另一个Survivor区<br>5、当某个存活对象的年龄到达值 (默认15)，将被放入老年代<br>6、部分对象如果大小超过Region的一半，会直接放入老年代，这类老年代被称为Humongous区。比如堆内存是4G，每个Region是2M，只要一个大对象超过了1M就被放入Humonous区，如果对象过大会横跨多个Region。<br>7、多次回收之后，会出现很多Old老年代区，此时总堆占有率达到闻值时(-XX:InitiatingHeap0ccupancyPercent默认45%)<br>会触发混合回收MixedGC。回收所有年轻代和部分老年代的对象以及大对象区。采用复制算法来完成？？？不会产生内存碎片</li>
</ul>
<hr>

<h1 id="JVM-排错调优"><a href="#JVM-排错调优" class="headerlink" title="JVM 排错调优"></a>JVM 排错调优</h1><p>？？</p>
<hr>

<h1 id="JVM-知识体系"><a href="#JVM-知识体系" class="headerlink" title="JVM 知识体系"></a>JVM 知识体系</h1><p><img src="https://pdai.tech/images/jvm/jvm-overview.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/04/JVM/" data-id="clue5uccf0005ogv55nu76s4o" data-title="JVM" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/09/05/Java%E5%B9%B6%E5%8F%91/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Java 并发
        
      </div>
    </a>
  
  
    <a href="/2021/09/03/Java%E5%AE%B9%E5%99%A8/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Java 容器</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2046/12/">December 2046</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2046/12/30/nice-photo/">Nice Photo</a>
          </li>
        
          <li>
            <a href="/2024/01/11/RabbitMQ/">RabbitMQ</a>
          </li>
        
          <li>
            <a href="/2024/01/07/SpringCloud/">SpringCloud</a>
          </li>
        
          <li>
            <a href="/2024/01/04/%E9%AA%8F%E4%BC%AF/">骏 伯</a>
          </li>
        
          <li>
            <a href="/2023/10/20/%E6%8A%80%E8%83%BD/">寄 能</a>
          </li>
        
          <li>
            <a href="/2023/10/13/%E9%9D%A2%E8%AF%95_%E4%B8%AA%E4%BA%BA/">面 逝 | 个人</a>
          </li>
        
          <li>
            <a href="/2023/10/12/%E9%9D%A2%E8%AF%95_Java/">面 逝 | Java</a>
          </li>
        
          <li>
            <a href="/2023/10/11/%E9%9D%A2%E8%AF%95_%E7%BB%84%E4%BB%B6/">面 逝 | 组件</a>
          </li>
        
          <li>
            <a href="/2023/07/31/Colab/">Colab</a>
          </li>
        
          <li>
            <a href="/2023/07/14/Pytorch/">Pytorch</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 fengcai<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>