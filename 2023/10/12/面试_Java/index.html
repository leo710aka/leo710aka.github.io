<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>面 逝 | Java | Qué miras Bobo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="围绕简历准备：https:&#x2F;&#x2F;www.wondercv.com&#x2F;cvs&#x2F;5hCOzINo&#x2F;editor,个人技能：https:&#x2F;&#x2F;leo710aka.github.io&#x2F;2023&#x2F;10&#x2F;10&#x2F;%E6%8A%80%E8%83%BD&#x2F; 八股（Java） 什么是B&#x2F;S架构，C&#x2F;S架构？Java都有那些开发平台？  B&#x2F;S(Browser&#x2F;Server)，浏览器&amp;#">
<meta property="og:type" content="article">
<meta property="og:title" content="面 逝 | Java">
<meta property="og:url" content="http://example.com/2023/10/12/%E9%9D%A2%E8%AF%95_Java/index.html">
<meta property="og:site_name" content="Qué miras Bobo">
<meta property="og:description" content="围绕简历准备：https:&#x2F;&#x2F;www.wondercv.com&#x2F;cvs&#x2F;5hCOzINo&#x2F;editor,个人技能：https:&#x2F;&#x2F;leo710aka.github.io&#x2F;2023&#x2F;10&#x2F;10&#x2F;%E6%8A%80%E8%83%BD&#x2F; 八股（Java） 什么是B&#x2F;S架构，C&#x2F;S架构？Java都有那些开发平台？  B&#x2F;S(Browser&#x2F;Server)，浏览器&amp;#">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://pdai.tech/images/java_collections_overview.png">
<meta property="og:image" content="https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/640-20230912141802980.png">
<meta property="og:image" content="https://leo710aka.github.io/bk/job6.png">
<meta property="og:image" content="https://leo710aka.github.io/bk/job9.png">
<meta property="og:image" content="https://leo710aka.github.io/bk/job3.png">
<meta property="og:image" content="https://leo710aka.github.io/bk/job2.png">
<meta property="og:image" content="https://leo710aka.github.io/bk/job4.png">
<meta property="article:published_time" content="2023-10-12T03:11:00.000Z">
<meta property="article:modified_time" content="2024-02-08T12:45:11.254Z">
<meta property="article:author" content="fengcai">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pdai.tech/images/java_collections_overview.png">
  
    <link rel="alternate" href="/atom.xml" title="Qué miras Bobo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="https://github.com/leo710aka/bk/blob/main/DT1.jpg?raw=true">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Qué miras Bobo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-面试_Java" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/10/12/%E9%9D%A2%E8%AF%95_Java/" class="article-date">
  <time class="dt-published" datetime="2023-10-12T03:11:00.000Z" itemprop="datePublished">2023-10-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      面 逝 | Java
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>围绕简历准备：<a target="_blank" rel="noopener" href="https://www.wondercv.com/cvs/5hCOzINo/editor">https://www.wondercv.com/cvs/5hCOzINo/editor</a>,<br>个人技能：<a target="_blank" rel="noopener" href="https://leo710aka.github.io/2023/10/10/%E6%8A%80%E8%83%BD/">https://leo710aka.github.io/2023/10/10/%E6%8A%80%E8%83%BD/</a></p>
<h2 id="八股（Java）"><a href="#八股（Java）" class="headerlink" title="八股（Java）"></a>八股（Java）</h2><ul>
<li><p>什么是B&#x2F;S架构，C&#x2F;S架构？Java都有那些开发平台？</p>
<ol>
<li>B&#x2F;S(Browser&#x2F;Server)，浏览器&#x2F;服务器程序</li>
<li>C&#x2F;S(Client&#x2F;Server)，客户端&#x2F;服务端，桌面应用程序</li>
<li>JAVA SE：主要用在客户端开发</li>
<li>JAVA EE：主要用在web应用程序开发</li>
<li>JAVA ME：主要用在嵌入式应用程序开发</li>
</ol>
</li>
<li><p>JDK, JRE, JVM？<br><strong>JDK（Java Development Kit）：</strong>JDK是Java开发工具包，它是Java开发的完整工具集，包括了Java编译器（javac）、Java虚拟机（JVM）、Java类库等。主要用于Java应用程序的开发，提供了开发、编译、调试和运行Java程序所需的工具。<br><strong>JRE（Java Runtime Environment）：</strong>JRE是Java运行时环境，它是Java应用程序执行的环境，包含了Java虚拟机（JVM）和Java类库。用于在计算机上运行已经编译过的Java应用程序，但不包含用于Java开发的工具，如编译器。<br><strong>JVM（Java Virtual Machine）：</strong>JVM是Java虚拟机，是一个在物理计算机上模拟运行Java字节码（.class）的虚拟机。负责解释和执行Java字节码，通过不同操作系统上的 JVM 解释为该操作系统的机器指令，使得Java程序能够在不同的平台上实现一次编译，到处运行的跨平台特性。</p>
</li>
<li><p>Java语言有哪些特点？</p>
<ol>
<li>简单易学、有丰富的类库</li>
<li>面向对象 OOP（Java最重要的特性，让程序耦合度更低，内聚性更高）<br>  类是对象的抽象，对象是类的具体，类是对象的模板，对象是类的实例</li>
<li>与平台无关性（JVM是Java跨平台使用的根本）</li>
<li>可靠安全</li>
<li>支持多线程</li>
</ol>
</li>
<li><p>一个java类中包含那些内容？<br>属性、方法、内部类、构造方法、代码块。</p>
</li>
<li><p>数据结构？Java的数据结构有那些？Java中有几种数据类型？<br>数据结构：计算机保存，组织数据的方式<br>java中数据结构有：1.线性表 2.链表 3.栈 4.队列 5.图 6.树<br>数据类型有，整形：byte,short,int,long；浮点型：float,double；字符型：char；布尔型：boolean</p>
</li>
<li><p>如何解决浮点型数据运算出现的误差的问题？float f&#x3D;3.4;是否正确？<br>使用 <code>Bigdecimal类</code> 进行浮点型数据的运算。<br>？？？3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于 下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换 float f &#x3D;(float)3.4; 或者写成 float f &#x3D;3.4F</p>
</li>
<li><p>？？？short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1; 有错吗？<br>对于 short s1 &#x3D; 1; s1 &#x3D; s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int 型，需要强制转换类型才能赋值给 short 型。<br>而 short s1 &#x3D;1; s1 +&#x3D; 1;可正确编译，因为 s1+&#x3D; 1;相当于 s1 &#x3D; (short)(s1 + 1);其中有隐含的强制类型转换。</p>
</li>
<li><p>什么是隐式转换，什么是显式转换？Char类型能不能转成int类型，string类型，double类型？<br>显示转换就是类型强转，把一个大类型的数据强制赋值给小类型的数据；隐式转换就是大范围的变量能够接受小范围的数据；隐式转换和显式转换其实就是自动类型转换和强制类型转换。<br>Char &lt; int &lt; long &lt; float &lt; double；Char类型可以隐式转成int,double类型，但是不能隐式转换成string；如果char类型转成byte，short类型的时候，需要强转。</p>
</li>
<li><p>char 型变量中能不能存贮一个中文汉字？<br>可以，因为  Java 中使用的编码是 Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个 char 类型占 2 个字节（16 比特），所以放一个中文是没问题的。<br>补充：使用 Unicode 意味着字符在  JVM 内部和外部有不同的表现形式，在  JVM内部都是 Unicode，当这个字符被从  JVM 内部转移到外部时（例如存入文件系统中），需要进行编码转换。所以  Java 中有字节流和字符流，以及在字符流和字节流之间进行转换的转换流，如InputStreamReader 和 OutputStreamReader，这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务；对于 C 程序员来说，要完成这样的编码转换恐怕要依赖于 union（联合体&#x2F;共用体）共享内存的特征来实现了。</p>
</li>
<li><p>面向对象和面向过程的区别。</p>
<ol>
<li>面向过程：一种较早的编程思想，顾名思义就是该思想是站着过程的角度思考问题，强调的就是功能行为，功能的执行过程，即先后顺序，而每一个功能我们都使用函数（类似于方法）把这些步骤一步一步实现。使用的时候依次调用函数就可以了。</li>
<li>面向对象：一种基于面向过程的新编程思想，顾名思义就是该思想是站在对象的角度思考问题，我们把多个功能合理放到不同对象里，强调的是具备某些功能的对象。<br>  具备某种功能的实体，称为对象。面向对象最小的程序单元是类。面向对象更加符合常规的思维方式，稳定性好，可重用性强，易于开发大型软件产品，有良好的可维护性。<br>  在软件工程上，面向对象可以使工程更加模块化，实现更低的耦合和更高的内聚。</li>
<li>instanceof 关键字的作用<br>  instanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例，用法为：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> obj <span class="keyword">instanceof</span> Class</span><br></pre></td></tr></table></figure>
  其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。注意：编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定。</li>
</ol>
</li>
<li><p><strong>封装</strong>？什么是拆装箱？int 与 Integer<br>Java面向对象语言，一切操作以对象为基础。对象中封装了属性和操作，使用灵活，数据不被外部修改。封装类在处理集合、泛型、反射等场景中非常有用。<br>装箱就是自动将基本数据类型转换为包装器类型（int–&gt;Integer）；调用方法：Integer的valueOf(int) 方法拆箱就是自动将包装器类型转换为基本数据类型（Integer–&gt;int）。<br>Integer初始值为null，存储在堆内存；int初始值0，存储在栈空间。</p>
</li>
<li><p><strong>面向对象的特征有哪些方面?</strong><br>  抽象:抽象是将一类对象的共同特征总结出来构造类的过程, 包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为,并不关注这些行为的细节是什么。</p>
<ol>
<li>封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。<br>  面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口。</li>
<li>继承：继承是从已有类得到继承信息创建新类的过程.提供继承信息的类被称为父类(超类、基类);得到继承信息的类被称为子类(派生类)。继承让变化中的软件系统有了一定的延续性,同时继承也是封装程序中可变因素的重要手段。</li>
<li>？？？多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。<br>  如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当 A 系统访问 B 系统提供的服务时，B系统有多种提供服务的方式，但一切对 A 系统来说都是透明的（就像电动剃须刀是 A 系统，它的供电系统是 B 系统，B 系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A 系统只会通过 B 类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1、方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2、对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</li>
</ol>
</li>
<li><p>重载和重写的区别</p>
<ul>
<li>重写 Override：在子类中把父类本身有的方法重新写一遍。子类继承了父类原有的方法，但有时子类并不想原封不动的继承父类中的某个方法，所以在方法名，参数列表，返回类型(除过子类中方法的返回值是父类中方法返回值的子类时)都相同的情况下， 对方法体进行修改或重写，这就是重写。被重写方法比父类更好访问（即子类函数的访问修饰权限不能少于父类的），不能比父类被重写方法声明更多的异常（里氏代换原则）。<br>  1、发生在父类与子类之间<br>  2、<strong>方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同</strong><br>  3、<strong>访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private）</strong><br>  4、重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常</li>
<li>重载（Overload）在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同甚至是参数顺序不同）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但不能通过返回类型是否相同来判断重载。<br>  1、重载Overload是一个类中多态性的一种表现<br>  2、<strong>重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序)</strong><br>  3、<strong>重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准</strong></li>
<li>方法的重载和重写<strong>都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</strong><br>  ，，、、</li>
</ul>
</li>
<li><p>？？？访问修饰符 public,private,protected,以及不写（默认） 时的区别？<br>、、，，<br>类的成员不写访问修饰时默认为 default。默认对于同一个包中的其他类相当于 public，对于不是同一个包中的其他类相当于 private。<br>受保护 protected 对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。<br>Java 中，外部类的修饰符只能是 public 或默认，类的成员（包括内部类）的 修饰符可以是以上四种。</p>
</li>
<li><p>String 是最基本的数据类型吗？<br>不是。Java 中的基本数据类型只有 8 个；除了基本类型 剩下的都是引用类型，Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。<br>String 是不可变类。不可变类指的是无法修改对象的值，当你创建一个 String 对象之后，这个对象就无法被修改。像执行s +&#x3D; “a”; 返回的是一个新的 String 对象，老的 s 指向的对象不会发生变化，只是 s 的引用指向了新的对象而已。“不可变”最主要的好处就是安全，在多线程环境下也是线程安全的；然后，配合常量池可以节省内存空间，且获取效率也更高（如果常量池里面已经有这个字符串对象了，就不需要新建，直接返回即可）。</p>
</li>
<li><p>？？？String 常见题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &quot;字面量创建字符串&quot;：yesA 是一个引用指向了堆里面的字符串常量池里的对象 a。如果字符串常量池已经有了 a，那么直接返回其引用，如果没有 a，则会创建 a 对象，然后返回其引用。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">yesA</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>; <span class="type">String</span> <span class="variable">yesB</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;                </span><br><span class="line">System.out.printIn(yesA == yesB);  <span class="comment">// true</span></span><br><span class="line"><span class="comment">// &quot;new String创建字符串&quot;：先判断字符串常量池里面是否有 a，如果没有 a 则创建一个 a。然后会在堆内存里面创建一个对象 a，返回堆内存对象 a 的引用，也就是说返回的不是字符串常量池里面的 a</span></span><br><span class="line">yesA = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>); yesB = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>);           </span><br><span class="line">System.out.println(yesA == yesB);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">yesA</span> <span class="operator">=</span> <span class="string">&quot;aaabbb&quot;</span>;            <span class="comment">// 通过字面量定义了 yesA，在字符串常量池里创建 aaabbb 对象，返回其引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">yesB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;bbb&quot;</span>); <span class="comment">// 返回堆内的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">yesC</span> <span class="operator">=</span> yesB.intern();       <span class="comment">// intern()：判断下 yesB 引用指向的值在字符串常量里面是否有，如果没有就在字符串常量池里面新建一个 aaabbb 对象，返回其引用，如果有则直接返回引用。</span></span><br><span class="line">System.out.println(yesA == yesB);  <span class="comment">// false</span></span><br><span class="line">System.out.println(yesA == yesC);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>JDK 1.6 时，字符串常量池是放置在永久代的; JDK 1.7 之后字符串常量池是放在堆内的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">yesB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;bbb&quot;</span>);  <span class="comment">// 此时，堆内会新建一个 aaabbb 对象，字符串常量池里不会创建，因为并没有出现 aaabbb 这个字面量。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">yesC</span> <span class="operator">=</span> yesB.intern();       <span class="comment">// 1.7 之后，如果堆内已经存在某个字符串对象的话，再调用 intern 此时不会在字符串常量池内新建对象，而是直接保存这个引用然后返回。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">yesA</span> <span class="operator">=</span> <span class="string">&quot;aaabbb&quot;</span>;            <span class="comment">// yesA 得到的引用与 yesC 和 yesB 一致，都指向堆内的 aaabbb 对象。</span></span><br><span class="line">System.out.println(yesA == yesB);  <span class="comment">// true</span></span><br><span class="line">System.out.println(yesA == yesC);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>String 连接？</p>
<ol>
<li><strong>使用 <code>+</code> 运算符</strong>：字符串连接最简单的方法，但在大量连接操作时可能效率较低，因为它会生成多个临时的字符串对象。</li>
<li>**使用 <code>StringBuilder</code>**：可变的字符序列，适用于需要频繁进行字符串连接的场景。<code>append</code> 方法用于添加字符串内容，最后使用 <code>toString</code> 方法获取最终的字符串。适合单线程环境下使用。</li>
<li>**使用 <code>StringBuffer</code>**：与 <code>StringBuilder</code> 类似，也是可变的字符序列，但不同之处在于 <code>StringBuffer</code> 是线程安全的，适用于多线程环境。</li>
</ol>
</li>
<li><p>String，StringBuffer 和 StringBuilder 的区别是什么？<br>String是只读字符串，它并不是基本数据类型，而是一个对象。从底层源码来看是一个final类型的字符数组，所引用的字符串不能被改变，一经定义，无法再增删改。每次对String的操作都会生成新的String对象。<br>StringBuffer与StringBuilder都继承了AbstractStringBulder类，而AbtractStringBuilder又实现了CharSequence接口，两个类都是用来进行字符串操作的。在做字符串拼接修改删除替换时，效率比string更高。<br>StringBuffer是线程安全的，Stringbuilder是非线程安全的。所以Stringbuilder比stringbuffer效率更高，StringBuffer的方法大多都加了synchronized关键字</p>
</li>
<li><p>String类的常用方法有那些？<br>charAt：返回指定索引处的字符<br>indexOf()：返回指定字符的索引<br>replace()：字符串替换<br>trim()：去除字符串两端空白<br>split()：分割字符串，返回一个分割后的字符串数组<br>getBytes()：返回字符串的byte类型数组<br>length()：返回字符串长度<br>toLowerCase()：将字符串转成小写字母<br>toUpperCase()：将字符串转成大写字符<br>substring()：截取字符串<br>format()：格式化字符串<br>equals()：字符串比较</p>
</li>
<li><p>分割字符串常用的方法。</p>
<ol>
<li><strong><code>split(String regex)</code> 方法：</strong> 使用正则表达式来分割字符串。返回一个字符串数组，包含分割后的子字符串。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;apple,orange,banana&quot;</span>;</span><br><span class="line">String[] fruits = input.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"><span class="comment">// fruits 数组: &#123;&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><strong><code>split</code> 方法配合正则表达式的转义字符：</strong> 如果分隔符是正则表达式的元字符，需要进行转义。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;apple.orange.banana&quot;</span>;</span><br><span class="line">String[] fruits = input.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line"><span class="comment">// fruits 数组: &#123;&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><strong><code>substring</code> 和 <code>indexOf</code> 方法：</strong> 手动截取子字符串。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;apple,orange,banana&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">commaIndex</span> <span class="operator">=</span> input.indexOf(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">firstPart</span> <span class="operator">=</span> input.substring(<span class="number">0</span>, commaIndex);</span><br><span class="line"><span class="type">String</span> <span class="variable">secondPart</span> <span class="operator">=</span> input.substring(commaIndex + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// firstPart: &quot;apple&quot;, secondPart: &quot;orange,banana&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>使用 <code>Pattern</code> 和 <code>Matcher</code> 类：</strong> 进行更复杂的正则表达式匹配和分割。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;apple,orange;banana&quot;</span>;</span><br><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;[,;]&quot;</span>);</span><br><span class="line">String[] fruits = pattern.split(input);</span><br><span class="line"><span class="comment">// fruits 数组: &#123;&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>JDK9为什么要将 String 的底层实现由 char[] 改为 byte[]？<br>jdk中字符用utf-16编码（UTF-16是Unicode的一种实现方式，它使用16位的编码单元来表示一个字符），一个字符char要占用2个字节；但是对于由纯英文字符和ascii字符组成的字符串，只需要一个字节就可以表示所有ascii字符，使用 byte[] 可以节省一半空间。<br>只有在需要存储非ascii字符时，才会使用char[]</p>
</li>
<li><p>++i与i++的区别<br>i++：先赋值，后计算；++i：先计算，后赋值<br>？？？在JVM层面，这两个操作的实现是通过指令集中的不同指令来完成的。Java虚拟机中的字节码指令包含 iinc 指令用于递增局部变量的值。这两种递增操作在底层都是通过 iinc 指令实现的，但在具体的使用上有一些差异。</p>
</li>
<li><p>a&#x3D;a+b 与 a+&#x3D;b 有什么区别吗?<br>+&#x3D; 操作符会进行隐式自动类型转换,此处a+&#x3D;b隐式的将加操作的结果类型强制转换为持有结果的类型, 而a&#x3D;a+b则不会自动进行类型转换.如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">127</span>, b = <span class="number">127</span>;</span><br><span class="line">b = a + b; <span class="comment">// 报编译错误:cannot convert from int to byte</span></span><br><span class="line">b += a;</span><br><span class="line"><span class="type">short</span> s1= <span class="number">1</span>;</span><br><span class="line">s1 = s1 + <span class="number">1</span>; <span class="comment">// 编译器会报错.short类型在进行运算时会自动提升为int类型,也就是说 s1+1 的运算结果是int类型,而s1是short类型,.</span></span><br><span class="line">s1 += <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>&amp;和&amp;&amp;的区别<br>&amp;是位运算符。&amp;&amp;是布尔逻辑运算符<br>在进行逻辑判断时用&amp;处理的前面为false后面的内容仍需处理，用&amp;&amp;处理的前面为false不再处理后面的内容。</p>
</li>
<li><p>Java 常用的类，包，接口。<br>类：BufferedReader BufferedWriter FileReader FileWirter String Integer<br>常用的包：java.lang java.awt java.io java.util java.sql Java.net Java.math<br>常用的接口：Remote List Map Document NodeList</p>
</li>
<li><p>Object类常用方法有那些？<br>Equals<br>Hashcode<br>toString<br>wait<br>notify<br>clone<br>getClass</p>
</li>
<li><p>equals与&#x3D;&#x3D;的区别</p>
<ul>
<li>&#x3D;&#x3D;：比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。<br>  1、比较的是操作符两端的操作数是否是同一个对象。<br>  2、两边的操作数必须是同一类型的（可以是父子类之间）才能编译通过。<br>  3、比较基本数据类型的 <code>==</code> 操作符直接比较它们的值，值相等则为true。如：int a&#x3D;10 与 long b&#x3D;10L 与 double c&#x3D;10.0都是相同的（为true），因为他们都指向地址为10的堆。而对于 Integer a &#x3D;10 与 Long b &#x3D; 10L， 使用 <code>==</code> 比较的是对象的引用而不是值，结果为 false。</li>
<li>equals：用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是&#x3D;&#x3D;的判断。</li>
</ul>
</li>
<li><p><code>equals()</code> 和 <code>hashCode()</code> 方法。为什么重写 <code>equals()</code> 时通常也需要重写 <code>hashCode()</code>？</p>
<ol>
<li><strong><code>equals()</code> 方法</strong>：用于比较两个对象是否在逻辑上相等。默认实现是比较对象的内存地址（相当于 &#x3D;&#x3D;），即两个对象是否是同一个对象。在实际应用中，一般需要根据对象的业务含义重写该方法，比较对象的实际内容。</li>
<li><strong><code>hashCode()</code> 方法：</strong>用于获取对象的哈希码，返回一个整数。哈希码是一种用于快速查找的技术，通常在集合（如 HashMap、HashSet）中用到。它可以帮助确定对象在哈希表中的存储位置，提高查找的效率。默认实现是c++编写的native方法，基于对象的内存地址生成哈希码。在实际应用中，一般需要在类中重写该方法，以便相等的对象具有相同的哈希码。<br>  但是，不是同一个对象，使用hashCode()返回的int值（取值范围2^32）也可能相等，即发生了hash冲突。</li>
<li><strong>关系：</strong>在使用哈希表的集合中，<code>hashCode()</code> 和 <code>equals()</code> 之间存在一定的关系。如果两个对象通过 <code>equals()</code> 方法比较相等，它们的 <code>hashCode()</code> 应该返回相同的值。这是为了保持一致性，使得相等的对象在哈希表中能够正确地识别和处理。确保相等的对象具有相同的哈希码，从而使得在集合中正确地处理相等性。<br>  如果两个对象通过 <code>equals()</code> 方法比较相等，但它们的 <code>hashCode()</code> 不相等，那么当放入哈希表等集合中时，它们将被视为不同的对象。这可能导致哈希表中存在相等的对象，破坏了集合的一致性。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// Constructors, getters, setters...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == obj) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span> || getClass() != obj.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">myClass</span> <span class="operator">=</span> (MyClass) obj;</span><br><span class="line">        <span class="keyword">return</span> id == myClass.id &amp;&amp; Objects.equals(name, myClass.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(id, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>有没有可能两个不相等的对象有相同的hashcode？<br>  有可能，即产生hash冲突。当hash冲突产生时,一般有以下几种方式来处理:</p>
<ol>
<li>拉链法:每个哈希表节点都有一个next指针,多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表进行存储.</li>
<li>开放定址法:一旦发生了冲突,就去寻找下一个空的散列地址,只要散列表足够大,空的散列地址总能找到,并将记录存入</li>
<li>再哈希:又叫双哈希法,有多个不同的Hash函数.当发生冲突时,使用第二个,第三个….等哈希函数计算地址,直到无冲突.</li>
</ol>
</li>
<li><p>java中有没有指针？java中是值传递引用传递？<br>有指针，但是隐藏了，开发人员无法直接操作指针，由jvm来操作指针<br>java都是引用传递，对于基本数据类型，传递是值的副本，而不是值本身。对于对象类型，传递是对象的引用，当在一个方法操作操作参数的时候，其实操作的是引用所指向的对象。</p>
</li>
<li><p>构造方法。<br>  构造方法是Java类中的一种特殊方法，用于在创建对象时进行初始化操作。构造方法的名称必须与类名相同，并且没有返回类型，包括 void。构造方法通常用于设置对象的初始状态，为对象的属性赋初值或执行其他初始化任务。</p>
<ul>
<li>一个类可以拥有多个构造方法，只要它们的参数列表不同。这称为构造方法的重载。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="comment">// 无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">()</span> &#123;            <span class="built_in">this</span>.value = <span class="number">0</span>;        &#125;</span><br><span class="line">    <span class="comment">// 有参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(<span class="type">int</span> value)</span> &#123;            <span class="built_in">this</span>.value = value;        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>构造方法能不能显式调用？<br>  不能，构造方法当成普通方法调用，只有在创建对象的时候它才会被系统调用</li>
<li>构造方法能不能重写，重载？<br>  可以重载，但不能重写。</li>
</ul>
</li>
<li><p>Java中有各种不同的类和代码块类型，让我们逐个解释它们：</p>
<ol>
<li><strong>普通类：</strong>是最基本的类类型，用于创建对象。它可以包含字段、方法、构造方法等。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// Fields, methods, constructors, etc.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>普通代码块：</strong>是包含在类中的一组语句块，没有使用任何关键字。它在对象创建时执行，可以用于初始化对象。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 普通代码块</span></span><br><span class="line">        <span class="comment">// 在对象创建时执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>内部类：</strong> 内部类是定义在另一个类内部的类。它有访问外部类成员的权限，并且可以用于实现一些封装和逻辑组织。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">        <span class="comment">// 内部类</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>外部类：</strong> 外部类是普通的顶级类，不嵌套在其他类中。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="comment">// 外部类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>静态代码块：</strong> 使用 <code>static</code> 关键字，包含在类中，用于在类加载时执行初始化操作。它仅执行一次。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 静态代码块</span></span><br><span class="line">        <span class="comment">// 在类加载时执行一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>静态内部类：</strong>是定义在另一个类内部的类，使用 <code>static</code> 修饰。与非静态内部类不同，它不依赖于外部类的实例。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClass</span> &#123;</span><br><span class="line">        <span class="comment">// 静态内部类</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>静态 static</p>
<ol>
<li>静态变量（Static Variables）：被声明为 <code>static</code> 的成员变量，属于类而不是类的实例。它被所有类的实例共享，只有一个副本存在于内存中。</li>
<li>静态方法（Static Methods）：被声明为 <code>static</code> 的方法，它不需要实例化类就可以直接通过类名调用。静态方法不能访问非静态成员，也无法使用 <code>this</code> 关键字。<br>  静态方法凭什么不能访问成员方法：因为成员方法属于对象实例，静态方法属于类本身，静态方法第一次加载(方法区)的时候还没有对象(堆)，也就无法调用成员方法</li>
<li>静态代码块（Static Blocks）：是包含在类中的静态块，它在类加载时执行，并且只执行一次。通常用于初始化静态变量或执行一些静态的初始化操作。</li>
<li>静态内部类（Static Inner Classes）：在类中使用 <code>static</code> 关键字修饰的内部类。静态内部类与外部类实例无关，可以直接通过外部类名访问。<br>  在使用静态成员时需要注意，它们的生命周期与类的生命周期相同，当类加载时会被初始化。静态成员属于类而不是对象，在合适的场景下能提供便利和效率。然而，过度使用静态成员可能会导致耦合度高和难以测试等问题，因此需要根据实际情况慎重使用。</li>
</ol>
</li>
<li><p>内部类与静态内部类的区别？</p>
<ul>
<li>静态内部类相对与外部类是独立存在的，在静态内部类中无法直接访问外部类中变量、方法。如果要访问的话，必须要new一个外部类的对象，使用new出来的对象来访问。但是可以直接访问静态的变量、调用静态的方法；</li>
<li>普通内部类作为外部类一个成员而存在，在普通内部类中可以直接访问外部类属性，调用外部类的方法。</li>
<li>如果外部类要访问内部类的属性或者调用内部类的方法，必须要创建一个内部类的对象，使用该对象访问属性或者调用方法。</li>
<li>如果其他的类要访问普通内部类的属性或者调用普通内部类的方法，必须要在外部类中创建一个普通内部类的对象作为一个属性，外同类可以通过该属性调用普通内部类的方法或者访问普通内部类的属性。</li>
<li>如果其他的类要访问静态内部类的属性或者调用静态内部类的方法，直接创建一个静态内部类对象即可。</li>
</ul>
</li>
<li><p>静态变量、静态代码块、普通代码块和构造方法的执行顺序？<br>  执行顺序可以总结为：静态变量（按定义顺序初始化） -&gt; 静态代码块（按定义顺序执行） -&gt; 普通代码块（对象实例化时按照定义顺序执行） -&gt; 构造方法。</p>
<ol>
<li>静态变量（静态成员变量）：在类加载时按照定义的顺序依次执行初始化，不论该变量在类中定义的位置如何，只会初始化一次。</li>
<li>静态代码块（Static Blocks）：静态代码块在类加载时执行，优先于普通代码块和构造方法。静态代码块只会执行一次。</li>
<li>普通代码块（普通初始化块）：普通代码块在对象实例化时执行，在构造方法之前执行。每次创建对象都会执行一次。</li>
<li>构造方法（Constructor）：构造方法在对象创建时执行，用于初始化对象。在普通代码块执行完毕后执行。</li>
</ol>
</li>
<li><p>子类继承父类，且都包含静态方法、构造方法，那么静态变量、静态代码块、普通代码块和构造方法的执行顺序？<br>顺序：父类静态方法 -&gt; 父类静态代码块 -&gt; 子类静态方法 -&gt; 子类静态代码块 -&gt; 父类普通代码块 -&gt; 父类构造方法 -&gt; 子类普通代码块 -&gt; 子类构造方法</p>
</li>
<li><p>final在java中的作用，有哪些用法?</p>
<ol>
<li>被final修饰的类不可以被继承</li>
<li>被final修饰的方法不可以被重写</li>
<li>被final修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变.</li>
<li>被final修饰的方法,JVM会尝试将其内联,以提高运行效率</li>
<li>被final修饰的常量,在编译阶段会存入常量池中.<br>  除此之外,编译器对final域要遵守的两个重排序规则更好:在构造函数内对一个final域的写入,与随后把这个被构造对象的引用赋值给一个引用变量,这两个操作之间不能重排序初次读一个包含fifinal域的对象的引用,与随后初次读这个fifinal域,这两个操作之间不能重排序</li>
</ol>
</li>
<li><p>Java中的继承是单继承还是多继承？ Super 与 this 表示什么？<br>Java中既有单继承，又有多继承。对于java类来说只能有一个父类，对于接口来说可以同时继承多个接口<br>Super表示当前类的父类对象，This表示当前类的对象</p>
</li>
<li><p>抽象类（Abstract Class）：</p>
<ol>
<li><strong>特点</strong>：抽象类是一种不能被实例化的类，通常用于定义其他类的结构和行为。它可以包含抽象方法（只有方法签名，没有具体实现），以及普通的方法和字段。一个类只能继承一个抽象类。可以包含构造函数，可以有访问修饰符（public、private、protected）的方法。子类必须实现抽象类中的所有抽象方法，除非子类也是抽象类。</li>
<li><strong>使用场景</strong>：当需要创建一个类，并在其中定义一些方法的行为，但不希望该类被实例化时，可以使用抽象类。抽象类也适合用于在类层次结构中作为其他类的基类，提供通用方法和字段，而具体实现交给其子类。</li>
</ol>
</li>
<li><p>普通类与抽象类有什么区别？<br>普通类不能包含抽象方法，抽象类可以包含抽象方法；<br>抽象类不能直接实例化，普通类可以直接实例化</p>
</li>
<li><p>抽象的方法是否可同时是静态的,是否可同时是本地方法（native），是否可同时被 synchronized修饰？<br>都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如 C 代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized 和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。</p>
</li>
<li><p>是否可以从一个静态方法内部发出对非静态方法的调用？<br>不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，在调用静态方法时可能对象并没有被初始化。</p>
</li>
<li><p>接口（Interface）：</p>
<ol>
<li><strong>特点</strong>：接口是一种完全抽象的类别，其中只包含方法的签名，但没有方法的实际实现。类可以实现多个接口，但接口不能包含字段或非抽象方法（在Java 8之后，引入了默认方法和静态方法）。接口就是某个事物对外提供的一些功能的声明，是一种特殊的java类，接口弥补了java单继承的缺点。</li>
<li><strong>使用场景</strong>：当不同类需要共享某些行为，但它们属于不同的类层次结构时，接口是一个很好的选择。接口允许类定义一组规范，以确保实现类必须提供接口中定义的所有方法。可以使用接口来实现多态性，允许不同的类实现相同的接口并具有不同的行为。</li>
<li>接口有什么特点？<br>  接口中声明全是public static final修饰的常量<br>  接口中所有方法都是抽象方法<br>  接口是没有构造方法的<br>  接口也不能直接实例化<br>  接口可以多继承</li>
</ol>
</li>
<li><p>接口与抽象类：<br>  接口和抽象类都是为了实现代码的重用和提供一致的编程接口而设计的。然而，接口更多地用于定义规范和合同，以确保实现类提供特定的行为，而抽象类更多地用于提供一些通用的方法和行为实现。</p>
<ul>
<li>抽象类和接口都用于实现多态性和提供一致的编程接口。它们通常用于大型项目中的类层次结构设计和代码组织。</li>
<li>在设计框架或库时，接口是一个有用的工具，因为它可以定义规范和标准，并允许用户通过实现接口来提供自定义行为。</li>
<li>抽象类用于将一些通用方法和字段提取到一个父类中，以便子类可以继承和共享这些功能。</li>
<li>抽象类和接口的区别?<ul>
<li>抽象类：1. 抽象方法，只有行为的概念，没有具体的行为实现。使用abstract关键字修饰，没有方法体。子类必须重写这些抽象方法。2. 包含抽象方法的类，一定是抽象类。3. 抽象类只能被继承，一个类只能继承一个抽象类。</li>
<li>接口：1. 全部的方法都是抽象方法，属性都是常量 2. 不能实例化，可以定义变量。3. 接口变量可以引用具体实现类的实例 4. 接口只能被实现，一个具体类实现接口，必须实现全部的抽象方法 5. 接口之间可以多实现 6. 一个具体类可以实现多个接口，实现多继承现象</li>
</ul>
</li>
<li>抽象类和接口有什么异同？<br>  抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是 private、默认、protected、public 的，而接口中的成员全都是 public 的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。</li>
</ul>
</li>
<li><p>接口是否可继承接口？抽象类是否可实现接口？抽象类是否可继承具体类？<br>接口可以继承接口 ，而且支持 多重继承 。 抽象类 可以 实现接口 ， 抽象类 可继承 具体类 也可以 继承抽象类 。</p>
</li>
<li><p>Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？<br>可以继承其他类或实现其他接口，在 Swing 编程和 Android 开发中常用此方式来实现事件监听和回调。 </p>
</li>
<li><p>内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？<br>一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。</p>
</li>
<li><p>？？？匿名类，匿名内部类。<br>  Java中的两个相关但不同的概念，它们通常用于创建临时的、一次性的类实例。</p>
<ul>
<li>匿名类：</li>
</ul>
<ol>
<li><strong>概念：</strong> 匿名类是指没有明确命名的类，通常用于创建一个实现某个接口或继承某个类的对象。</li>
<li><strong>语法：</strong> 匿名类的语法形式是通过 <code>new</code> 关键字创建一个对象的同时实现接口或继承类，并在花括号内定义类的实现。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SomeInterface</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SomeInterface</span>() &#123;</span><br><span class="line">    <span class="comment">// 匿名类的实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><strong>使用场景：</strong> 匿名类通常用于创建简单的、一次性的类实例，不需要为其定义专门的类名。</li>
</ol>
<ul>
<li>匿名内部类：</li>
</ul>
<ol>
<li><strong>概念：</strong> 匿名内部类是指定义在其他类内部、没有类名的类。通常使用它来实现接口或继承类，并在类的内部进行实现。</li>
<li><strong>语法：</strong> 匿名内部类的语法形式与匿名类相似，但它通常在其他类的方法内部定义，而不是在类的成员变量或其他地方。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SomeInterface</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SomeInterface</span>() &#123;</span><br><span class="line">            <span class="comment">// 匿名内部类的实现</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>使用场景：</strong> 匿名内部类通常用于在方法内部创建一个实现某个接口或继承某个类的临时对象，它有助于简化代码结构，避免为一次性的需求专门定义一个新的类。<br>  总体而言，匿名类和匿名内部类都是用于创建临时的、一次性的类实例，通常在需要实现某个接口或继承某个类的情况下使用。在Java中，Lambda 表达式的引入也提供了一种更简洁的方式来实现函数接口的匿名类。</li>
</ol>
</li>
<li><p>Java的四种引用，强弱软虚</p>
<ul>
<li>强引用：是平常中使用最多的引用，强引用在程序内存不足（OOM）的时候也不会被回收  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;str&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li>软引用：在程序内存不足时，会被回收，使用方式：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：wrf这个引用也是强引用，它是指向SoftReference这个对象的，</span></span><br><span class="line"><span class="comment">// 这里的软引用指的是指向new String(&quot;str&quot;)的引用，也就是SoftReference类中T</span></span><br><span class="line">SoftReference&lt;String&gt; wrf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;str&quot;</span>));</span><br></pre></td></tr></table></figure>
  可用场景： 创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收早先创建的对象。</li>
<li>弱引用：只要JVM垃圾回收器发现了它，就会将之回收，使用方式：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;String&gt;wrf=newWeakReference&lt;String&gt;(str);</span><br></pre></td></tr></table></figure>
  可用场景：Java源码中的j的java.util.WeakHashMap中的key就是使用弱引用，我的理解就是，一旦我不需要某个引用，JVM会自动帮我处理它，这样我就不需要做其它操作。</li>
<li>虚引用：虚引用的回收机制跟弱引用差不多，但是它被回收之前，会被放入ReferenceQueue中。注意哦，其它引用是被JVM回收后才被传入ReferenceQueue中的。由于这个机制，所以虚引用大多被用于引用销毁前的处理工作。还有就是，虚引用创建的时候，必须带有ReferenceQueue，使用例子：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PhantomReference&lt;String&gt; prf = newPhantomReference&lt;String&gt;(newString(<span class="string">&quot;str&quot;</span>),newReferenceQueue&lt;&gt;());</span><br></pre></td></tr></table></figure>
  可用场景：对象销毁前的一些操作，比如说资源释放等。Object.finalize() 虽然也可以做这类动作，但是这个方式即不安全又低效</li>
<li>？？？上诉所说的几类引用，都是指对象本身的引用，而不是指 Reference 的四个子类的引用</li>
</ul>
</li>
<li><p>Java创建对象有几种方式？<br>  java中提供了以下四种创建对象的方式:</p>
<ol>
<li>new创建新对象</li>
<li>通过反射机制</li>
<li>采用clone机制</li>
<li>通过序列化机制</li>
</ol>
</li>
<li><p>注解 Annotation<br>注解在我的理解下，就是代码中的特殊标记，这些标记可以在编译、类加载、运行时被读取，并执行相对应的处理。<br>注解在开发中是非常常见的，比如Spring框架的 @Controller &#x2F; @Param &#x2F; @Select 等等。一些项目也用到lombok的注解，@Slf4j &#x2F; @Data 等等。Java原生也有@Overried、@Deprecated、@FunctionalInterface等基本注解。Java原生的基本注解大多数用于「标记」和「检查」还，此外有一种叫做元Annotation（元注解），所谓的元Annotation就是用来修饰注解的。<br>那你自己写过注解吗？？<a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv22578322/?spm_id_from=333.999.0.0&jump_opus=1">https://www.bilibili.com/read/cv22578322/?spm_id_from=333.999.0.0&amp;jump_opus=1</a><br>@Passtoken？？<br>，，、、<br>，、</p>
</li>
<li><p>4种标准元注解是哪四种？<br>  元注解的作用是负责注解其他注解。Java5.0 定义了 4 个标准的 meta-annotation 类型，被用来提供对其它 annotation 类型作说明。</p>
<ul>
<li>@Target 修饰的对象范围<br>  @Target说明了Annotation所修饰的对象范围： Annotation可被用于 packages、types（类、接口、枚举、Annotation 类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch 参数）。在 Annotation 类型的声明中使用了 target可更加明晰其修饰的目标</li>
<li>@Retention 定义 被保留的时间长短<br>  Retention 定义了该 Annotation 被保留的时间长短：表示需要在什么级别保存注解信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效），取值（RetentionPoicy）<br>  由：1. SOURCE:在源文件中有效（即源文件保留）2. CLASS:在 class 文件中有效（即 class 保留）3. RUNTIME:在运行时有效（即运行时保留）4.</li>
<li>@Documented 描述-javadoc<br>  @Documented 用于描述其它类型的 annotation 应该被作为被标注的程序成员的公共 API，因此可以被例如  javadoc 此类的工具文档化。</li>
<li>@Inherited 阐述了某个被标注的类型是被继承的<br>  @Inherited 元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited 修饰的 annotation 类型被用于一个 class，则这个 annotation 将被用于该class 的子类。</li>
</ul>
</li>
<li><p>泛型。<br>在Java中的泛型简单来说就是：在创建对象或调用方法的时候才明确下具体的类型<br>使用泛型的好处就是代码更加简洁（无需强制转换），程序更加健壮（编译期间没有警告，在运行期就无ClassCastException）<br>使用场景：操作集合的时候，List<String> lists &#x3D; new ArrayList&lt;&gt;();<br>如果是其他场景的话，那就是在写「基础组件」的时候了：再明确一下泛型就是「在创建对象或调用方法的时候才明确下具体的类型」，而组件为了做到足够的通用性，是不知道「用户」传入什么类型参数进来的，所以在这种情况下用泛型就是很好的实践。 </p>
</li>
<li><p>泛型是会擦除的，那为什么反射能获取到泛型的信息呢？<br>泛型的信息只存在编译阶段，在class字节码就看不到泛型的信息了。那为什么下面这段代码能获取得到泛型的信息呢？<br>可以理解为泛型擦除是有范围的，定义在类上的泛型信息是不会被擦除的。<br>Java 编译器仍在 class 文件以 Signature 属性的方式保留了泛型信息。Type作为顶级接口，Type下还有几种类型，比如TypeVariable、ParameterizedType、WildCardType、GenericArrayType、以及Class。通过这些接口我们就可以在运行时获取泛型相关的信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类，定义泛型&lt;T&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseDao</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseDao</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass();</span><br><span class="line">        <span class="type">ParameterizedType</span>  <span class="variable">pt</span> <span class="operator">=</span> (ParameterizedType) clazz.getGenericSuperclass(); </span><br><span class="line">        clazz = (Class) pt.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">        System.out.println(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> <span class="keyword">extends</span> <span class="title class_">BaseDao</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        BaseDao&lt;User&gt; userDao = <span class="keyword">new</span> <span class="title class_">UserDao</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果输出</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">com</span>.entity.User</span><br></pre></td></tr></table></figure>
</li>
<li><p>泛型中extends和super的区别<br>1、&lt;?extends T&gt; 表示包括T在内的任何T的子类<br>2、&lt;?super T&gt; 表求包括T在内的任何T的父类</p>
</li>
<li><p>final、finalize()、finally</p>
<ul>
<li>性质不同：1. final为关键字；2. finalize()为方法；3. finally为区块标志，用于try语句中；</li>
<li>作用：<ol>
<li>final为用于标识常量的关键字，final标识的关键字存储在常量池中（在这里final常量的具体用法将在下面进行介绍）；</li>
<li>finalize()方法在Object中进行了定义，用于在对象“消失”时，由JVM进行调用用于对对象进行垃圾回收，类似于C++中的析构函数；用户自定义时，用于释放对象占用的资源（比如进行I&#x2F;0操作）；</li>
<li>finally{}用于标识代码块，与try{}进行配合，不论try中的代码执行完或没有执行完（这里指有异常），该代码块之中的程序必定会进行；</li>
</ol>
</li>
</ul>
</li>
<li><p>Java中的异常体系是怎样的？<br>  Java中的所有异常都来自顶级父类Throwable。Throwable下有两个子类Exception和Error。</p>
<ul>
<li>Error表示非常严重的错误，比如 java.lang.StackOverFlowError 和 Java.lang.OutofMemoryError，通常这些错误出现时，仅仅想靠程序自己是解决不了的，可能是虚拟机、磁盘、操作系统层面出现的问题了，所以通常也不建议在代码中去捕获这些Error，因为捕获的意义不大，因为程序可能已经根本运行不了了。</li>
<li>Exception表示异常，表示程序出现Exception时，是可以靠程序自己来解决的比如NullPointerException、legalAccessException等，我们可以捕获这些异常来做特殊处理。<br>  Exception这种异常又分为两类：运行时异常 和 编译异常。<ol>
<li>运行时异常(不受检异常)：RuntimeException类及其子类表示JVM在运行期间可能出现的错误。比如说试图使用空值对象的引用（NullPointerException）、数组下标越界（ArrayIndexOutBoundException）。此类异常属于不可查异常，一般是由程序逻辑错误引起的，在程序中可以选择捕获处理，也可以不处理。</li>
<li>编译异常(受检异常)：Exception中除RuntimeException极其子类之外的异常。如果程序中出现此类异常，比如说IOException、FileNotFoundException、SQLException，必须对该异常进行处理，否则编译不通过。在程序中，通常不会自定义该类异常，而是直接使用系统提供的异常类。</li>
</ol>
</li>
</ul>
</li>
<li><p>如何自定义一个异常<br>继承一个异常类，通常是RumtimeException或者Exception</p>
</li>
<li><p>异常的处理机制有几种？<br>异常捕捉：try…catch…finally，异常抛出：throws。</p>
</li>
<li><p>try catch finally，try里有return，finally还执行么？<br>执行，并且finally的执行早于try里面的return。结论：<br>1、不管有木有出现异常，finally块中代码都会执行；<br>2、当try和catch中有return时，finally仍然会执行；<br>3、finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的；<br>4、finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。</p>
</li>
<li><p>？？？Thow与thorws区别</p>
<ul>
<li>位置不同 <ol>
<li>throws 用在函数上，后面跟的是异常类，可以跟多个；而 throw 用在函数内，后面跟的是异常对象。</li>
</ol>
</li>
<li>功能不同：<ol start="2">
<li>throws 用来声明异常，让调用者只知道该功能可能出现的问题，可以给出预先的处理方式；throw 抛出具体的问题对象，执行到 throw，功能就已经结束了，跳转到调用者，并将具体的问题对象抛给调用者。也就是说 throw 语句独立存在时，下面不要定义其他语句，因为执行不到。</li>
<li>throws 表示出现异常的一种可能性，并不一定会发生这些异常；throw 则是抛出了异常，执行 throw 则一定抛出了某种异常对象。</li>
<li>两者都是消极处理异常的方式，只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。</li>
</ol>
</li>
</ul>
</li>
<li><p>在Java的异常处理机制中，什么时候应该抛出异常，什么时候捕获异常?<br>异常相当于一种提示，如果我们抛出异常，就相当于告诉上层方法，我抛了一个异常，我处理不了这个异常，交给你来处理，而对于上层方法来说，它也需要决定自己能不能处理这个异常，是否也需要交给它的上层。<br>所以我们在写一个方法时，我们需要考虑的就是，本方法能否合理的处理该异常，如果处理不了就继续向上抛出异常，包括本方法中在调用另外一个方法时，发现出现了异常，如果这个异常应该由自己来处理，那就捕获该异常并进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lowerLevelOperation</span><span class="params">()</span> <span class="keyword">throws</span> SpecificException &#123;</span><br><span class="line">        <span class="comment">// 一些可能抛出 SpecificException 的操作</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SpecificException</span>(<span class="string">&quot;Something went wrong at lower level&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">higherLevelOperation</span><span class="params">()</span> <span class="keyword">throws</span> HigherLevelException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用底层方法</span></span><br><span class="line">            lowerLevelOperation();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SpecificException e) &#123;</span><br><span class="line">            <span class="comment">// 捕获底层方法抛出的 SpecificException</span></span><br><span class="line">            <span class="comment">// 记录异常信息或进行其他处理</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Caught specific exception: &quot;</span> + e.getMessage());</span><br><span class="line">            <span class="comment">// 封装并递交异常给更高层</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">HigherLevelException</span>(<span class="string">&quot;Exception at higher level&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExampleService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExampleService</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用更高层的方法</span></span><br><span class="line">            service.higherLevelOperation();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (HigherLevelException e) &#123;</span><br><span class="line">            <span class="comment">// 捕获更高层方法抛出的 HigherLevelException</span></span><br><span class="line">            <span class="comment">// 记录异常信息或进行其他处理</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Caught higher level exception: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Java 反射</strong>？<br>简单来说，反射就是Java可以给我们在运行时获取类的信息<br>什么是「运行时」：在编译器写的代码是 .java 文件，经过javac 编译会变成 .class 文件，class 文件会被JVM装载运行（这里就是真正运行着我们所写的代码（虽然是被编译过的），也就所谓的运行时。<br>为什么要在「运行时」获取类的信息：其实就是为了让我们所写的代码更具有「通用性」和「灵活性」。一个好用的“工具”是需要兼容各种情况的，不知道用该“工具”的用户传入的是什么对象，但你需要帮他们得到需要的结果。例如 SpringMVC 你在方法上写上对象，传入的参数就会帮你封装到对象上；Mybatis可以让我们只写接口，不写实现类，就可以执行SQL；在类上加上@Component注解，Spring就帮你创建对象…<br>这些统统都有反射的身影：约定大于配置，配置大于硬编码。通过”约定”使用姿势，使用反射在运行时获取相应的信息（毕竟作为一个”工具“是真的不知道你是怎么用的），实现代码功能的「通用性」和「灵活性」 </p>
</li>
<li><p>除了使用new创建对象之外，还可以使用 Java 反射可以创建对象，谁的效率高？<br>通过new创建对象的效率比较高。通过反射时，先找查找类资源，使用类加载器创建，过程比较繁琐，所以效率较低。</p>
</li>
<li><p>用 new 关键字创建对象到底是编译时的还是运行时的方式？有什么区别？<br>使用 new 关键字创建对象是一种在编译时进行的方式。在编写代码时，通过 new 关键字可以直接在源代码中创建对象，在源代码被编译成字节码时就确定了对象的创建，然后在运行时，Java 虚拟机（JVM）会加载字节码文件，并根据 new 关键字创建对象。这时会分配内存、调用构造方法等，完成对象的初始化。<br>这种方式的主要特点是静态，因为对象的创建和初始化都是在编译时确定的。相比之下，使用反射等机制可以实现在运行时动态创建对象，但也更为灵活，因为它可以处理一些在编译时无法确定的类型和类。</p>
</li>
<li><p>java反射的作用<br>反射机制是在运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意个对象，都能够调用它的任意一个方法。在java中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。</p>
</li>
<li><p>哪里会用到反射机制？</p>
<ul>
<li>jdbc就是典型的反射，hibernate，struts等框架使用反射实现的。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&#x27;com.mysql.jdbc.Driver.class&#x27;</span>);<span class="comment">//加载MySQL的驱动类</span></span><br></pre></td></tr></table></figure></li>
<li>在 Spring 中使用反射机制，<br>  目的是为了实现框架的灵活性和可扩展性，使得开发人员能够通过配置和注解等方式，实现各种功能而无需修改源代码：</li>
</ul>
<ol>
<li>依赖注入：Spring 使用反射来实现依赖注入，即通过在配置文件或注解中声明依赖关系，Spring 在运行时动态地注入对象之间的依赖关系。通过反射，Spring 能够实例化和初始化对象，以及在运行时处理依赖注入。</li>
<li>Bean 的自动装配： Spring 的自动装配机制依赖于反射，它能够根据一定的规则自动将 Bean 与其他 Bean 进行关联。通过反射，Spring 可以动态地识别和连接相应的 Bean。</li>
<li>AOP（面向切面编程）： 在 Spring 中，AOP 是通过动态代理和反射来实现的。通过反射，Spring 能够在运行时动态地创建代理对象，并在方法执行前后执行额外的逻辑。</li>
<li>Bean 的生命周期管理： Spring 容器可以通过反射来实现对 Bean 的生命周期的管理，包括实例化、初始化、销毁等过程。</li>
<li>动态代理：Spring 使用动态代理和反射来实现一些特定的功能，比如事务管理。通过动态代理，Spring 能够在运行时创建代理对象，将横切逻辑织入到目标对象中。</li>
<li>处理注解：Spring 使用反射来处理注解，包括扫描类路径上的注解、解析注解的属性值等。通过反射，Spring 能够在运行时获取和处理注解信息。</li>
</ol>
</li>
<li><p>反射机制的优缺点</p>
<ul>
<li>优点：</li>
</ul>
<ol>
<li>能够运行时动态获取类的实例，提高灵活性；</li>
<li>与动态编译结合</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>使用反射性能较低，需要解析字节码，将内存中的对象进行解析。解决方案：1、通过setAccessible(true)关闭JDK的安全检查来提升反射速度；2、多次创建一个类的实例时，有缓存会快很多; 3、ReflflectASM工具类，通过字节码生成的方式加快反射速度</li>
<li>相对不安全，破坏了封装性（因为通过反射可以获得私有方法和属性）</li>
</ol>
</li>
<li><p>反射的实现方式：</p>
</li>
</ul>
<ol>
<li>获取想要操作的类的 Class 对象，他是反射的核心，通过 Class 对象我们可以任意调用类的方法。<br>有4种方法：1）Class.forName(“类的路径”)；2）类名.class3）对象名.getClass()4）基本类型的包装类，可以调用包装类的TyType属性来获得该包装类的Class对象</li>
<li>调用 Class 类中的方法，既就是反射的使用阶段。</li>
<li>使用反射 API 来操作这些信息。</li>
</ol>
<ul>
<li><p>获取 Class 对象有几种方法</p>
<ol>
<li>调用某个对象的 getClass()方法  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p=<span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">Class clazz=p.getClass();</span><br></pre></td></tr></table></figure></li>
<li>调用某个类的 class 属性来获取该类对应的 Class 对象  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clazz=Person.class;</span><br></pre></td></tr></table></figure></li>
<li>使用 Class 类中的 forName()静态方法(最安全&#x2F;性能最好)  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clazz=Class.forName(<span class="string">&quot;类的全路径&quot;</span>); </span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Java 反射 API<br>  反射 API 用来生成 JVM 中的类、接口或则对象的信息。</p>
<ol>
<li>Class 类：反射的核心类，可以获取类的属性，方法等信息。</li>
<li>Field 类：Java.lang.reflec 包中的类，表示类的成员变量，可以用来获取和设置类之中的属性值。</li>
<li>Method 类：  Java.lang.reflec 包中的类，表示类的方法，它可以用来获取类中的方法信息或者执行方法。</li>
<li>Constructor 类：  Java.lang.reflec 包中的类，表示类的构造方法。<br>  当我们获得了想要操作的类的 Class 对象后，可以通过 Class 类中的方法获取并查看该类中的方法和属性。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取 Person 类的 Class 对象</span></span><br><span class="line">Class clazz=Class.forName(<span class="string">&quot;reflection.Person&quot;</span>);</span><br><span class="line"><span class="comment">//获取 Person 类的所有方法信息</span></span><br><span class="line">Method[] method=clazz.getDeclaredMethods();</span><br><span class="line"><span class="keyword">for</span>(Method m:method)&#123;  System.out.println(m.toString());  &#125;</span><br><span class="line"><span class="comment">//获取 Person 类的所有成员属性信息</span></span><br><span class="line">Field[] field=clazz.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span>(Field f:field)&#123;    System.out.println(f.toString());  &#125;</span><br><span class="line"><span class="comment">//获取 Person 类的所有构造方法信息</span></span><br><span class="line">Constructor[] constructor=clazz.getDeclaredConstructors();</span><br><span class="line"><span class="keyword">for</span>(Constructor c:constructor)&#123;   System.out.println(c.toString()); &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>利用反射动态创建对象实例.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 使用 Class 对象的 newInstance()方法来创建该 Class 对象对应类的实例，但是这种方法要求该 Class 对象对应的类有默认的空构造器。</span></span><br><span class="line"><span class="comment">// 获取 Person 类的 Class 对象</span></span><br><span class="line">Class clazz=Class.forName(<span class="string">&quot;reflection.Person&quot;</span>);</span><br><span class="line"><span class="comment">// 使用.newInstane 方法创建对象</span></span><br><span class="line">Person p=(Person) clazz.newInstance();</span><br><span class="line"><span class="comment">// 2. 先使用 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 newInstance()方法来创建 Class 对象对应类的实例,通过这种方法可以选定构造方法创建实例。</span></span><br><span class="line"><span class="comment">// 获取构造方法并创建对象</span></span><br><span class="line">Constructor c=clazz.getDeclaredConstructor(String.class,String.class,<span class="type">int</span>.class);</span><br><span class="line"><span class="comment">// 创建对象并设置属性</span></span><br><span class="line">Person p1=(Person) c.newInstance(<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;男&quot;</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>你了解动态代理吗？<br>动态代理其实就是代理模式的一种，代理模式是设计模式之一。代理模型有静态代理和动态代理。静态代理需要自己写代理类，实现对应的接口，比较麻烦。在Java中，动态代理常见的又有两种实现方式：JDK动态代理和CGLIB代理。<br>JDK动态代理其实就是运用了反射的机制，而CGLIB代理则用的是利用ASM框架，通过修改其字节码生成子类来处理。JDK动态代理会帮我们实现接口的方法，通过invokeHandler对所需要的方法进行增强。<br>动态代理这一技术在实际或者框架原理中是非常常见的。像上面所讲的Mybatis不用写实现类，只写接口就可以执行SQL，又或是SpringAOP 等等好用的技术，实际上用的就是动态代理。</p>
</li>
<li><p>设计模式：<a target="_blank" rel="noopener" href="https://fengxiuyang.cn/articles/67">https://fengxiuyang.cn/articles/67</a></p>
</li>
<li><p>深拷贝和浅拷贝<br>深拷贝和浅拷贝就是指对象的拷贝，一个对象中存在两种类型的属性，一种是基本数据类型，一种是实例对象的引用。<br>1，浅拷贝是指，只会拷贝基本教据半型的值，以及实例对象的引用地址，并不会复制一份引用地处所指的对象。也就是浅拷贝出来的对象，内部的类属性指向的是同一个对象<br>2，深拷贝是指，既会拷贝基本数据类型的值，也会针对实例对象的引用地址所指向的对象进行复制，深拷贝出来的对象，内部的属性指向的不是同一个对象</p>
</li>
<li><p>什么时候用assert<br>assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。在实现中，assertion就是在程序中的一条语句，它对一个boolean表达式进行检查，一个正确程序必须保证这个boolean表达式的值为true；如果该值为false，说明程序已经处于不正确的状态下，系统将给出警告或退出。一般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时开启。为了提高性能，在软件发布后，assertion检查通常是关闭的</p>
</li>
<li><p>Java有没有goto<br>java中的保留字，现在没有在java中使用</p>
</li>
</ul>
<hr>


<h2 id="Java-集合"><a href="#Java-集合" class="headerlink" title="Java 集合"></a>Java 集合</h2><ul>
<li><p>java集合：<a target="_blank" rel="noopener" href="https://leo710aka.github.io/2021/09/03/Java%E9%9B%86%E5%90%88/">https://leo710aka.github.io/2021/09/03/Java集合/</a></p>
</li>
<li><p>集合有什么。<br>Java 集合 主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对(两个对象)的映射表。<br><img src="https://pdai.tech/images/java_collections_overview.png"></p>
</li>
<li><p>Collection包结构，与Collections的区别<br>Collection是集合类的上级接口，子接口有 Set、List、LinkedList、ArrayList、Vector、Stack、Set；<br>Collections是集合类的一个帮助类， 它包含有各种有关集合操作的静态多态方法，用于实现对各种集合的搜索、排序、线程安全化等操作。此类不能实例化，就像一个工具类，服务于Java的Collection框架。</p>
</li>
<li><p>说说List,Set,Map三者的区别<br>List(对付顺序的好帮手)： List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象<br>Set(注重独一无二的性质):不允许重复的集合。不会有多个元素引用相同的对象。<br>Map(用Key来搜索的专家): 使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。</p>
</li>
<li><p>Java 的 List？<br>List在Java里边是一个接口，常见的实现类有ArrayList和LinkedList，ArrayList底层数据结构是数组，LinkedList链表。</p>
</li>
<li><p><strong>ArrayList</strong><br>实现了动态扩容。当new ArrayList()时，默认会有一个大小为0空的Object数组。第一次add添加数据的时候，会给数组初始化一个默认值<strong>10</strong>的大小。使用ArrayList在每一次add的时候，会先去计算数组空间；如果空间是够的，直接追加上去；如果不够，那就得扩容。在源码里边，有个grow方法，每一次扩容原来的<strong>1.5倍</strong>，之后会调用arraycopy来对数组进行拷贝。<br>日常开发中用得最多的是ArrayList呢：是由底层的数据结构来决定的，在日常开发中，遍历的需求比增删要多，即便是增删也是往往在List的尾部添加就OK了。像在尾部添加元素，ArrayList的时间复杂度也就O(1)。<br>??另外的是，ArrayList的增删底层调用的copyOf()被优化过；现代CPU对内存可以块操作，ArrayList的增删一点儿也不会比LinkedList慢？？</p>
</li>
<li><p>Array与ArrayList有什么不一样？<br>Array与ArrayList都是用来存储数据的集合。ArrayList底层是使用数组实现的，但是arrayList对数组进行了封装和功能扩展，拥有许多原生数组没有的一些功能。我们可以理解成ArrayList是Array的一个升级版。</p>
</li>
<li><p>Vector 你了解吗？<br>Vector是底层结构是数组，一般现在已经很少用了。相对于ArrayList，它是线程安全的，在扩容的时候直接扩容两倍。</p>
</li>
<li><p>LinkedList<br>是基于链表实现的，对于增删操作来说，由于链表节点的指针调整相对比较简单，删除或添加一个节点的开销是 O(1) 的。但在进行遍历和随机访问时，由于链表的非连续存储，性能相对较差。<br>因此，在实际场景中，ArrayList 在随机访问和遍历方面的性能通常比 LinkedList 更好，而在频繁的增删操作时，LinkedList 可能更具优势.<br>LinkedList 还实现了 DeQueue，可以对头尾元素操作，所以 LinkedList 也可以当作队列使用。</p>
</li>
<li><p>线程安全的List还有什么？<br>首先，我们也可以用Collections来将ArrayList来包装一下，变成线程安全。<br>在java.util.concurrent包下还有一个类，叫做<strong>CopyOnWriteArrayList</strong>，是一个线程安全的List，底层是通过复制数组的方式来实现的。在add()方法会加lock锁，然后会复制出一个新的数组，往新的数组里边add真正的元素，最后把array的指向改变为新的数组，get()方法又或是size()方法只是获取array所指向的数组的元素或者大小。读不加锁，写加锁。CopyOnWriteArrayList跟文件系统的COW机制是很像的。</p>
</li>
<li><p>CopyOnWriteArrayList的底层原理是怎样的<br>1，首先CopyOnWriteArraylst内部也是用过数组来实现的，在向CpyOnWriteAraist添加元素时，会复制一个新的数组，写操作在新数组上进行，读操作在原数组上行<br>2，并且，写操作会加锁，防止出现并发写入丢失数据的问题<br>3，写操作结束之后会把原数组指向新数组<br>4，CopyOnWriteArraylist允许在写操作时来读取数据，大大提高了读的性能，因此适合读多写少的应用场，但会占内存，同时可能读到的数据不是实时最新的教据（写线程操作结束后才能读到新数据），所以不适合实时性要求很高的场景</p>
</li>
<li><p>set 集合<br>Set 注重独一无二的性质,该体系集合用于存储无序(存入和取出的顺序不一定相同)元素， 值不能重复。对象的相等性本质是对象 hashCode 值（java 是依据对象的内存地址计算出的此序号） 判断的， 如果想要让两个不同的对象视为相等的，就必须覆盖 Object 的 hashCode 方法和 equals 方法。</p>
</li>
<li><p>HashSet（ Hash 表）<br>哈希表边存放的是哈希值。 HashSet 存储元素的顺序并不是按照存入时的顺序（和 List 显然不同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。<br>元素的哈希值是通过元素的hashcode 方法来获取的, HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals 方法 如果 equls 结果为 true ， HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素。<br>哈希值相同 equals 为 false 的元素是怎么存储呢,就是在同样的哈希值下顺延（可以认为哈希值相同的元素放在一个哈希桶中）。也就是哈希一样的存一列。 </p>
</li>
<li><p><code>HashSet</code>、<code>HashMap</code> 和 <code>Hashtable</code> 的关系。<br>  关系总结：</p>
<ul>
<li><code>HashSet</code> 使用 <code>HashMap</code> 作为底层实现，用于存储不重复的元素。</li>
<li><code>HashMap</code> 是键值对的存储结构，而 <code>HashSet</code> 只存储键。</li>
<li><code>Hashtable</code> 也是键值对的存储结构，类似于 <code>HashMap</code>，但是是同步的，因此适合于多线程环境。</li>
<li><code>HashMap</code> 和 <code>Hashtable</code> 允许键和值为 <code>null</code>，而 <code>HashSet</code> 只允许一个 <code>null</code> 元素。<br>  在实际开发中，一般推荐使用 <code>HashMap</code> 而不是 <code>Hashtable</code>，因为 <code>Hashtable</code> 的同步性会带来额外的性能开销。如果需要在多线程环境下使用，也可以考虑使用 <code>Collections.synchronizedMap()</code> 方法来创建一个同步的 <code>HashMap</code>。</li>
</ul>
</li>
<li><p>TreeSet</p>
<ol>
<li>TreeSet()是使用二叉树的原理对新 add()的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。</li>
<li>Integer 和 String 对象都可以进行默认的 TreeSet 排序，而自定义类的对象是不可以的， 自己定义的类必须实现 Comparable 接口，并且覆写相应的 compareToTo()函数，才可以正常使用。</li>
<li>在覆写 compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序</li>
<li>比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数</li>
</ol>
</li>
<li><p>？？？LinkHashSet（ HashSet+LinkedHashMap）<br>对于 LinkedHashSet 而言，它继承与 HashSet、又基于 LinkedHashMap 来实现的。LinkedHashSet 底层使用 LinkedHashMap 来保存所有元素，它继承与 HashSet，其所有的方法操作上又与 HashSet 相同，因此 LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操作上与父类 HashSet 的操作相同，直接调用父类 HashSet 的方法即可。</p>
</li>
<li><p>Map 了解多少？<br>Map在Java里边是一个接口，常见的实现类有HashMap、LinkedHashMap、TreeMap和ConcurrentHashMap<br>在Java里边，哈希表的结构是数组+链表的方式。HashMap底层数据结构是数组+链表&#x2F;红黑树；LinkedHashMap是数组+链表&#x2F;红黑树+双向链表；TreeMap是红黑树；而ConcurrentHashMap是数组+链表&#x2F;红黑树 </p>
</li>
<li><p><strong>HashMap</strong></p>
<ul>
<li>实现原理：其实就是有个 Entry 数组，Entry 保存了 key 和 value。当你要塞入一个键值对的时候，会根据一个 hash 算法计算 key 的 hash 值，然后通过数组大小 <code>n-1 &amp; hash</code> 值之后，得到一个数组的下标，然后往那个位置塞入这个 Entry。为了解决 hash 冲突的问题，采用了链表法<ul>
<li>在 JDK1.7 及之前链表的插入采用的是头插法，即在链表的头部插入新的 Entry。在 JDK1.8 的时候，改成了尾插法，并且引入了红黑树。当链表的长度大于 8 且数组大小大于等于 64 的时候，就把链表转化成红黑树，当红黑树节点小于 6 的时候，又会退化成链表。</li>
<li>为什么 JDK 1.8 要对 HashMap 做红黑树这个改动？主要是避免 hash 冲突导致链表的长度过长，这样 get 的时候时间复杂度严格来说就不是 O(1) 了，因为可能需要遍历链表来查找命中的 Entry。</li>
<li>为什么定义链表长度为 8 且数组大小大于等于 64 才转红黑树？不要链表直接用红黑树不就得了吗？因为红黑树节点的大小是普通节点大小的两倍，所以为了节省内存空间不会直接只用红黑树，只有当节点到达一定数量才会转成红黑树，这里定义的是 8（泊松分布）</li>
<li>为什么节点少于 6 要从红黑树转成链表？也是为了平衡时间和空间，节点太少链表遍历也很快，节约内存。</li>
</ul>
</li>
<li>HashMap <strong>默认大小为16，负载因子的大小为0.75。</strong><ul>
<li>HashMap的大小只能是2次幂的，假设你传一个10进去，实际上最终HashMap的大小是16（具体的实现在tableSizeFor可以看到）把元素放进HashMap的时候，需要算出这个元素所在的位置（hash）。在HashMap里用的是位运算来代替取模，更加高效。HashMap的大小只能是2次幂时，才能合理用位运算替代取模。 </li>
<li>负载因子的大小决定着哈希表的扩容和哈希冲突。比如默认的HashMap大小为16，负载因子为0.75，这意味着数组最多只能放16*0.75&#x3D;12个元素，每次put元素进去的时候，都会检查HashMap的大小有没有超过这个阈值，一旦超过12，则哈希表需要扩容。如果把负载因子调高了，哈希冲突的概率会增高，同样会耗时（因为查找的速度变慢了）</li>
</ul>
</li>
<li>hash 函数的优化：1.8后，在put元素的时候传递的Key，先算出正常的哈希值，然后与高16位做异或运算，产生最终的哈希值。这样做的好处可以增加了随机性，减少了碰撞冲突的可能性。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>扩容</strong> rehash 的优化：默认是扩原来的2倍（因为HashMap的大小只能是2次幂），扩的是数组不是链表。<ul>
<li>1.7版本：<br>  1.先生成新数组<br>  2.遍历老数组中的每个位置上的链表上的每个元素<br>  3.取每个元素的key，并基于新数组长度，计算出每个元素在新数组中的下标<br>  4.将元素添加到新数组中去<br>  5.所有元素转移完了之后，将新数组赋值给HashMap对象的table属性</li>
<li>1.8版本：<br>  1.先生成新数组<br>  2.遍历老数组中的每个位置上的链表或红黑树<br>  3.如果是链表，则直接将链表中的每个元素里新计算下标，并添加到新数组中去<br>  ？？4.如果是红黑树，则先遍历红黑树，先计算出红黑树中每个元素对应在新数组中的下标位置：统计每个下标位置的元素个数，如果该位置下的元素个数超过了8，则生成一个新的红黑树，并将根节点的添加到新数组的对应位置；如果该位置下的元素个数没有超过8，那么则生成一个链表，并将链表的头节点添加到新数组的对应位置<br>  5.所有元素转移完了之后，将新数组赋值给HashMap对象的table属性</li>
<li>1.8:：</li>
</ul>
</li>
<li><strong>put</strong>：首先对key做hash运算，计算出该key所在的index。如果没碰撞，直接放到数组中，如果碰撞了，需要判断目前数据结构是链表还是红黑树，根据不同的情况来进行插入。假设key是相同的，则替换到原来的值。最后判断哈希表如果满了，扩容。</li>
<li><strong>get</strong>：还是对key做hash运算，计算出该key所在的index，然后判断是否有hash冲突。假设没有冲突直接返回，假设有冲突则判断当前数据结构是链表还是红黑树，分别从不同的数据结构中取出。<br>  在HashMap中怎么判断一个元素是否相同？首先会比较hash值，随后会用&#x3D;&#x3D;运算符和equals()来判断该元素是否相同。如果只有hash值相同，那说明该元素哈希冲突了，如果hash值和equals() || &#x3D;&#x3D; 都相同，那说明该元素是同一个。</li>
</ul>
</li>
<li><p>Jdk1.7 到 Jdk1.8 HashMap 发生了什么变化(底层)?</p>
<ol>
<li>1.7中底层是数组+链表，1.8中底层是数组+链表+红黑树，加红黑树的目的是提高HashMap插入和查询整体效率</li>
<li>1.7中链表插入使用的是头插法，1.8中链表插入使用的是尾插法，因为1.8中插入key和value时需要判断链表元素个数，所以需要遍历链表统计链表元素个数，所以正好就直接使用尾插法</li>
<li>？？？1.7中哈希算法比较复杂，存在各种右移与异或运算，1.8中进行了简化，因为复杂的哈希算法的目的就是提高散列性，来提供HashMap的整体效率，而1.8中新增了红黑树，所以可以适当的简化哈希算法，节省CPU资源</li>
</ol>
</li>
<li><p>HashMap 和 HashTaTable 的区别<br>1、两者父类不同。HashMap是继承自AbstractMap类，而Hashtable是继承自Dictionary类。<br>不过它们都实现了同时实现了map、Cloneable（可复制）、Serializable（可序列化）这三个接口。<br>2、对外提供的接口不同。Hashtable比HashMap多提供了elments() 和contains() 两个方法。elments() 方法继承自Hashtable的父类Dictionnary。elements() 方法用于返回此Hashtable中的value的枚举。<br>3、对null的支持不同。Hashtable：key和value都不能为null。HashMap：key可以为null，但是这样的key只能有一个，因为必须保证key的唯一性；可以有多个key值对应的value为null。<br>4、安全性不同。HashMap是线程不安全的，在多线程并发的环境下，可能会产生死锁等问题，因此需要开发人员自己处理多线程的安全问题。Hashtable是线程安全的，它的每个方法上都有synchronized 关键字，因此可直接用于多线程中。<br>虽然HashMap是线程不安全的，但是它的效率远远高于Hashtable，这样设计是合理的，因为大部分的使用场景都是单线程。当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap。ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。<br>5、初始容量大小和每次扩充容量大小不同<br>6、计算hash值的方法不同</p>
</li>
<li><p>LinkedHashMap？<br>LinkedHashMap底层结构是数组+链表+双向链表，实际上它继承了HashMap，在HashMap的基础上维护了一个双向链表<br>LinkedHashMap 把 HashMap 的 Entry 加了两个指针：before 和 after。就是要把塞入的 Entry 之间进行关联，串成双向链表；有了这个双向链表，我们的插入可以是有序的，这里的有序不是指大小有序，而是插入有序。LinkedHashMap在遍历的时候实际用的是双向链表来遍历的，所以LinkedHashMap的大小不会影响到遍历的性能</p>
<img src="https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/640-20230912141802980.png" width="550" height="300" alt="">
并且内部还有个 accessOrder 成员，默认是 false， 代表链表是顺序是按插入顺序来排的，如果是 true 则会根据访问顺序来进行调整，就是咱们熟知的 LRU 那种，如果哪个节点访问了，就把它移到最后，代表最近访问的节点。
</li>
<li><p>？？？TreeMap呢？<br>TreeMap的底层数据结构是红黑树，TreeMap的key不能为null（如果为null，那还怎么排序呢），TreeMap有序是通过实现 Comparable 接口或者自定义实现一个 comparator 传入构造函数，这样塞入的节点就会根据你定义的规则进行排序。如果comparator为null，那么就使用自然顺序 </p>
</li>
<li><p>？？ConcurrentHashMap？</p>
<ul>
<li>ConcurrentHashMap是线程安全的Map实现类，它在juc包下的。线程安全的Map实现类除了ConcurrentHashMap还有一个叫做Hashtable。当然了，也可以使用Collections来包装出一个线程安全的Map。但无论是Hashtable还是Collections包装出来的都比较低效（因为是直接在外层套synchronize），所以一般都使用ConcurrentHashMap<br>  HashMap不是线程安全的，多线程环境下有可能会有数据丢失和获取不了最新数据的问题</li>
<li>ConcurrentHashMap 本质上是一个 HashMap，因此功能和 HashMap 一样，但是ConcurrentHashMap 在 HashMap 的基础上，提供了并发安全的实现。并发安全的主要实现是通过对指定的 Node 节点加锁，来保证数据更新的安全性</li>
<li>通过在部分加锁和利用CAS算法来实现同步，在get的时候没有加锁，Node都用了volatile给修饰。在扩容时，会给每个线程分配对应的区间，并且为了防止putVal导致数据不一致，会给线程的所负责的区间加锁。</li>
</ul>
</li>
<li><p>泛型类<br>泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用泛型的好处？<br>“泛型” 意味着编写的代码可以被不同类型的对象所重用。<br>以集合来举例，使用泛型的好处是我们不必因为添加元素类型的不同而定义不同类型的集合，如整型集合类，浮点型集合类，字符串集合类，我们可以定义一个集合来存放整型、浮点型，字符串型数据，而这并不是最重要的，因为我们只要把底层存储设置了Object即可，添加的数据全部都可向上转型为Object。 更重要的是我们可以通过规则按照自己的想法控制存储的数据类型。</p>
</li>
<li><p>类型通配符?<br>类 型 通 配 符 一 般 是 使 用 ? 代 替 具 体 的 类 型 参 数 。 例 如 List&lt;?&gt; 在 逻 辑 上 是List,List 等所有 List&lt;具体类型实参&gt;的父类。 </p>
</li>
<li><p>？？？类型擦除<br>Java 中的泛型基本上都是在编译器这个层次来实现的。在生成的  Java 字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。<br>如在代码中定义的 List和 List等类型，在编译之后都会变成 List。 JVM 看到的只是 List，而由泛型附加的类型信息对  JVM 来说是不可见的。<br>类型擦除的基本过程也比较简单，首先是找到用来替换类型参数的具体类。这个具体类一般是 Object。如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换成具体的类。</p>
</li>
</ul>
<hr>

<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><ul>
<li><p>Java 编译到执行的过程？</p>
<ul>
<li>“Java 跨平台”：因为有 JVM 屏蔽了底层操作系统。Java源代码会被编译为class文件，class文件运行在JVM之上。JVM是面向操作系统的，它负责把Class字节码解释成系统所能识别的指令并执行，同时也负责程序运行时内存的管理。安装JDK的时可以发现JDK是分「不同的操作系统」，JDK里是包含JVM的，所以Java依赖着JVM实现了『跨平台』</li>
<li>Java源码到执行的过程，从JVM的角度看可以总结为四个步骤：编译-&gt;加载-&gt;解释-&gt;执行<ul>
<li>「编译」java源代码 经过 语法分析、语义分析、注解处理 最后才生成会class文件。对泛型的擦除和Lombok就是在编译阶段干的。 </li>
<li>「加载」又可以细分步骤为：装载-&gt;连接-&gt;初始化。装载则把class文件装载至JVM，连接则校验class信息、分配内存空间及赋默认值，初始化则为变量赋值为正确的初始值。连接里又可以细化为：验证、准备、解析<ul>
<li>【装载时机】为了节省内存的开销，并不会一次性把所有的类都装载至JVM，而是等到「有需要」的时候才进行装载（比如new和反射等等） 【装载发生】class文件是通过「类加载器」装载到jvm中的，为了防止内存中出现多份同样的字节码，使用了<strong>双亲委派机制</strong></li>
<li>【装载规则】JDK 中的本地方法类一般由根加载器（Bootstrp loader）装载，JDK 中内部实现的扩展类一般由扩展加载器（ExtClassLoader）实现装载，而程序中的类文件则由系统加载器（AppClassLoader）实现装载。</li>
<li>装载这个阶段它做的事情可以总结为：查找并加载类的二进制数据，在JVM「堆」中创建一个java.lang.Class类的对象，并将类相关的信息存储在JVM「方法区」中 </li>
<li>「连接」这个阶段它做的事情可以总结为：对class的信息进行验证、为「类变量」分配内存空间并对其赋默认值。又可以细化为几个步骤：1. 验证：验证类是否符合 Java 规范和 JVM 规范 2. 准备：为类的静态变量分配内存，初始化为系统的初始值 3. 解析：将符号引用转为直接引用的过程 </li>
<li>接下来就是「初始化」阶段了，可以总结为：为类的静态变量赋予正确的初始值。过程大概就是收集class的静态变量、静态代码块、静态方法至()方法，随后从上往下开始执行。如果「实例化对象」则会调用方法对实例变量进行初始化，并执行对应的构造方法内的代码。</li>
</ul>
</li>
<li>「解释」则是把字节码转换成操作系统可识别的执行指令，在JVM中会有字节码解释器和即时编译器。在解释时会对代码进行分析，查看是否为「热点代码」，如果为「热点代码」则触发JIT编译，下次执行时就无需重复进行解释，提高解释速度<ul>
<li>JVM会对「热点代码」做编译，非热点代码直接进行解释。当JVM发现某个方法或代码块的运行特别频繁的时候，就有可能把这部分代码认定为「热点代码」。</li>
<li>使用「热点探测」来检测是否为热点代码。「热点探测」一般有两种方式，计数器和抽样。HotSpot使用的是「计数器」的方式进行探测，为每个方法准备了两类计数器：方法调用计数器和回边计数器。这两个计数器都有一个确定的阈值，当计数器超过阈值溢出了，就会触发JIT编译。即时编译器把热点方法的指令码保存起来，下次执行的时候就无需重复的进行解释，直接执行缓存的机器语言。</li>
</ul>
</li>
<li>「执行」 操作系统把解释器解析出来的指令码，调用系统的硬件执行最终的程序指令。</li>
</ul>
</li>
</ul>
</li>
<li><p>类加载器。<br>JDK自带有三个类加载器:bootstrap ClassLoader、ExtClassLoader、AppClassLoader.<br>BootStrapClassLoader是ExtClassLoader的父类加载器，默认负责加载%JAVA HOME%lib下的jar包和class文件ExtClassLoader是AppClassLoader的父类加载器，负贵加载%JAVA HOME%&#x2F;lib&#x2F;ext文件夹下的jar包和class类。AppClassLoader是自定义类加载器的父类，负贵加载classpath下的类文件。</p>
</li>
<li><p><strong>双亲委派模型</strong></p>
<ul>
<li>上次提到了：class文件是通过「类加载器」装载至JVM中的，为了防止内存中存在多份同样的字节码，使用了双亲委派机制（它不会自己去尝试加载类，而是把请求委托给父加载器去完成，依次向上）</li>
<li>JDK 中的本地方法类一般由根加载器（Bootstrp loader）装载，内部实现的扩展类一般由扩展加载器（ExtClassLoader）实现装载，而程序中的类文件则由系统加载器（AppClassLoader）实现装载。<br>  AppClassLoader的父加载器为Ext ClassLoader、Ext ClassLoader的父加载器为BootStrap ClassLoader。这里的父子关系并不是通过继承实现的，而是组合。</li>
<li>打破双亲委派机制：自定义ClassLoader，重写loadClass方法（只要不依次往上交给父加载器进行加载，就算是打破双亲委派机制） </li>
<li>打破双亲委派机制案例：Tomcat<ul>
<li>为了Web应用程序类之间隔离，为每个应用程序创建WebAppClassLoader类加载器</li>
<li>为了Web应用程序类之间共享，把ShareClassLoader作为WebAppClassLoader的父类加载器，如果WebAppClassLoader加载器找不到，则尝试用ShareClassLoader进行加载</li>
<li>为了Tomcat本身与Web应用程序类隔离，用CatalinaClassLoader类加载器进行隔离和加载Tomcat本身的类</li>
<li>为了Tomcat与Web应用程序类共享，用CommonClassLoader作为CatalinaClassLoader和ShareClassLoader的父类加载器</li>
<li>ShareClassLoader、CatalinaClassLoader、CommonClassLoader的目录可以在Tomcat的catalina.properties进行配置   <img src="https://leo710aka.github.io/bk/job6.png" width="450" height="300" alt=""></li>
</ul>
</li>
<li>线程上下文加载器：由于类加载的规则，很可能导致父加载器加载时依赖子加载器的类，导致无法加载成功（BootStrap ClassLoader无法加载第三方库的类），所以存在「线程上下文加载器」来进行加载。 ？？？</li>
</ul>
</li>
<li><p>JVM的内存结构？ <a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv25819369/?spm_id_from=333.999.0.0&jump_opus=1">https://www.bilibili.com/read/cv25819369/?spm_id_from=333.999.0.0&amp;jump_opus=1</a></p>
<ul>
<li>前面提到了：class文件会被类加载器装载至JVM中，并且JVM会负责程序「运行时」的「内存管理」。而JVM的内存结构，往往指的就是JVM定义的「运行时数据区域」。简单来说就分为了5大块：方法区、堆、程序计数器、虚拟机栈、本地方法栈</li>
<li>要值得注意的是：这是JVM「规范」的分区概念，到具体的实现落地，不同的厂商实现可能是有所区别的。 </li>
<li><strong>程序计数器</strong>：线程切换意味着「中断」和「恢复」，那自然就需要有一块区域来保存「当前线程的执行信息」。所以，程序计数器就是用于记录各个线程执行的字节码的地址（分支、循环、跳转、异常、线程恢复等都依赖于计数器）</li>
<li><strong>虚拟机栈</strong>：每个线程在创建的时候都会创建一个「虚拟机栈」，每次方法调用都会创建一个「栈帧」。每个「栈帧」会包含几块内容：局部变量表、操作数栈、动态连接和返回地址。它的作用：它保存方法的局部变量、部分变量的计算并参与了方法的调用和返回。</li>
<li><strong>本地方法栈</strong>：本地方法栈跟虚拟机栈的功能类似，虚拟机栈用于管理 Java 函数的调用，而本地方法栈则用于管理本地方法的调用。这里的「本地方法」指的是「非Java方法」，一般本地方法是使用C语言实现的。</li>
<li><strong>方法区</strong>：在HotSpot虚拟机，就会常常提到「永久代」这个词，「JDK8前」用「永久代」实现了「方法区」，而很多其他厂商虚拟机其实是没有「永久代」的概念的。JDK8中，已经用「元空间」来替代了「永久代」作为「方法区」的实现了<ul>
<li>方法区主要是用来存放已被虚拟机加载的「类相关信息」：包括类信息、常量池<br>  类信息又包括了类的版本、字段、方法、接口和父类等信息。<br>  常量池又可以分「静态常量池」和「运行时常量池」<ul>
<li>静态常量池主要存储的是「字面量」以及「符号引用」等信息，也包括了我们说的「字符串常量池」。</li>
<li>运行时常量池存储的是「类加载」时生成的「直接引用」等信息。</li>
</ul>
</li>
<li>又值得注意的是：从「逻辑分区」的角度而言「常量池」是属于「方法区」的。但自从在「JDK7」以后，就已经把「运行时常量池」和「静态常量池」转移到了「堆」内存中进行存储（对于「物理分区」来说「运行时常量池」和「静态常量池』就属于堆）</li>
<li>从「JDK8」已经把「方法区」的实现从「永久代」变成「元空间」，有什么区别？<br>  最主要的区别就是：「元空间」存储不在虚拟机中，而是使用本地内存，JVM 不会再出现方法区的内存溢出，以往「永久代」经常因为内存不够用导致跑出OOM异常。按JDK8版本，总结起来其实就相当于：「类信息」是存储在「元空间」的（也有人把「类信息」这块叫做「类信息常量池」，主要是叫法不同，意思到位就好）。而「常量池」用JDK7开始，从「物理存储」角度上就在「堆中」，这是没有变化的。</li>
</ul>
</li>
<li><strong>堆</strong>：堆是线程共享的区域，几乎类的实例和数组分配的内存都来自于它。「堆」被划分为「新生代」和「老年代」，「新生代」又被进一步划分为 Eden 和 Survivor 区，最后 Survivor 由 From Survivor 和 To Survivor 组成。将「堆内存」分开了几块区域，主要跟「内存回收」有关（垃圾回收机制）</li>
</ul>
</li>
<li><p>jvm线程共享区？<br>线程共享：堆区和方法区<br>线程独有：栈、本地方法栈和程序计数器</p>
</li>
<li><p>java的对象是怎么被回收的？<a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv25951929/?spm_id_from=333.999.0.0&jump_opus=1">https://www.bilibili.com/read/cv25951929/?spm_id_from=333.999.0.0&amp;jump_opus=1</a></p>
</li>
<li><p>JVM有哪些垃圾回收算法?</p>
<ol>
<li>标记清除算法:<br>  a.标记阶段:把垃圾内存标记出来<br>  b.清除阶段：直接将垃圾内存回收。<br>  c.这种算法是比较简单的，但是有个很严重的问题，就是会产生大量的内存碎片。</li>
<li>复制算法：为了解决标记清除算法的内存碎片问题，就产生了复制算法。复制算法将内存分为大小相等的两半，每次只使用其中一半。垃圾回收时，将当前这一块的存活对象全部拷贝到另一半，然后当前这一半内存就可以直接清除。这种算法有内存碎片，但是他的问题就在于浪费空间。而且，他的效率跟存活对象的个数有关。</li>
<li>标记压缩算法:为了解决复制算法的缺陷，就提出了标记压缩算法。这种算在标记阶段跟标记清除算法是一样的，但是在完成标记之后，不是直接清理垃圾内存，而是将存活对象往一端移动，然后将边界以外的所有内存直接清除。</li>
</ol>
</li>
<li><p>CMS垃圾收集器 <a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv26111304/?spm_id_from=333.999.0.0&jump_opus=1">https://www.bilibili.com/read/cv26111304/?spm_id_from=333.999.0.0&amp;jump_opus=1</a></p>
</li>
<li><p>G1垃圾收集器 <a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv26352521/?spm_id_from=333.999.0.0&jump_opus=1">https://www.bilibili.com/read/cv26352521/?spm_id_from=333.999.0.0&amp;jump_opus=1</a></p>
</li>
<li><p>JVM调优到底是干啥的？</p>
<ul>
<li>我们一般优化系统的思路是这样的：<ol>
<li>一般来说关系型数据库是先到瓶颈，首先排查是否为数据库的问题（这个过程中就需要评估自己建的索引是否合理、是否需要引入分布式缓存、是否需要分库分表等等）</li>
<li>然后，我们会考虑是否需要扩容（横向和纵向都会考虑）（这个过程中我们会怀疑是系统的压力过大或者是系统的硬件能力不足导致系统频繁出现问题）</li>
<li>接着，应用代码层面上排查并优化（扩容是不能无止境的，里头里外都是钱阿。这个过程中我们会审视自己写的代码是否存在资源浪费的问题，又或者是在逻辑上可存在优化的地方，比如说通过并行的方式处理某些请求）</li>
<li>再接着，JVM层面上排查并优化（审视完代码之后，这个过程我们观察JVM是否存在多次GC问题等等）</li>
<li>最后，网络和操作系统层面排查（这个过程查看内存&#x2F;CPU&#x2F;网络&#x2F;硬盘读写指标是否正常等等）</li>
</ol>
</li>
<li>绝大多数情况下到第三步就结束了，一般经过「运维团队」给我们设置的JVM和机器上的参数已经满足绝大多数的需求了。</li>
<li>在我的理解下，调优JVM其实就是在「理解」JVM内存结构以及各种垃圾收集器前提下，结合自己的现有的业务来「调整参数」，使自己的应用能够正常稳定运行。一般调优JVM我们认为会有几种指标可以参考：『吞吐量』、『停顿时间』和『垃圾回收频率』。基于这些指标，我们就有可能需要调整：<ol>
<li>内存区域大小以及相关策略（比如整块堆内存占多少、新生代占多少、老年代占多少、Survivor占多少、晋升老年代的条件等等）比如（-Xmx：设置堆的最大值、-Xms：设置堆的初始值、-Xmn：表示年轻代的大小、-XX:SurvivorRatio：伊甸区和幸存区的比例等等）（按经验来说：IO密集型的可以稍微把「年轻代」空间加大些，因为大多数对象都是在年轻代就会灭亡。内存计算密集型的可以稍微把「老年代」空间加大些，对象存活时间会更长些）</li>
<li>垃圾回收器（选择合适的垃圾回收器，以及各个垃圾回收器的各种调优参数）比如（-XX:+UseG1GC：指定 JVM 使用的垃圾回收器为 G1、-XX:MaxGCPauseMillis：设置目标停顿时间、-XX:InitiatingHeapOccupancyPercent：当整个堆内存使用达到一定比例，全局并发标记阶段 就会被启动等等）<br>  没错，这些都是因地制宜，具体问题具体分析（前提是得懂JVM的各种基础知识，基础知识都不懂，谈何调优）</li>
</ol>
</li>
<li>一般我们是「遇到问题」之后才进行调优的，而遇到问题后需要利用各种的「工具」进行排查<ol>
<li>通过jps命令查看Java进程「基础」信息（进程号、主类）。这个命令很常用的就是用来看当前服务器有多少Java进程在运行，它们的进程号和加载主类是啥</li>
<li>通过jstat命令查看Java进程「统计类」相关的信息（类加载、编译相关信息统计，各个内存区域GC概况和统计）。这个命令很常用于看GC的情况</li>
<li>通过jinfo命令来查看和调整Java进程的「运行参数」。</li>
<li>通过jmap命令来查看Java进程的「内存信息」。这个命令很常用于把JVM内存信息dump到文件，然后再用MAT( Memory Analyzer tool 内存解析工具)把文件进行分析</li>
<li>通过jstack命令来查看JVM「线程信息」。这个命令用常用语排查死锁相关的问题</li>
<li>还有近期比较热门的Arthas（阿里开源的诊断工具），涵盖了上面很多命令的功能且自带图形化界面。</li>
</ol>
</li>
<li>JVM 的 JIT 优化技术：比较出名的有两种：方法内联和逃逸分析<br>  所谓方法内联就是把「目标方法」的代码复制到「调用的方法」中，避免发生真实的方法调用<br>  因为每次方法调用都会生成栈帧（压栈出栈记录方法调用位置等等）会带来一定的性能损耗，所以「方法内联」的优化可以提高一定的性能。在JVM中也有相关的参数给予我们指定（-XX:MaxFreqInlineSize、-XX:MaxInlineSize）<br>  而「逃逸分析」则是判断一个对象是否被外部方法引用或外部线程访问的分析技术，如果「没有被引用」，就可以对其进行优化，比如说：<ol>
<li>锁消除（同步忽略）：该对象只在方法内部被访问，不会被别的地方引用，那么就一定是线程安全的，可以把锁相关的代码给忽略掉</li>
<li>栈上分配：该对象只会在方法内部被访问，直接将对象分配在「栈」中（Java默认是将对象分配在「堆」中，是需要通过JVM垃圾回收期进行回收，需要损耗一定的性能，而栈内分配则快很多）</li>
<li>标量替换&#x2F;分离对象：当程序真正执行的时候可以不创建这个对象，而直接创建它的成员变量来代替。将对象拆分后，可以分配对象的成员变量在栈或寄存器上，原本的对象就无需分配内存空间了</li>
</ol>
</li>
</ul>
</li>
<li><p>有没有排查过线上 oom 的问题？<br>  没有，但是，知道。。。<br>  OOM 是 out of memory 的简称，表示程序需要的内存空间大于 JVM 分配的内存空间。OOM 后果就是导致程序崩溃；可以通俗理解：程序申请内存过大，虚拟机无法满足。</p>
<ul>
<li>导致 OOM 错误的情况一般是：<br>  1、给 JVM 虚拟机分配的内存太小，实际业务需求对内存的消耗比较多<br>  2、Java 应用里面存在内存泄漏的问题，或者应用中有大量占用内存的对象，并且没办法及时释放。我给大家解释一下内存泄漏和内存溢出是两个完全不一样的情况<br>  内存泄露：申请使用完的内存没有释放，导致虚拟机不机不能再次使用该内存，此时这段内存就泄露了，因为申请者不用了，而又不能被虚拟机分机分配给别人用。<br>  内存溢出：申请的内存超出了 JVM 能提供的内存大小，此时称之为溢出。</li>
<li>常见的 OOM 异常情况有两种：<br>  java.lang.OutOfMemoryError: Java heap space ——&gt;java 堆内存溢出，此种情况最常见，一般由于内存泄露或者堆的大小设置不当引起。对于内存泄露，需要通过内存监控软件查找程序中的泄露代码，而堆大小可以通过虚拟机参数-Xms,-Xmx 来修改。<br>  java.lang.OutOfMemoryError: PermGen space 或java.lang.OutOfMemoryError：MetaSpace ——&gt;java 方法区，溢出了，一般出现在大量 Class、或者采用 cglib 等反射机制的情况，因为这些情况会产生大量的 Class 信息存储于方法区。这种情况可以通过更改方法区的大小来解决，使用类似-XX:PermSize&#x3D;64m-XX:MaxPermSize&#x3D;256m 的形式修改。</li>
<li>另外，过多的常量尤其是字符串也会导致方法区溢出。<br>  遇到这类问题，通常的排查方式是，先获取内存的 Dump 文件。Dump 文件有两种方式来生成：第一种是配置 JVM 启动参数，当触发了 OOM 异常的时候自动生成；第二种是使用 jmap 工具来生成。<br>  然后使用 MAT 工具来分析 Dump 文件。如果是内存泄漏，可进一步通过工具查看泄漏对象到 GC Roots 的引用链。掌握了泄漏对象的类信息和 GC Roots 引用链的信息，就可以比较准确地定位泄漏代码的位置。如果是普通的内存溢出，确实有很多占用内存的对象，那就只需要提升堆内存空间即可。</li>
</ul>
</li>
<li><p>Java 中会存在内存泄漏吗，请简单描述。<br>理论上 Java 因为有垃圾回收机制（GC）不会存在内存泄露问题（ 这也是 Java 被广泛使用于服务器端编程的一个重要原因 ）；然而在实际开发中，可能会存在无用但可达的对 象，这些对象 不能被 GC 回收 ，因此也会导致内存泄露的发生 。</p>
</li>
</ul>
<hr>


<h2 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h2><ul>
<li><p>并发、并行、串行之间的区别<br>1，串行:一个任务执行完，才能执行下一个任务<br>2，并行(Parallelism):两个任务同时执行<br>3，并发(Concurency):两个任务整体看上去是同时执行，在底层，两个任务被拆成了很多份，然后一个一个执行，站在更高的度看来两个任务是同时在执行的</p>
</li>
<li><p>怎么理解Java多线程？  <a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv22973356/?spm_id_from=333.999.0.0&jump_opus=1">https://www.bilibili.com/read/cv22973356/?spm_id_from=333.999.0.0&amp;jump_opus=1</a></p>
</li>
<li><p>Java内存模型？ Java3y <a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv24200309/?spm_id_from=333.999.0.0&jump_opus=1">https://www.bilibili.com/read/cv24200309/?spm_id_from=333.999.0.0&amp;jump_opus=1</a></p>
</li>
<li><p>ThreadLocal的底层原理<br>1，Threadlocal是java中所提供的线程本地存储机制，可以利用该机制将数据存在某个线程内部，该线程可以在任意时刻、任意方法中获取领存的数据<br>2，Threadlocal底层通过ThreadlocaMap来实现的，每个Thread对象（注意不是Threadloca对象）中都存在ThreadlocalMap，Map的key为Thredloca对象，Map的value为需要授存的值<br>？？3，如果在线程池中使用Threadloal会造成内存泄漏，因为当Threadloca对象使用完之后，应该要把设置的key,value，也就是Entry对象进行回收，但线程池中的线程不会回收，而线理对象是通过观引用指向ThreadlocaMap，ThreadlocaMap也是通过用强引用指向entry对象，线理不被回收，entry对象也就不会被回收，从而出现内存泄露，解决办法是，在使用了ThreadLocal对象之后，手动调用ThreadLocal的remove方法，手动清楚Entry对象<br>4，Threadlocal经典的应用场就是连接管理（一个线程持有一个连接，该连接对象可以在不同的方法之进行传递，线程之间不共享同一个连接）</p>
</li>
<li><p>Java死锁如何避免?<br>造成死锁的几个原因:<br>1。一个资源每次只能被一个线程使用<br>2。一个线程在阻塞等待某个资源时，不释放已占有资源<br>3。一个线程已经获得的资源，在未使用完之前，不能被强行剥夺<br>4，若干线程形成头尾相接的循环等待资源关系<br>这是造成死锁必须要达到的4个条件，如果要避免死锁，只需不满足其中某一个即可，而其中前3个是作为锁要符合的条件，所以要避免死锁就要打破第4个条件，不出现循环等待锁的关系。<br>？？在开发过程中:<br>1，要注意加锁顺序，保证每个线程按同样的顺序进行加锁<br>2，要注意加锁时限，可以针对所设置一个超时时间<br>3，要注意死铁检查，这是一种预防机制，确保在第一时间发现死锁并进行解决</p>
</li>
<li><p>Lock 和 Synchronized 区别<br>、、</p>
</li>
</ul>
<hr>

<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><ul>
<li><p>JDBC操作的步骤<br>加载数据库驱动类<br>打开数据库连接<br>执行sql语句<br>处理返回结果<br>关闭资源</p>
</li>
<li><p>在使用jdbc的时候，如何防止出现sql注入的问题？<br>使用PreparedStatement类，而不是使用Statement类</p>
</li>
<li><p>怎么在JDBC内调用一个存储过程<br>使用CallableStatement</p>
</li>
<li><p>是否了解连接池，使用连接池有什么好处？<br>数据库连接是非常消耗资源的，影响到程序的性能指标。连接池是用来分配、管理、释放数据库连接的，可以使应用程序重复使用同一个数据库连接，而不是每次都创建一个新的数据库连接。通过释放空闲时间较长的数据库连接，避免数据库因为创建太多的连接而造成的连接遗漏问题，提高了程序性能。</p>
</li>
<li><p>你所了解的数据源技术有那些？使用数据源有什么好处？<br>Dbcp,c3p0等，用的最多还是c3p0，因为c3p0比dbcp更加稳定，安全；通过配置文件的形式来维护数据库信息，而不是通过硬编码。当连接的数据库信息发生改变时，不需要再更改程序代码就实现了数据库信息的更新。</p>
</li>
<li><p>spring dao？mybatis？<br>  JDBC（Java Database Connectivity）、Spring DAO（Data Access Object）和 MyBatis 是 Java 中用于数据库访问的三种不同的技术或模式。</p>
<ol>
<li>JDBC 是 Java 提供的标准数据库访问接口，它允许 Java 应用程序与不同的关系型数据库进行通信。JDBC 提供了一组 API，通过这些 API，开发者可以执行 SQL 查询、更新数据库、处理事务等操作。JDBC 是直接与数据库进行交互的底层技术，需要开发者编写较多的代码来处理数据库连接、SQL 执行和结果集处理等细节。</li>
<li>Spring DAO 是 Spring 框架中的一个模块，它提供了一种高层次的、面向对象的数据库访问方式，通过封装底层的 JDBC 操作，简化了数据库访问的代码。Spring DAO 的目标是提供更高级别的抽象，使得开发者可以更专注于业务逻辑而不用过多关心数据库访问的细节。Spring DAO 提供了对声明式事务、异常处理等特性的支持。</li>
<li>MyBatis 是一种基于 Java 的持久层框架，它提供了一种将 SQL 语句与 Java 对象进行映射的方式，通过 XML 或注解配置 SQL 映射关系。MyBatis 避免了手动编写大量 JDBC 代码，同时提供了更灵活的 SQL 控制和结果集映射。MyBatis 是一种半自动化的持久层框架，它允许开发者直接编写 SQL，但提供了一些便利的功能来简化数据库访问。</li>
<li>关系总结：</li>
</ol>
<ul>
<li>JDBC 是直接与数据库进行交互的底层技术，需要开发者编写更多的数据库访问相关代码。</li>
<li>Spring DAO 是 Spring 框架中的一部分，提供了更高层次的抽象，简化了数据库访问的代码，提供声明式事务等功能。</li>
<li>MyBatis 是一种基于 Java 的持久层框架，通过将 SQL 语句与 Java 对象进行映射，简化了数据库访问的代码，提供了更灵活的 SQL 控制和结果集映射。<br>  在实际应用中，Spring DAO 和 MyBatis 可以与 JDBC 结合使用，以便在不同层次上提供更多的抽象和功能，同时使开发更加方便。例如，可以使用 MyBatis 提供的 SQL 映射和结果集映射功能，与 Spring DAO 集成，同时利用 Spring 提供的声明式事务管理。</li>
</ul>
</li>
</ul>
<hr>

<h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h2><ul>
<li><p>Java 中 IO 流？<br>Java 中 IO 流分为几种?<br>1、按照流的流向分，可以分为输入流和输出流；<br>2、按照操作单元划分，可以划分为字节流和字符流；<br>3、按照流的角色划分为节点流和处理流。<br>Java Io 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系，都是从如下 4 个抽象类基类中派生出来的。<br>1、InputStream &#x2F; Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。<br>2、OutputStream &#x2F; Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</p>
</li>
<li><p>字节流与字符流的区别<br>以字节为单位输入输出数据，字节流按照8位传输<br>以字符为单位输入输出数据，字符流按照16位传输</p>
</li>
<li><p>常用io类有那些<br>File<br>FileInputSteam，FileOutputStream<br>BufferInputStream，BufferedOutputSream<br>PrintWrite<br>FileReader，FileWriter<br>BufferReader，BufferedWriter<br>ObjectInputStream，ObjectOutputSream</p>
</li>
<li><p>阻塞 IO 模型<br>最传统的一种 IO 模型，即在读写数据过程中会发生阻塞现象。当用户线程发出 IO 请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出 CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用 户线程才解除 block 状态。<br>典型的阻塞 IO 模型的例子为： data &#x3D; socket.read();如果数据没有就绪，就会一直阻塞在 read 方法 </p>
</li>
<li><p>非阻塞 IO 模型<br>当用户线程发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。 如果结果是一个error 时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。所以事实上，在非阻塞 IO 模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞 IO不会交出 CPU，而会一直占用 CPU。 典型的非阻塞 IO 模型一般如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    data = socket.read();</span><br><span class="line">    <span class="keyword">if</span>(data!= error)&#123;</span><br><span class="line">        <span class="comment">//处理数据break;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是对于非阻塞 IO 就有一个非常严重的问题， 在 while 循环中需要不断地去询问内核数据是否就绪，这样会导致 CPU 占用率非常高，因此一般情况下很少使用 while 循环这种方式来读取数据。</p>
</li>
<li><p>???多路复用 IO 模型<br>多路复用 IO 模型是目前使用得比较多的模型。  Java NIO 实际上就是多路复用 IO。在多路复用 IO模型中，会有一个线程不断去轮询多个socket 的状态，只有当 socket 真正有读写事件时，才真正调用实际的 IO 读写操作。因为在多路复用 IO 模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket 读写事件进行时，才会使用IO 资源，所以它大大减少了资源占用。在  Java NIO 中，是通过 selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。多路复用 IO 模式，通过一个线程就可以管理多个 socket，只有当socket 真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用 IO 比较适合连接数比较多的情况。<br>另外多路复用 IO 为何比非阻塞 IO 模型的效率高是因为在非阻塞 IO 中，不断地询问 socket 状态时通过用户线程去进行的，而在多路复用IO 中，轮询每个 socket 状态是内核在进行的，这个效率要比用户线程要高的多。<br>不过要注意的是，多路复用 IO 模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用 IO 模型来说， 一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。 </p>
</li>
<li><p>信号驱动 IO 模型<br>在信号驱动 IO 模型中，当用户线程发起一个 IO 请求操作，会给对应的 socket 注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用 IO 读写操作来进行实际的 IO 请求操作。</p>
</li>
<li><p>???异步 IO 模型<br>异步 IO 模型才是最理想的 IO 模型，在异步 IO 模型中，当用户线程发起 read 操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个 asynchronous read 之后，它会立刻返回，说明 read 请求已经成功发起了，因此不会对用户线程产生任何block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read 操作完成了。也就说用户线程完全不需要实际的整个 IO 操作是如何进行的， 只需要先发起一个请求，当接收内核返回的成功信号时表示 IO 操作已经完成，可以直接去使用数据了。<br>也就说在异步 IO 模型中， IO 操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用 IO 函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用 IO 函数进行实际的读写操作；而在异步 IO 模型中，收到信号表示 IO 操作已经完成，不需要再在用户线程中调用 IO 函数进行实际的读写操作。 注意，异步 IO 是需要操作系统的底层支持，在  Java 7 中，提供了 Asynchronous IO。</p>
</li>
<li><p>Java 的 NIO？<br><a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv22750549/?spm_id_from=333.999.0.0&jump_opus=1">https://www.bilibili.com/read/cv22750549/?spm_id_from=333.999.0.0&amp;jump_opus=1</a><br>Java NIO 是JDK 1.4 开始有的，其目的是为了提高速度。传统IO是一次一个字节地处理数据，NIO是以块（缓冲区）的形式处理数据，所以NIO的效率要比IO高很多。最主要的是，NIO可以实现非阻塞，而传统IO只能是阻塞的。IO的实际场景是文件IO和网络IO，NIO在网络IO场景下提升就尤其明显了。<br>在Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO。</p>
</li>
<li><p>？？？NIO 的缓冲区<br>Java IO 面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据， 需要先将它缓存到一个缓冲区。 NIO 的缓冲导向方法不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。 </p>
</li>
<li><p>???NIO 的非阻塞<br>IO 的各种流是阻塞的。这意味着，当一个线程调用 read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 NIO 的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞 IO 的空闲时间用于在其它通道上执行 IO 操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p>
</li>
<li><p>Channel<br>首先说一下 Channel，国内大多翻译成“通道”。 Channel 和 IO 中的 Stream(流)是差不多一个等级的。<br>只不过 Stream 是单向的，譬如：InputStream, OutputStream， 而 Channel 是双向的，既可以用来进行读操作，又可以用来进行写操作。<br>NIO 中的 Channel 的主要实现有：1、FileChannel 2、DatagramChannel 3、SocketChannel 4、ServerSocketChannel，分别可以对应文件 IO、 UDP 和 TCP（Server 和 Client）。</p>
</li>
<li><p>Buffer<br>Buffer，缓冲区，实际上是一个容器，是一个连续数组。 Channel 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer。<br>下图描述了从一个客户端向服务端发送数据，然后服务端接收数据的过程。客户端发送数据时，必须先将数据存入 Buffer 中，然后将Buffer 中的内容写入通道。服务端这边接收数据必须通过 Channel 将数据读入到 Buffer 中，然后再从 Buffer 中取出数据来处理。在 NIO 中， Buffer 是一个顶层父类，它是一个抽象类，常用的 Buffer 的子类有：ByteBuffer、 IntBuffer、 CharBuffer、 LongBuffer、DoubleBuffer、 FloatBuffer、ShortBuffer</p>
<img src="https://leo710aka.github.io/bk/job9.png" width="750" height="300" alt="">
</li>
<li><p>???Selector<br>Selector 类是 NIO 的核心类， Selector 能够检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然后针对每个事件进行相应的响应处理。这样一来，只是用一个单线程就可以管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程，并且避免了多线程之间的上下文切换导致的开销。</p>
</li>
<li><p>？？？介绍一下自己对 Netty 的认识。<br>第一：Netty 是一个 基于 NIO 模型的高性能网络通信框架，其实可以认为它是对 NIO 网络模型的封装，提供了简单易用的 API，我们可以利用这些封装好的API 快速开发自己的网络程序。<br>第二：Netty 在 NIO 的基础上做了很多优化，比如零拷贝机制、高性能无锁队列、内存池等，因此性能会比 NIO 更高。<br>第三：Netty 可以支持多种通信协议，如 Http、WebSocket 等，并且针对数据通信的拆包黏包问题，Netty 内置了拆包策略。</p>
</li>
</ul>
<hr>


<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><ul>
<li><p>Spring 是什么？<br>Spring 是个java企业级应用的开源开发框架。Spring主要用来开发Java应用，但是有些<strong>扩展是针对构建J2EE？，</strong>平台的web应用。Spring 框架目标是简化Java企业级应用开发，并通过POJO为基础的编程模型促进良好的编程习惯。<br>框架—–》容器——》生态、、</p>
</li>
<li><p>你们项目中为什么使用Spring框架？Spring框架的好处，特点。<br>轻量: Spring 是轻量的，基本的版本大约2MB。<br>控制反转: Spring通过控制反转实现了松散稠合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。<br>面向切面的编程(AOP): Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。<br>容器: Spring 包含并管理应用中对象的生命周期和配置。<br>MVC框架: Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。<br>事务管理: Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务(JTA)。（编程式事务对新手难度、、<br>异常处理: Spring 提供方便的API把具体技术相关的异常(比如由JDBC，Hibernate orJDO抛出的) 转化为致的unchecked 异常。</p>
</li>
<li><p>spring核心模块。<br>Spring是一个轻量级的IoC和AOP容器框架。是为Java应用程序提供基础性服务的一套框架，目的是用于简化企业应用程序的开发，它使得开发者只需要关心业务需求。常见的配置方式有三种: 基于XML的配置、基于注解的配置、基于Java的配置。<br>主要由以下几个模块组成:<br>Spring Core: 核心类库，提供IOC服务;<br>Spring Context: 提供框架式的Bean访问方式，以及企业级功能 (JNDI、定时任务等);<br>Spring AOP: AOP服务;<br>Spring DAO: 对JDBC的抽象，简化了数据访问异常的处理:<br>Spring ORM: 对现有的ORM框架的支持;<br>Spring Web: 提供了基本的面向Web的综合特性，例如多方文件上传<br>Spring MVC：提供面向Web应用的Model-View-Controller实现。</p>
</li>
</ul>
<ul>
<li>Spring IOC<br>  Spring IOC 解决的是对象管理和对象依赖的问题。IOC容器可以理解为一个对象工厂，我们都把该对象交给工厂，工厂管理这些对象的创建以及依赖关系；需要用对象的时候，从工厂里边获取就好了<ul>
<li>「控制反转」指：把原有自己掌控的事交给别人去处理。它更多的是一种思想或者可以理解为设计模式。比如：本来由我们自己new出来的对象，现在交由IOC容器，把对象的控制权交给它方</li>
<li>「注入依赖」：是「控制反转」的实现方式，对象无需自行创建或者管理它的依赖关系，依赖关系将被「自动注入」到需要它们的对象当中去</li>
<li>用Spring IOC有什么好处吗？主要在于「将对象集中统一管理」并且「降低耦合度」<br>  如果项目里的对象都是就new下就完事了，没有多个实现类，那没事，不用Spring也没啥问题。但 Spring核心不仅仅IOC啊，除了把对象创建出来，还有一整套的Bean生命周期管理。用Spring IOC 可以方便 单元测试、对象创建复杂、对象依赖复杂、单例等等的，什么都可以交给Spring IOC</li>
<li>你们项目一般是怎么把对象交给IOC容器管理的？换个问法：一般是怎么定义Bean的？<br>  Spring提供了4种方式，分别是：1、注解 2、XML 3、JavaConfig 4、基于Groovy DSL配置<br>  日常写业务代码一般用注解来定义各种对象，责任链这种一般配置在XML，「注解」解决不了的就用JavaConfig。反正就是定义元数据，能给到Spring解析就好了</li>
</ul>
</li>
</ul>
<ul>
<li>依赖注入的方法有几种？</li>
</ul>
<ol>
<li>构造器注入：将被依赖对象通过构造函数的参数注入给依赖对象，并且在初始化对象的时候注入。<br>优点:对象初始化完成后便可获得可使用的对象。<br>缺点: 当需要注入的对象很多时，构造器参数列表将会很长， 不够灵活。若有多种注入方式，每种方式只需注入指定几个依赖，那么就需要提供多个重载的构造函数，麻烦。</li>
<li>！？？setter方法注入：lOC Service Provider通过调用成员变量提供的setter函数将被依赖对象注入给依赖类<br>优点: 灵活，可以选择性地注入需要的对象。用的最多。<br>缺点: 依赖对象初始化完成后，由于尚未注入被依赖对象，因此还不能使用。</li>
<li>接口注入：依赖类必须要实现指定的接口，然后实现该接口中的一个函数，该函数就是用于依赖注入。该函数的参数就是要注入的对象。<br>优点: 接口注入中，接口的名字、函数的名字都不重要，只要保证函数的参数是要注入的对象类型即可。<br>缺点：侵入性太强，不建议使用。PS:什么是侵入行?如果类A要使用别人提供的一个功能，若为了使用这功能，需要在自己的类中增加额外的代码，这就是侵入性。</li>
</ol>
<ul>
<li><p>@Autowired与@Resource的区别。<br>、、</p>
</li>
<li><p>Spring AOP<br>Spring AOP 解决的是 非业务代码抽取的问题。<br>？？？AOP 底层的技术是动态代理，在Spring内实现依赖的是BeanPostProcessor<br>比如我们需要在方法上注入些「重复性」的非业务代码，就可以利用Spring AOP。所谓「面向切面编程」在我理解下其实就是在方法前后增加非业务代码 </p>
<img src="https://leo710aka.github.io/bk/job3.png" width="550" height="300" alt="">
</li>
<li><p>SpringMVC 流程<br>？？<a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv26597569/?spm_id_from=333.999.0.0&jump_opus=1">https://www.bilibili.com/read/cv26597569/?spm_id_from=333.999.0.0&amp;jump_opus=1</a></p>
<img src="https://leo710aka.github.io/bk/job2.png" width="750" height="300" alt="">
</li>
<li><p>请简述你对 Spring MVC 的理解。<br>SpringMVC 是一种基于 Java 语言开发，实现了 Web MVC 设计模式，请求驱动类型的轻量级 Web 框架。采用了 MVC 架构模式的思想，通过把 Model，View，Controller 分离，将 Web 层进行职责解耦，从而把复杂的 Web 应用分成逻辑清晰的几个组件：<br>9 大重要的组件：p151<br>在 Spring MVC 的九大组件中，涉及到请求处理响应的核心组件分别是：HandlerMapping、HandlerAdapter、ViewResolver<br>具体调用分为以下几个步骤：1、HandlerMapping 回到调用 HandlerAdapter 2、HandlerAdapter 会返回 ModelAndView 3、ModelAndView 根据用户传入参数得到 ViewResolvers 4、ViewResolvers 会将用户传入的参数封装为 View，交给引擎进行渲染。注意：有大家最熟悉的两个类：ModelAndView 和 View 类并不属于 Spring MVC 九大组件之列。，？</p>
</li>
<li><p>三层架构：表现层、业务层、数据访问层<br>MVC：解决表现层的问题（Model：模型层 - View：视图层 - Controller：控制层）</p>
</li>
<li><p>service 层为什么用的是接口？为什么不直接使用实现类？？<br>  Service 层负责处理业务逻辑、调用数据访问层（DAO，Data Access Object）并与控制器层进行交互。使用接口而不是直接使用实现类呢，这主要有以下几个原因：</p>
<ol>
<li>解耦和可扩展性：使用接口将 Service 层与其实现类解耦。通过面向接口编程，控制器（或其他类）可以只依赖于接口而不是具体的实现类。这样使得代码更加灵活，能够轻松切换不同的实现类或者模拟测试用的虚拟实现。</li>
<li>单一职责原则：接口定义了 Service 层的契约和行为，实现类负责具体的逻辑实现。这符合单一职责原则，即一个类应该只负责一项职责。</li>
<li>测试和模拟：？？接口的使用使得单元测试更加容易。在测试时，可以使用模拟实现来替代真正的实现类，从而更好地进行单元测试。通过模拟，可以控制和验证不同的行为，而无需依赖于底层实现细节。</li>
<li>依赖注入：？？Spring 容器能够通过依赖注入将接口的实现类注入到需要的地方，而不需要直接关注具体的实现细节。</li>
</ol>
</li>
<li><p>切换一个接口下的不同的实现类有什么意义？为什么不直接使用不同的实现类？</p>
<ol>
<li>灵活性和可维护性：使用接口定义规范可以提高代码的灵活性。通过面向接口编程，可以将调用方与具体实现类解耦，使得代码更易于维护和修改。如果后续需要替换实现类或引入新的实现，只需要修改实现类的绑定，而不需要修改调用方的代码。</li>
<li>解耦和依赖注入：接口的使用支持依赖注入，使得系统更易于管理和测试。依赖注入能够减少类之间的耦合度，提高了代码的可测试性，有利于单元测试和模拟测试。</li>
<li>扩展性和适应性：使用接口和不同的实现类使得系统更具扩展性。根据不同的需求和场景，可以轻松地切换实现类，使得系统更具适应性和灵活性。</li>
<li>遵循设计原则：使用接口遵循了面向对象编程的设计原则，如开闭原则（对扩展开放，对修改关闭）、单一职责原则等。这种设计模式使得代码更清晰、更易于理解和维护。</li>
</ol>
</li>
<li><p>？？Spring容器启动流程是怎样的<br>1，在创建Spring容器，也就是启动Spring时:<br>2，首先会进行扫描，扫描得到所有的BeanDefinition对象，并存在一个Map中<br>3，然后筛选出非懒加弱的单例BeanDefinton进行创建Bean，对于多例Bean不需要在启动过程中去进行创建，对于多例Bean会在每次获取Bean时利用BeanDeinition去建<br>4，利用BeanDefinition创建Bean就是Bean的创建生命因期，这期间包括了合并BeanDefintion、推断构造法、实例化、属性填充、初始化前、初始化、初始化后等步骤其中AOP就是发生在初始化后这一步骤中<br>5，单例Bean创建完了之后，Spring会发布一个容器启动事件<br>6，Spring启动结束<br>7，在源码中会更复杂，比如源码中会提供一些模板方法，让子类来实现，比如源码中还涉及到一些BeanfatoyPostProcessor和BeanPostprocessor的注册，Spring的描就是通过BenaFactoryPostProcessor来实现的，依赖注入就是通过BeanPostProcessor来实现的8。在sprina启动过程中还会去处理@Import等注解</p>
</li>
<li><p>说说SpringBean生命周期原理？<br>？？</p>
<img src="https://leo710aka.github.io/bk/job4.png" width="650" height="300" alt="">
</li>
<li><p>？？能回答一下 Spring Bean 生命周期的执行流程吗？<br>  Spring 生命周期全过程大致分为五个阶段：创建前准备阶段、创建实例阶段、依赖注入阶段、容器缓存阶段和销毁实例阶段。</p>
<ul>
<li>创建前准备阶段：这个阶段主要的作用是，Bean 在开始加载之前，需要从上下文和相关配置中解析并查找 Bean 有关的扩展实现，比如像<code>init-method</code>-容器在初始化 bean 时调用的方法、<code>destory-method</code>，容器在销毁 bean 时调用的方法。以及，BeanFactoryPostProcessor 这类的 bean 加载过程中的前置和后置处理。这些类或者配置其实是 Spring 提供给开发者，用来实现 Bean 加载过程中的扩展机制，在很多和 Spring 集成的中间件中比较常见，比如 Dubbo。</li>
<li>创建实例阶段：这个阶段主要是通过反射来创建 Bean 的实例对象，并且扫描和解析 Bean 声明的一些属性。</li>
<li>依赖注入阶段：如果被实例化的 Bean 存在依赖其他 Bean 对象的情况，则需要对这些依赖 bean 进行对象注入。比如常见的<code>@Autowired</code>、setter 注入等依赖注入的配置形式。同时，在这个阶段会触发一些扩展的调用，比如常见的扩展类：BeanPostProcessors（用来实现 bean 初始化前后的扩展回调）、InitializingBean（这个类有一个 afterPropertiesSet()，这个在工作中也比较常见）、BeanFactoryAware 等等。</li>
<li>容器缓存阶段：容器缓存阶段主要是把 bean 保存到容器以及 Spring 的缓存中，到了这个阶段，Bean就可以被开发者使用了。这个阶段涉及到的操作，常见的有，<code>init-method</code>这个属性配置的方法， 会在这个阶段调用。以及像 BeanPostProcessors 方法中的后置处理器方法如：postProcessAftfterInitialization，也会在这个阶段触发。</li>
<li>销毁实例阶段：当 Spring 应用上下文关闭时，该上下文中的所有 bean 都会被销毁。如果存在 Bean 实现了 DisposableBean 接口，或者配置了<code>destory-method</code>属性，会在这个阶段被调用。</li>
</ul>
</li>
<li><p>Spring中Bean是线程安全的吗<br>Spring本身并没有针对Bean做线程安全的处理，所以:<br>1，如果Bean是无状志的，那么Bean则是线程安全的<br>2，如果Bean是有状态的，那么Bean则不是线程安全的<br>另外，Bean是不是线程安全，跟Bean的作用域没有关系，Bean的作用域只是表示Bean的生命周期范围，对于任何生命周期的Bean都是一个对象，这个对象是不是线挥安全的还得看这个Bean本身。</p>
</li>
<li><p>Spring 是如何解决循环依赖问题的？<br>如果两个或多个 Bean 互相之间持有对方的引用就会发生循环依赖。循环的依赖将会导致注入死循环。这是 Spring 发生循环依赖的原因。循环依赖有三种形态：<br>？？？<br>而 Spring 中设计了三级缓存来解决循环依赖问题，当我们去调用 getBean()方法的时候，Spring 会先从一级缓存中去找到目标 Bean，如果发现一级缓存中没有便会去二级缓存中去找，而如果一、二级缓存中都没有找到，意味着该目标 Bean 还没有实例化。于是，Spring 容器会实例化目标 Bean（PS：刚初始化的 Bean 称为早期 Bean） 。然后，将目标 Bean 放入到二级缓存中，同时，加上标记是否存在循环依赖。如果不存在循环依赖便会将目标 Bean 存入到二级缓存，否则，便会标记该 Bean 存在循环依赖，然后将等待下一次轮询赋值，也就是解析@Autowired 注解。等@Autowired 注解赋值完成后（PS：完成赋值的 Bean 称为成熟 Bean） ，会将目标 Bean 存入到一级缓存。</p>
</li>
<li><p>三级缓存的作用是什么？Spring 中哪些情况下，不能解决循环依赖问题？<br>p156</p>
</li>
<li><p>Spring中的Bean创建的生命周期有哪些步骤<br>大概分为以下几个步骤:<br>1，推断构造方法 ？？<br>2，实例化对象<br>3，填充属性，也就是依赖注入<br>4，处理Aware回调<br>5，初始化前，处理@PostConstruct注解<br>6，初始化，处理InitializingBean接口<br>7，初始化后，进行AOP<br>真正的步骤更加细致，，，，、、、、</p>
</li>
<li><p>ApplicationContext和BeamFactory有什么区别？<br>Beanfactony是Spring中非常核心的组件，表示Bean工厂，可以生成Bean，维护Bean，而AppitcationContext继承了Beanfactony,所以ApplicationContext拥有Beanfacton所有的特点，也是一个Bean工厂，但是AppicationContext除开继承了Beanfacton之外，还继承了诸如EnvronmentCapable、Messaaesource、AppicationEventPubishe等接口，从而ApplicationCcontext还有获取系统环境变量、国际化、事件发布等功能，这是BeanFactory所不具备的</p>
</li>
<li><p>Spring Boot中常用注解及其底层实现</p>
<ul>
<li>@Bean注解:用来定义Bean，类似于XML中的bean&gt;标签，Spring在启动时，会对加了@Bean注解的方法进行折，将方法的名字做为beanName，并通过执行方法得到bean对象</li>
<li>Bean处理<ul>
<li>@Autowired：依赖注入</li>
<li>@Component：泛指组件</li>
<li>@Controller、@Service、@Repository</li>
<li>@RestController</li>
<li>@Configuration</li>
</ul>
</li>
<li>Http请求：@GetMapping、@PostMapping、@PutMapping、@DeleteMapping</li>
<li>前后端参数传递：<ul>
<li>@RequestParam：用在方法的参数前面，获取请求中表单类型的key&#x3D;value格式的数据</li>
<li>@PathVariable：路径变量，参数与大括号里的名字一样要相同</li>
<li>@RequestBody：获取请求body中的数据，常用于搭配@PostMapping请求来提交对象数据</li>
<li>@ResponseBody：表示该方法的返回结果直接写入HTTP response body中，格式为json</li>
</ul>
</li>
<li>读取配置<ul>
<li>@value：直接读取各种配置源的属性名</li>
<li>@ConfigurationProperties：读取配置信息并与 bean 绑定</li>
<li>@PropertySource：指定加载自定义的配置文件</li>
</ul>
</li>
<li>参数校验<ul>
<li>Bean字段验证注解：@Null、@Min()、，，？？</li>
<li>？？@Valid：用于标注验证对象的级联属性</li>
<li>？？@Validated：Spring提供的注解，于SpringMVC一起使用标注方法参数需要检查</li>
</ul>
</li>
<li>统一异常处理<ul>
<li>@ControllerAdvice：注解定义全局异常处理类，包含@Component所以可以被Spring扫描到</li>
<li>@ExceptionHandler：注解声明异常处理方法，表示遇到这个异常，就执行标注的方法</li>
</ul>
</li>
<li>JPA数据持久化<ul>
<li>@Entity：声明数据库实体类</li>
<li>@Table：设置表明</li>
<li>@ld：声明一个字段为主键</li>
<li>@GeneratedValue：声明主键的生成策略</li>
<li>@Column：声明字段，经常用于属性名和表字段的映射</li>
<li>@Transient：指定不需要持久化的字段</li>
<li>@Lob：声明某个字段为大字段</li>
<li>@Enumerated：声明枚举类型的字段</li>
<li>@Modifying：加在DAO方法上，提示是修改操作</li>
<li>@Transactional<ul>
<li>作用于类上：表示所有该类的public 方法都配置相同的事务属性信息</li>
<li>作用于方法上：当类配置了@Transactional，方法也配置了@Transactional，方法的事务会覆盖类的事务配置信息</li>
</ul>
</li>
</ul>
</li>
<li>测试处理<ul>
<li>@ActiveProfiles：常作思于测试类上，用于声明生效的 Spring 配置文件</li>
<li>@Test：声明一个方法为测试方法</li>
<li>@Transactional：被声明的测试方法的数据会回滚，避免污染测试数据</li>
<li>@WithMockUser：Spring Security 提供的，用来模拟一个真实用户，并且可以赋予权限</li>
</ul>
</li>
<li>配置启动<ul>
<li>@SpringBootApplication注解: 这个注解标识了一个SpringBoot工程，它实际上是另外三个注解的组合:<br>  a，@SpringBootConfiguration: 这个注解实际就是一个@Configuration，表示启动类也是一个配置类<br>  b，@EnableAutoConfiguration:向Spring容器中导入了一Seletor，用来加ClassPath下SpringFactoties中所定义的自动配置类，将这些自动为配置Bean<br>  c，@ComponentScan:标识扫描路径，因为赋认是没有配置实际扫描路径，所以SpringBoot扫描的路径是启动类所在的当前目录</li>
<li>@Conditional<ul>
<li>@ConditionalOnBean：配置了某个特定的Bean</li>
<li>@ConditionalOnMissingBean：没有配置特定的Bean           </li>
<li>@ConditionalOnClass：Classpath里有指定的类</li>
<li>@ConditionalOnMissingClass：Classpath里没有指定的类          </li>
<li>@ConditionalOnExpression：给定的SpEL表达式计算结果为true</li>
<li>@ConditionalOnJava：Java的版本匹配特定值或者一个范围值                       </li>
<li>@ConditionalonIndi：参数中给定的INDI位置必须存在一个，如果没有给参数，则要有JNDIInitialContext            </li>
<li>@ConditionalOnProperty：指定的配置属性要有一个明确的值</li>
<li>@ConditionalOnResource：Classpath里没有指定的资源            </li>
<li>@ConditionalOnWebApplication：这是一个Web应用程序</li>
<li>@ConditionalOnNotWebApplication：这不是一个Web应用程序</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>？？说说<strong>SpringBoot自动配置</strong>。<br>1、SpringBoot有着“约定大于配置”的理念，这一理念一定程度上可以用“SpringBoot自动配置”来解释。<br>通过 Spring Boot，我们可以快速开发基于 Spring 生态下的应用程序。<br>2、Spring Boot 约定由于配置的体现有很多，比如：<br>Spring Boot Starter 启动依赖，它能帮我们管理所有 jar 包版本；<br>如果当前应用依赖了 spring mvc 相关的 jar，那么 Spring Boot 会自动内置Tomcat 容器来运行 web 应用，我们不需要再去单独做应用部署；<br>Spring Boot 的自动装配机制的实现中，通过扫描约定路径下的 spring.factories 文件来识别配置类，实现 Bean 的自动装配；<br>默认加载的配置文件 application.properties 等等<br>3、在使用SpringBoot的时候，肯定会依赖于autoconfigure这么一个包，autoconfigure这个包里会有一个spring.factories文件，该文件定义了100+个入口的配置类。比如我们经常使用的redis、kafka等等这样常见的中间件都预置了配置类。当我们在启动SpringBoot项目的时候，内部就会加载这个spring.factories文件，进而去加载“有需要”的配置类。那我们在使用相关组件的时候，就会非常的方便（因为配置类已经初始化了一大部分配置信息）。一般我们只要在application配置文件写上对应的配置，就能通过各种template类直接操作对应的组件啦。<br>4、不是所有的配置类都会加载的，假设我们没有引入redis-starter的包，那Redis的配置类就不会被加载。具体Spring在实现的时候就是使用<code>@ConditionalXXX</code>进行判断的。比如Redis的配置类就会有@ConditionalOnClass({RedisOperations.class})的配置，说明当前环境下如果有RedisOperations.class这个字节码，才会去加载Redis的配置类。</p>
</li>
<li><p>？？Spring Boot 中自动装配机制的原理。<br>自动装配，简单来说就是自动把第三方组件的 Bean 装载到 Spring IOC 器里面，不需要开发人员再去写 Bean 的装配配置。在 Spring Boot 应用里面，只需要在启动类加上 <strong>@SpringBootApplication</strong> 注解就可以实现自动装配。<br>@SpringBootApplication 是一个复合注解，真正实现自动装配的注解是 <strong>@EnableAutoConfiguration</strong>。自动装配的实现主要依靠三个核心关键技术。<br>1、引入 Starter 启动依赖组件的时候，这个组件里面必须要包含@Configuration 配置类，在这个配置类里面通过@Bean 注解声明需要装配到 IOC 容器的 Bean 对象。<br>2、这个配置类是放在第三方的 jar 包里面，然后通过 SpringBoot 中的约定优于配置思想，把这个配置类的全路径放在 classpath:&#x2F;META-INF&#x2F;spring.factories 文件中。这样 SpringBoot 就可以知道第三方 jar 包里面的配置类的位置，这个步骤主要是用到了 Spring 里面的 SpringFactoriesLoader 来完成的。<br>3、SpringBoot 拿到所第三方 jar 包里面声明的配置类以后，再通过 Spring 提供的ImportSelector 接口，实现对这些配置类的动态加载。<br>在我看来，SpringBoot 是约定优于配置这一理念下的产物，所以在很多的地方，都会看到这类的思想。它的出现，让开发人员更加聚焦在了业务代码的编写上，而不需要去关心和业务无关的配置。其实，自动装配的思想，在 SpringFramework3.x 版本里面的@Enable 注解，就有了实现的雏形。@Enable 注解是模块驱动的意思，我们只需要增加某个@Enable 注解，就自动打开某个功能，而不需要针对这个功能去做 Bean 的配置，@Enable 底层也是帮我们去自动完成这个模块相关 Bean 的注入。以上，就是我对 Spring Boot 自动装配机制的理解。</p>
</li>
<li><p>Spring Boot 属性源<br>1.命令行参数<br>2.JVM系统属性<br>3.操作系统环境变量<br>4.打包在应用程序内的 application.properties 或者 application.yml 文件<br>5.通过 @PropertySource 标注的属性源<br>6.默认属性</p>
</li>
<li><p>你对SpringBoot starter的理解？<br>starter这东西就是为了方便调用方去使用相关的组件的嘛，Spring框架也给我们实现了很多好用的starter。<br>比如以前我们要用Mybatis框架，可能会引入各种的包才能使用。而starter就是做了一层封装，把相关要用到的jar都给包起来了，并且也写好了对应的版本。这我们使用的时候就不需要引入一堆jar包且管理版本类似的问题了。<br>最后聊下你是怎么看这块源码的？？思路：我先从启动类开始，会有个@SpringBootApplication，后面会定位到一个自动配置的注解@EnableAutoConfiguration，那最后就能看到注解内部会去META-INF&#x2F;spring.factories加载配置类 </p>
</li>
<li><p>Spring Boot是如何启动Tomcat的<br>1，首先，SpringBoot在启动时会先创建一个Spring容器<br>2，在创建 Spring容器过程中，会利用 @ConditionalOnClass 技术来判断当前 classpath中是否存在 Tomcat 依赖，如果存在则会生成一个启动 tomcat 的Bean<br>3，Spring 容器创建完之后，就会获取启动 Tomcat 的Bean，并创建 Tomcat 对象，并绑定端口等，然后启动 Tomcat<br>（ Spring Boot内嵌tomcat，与springmvc启动tomcat过程相反？？</p>
</li>
<li><p>Spring Cloud和 Dubbo有哪些区别?<br>Spring cloud是一个微服务框架，提供了微服务领域中的很多功能组件，Dubbo以开始是一个RPC调用框架，核心是解决服务调用间的问题，Springcloud是一个大而全框架，Dubbo则更侧重于服务调用，所以Dubbo所提供的功能没有Springcloud全面，但Dubbo的服务调用性能Springcloud高，不过并不对立的，是可以结合起来一起使用的。</p>
</li>
<li><p><strong>Spring中常见的设计模式。</strong><br><strong>1，工厂模式</strong>：Spring通过工厂模式实现了IOC（Inversion of Control）容器，使得对象的创建和管理被委托给了Spring容器，而不是由应用程序代码直接实例化对象。<br><strong>2，单例模式</strong>：Spring默认情况下，容器中的Bean是单例的，即每个容器中的Bean只有一个实例。这有助于提高性能和减少资源消耗。<br><strong>3，代理模式</strong>：Spring AOP就是通过代理模式实现的。AOP允许开发者在不修改原始代码的情况下，插入和控制横切关注点，如日志、事务等。<br>4，观察者模式：Spring的事件机制是基于观察者模式的。通过定义事件和监听器，应用程序可以订阅感兴趣的事件，从而实现松耦合的通信机制。<br><strong>5，模板方法模式</strong>： 在Spring中，JdbcTemplate 和 RedisTemplate 等模板类使用了模板方法模式，将通用的任务实现在模板方法中，而将具体实现留给子类。<br>6，策略模式：Spring的资源加载、事务管理等功能使用了策略模式，通过定义一组算法族，分别封装起来，并使它们可以相互替换。<br>7，适配器模式：Spring的AOP中，通知（Advice）就是一种适配器模式的应用。通知包装了一个切面逻辑，使得它可以在切点（Join Point）上执行。<br>8，建造者模式： Spring框架中的<code>BeanDefinitionBuilder</code>等类使用了建造者模式，通过流畅的接口构建复杂对象。<br>这些设计模式使得Spring框架具有高度的可扩展性、灵活性和易维护性。Spring的设计理念强调面向接口编程、依赖注入、松耦合等原则，从而使得应用程序更容易进行测试、扩展和维护。</p>
</li>
<li><p>??单例Bean和单例模式<br>单例模式表示JVM中某个类的对象只会存在唯一一个。<br>而单例Bean并不表示JVM中只能存在唯一的某个类的Bean对象。</p>
</li>
</ul>
<h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><ul>
<li><p>什么是 Mybatis？<br>1、Mybatis 是一个开源的<strong>Java持久层框架</strong>，半 ORM（对象关系映射）框架，它内部封装了  JDBC，开发时只需要关注 SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement 等繁杂的过程。程序员直接编写原生态 sql，可以严格控制 sql 执行性能，灵活度高。（JDBC（Java Database Connectivity）是 Java 语言用于与关系型数据库进行交互的一种标准接口。JDBC 提供了一组 Java API，允许开发者通过 Java 代码来执行 SQL 查询、更新数据库、以及处理数据库事务等操作。）<br>2、MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO 映射成数据库中的记录，避免了几乎所有的  JDBC 代码和手动设置参数以及获取结果集。<br>3、通过 xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过 java 对象和 statement 中 sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为  java 对象并返回。（从执行 sql 到返回 result 的过程）。</p>
</li>
<li><p>ORM，DAO，持久层？<br>ORM 和 DAO 是持久层的实现方式，ORM 和 DAO 通常一起协同工作，以实现数据的持久化和访问。持久层包括了使用 ORM 框架进行对象和数据库映射的方式，以及使用 DAO 设计模式封装数据访问操作的方式。DAO 提供了数据访问的通用接口，业务逻辑层通过 DAO 来进行数据访问，从而实现了持久层的解耦。</p>
</li>
<li><p>一般 JDBC 执行 SQL 查询或更新操作的流程涉及以下步骤：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 加载数据库驱动</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>); </span><br><span class="line"><span class="comment">//2. 建立数据库连接</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/mydatabase&quot;</span>, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;password&quot;</span>);</span><br><span class="line"><span class="comment">//3. 创建 Statement 或 PreparedStatement 对象</span></span><br><span class="line"><span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line"><span class="comment">//4. 执行 SQL 语句</span></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery(<span class="string">&quot;SELECT * FROM mytable&quot;</span>);</span><br><span class="line"><span class="comment">//5. 处理结果集（如果有）</span></span><br><span class="line"><span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">    <span class="comment">// 处理查询结果</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6. 关闭资源：方法关闭 ResultSet、Statement 和 Connection 对象，释放数据库连接和资源。</span></span><br><span class="line">resultSet.close();</span><br><span class="line">statement.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure>
</li>
<li><p>Mybatis的优缺点，适用场合。</p>
<ul>
<li>优点:<br>  1.基于 SQL 编程，相当灵活，不会对应用程序或者数据库的现有设计成任何影响，SQL 写在 XML 里，解除 sql 与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态 SQL 语句，并可重用。<br>  2.与 JDBC 相比，减少了 50%以上的代码量，消除了JDBC 大量几余的代码，不需要手动开关连接;<br>  3.很好的与各种数据库兼容(因为 Myatis 使用JDBC 来连接数据库，所以只要 JDBC 支持的数据库 MyBatis 都支持)。<br>  4.能够与Spring 很好的集成;<br>  5.提供映射标签，支持对象与数据库的 ORM 字段关系映射;提供对象关系映射标签，支持对象关系组件维护。</li>
<li>缺点:<br>  1.SQL 语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL 语句的功底有一定要求.<br>  2.SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</li>
<li>MyBatis 框架适用场合<br>  1、MyBatis 专注于 SQL 本身，是一个足够灵活的 DAO 层解决方案。<br>  2、对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis 将是不错的选择。</li>
</ul>
</li>
<li><p>#{} 与 ${} 的区别？<br>  两种占位符，都是实现动态sql的方式，可以把参数传递到xml中，执行操作前，mybatis会对这两个占位符进行动态解析</p>
<ol>
<li><strong><code>#&#123;&#125;</code>（预编译）</strong>：<code>#&#123;&#125;</code> 是 MyBatis 的预处理语法，会在 SQL 中使用占位符 <code>?</code> 的形式，通过预编译的方式来处理参数，可以有效防止 SQL 注入攻击。使用 <code>#&#123;&#125;</code> 时，MyBatis 会将传入的参数值转义并进行预编译，同时会根据参数的类型决定使用不同的 JDBC 类型。这种方式可以确保 SQL 的安全性。</li>
<li><strong><code>$&#123;&#125;</code>（拼接字符串）</strong>：<code>$&#123;&#125;</code> 是 MyBatis 的字符串替换语法，会直接将传入的参数值以字符串的形式拼接到 SQL 语句中。使用 <code>$&#123;&#125;</code> 时，需要注意潜在的 SQL 注入风险，因为参数值会直接替换到 SQL 语句中，不会进行预编译。</li>
<li><code>#&#123;&#125;</code> 适用于参数值，防止 SQL 注入，用于预编译。<code>$&#123;&#125;</code> 适用于非参数值，直接将参数值拼接到 SQL 语句中。在开发中，推荐使用 <code>#&#123;&#125;</code> 来处理参数，以保障 SQL 的安全性。<code>$&#123;&#125;</code> 的使用应谨慎，尽量避免直接将用户输入的数据用于 <code>$&#123;&#125;</code> 形式的参数。</li>
</ol>
</li>
<li><p>当实体类中的属性名和表中的字段名不一样，怎么办 ？</p>
<ol>
<li>使用注解映射：ORM 框架（如 Hibernate）提供了注解（如 @Column）来映射实体类属性和数据库表字段之间的关系。<br>  可以在实体类的属性上使用注解，指定属性与表字段的映射关系  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;my_table&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyEntity</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;column_name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// other fields and methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  优点：灵活，可以通过注解直接在实体类中定义映射关系，不需要修改数据库表结构。<br>  缺点：如果数据库表结构已经存在，需要在实体类中添加注解进行映射，可能会导致代码中出现大量注解。</li>
<li>通过在查询的 sql 语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="keyword">select</span> id<span class="operator">=</span>”selectorder” parametertype<span class="operator">=</span>”<span class="type">int</span>” resultetype<span class="operator">=</span>”me.gacl.domain.order”<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">select</span> order_id id, order_no orderno ,order_price price form orders <span class="keyword">where</span> order_id<span class="operator">=</span>#&#123;id&#125;;</span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">select</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>通过 resultMap 映射字段名和实体类属性名的一一对应的关系。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="keyword">select</span> id<span class="operator">=</span>&quot;getOrder&quot; parameterType<span class="operator">=</span>&quot;int&quot; resultMap<span class="operator">=</span>&quot;orderresultmap&quot;<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> orders <span class="keyword">where</span> order_id<span class="operator">=</span>#&#123;id&#125;</span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">select</span><span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span>resultMap type<span class="operator">=</span>”me.gacl.domain.order” id<span class="operator">=</span>”orderresultmap”<span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span><span class="operator">!</span>–用 id 属性来映射主键字段–<span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span>id property<span class="operator">=</span>”id” <span class="keyword">column</span><span class="operator">=</span>”order_id”<span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span><span class="operator">!</span>–用 <span class="keyword">result</span> 属性来映射非主键字段，property 为实体类属性名，<span class="keyword">column</span>为数据表中的属性–<span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span><span class="keyword">result</span> property <span class="operator">=</span> “orderno” <span class="keyword">column</span> <span class="operator">=</span>”order_no”<span class="operator">/</span><span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span><span class="keyword">result</span> property<span class="operator">=</span>”price” <span class="keyword">column</span><span class="operator">=</span>”order_price” <span class="operator">/</span><span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span>reslutMap<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
  优点：将映射关系从代码中分离出来，使得配置更加灵活。<br>  缺点：需要额外的配置文件，增加了维护成本。</li>
</ol>
</li>
<li><p>模糊查询 like 语句该怎么写?<br>,,、、</p>
</li>
<li><p>???通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？<br>Dao 接口里的方法，参数不同时，方法能重载吗？Dao 接口即 Mapper 接口。接口的全限名，就是映射文件中的 namespace 的值；接口的方法名，就是映射文件中 Mapper 的 Statement的 id 值；接口方法内的参数，就是传递给 sql 的参数。Mapper 接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个 MapperStatement。在 Mybatis 中，每一个<br>，，、、</p>
</li>
<li><p>、、</p>
</li>
<li><p>？？？Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？<br>Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询。在 Mybatis配置文件中，可以配置是否启用延迟加载 lazyLoadingEnabled&#x3D;true|false。<br>它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName()，拦截器 invoke()方法发现 a.getB()是null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()方法的调用。这就是延迟加载的基本原理。<br>当然了，不光是 Mybatis，几乎所有的包括 Hibernate，支持延迟加载的原理都是一样的。</p>
</li>
<li><p>？？？Mybatis 的一级、二级缓存<br>1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。<br>2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态),可在它的映射文件中配置 ；<br>3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session&#x2F;二级缓存Namespaces)的进行了 C&#x2F;U&#x2F;D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>
</li>
<li><p>Mybatis是怎么分页的？<br>  逻辑分页：先查出数据，如何自己编写逻辑实现分页；物理分页：使用mysql提供的分页关键词limit<br>  Mybatis提供了 3 种分页方式：</p>
<ol>
<li>mybatis mapper配置文件写分页sql，直接在select语句里面加limit</li>
<li>？？使用mybatis提供的RowBounds对象，实现内存级的分页</li>
<li>？？基于mybatis中的Interceptor拦截器，在select语句执行之前动态拼接分页关键字</li>
</ol>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/10/12/%E9%9D%A2%E8%AF%95_Java/" data-id="cls3bhyy00011sgv5ayvhb4w7" data-title="面 逝 | Java" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/10/13/%E9%9D%A2%E8%AF%95_%E4%B8%AA%E4%BA%BA/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          面 逝 | 个人
        
      </div>
    </a>
  
  
    <a href="/2023/10/11/%E9%9D%A2%E8%AF%95_%E7%BB%84%E4%BB%B6/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">面 逝 | 组件</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2046/12/">December 2046</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2046/12/30/nice-photo/">Nice Photo</a>
          </li>
        
          <li>
            <a href="/2024/01/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
          </li>
        
          <li>
            <a href="/2024/01/11/RabbitMQ/">RabbitMQ</a>
          </li>
        
          <li>
            <a href="/2024/01/10/Redis/">Redis</a>
          </li>
        
          <li>
            <a href="/2024/01/07/SpringCloud/">SpringCloud</a>
          </li>
        
          <li>
            <a href="/2024/01/04/%E9%AA%8F%E4%BC%AF/">骏 伯</a>
          </li>
        
          <li>
            <a href="/2023/10/13/%E9%9D%A2%E8%AF%95_%E4%B8%AA%E4%BA%BA/">面 逝 | 个人</a>
          </li>
        
          <li>
            <a href="/2023/10/12/%E9%9D%A2%E8%AF%95_Java/">面 逝 | Java</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 fengcai<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>