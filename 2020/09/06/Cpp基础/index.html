<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>C++ 基础 | Qué miras Bobo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Cpp 是一种通用编程语言，它扩展了 C 语言，加入了面向对象编程的特性。 数据类型 数据类型 简单类型 基本类型： 整型：int通常是机器的最自然大小，占4B。short：短整数 2B。long：长整数，4 或 8B(取决于编译器和系统)。long long：长长整数，至少64位(8 byte)。INT_MIN &#x3D; -2147483648 &#x3D; 1 + INT_MAX 浮点型：">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 基础">
<meta property="og:url" content="http://example.com/2020/09/06/Cpp%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Qué miras Bobo">
<meta property="og:description" content="Cpp 是一种通用编程语言，它扩展了 C 语言，加入了面向对象编程的特性。 数据类型 数据类型 简单类型 基本类型： 整型：int通常是机器的最自然大小，占4B。short：短整数 2B。long：长整数，4 或 8B(取决于编译器和系统)。long long：长长整数，至少64位(8 byte)。INT_MIN &#x3D; -2147483648 &#x3D; 1 + INT_MAX 浮点型：">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-09-06T08:23:20.000Z">
<meta property="article:modified_time" content="2023-12-27T04:46:28.003Z">
<meta property="article:author" content="fengcai">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Qué miras Bobo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="https://github.com/leo710aka/bk/blob/main/DT1.jpg?raw=true">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Qué miras Bobo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Cpp基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/09/06/Cpp%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2020-09-06T08:23:20.000Z" itemprop="datePublished">2020-09-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      C++ 基础
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><em>Cpp</em> 是一种通用编程语言，它扩展了 C 语言，加入了面向对象编程的特性。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>数据类型<ol>
<li>简单类型<ul>
<li>基本类型：<ul>
<li><strong>整型</strong>：<strong>int</strong>通常是机器的最自然大小，占<strong>4B</strong>。short：短整数 2B。long：长整数，4 或 8B(取决于编译器和系统)。long long：长长整数，至少64位(8 byte)。INT_MIN &#x3D; -2147483648 &#x3D; 1 + INT_MAX</li>
<li><strong>浮点型</strong>：float 单精度浮点数 4B；double双精度 8B；long double 8B 或 16B。</li>
<li><strong>字符型</strong>：C++ 中表示字符的基本类型<code>char</code>，通常是 1B。字符用 ASCII 编码，以 ASCII 值参与运算</li>
<li>空类型 void</li>
</ul>
</li>
<li>用户定义类型：枚举类型 enum</li>
</ul>
</li>
<li>结构类型：数组 [ ]，结构 struct，联合 union，类 class</li>
<li>指针类型（*）<table>
<thead>
<tr>
<th>类型</th>
<th>长度（字节）</th>
<th>表示范围</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>1</td>
<td>-128 ~ 127</td>
<td>-2^7 ~ 2^7-1</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>-2147483648 ~ 2147483647</td>
<td>-2^31 ~ 2^31-1</td>
</tr>
<tr>
<td>double双精度型</td>
<td>8</td>
<td>-1.7<em>10^308 ~ 1.7</em>10^308</td>
<td>15位有效数字</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><code>十六进制</code>[hexadecimal]：使用数字 0-9 和字母 A-F（或 a-f）来表示数值，每个十六进制位对应四个二进制位。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> hexValue = <span class="number">0x1A3F</span>;        <span class="comment">// 0x 表示十六进制，用位运算进行十六进制的操作，输出时显示为二进制</span></span><br><span class="line">cout &lt;&lt; hex &lt;&lt; value &lt;&lt; endl; <span class="comment">// 使用iomanip中的 hex 控制符来设置输出为十六进制格式</span></span><br></pre></td></tr></table></figure></li>
<li><code>ASCII码</code>：是一种将字符映射到数字的编码标准。ASCII码用于表示键盘上的字符，每个字符都对应一个唯一的数字。<br>0-“\0”(空字符,字符串结束标志)、9-“\t”(制表符：四个空格)、10-“\n”(换行符)、32-“ “(空格)<br>48-“0”(字符0)、65-“A”、 97-“a” 大小写差32（tolower()大写字符转换为小写）<br>转义字符 “\ character”：以 “\” 为前缀，表示改变后面 character 符号或整数值的意义，使其成为控制符或字符值。</li>
<li>char16_t：UTF-16字符类型。 char32_t：UTF-32字符类型。char16&#x2F;32_t 是引入的字符类型，用于支持 <code>Unicode</code> 字符。</li>
<li>类型转换<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">65</span>; string b = <span class="string">&#x27;9&#x27;</span>, s = <span class="string">&quot;80&quot;</span>;</span><br><span class="line"><span class="type">char</span> c = (<span class="type">char</span>)a;         <span class="comment">// ASCII -&gt; char: 65 -&gt; &#x27;65&#x27; 类型强制转换或显式转换</span></span><br><span class="line"><span class="type">char</span> d = a + <span class="string">&#x27;0&#x27;</span>;         <span class="comment">// int -&gt; char: 65 + &#x27;0&#x27; -&gt; &#x27;65&#x27;</span></span><br><span class="line"><span class="type">int</span> e = b - <span class="string">&#x27;0&#x27;</span>;          <span class="comment">// char -&gt; int: &#x27;9&#x27; - &#x27;0&#x27; -&gt; 9</span></span><br><span class="line"><span class="type">int</span> f = <span class="built_in">stoi</span>(s);          <span class="comment">// string -&gt; int</span></span><br><span class="line">string g = <span class="built_in">to_string</span>(a);  <span class="comment">// int - &gt; string</span></span><br></pre></td></tr></table></figure></li>
<li>常量<ul>
<li><strong>字面常量</strong>：字面常量是源代码中的常量值。例如，整数字面常量（ <code>5</code>、<code>-10</code>）、浮点数字面常量（ <code>3.14</code>、<code>-0.001</code>）、字符常量（<code>&#39;a&#39;</code>、<code>&#39;B&#39;</code>）、字符串字面常量（<code>&quot;Hello&quot;</code>、<code>&quot;C++&quot;</code>）等。值在程序编译时就已经确定。</li>
<li><strong>const 关键字创建的常量</strong>：在C++中，可以使用 <code>const</code> 关键字创建常量变量。这些变量在声明时被初始化，并且一旦被赋值后就不能再修改其值。例如：const double PI &#x3D; 3.14159;</li>
<li><strong>枚举常量（Enumeration Constants）</strong>：使用 <code>enum</code> 关键字定义的枚举类型也可以产生常量。枚举常量是一组具有整数值的符号常量。例如：enum Day { MON, TUE, WED, THU, FRI, SAT, SUN };</li>
</ul>
</li>
</ul>
<h3 id="数据访问"><a href="#数据访问" class="headerlink" title="数据访问"></a>数据访问</h3><ul>
<li>名访问：程序被编译后，系统对已声明对象保存一张名表，登记对象的属性 &lt; 名字，类型，地址 &gt;</li>
<li>地址访问<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span>  b  <span class="comment">// &lt; b, double, 0X0066FDEC &gt;</span></span><br><span class="line">&amp;b         <span class="comment">// 取对象b的地址	</span></span><br><span class="line">b          <span class="comment">// 访问对象b	</span></span><br><span class="line">*(&amp;b)      <span class="comment">// 间址访问		</span></span><br></pre></td></tr></table></figure></li>
<li>指针变量：能够存放对象地址的变量。定义形式：类型  * 标识符 ;<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * iptr; <span class="comment">// iptr 是指向整型对象的指针，可以存放一个整型变量的地址</span></span><br><span class="line"><span class="type">char</span> * s ;	  <span class="comment">// s 是指向字符对象的指针</span></span><br><span class="line"><span class="type">int</span>  ** p2;  <span class="type">int</span>  * p1;  <span class="type">int</span>  i = <span class="number">3</span>;  p1 = &amp; i;  p2 = &amp; p1; <span class="comment">// 指向指针的指针 </span></span><br></pre></td></tr></table></figure></li>
<li>引用：引用说明为对象建立引用名，即别名；<ul>
<li>引用在定义初始化时与对象名绑定，程序中不能对引用重定义；一个对象的别名，从使用方式和效果上与使用对象名一致 </li>
<li>定义形式:	类型 &amp; 引用名 &#x3D; 对象名 ；</li>
</ul>
</li>
<li>指向常量的指针 ：间址访问只读。定义形式：const 类型 * 指针 或 类型  const * 指针</li>
<li>指针常量：指针常量的值只能在定义的时候初始化。定义形式：类型  * const 指针</li>
<li>常引用：const  类型  &amp; 引用名  &#x3D; 对象名 ;</li>
</ul>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><ul>
<li>类型转换：表达式求值之前，要对操作数进行必要的类型转换<ol>
<li>将短数扩展为机器处理的长度：参与算术运算的只有5种类型数据<br>  char、short -&gt; int，unsigned char、unsigned short -&gt; unsigned int，float -&gt; double、long、unsigned long</li>
<li>使运算符两端的操作数具有相同的类型： “向高看齐”，向表达能力强的类型转换；逐个算符转换</li>
</ol>
</li>
<li>运算符的优先关系<ul>
<li>单目运算符 &gt; 乘除运算 &gt; 加减运算 &gt; 关系运算 &gt; 逻辑与 &gt; 逻辑或 &gt; 赋值 &gt; 逗号</li>
<li>i + 1 &lt; j * 4 &amp;&amp; ! P || Q  等价于 :    ( ( ( i +1 ) &lt; ( j * 4 ) ) &amp;&amp; ( ! P ) ) || Q</li>
<li>P !&#x3D; i &lt; j || Q &amp;&amp; S       等价于 :    ( P !&#x3D; ( i &lt; j ) ) || ( Q &amp;&amp; S )</li>
</ul>
</li>
<li>自增、自减<ul>
<li>前缀式：先增值后引用	例：x &#x3D; ++ i 	相当于	i &#x3D; i + 1 ;    x &#x3D; i ;</li>
<li>后缀式：先引用后增值	例：x &#x3D; i ++ 	相当于	x &#x3D; i ;     i &#x3D; i + 1 ; </li>
<li>自增、自减算符的运算对象只能是整型变量，不能为常量或表达式</li>
</ul>
</li>
<li>位运算<ul>
<li>16进制表示:  0xff -&gt; 1111 1111  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">3</span>;        <span class="comment">// a 二进制: 0101, b 二进制: 0011</span></span><br><span class="line"><span class="type">int</span> andResult = a &amp; b;   <span class="comment">// 0001 (1) 按位与 `&amp;`</span></span><br><span class="line"><span class="type">int</span> orResult = a | b;    <span class="comment">// 0111 (7) 按位或 `|`</span></span><br><span class="line"><span class="type">int</span> xorResult= a ^ b;    <span class="comment">// 0110 (6) 按位异或 `^`</span></span><br><span class="line"><span class="type">int</span> notA = ~a;           <span class="comment">// 1010 (-6 in two&#x27;s complement representation) 按位取反 `~`</span></span><br><span class="line"><span class="type">int</span> leftShift = a &lt;&lt; <span class="number">1</span>;  <span class="comment">// 1010 (10) 左移&lt;&lt;：将操作数的每个位向左移动指定的位数，右侧用零填充</span></span><br><span class="line"><span class="type">int</span> rightShift= a &gt;&gt; <span class="number">1</span>;  <span class="comment">// 0010(2) 右移&gt;&gt;：每个位右移指定位数，左侧用符号位(对于有符号数)或零填充</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="程序控制结构"><a href="#程序控制结构" class="headerlink" title="程序控制结构"></a>程序控制结构</h3><ul>
<li>所有程序都只能包含三种控制结构：顺序结构、选择结构和循环结构</li>
<li>if 语句，while语句，do-while语句，for语句</li>
<li>switch语句：根据一个整型表达式的值决定程序分支 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)</span><br><span class="line">&#123;   <span class="keyword">case</span> 常量表达式 <span class="number">1</span> : 语句 <span class="number">1</span>  <span class="comment">// case 标签是用来匹配 switch 后面表达式的值，执行相应的代码</span></span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">case</span> 常量表达式 n : 语句 n</span><br><span class="line">    <span class="keyword">default</span> : 语句 n+<span class="number">1</span>        <span class="comment">// 如果没有任何一个 case 匹配成功，用 default 标签来执行默认的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
表达式类型为非浮点型；各常量表达式类型要与之匹配；各常量表达式要求各不相等；default 子句可选。<br>缺省时，没有匹配值 switch 语句为空<br>case 和 default 仅起语句标号作用，不能控制程序流程；一旦选中一个case分支后，将继续往下顺序执行（剩余所有）语句序列。添加 break 语句可以跳出 switch 语句体，达到控制流程作用</li>
</ul>
<hr>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ul>
<li><code>库函数</code>：预定义的函数，它们提供了各种功能，可以通过包含相应的头文件来使用。<br>C++标准库是一个包含许多有用函数和类的集合，可以使用这些函数和类来构建程序，而不必从头开始编写所有功能。<br><strong>iostream</strong> 是一个C++标准库的头文件，提供了输入输出操作，包括 cin 和 cout。<br><strong>cmath</strong> 是另一个头文件，提供了数学函数如 指数函数pow(10.0, 2)、平方根sqrt()、三角cos()、绝对值abs() 等。<br><strong>algorithm</strong> 中含有sort()、reverse()、swap()等函数。<br><strong>string</strong> 是一个代表字符串string的类，它封装了许多处理字符串的函数和操作符。如substr()、find()函数等。<br><strong>vector</strong> vec.size()获取 vector 的大小</li>
<li><code>命名空间</code>：是用于组织代码标识符（如变量、函数、类等）的一种方式，以避免命名冲突。命名空间允许你在不同的命名空间中定义相同名称的标识符，从而使不同部分的代码可以使用相同的名字而不会产生冲突。C++标准库中的函数和类通常被放置在一个叫做 std 的命名空间中。你可以使用命名空间限定符 std:: 来访问其中的成员。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// 这是一个预处理指令，用于包含C++标准库中的 `iostream` 头文件。这个头文件包含了用于输入输出的流对象（如 `cin` 和 `cout`）以及其他相关函数。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;    <span class="comment">// 这是一个命名空间声明。`std` 是C++标准库的命名空间，包含了许多标准函数、对象和类。通过使用 `using namespace std;`，你可以在代码中直接使用 `cout` 和 `endl`，而无需在前面加上 `std::` 前缀。注意，虽然使用 using namespace std; 可以简化代码，但在大型项目中，为了避免命名冲突，可能会选择显式地使用命名空间限定符。</span></span><br></pre></td></tr></table></figure></li>
<li>函数定义形式：类型 函数名（形式参数表） { 语句序列 }</li>
<li>函数调用形式：函数名（实际参数表）</li>
<li>函数原型：作用是告诉编译器有关函数的信息：函数的名字、函数返回的数据类型、函数要接受的参数个数、参数类型和参数的顺序；编译器根据函数原型检查函数调用的正确性。函数原型的形式：类型 函数名（形式参数表）;</li>
<li>函数参数的传递：值传递，指针传递，引用传递 </li>
<li>传值参数：调用函数时，实参表达式的值被复制到相应形参标识的对象中，并按形参类型强制转换；函数内对形参的访问、修改，都在形参的标识对象进行；函数返回时，形参对象被撤消，不影响实参的值；值传送的实参可以是常量、有确定值的变量或表达式；函数返回值通过匿名对象传递<table>
<thead>
<tr>
<th></th>
<th>丨函数 FunctionObj</th>
<th>丨数据 DataObj</th>
<th>丨数组 DataObj</th>
</tr>
</thead>
<tbody><tr>
<td>地址</td>
<td>丨FunctionObj、&amp;FunctionObj、<em>FunctionObj、</em>&amp;FunctionObj</td>
<td>丨&amp;DataObj</td>
<td>丨第i行第j列元素：a[i]+j、*(a+i)+j、&amp;a[i][j]</td>
</tr>
</tbody></table>
</li>
<li>函数、应用程序是编译器处理的对象，每一个函数模块都有一个首地址，称为函数的入口地址。<br>函数调用：找到函数入口地址；传递参数。函数入口地址：就是不带括号的函数名。<br>  函数指针：指向函数的指针变量，值为函数的入口地址。函数的类型是函数的接口，可以通过指针变量的间址方式调用函数<ul>
<li>若有函数类型为：double  ( double, double ) ;  或 typedef double  functionType  ( double, double ) ;</li>
<li>定义指向这类函数的指针变量：double  ( * fp ) ( double, double );  或 functionType  * fp1 ,  * fp2 ;</li>
</ul>
</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul>
<li>结构由数目固定的成员构成，各成员可以具有不同的数据类型，一个结构变量在内存占有一片连续的存储空间</li>
<li>结构类型定义形式为：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>  标识符</span><br><span class="line">&#123;  类型   成员<span class="number">1</span> ;</span><br><span class="line">   …</span><br><span class="line">   类型   成员n ;</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure></li>
<li>可以用不同方法定义一个结构变量：(1) 声明类型之后声明变量 (2)声明类型的同时声明变量 (3)直接声明结构类型变量</li>
<li>访问结构变量的成员：（1）结构变量.成员 （2）结构指针 -&gt; 成员， (*结构指针 ) . 成员</li>
</ul>
<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><p>C++的STL（Standard Template Library，标准模板库）是C++标准库的一部分，它提供了一组通用的模板类和函数，用于实现常见的数据结构和算法。STL的设计目标是提供高效、通用、可复用的组件，以帮助开发者编写更加优雅和高效的C++代码。</p>
<ol>
<li>容器（Containers）：容器是用于存储和管理一组对象的类模板。STL提供多种容器，每个容器都有不同的特性和适用场景。<br><code>vector</code>：动态数组，支持快速的随机访问，底层实现是array，封装后使用更友好。<code>list</code>：双向链表，支持在任意位置插入和删除元素。<code>deque</code>：双端队列，类似于动态数组。<code>map</code>：关联数组，使用键值对存储数据。<code>set</code>：集合，存储不重复的值。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(cost.size() + <span class="number">1</span>)</span></span>;               <span class="comment">// 指定数据类型、数组大小</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">3</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>));     <span class="comment">// 创建一个包含3行4列的二维 vector</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;  </span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());                  <span class="comment">// 利用迭代器排序</span></span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="number">4</span>);  vec.<span class="built_in">pop_back</span>();             <span class="comment">// 添加数据、移除末尾元素</span></span><br></pre></td></tr></table></figure></li>
<li>算法（Algorithms）：STL提供了一组强大的通用算法，这些算法可以用于各种容器类型。这些算法涵盖了排序、查找、遍历、变换等多种操作。一些常见的算法包括： <code>sort</code>：对容器中的元素进行排序。<code>find</code>：在容器中查找特定元素。<code>for_each</code>：对容器中的每个元素执行操作。<code>transform</code>：将容器中的元素进行转换操作。</li>
<li>迭代器（Iterators）：迭代器用于遍历容器中的元素，提供了统一的访问接口，使得代码更具可扩展性。迭代器分为多种类型，包括输入迭代器、输出迭代器、前向迭代器、双向迭代器和随机访问迭代器。(begin()、end()、++、–、* 、&#x3D;&#x3D; 和 !&#x3D;)</li>
<li>函数对象（Function Objects）：函数对象是类的实例，可以像函数一样被调用。STL的算法和其他组件允许你使用函数对象来执行操作，或者使用标准库提供的一些预定义的函数对象。</li>
<li>适配器（Adapters）：适配器是用于转换或扩展容器或迭代器接口的类模板。例如，<code>std::stack</code> 是一个基于双端队列的堆栈容器适配器，<code>std::queue</code> 是一个基于双端队列的队列容器适配器。</li>
</ol>
<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><ul>
<li>通常通过标准库中的 <code>iostream</code> 完成，包括 <code>cin</code> 用于从用户获取数据， <code>cout</code> 向屏幕输出数据，<code>endl</code> 输出一个换行符。</li>
<li>格式化输出：用到 <code>iomanip</code> 库<br><strong>setw 和 setfill</strong>：这两个函数可以用来设置输出的宽度和填充字符。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; <span class="number">42</span>;  <span class="comment">// 将数字 42 输出为 &quot;000042&quot;，总宽度为 6，使用 &#x27;0&#x27; 填充</span></span><br></pre></td></tr></table></figure>
<strong>fixed + setprecision</strong>：用于输出指定小数位数的浮点数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; <span class="number">3.1415926</span>;</span><br></pre></td></tr></table></figure></li>
<li>如果要处理多行输入可以使用 <code>getline</code> 函数，需要包含 <code>iostream</code> 头文件<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line">string input; </span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line"><span class="built_in">getline</span>(cin, input);         <span class="comment">// 读取整行输入：1 -1 -1 0</span></span><br><span class="line"><span class="function">istringstream <span class="title">ss</span><span class="params">(input)</span></span>;     <span class="comment">// 使用 istringstream 来分割数字</span></span><br><span class="line"><span class="keyword">while</span> (ss &gt;&gt; number) &#123;```&#125;   <span class="comment">// 逐个获取数字</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>

<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>时间复杂度是一种用来衡量算法运行时间与输入规模之间关系的概念。它不是用来精确测量程序运行时间的，而是描述在输入规模变化时，算法运行时间的增长趋势。</li>
<li>大O表示上界，当用它作为算法的最坏情况运行时间的上界，就是对任意数据输入的运行时间的上界。<br>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!)</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li>数组（Array）是有序的元素序列。数组是一种固定大小的数据结构，用于存储相同类型的元素。在C++中，数组的长度在创建时就固定了，无法在运行时改变。数组的元素是连续存储在内存中的，可以通过索引访问。数组有一些限制，例如长度固定、不能动态扩展等。当数组作为函数参数传递时，实际上传递的是指向数组首元素的指针。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> myArray[<span class="number">5</span>];  <span class="type">int</span> numbers[<span class="number">3</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;  <span class="type">int</span> matrix[<span class="number">3</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;&#125;;  <span class="comment">// 声明并初始化一个整数数组</span></span><br></pre></td></tr></table></figure></li>
<li>在C++中，动态声明数组意味着在运行时根据需要分配数组的内存空间，而不是在编译时固定数组大小。<br><strong>使用指针声明数组：</strong> 首先，你需要声明一个指针变量，该指针变量将用于存储动态分配的数组的地址。然后，使用内存分配函数（如 <code>new</code> 或 <code>malloc</code>）分配所需大小的内存空间。<br><strong>释放内存：</strong> 在不再需要数组时，必须手动释放分配的内存，以避免内存泄漏。使用 <code>delete</code> 或 <code>free</code> 来释放内存。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* dynamicArray = <span class="keyword">new</span> <span class="type">int</span>[size];   <span class="keyword">delete</span>[] dynamicArray;   <span class="comment">// 动态分配数组内存 释放分配的内存</span></span><br></pre></td></tr></table></figure></li>
<li>数组容器（Array Container）：在C++中，数组（Array）和数组容器（Array Container）是两种不同的数据结构，它们在用法和特性上有一些区别。数组容器是C++标准库中提供的一种数据结构，用于存储相同类型的元素，并提供了一些更方便的功能。<br><code>array</code> 是一个数组容器，它在内部使用数组来存储元素，是一个类模板，具有类似对象的行为，可以使用成员函数和操作符进行操作，提供了更多的功能，如获取数组大小、迭代器、操作符重载等，还可以像其他C++容器一样与STL算法一起使用。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span>  array<span class="string">&lt;int, 5&gt;</span> myArray;  array<span class="string">&lt;int, 3&gt;</span> numbers = &#123;10, 20, 30&#125;;  <span class="comment">// 声明一个包含3个整数的array</span></span></span><br></pre></td></tr></table></figure></li>
<li>动态数组<code>vector</code>的底层实现是 array，严格来讲vector是容器，不是数组。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; myVector = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;   <span class="comment">// vector&lt;int&gt; myVector(n)  大小为n的空vector</span></span><br><span class="line"><span class="comment">// vector&lt;vector&lt;int&gt;&gt; myMatrix(n, vector&lt;int&gt;(n, 0))  n阶二维vector</span></span><br><span class="line">myVector.<span class="built_in">push_back</span>(<span class="number">1</span>);    <span class="comment">// 或直接下标索引 myVector[0] = 1;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; value : myVector)  cout &lt;&lt; value;  <span class="comment">// for (int i=0;i&lt;myVector.size();i++)&#123;..&#125;</span></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = myVector.<span class="built_in">begin</span>(); it != myVector.<span class="built_in">end</span>(); ++it)  cout &lt;&lt; *it;</span><br><span class="line">myVector.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="keyword">if</span> (myVector.<span class="built_in">empty</span>())  cout &lt;&lt; myVector.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure></li>
<li><code>sort</code>函数接受两个迭代器参数，即要排序的范围的开始和结束位置。排序默认是升序的，如果需要降序排序，可以使用 std::greater<int>() 作为第三个参数。在使用 sort 函数之前，请确保引入了 <algorithm> 头文件。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(arr, arr + n);</span><br><span class="line"><span class="built_in">sort</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul>
<li>处理头结点有两种方式：直接使用原来的链表来进行删除操作、设置一个虚拟头结点在进行删除操作。</li>
<li>使用 ListNode* cur &#x3D; head 进行链表操作，不要直接使用头结点操作！！！ </li>
<li>判断空指针为 <strong>if(ptr !&#x3D; nullptr)</strong> ，不要用 <strong>if(!ptr)</strong></li>
<li>nullptr与NULL：NULL 是一个宏定义，通常被定义为整数 0，NULL 用于表示空指针存在一些问题，因为它实际上是一个整数，可能会导致类型不匹配和模糊的代码。nullptr 是 C++11 标准引入的新关键字，用于表示空指针，是类型安全的，可以隐式转换为任何指针类型，但不会导致模糊的类型问题。推荐在现代 C++ 代码中使用 nullptr 来表示空指针。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">5</span>);             <span class="comment">// 初始化节点</span></span><br><span class="line"><span class="keyword">delete</span> head;                                  <span class="comment">// 删除节点，回收内存</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>在C++中，哈希（Hash）是一种将数据映射到固定大小的散列值的技术。哈希函数将输入数据转换为散列值，这个散列值通常用于快速查找或存储数据。C++标准库提供了一些哈希函数和相关的数据结构，让你可以在自己的程序中应用哈希。</p>
<ul>
<li>什么时候使用哈希法？当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。</li>
<li>哈希容器（Hash Containers）：C++标准库提供了一些哈希容器，它们使用哈希函数来快速存储和检索数据。<br><code>unordered_set</code>：基于哈希表的集合，用于实现无序映射。类似于 <code>set</code>，但具有更快的查找性能。set 是一个有序的容器，它存储一组唯一的元素。<br><code>unordered_map</code>：基于哈希表的关联数组，不保持元素的插入顺序，类似于 <code>map</code>但具有更快的查找性能。map 是一个有序（按键的字典顺序）的键-值对容器，它存储一组唯一的键，并且每个键关联一个值。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;Key, T&gt; mapp;                 <span class="comment">// 创建一个空的无序映射。</span></span><br><span class="line">mapp[x]                                     <span class="comment">// 直接访问指定键的值，如果键不存在，会创建一个新的键并初始化为默认值。</span></span><br><span class="line"><span class="built_in">insert</span>(&#123;key, value&#125;)   <span class="built_in">erase</span>(key)           <span class="comment">// 插入，删除一个键值对。</span></span><br><span class="line"><span class="built_in">at</span>(key)                                     <span class="comment">// 访问指定键的值，如果键不存在会抛出异常。</span></span><br><span class="line"><span class="built_in">find</span>(key)                                   <span class="comment">// 查找指定键，返回指向该键的迭代器，若不存在，返回mapp.end() </span></span><br><span class="line"><span class="built_in">empty</span>()   <span class="built_in">size</span>()                            <span class="comment">// 检查是否为空；返回键值对的数量</span></span><br><span class="line"><span class="built_in">begin</span>()   <span class="built_in">end</span>()                             <span class="comment">// 返回迭代器，用于遍历所有键值对。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : mapp) &#123;             <span class="comment">// 范围循环,遍历所有键值对。</span></span><br><span class="line">    cout &lt;&lt; pair.first &lt;&lt; pair.second;</span><br><span class="line">&#125;    </span><br><span class="line">                                            <span class="comment">// set的用法类似</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li>访问 string 字符串特定索引位置的字符时，返回的类型是 char</li>
<li>直接使用 <strong>+</strong> 连接字符串和字符串string&#x2F;字符char；<br>使用 <strong>&#x3D;&#x3D;、!&#x3D;、&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;</strong> 比较字符串和字符串string&#x2F;字符char；<br>使用<code>cstring</code>库中的字符串处理函数。其中，strcmp() 用于比较两个 C 风格字符串，strcpy()复制。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getline</span>(cin, str)                            <span class="comment">// cin以空格分隔string。而getline()会等待用户在终端输入一行字符串，然后将该字符串存储在 str 变量中。注意，getline() 会读取一行完整的输入，包括换行符，并且将换行符从输入中删除。</span></span><br><span class="line">str.<span class="built_in">append</span>(count, <span class="string">&#x27;0&#x27;</span>)                       <span class="comment">// 在str末尾加上count个&#x27;0&#x27;</span></span><br><span class="line">str.<span class="built_in">substr</span>(i, <span class="number">8</span>)                             <span class="comment">// 从位置i开始截取长度为8的str的子串</span></span><br><span class="line">str.<span class="built_in">erase</span>(i, <span class="number">5</span>);                             <span class="comment">// 从位置i开始，删除5个字符</span></span><br><span class="line">str1.<span class="built_in">compare</span>(str2)                           <span class="comment">// 逐字符比较字符串(字典顺序)大小，返回0/1/-1</span></span><br><span class="line"><span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + <span class="number">0</span>, s.<span class="built_in">begin</span>() + n);       <span class="comment">// algorithm库字符串翻转函数，翻转范围[0, n-1]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string&amp; s,<span class="type">int</span> start,<span class="type">int</span> end)</span></span>&#123;   <span class="comment">// 自制字符串反转函数，reverse(str, 0, str.size()-1)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start, j = end; i &lt; j; i++, j--)  <span class="built_in">swap</span>(s[i], s[j]);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><p>我们常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈、队列的底层结构。<br>不允许有遍历行为，不提供迭代器。<br>所以STL 栈、队列不被归类为容器，而被归类为container adapter（ 容器适配器）。</p>
<ul>
<li>栈（Stack）遵循后进先出（Last-In-First-Out，LIFO）的原则。 std::stack 容器用于实现栈。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; myStack;               <span class="comment">// 创建一个空的栈，存储整数</span></span><br><span class="line">myStack.<span class="built_in">push</span>(<span class="number">10</span>);                 <span class="comment">// 添加元素到栈</span></span><br><span class="line">myStack.<span class="built_in">top</span>();                    <span class="comment">// 访问栈顶元素</span></span><br><span class="line">myStack.<span class="built_in">pop</span>();                    <span class="comment">// 移除栈顶元素</span></span><br><span class="line"><span class="keyword">while</span> (!myStack.<span class="built_in">empty</span>()) &#123;...     <span class="comment">// 遍历栈</span></span><br></pre></td></tr></table></figure></li>
<li>队列（Queue）遵循先进先出（First-In-First-Out，FIFO）的原则。 std::queue 容器用于实现队列。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span>   </span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; myQueue;   myQueue.<span class="built_in">push</span>(<span class="number">10</span>);   myQueue.<span class="built_in">front</span>();   myQueue.<span class="built_in">pop</span>();   <span class="keyword">while</span> (!myQueue.<span class="built_in">empty</span>()) &#123;...   </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="list（双向链表）"><a href="#list（双向链表）" class="headerlink" title="list（双向链表）"></a><code>list</code>（双向链表）</h2><ul>
<li><code>std::list</code> 是一个双向链表容器，每个元素都包含一个指向前一个元素和一个指向后一个元素的指针。这使得插入和删除操作在链表中非常高效，但随机访问较慢。以下是一些 <code>std::list</code> 的常见用法：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; myList;</span><br><span class="line">    myList.<span class="built_in">push_back</span>(<span class="number">1</span>);                                 <span class="comment">// 插入元素</span></span><br><span class="line">    myList.<span class="built_in">push_front</span>(<span class="number">2</span>);          </span><br><span class="line">    myList.<span class="built_in">insert</span>(std::<span class="built_in">next</span>(myList.<span class="built_in">begin</span>()), <span class="number">3</span>);         <span class="comment">// 在迭代器位置后插入</span></span><br><span class="line">    myList.<span class="built_in">pop_back</span>();                                   <span class="comment">// 删除元素</span></span><br><span class="line">    myList.<span class="built_in">pop_front</span>();</span><br><span class="line">    myList.<span class="built_in">erase</span>(std::<span class="built_in">next</span>(myList.<span class="built_in">begin</span>()));             <span class="comment">// 删除迭代器位置的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; item : myList) &#123; cout &lt;&lt; item,,      <span class="comment">// 遍历元素</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="deque（双端队列）"><a href="#deque（双端队列）" class="headerlink" title="deque（双端队列）"></a><code>deque</code>（双端队列）</h2><ul>
<li><code>deque</code> 是双端队列容器，支持在两端进行高效的插入和删除操作，并且允许随机访问。它的特性使得它在需要在两端进行频繁操作的场景下很有用。以下是一些 <code>deque</code> 的常见用法：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line">std::deque&lt;<span class="type">int</span>&gt; myDeque;</span><br><span class="line">myDeque.<span class="built_in">push_back</span>(<span class="number">1</span>);                                   <span class="comment">// 插入元素</span></span><br><span class="line">myDeque.<span class="built_in">push_front</span>(<span class="number">2</span>);  </span><br><span class="line">myDeque.<span class="built_in">pop_back</span>();                                     <span class="comment">// 删除元素</span></span><br><span class="line">myDeque.<span class="built_in">pop_front</span>();</span><br><span class="line">myDeque.<span class="built_in">push_back</span>(<span class="number">3</span>);                                   <span class="comment">// 随机访问</span></span><br><span class="line">myDeque.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"><span class="type">int</span> value = myDeque[<span class="number">1</span>];                                 <span class="comment">// 访问第二个元素，值为4</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; item : myDeque) &#123; cout &lt;&lt; item ;;;      <span class="comment">// 遍历元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Heap（堆）"><a href="#Heap（堆）" class="headerlink" title="Heap（堆）"></a><code>Heap</code>（堆）</h2><p>在 C++ 中，你可以使用 <code>priority_queue</code> 来实现小顶堆和大顶堆。默认情况下，<code>priority_queue</code> 是大顶堆，但你可以通过改变比较函数来实现小顶堆或大顶堆。</p>
<ul>
<li>实现大顶堆：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="comment">// 创建一个大顶堆（默认情况）</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; maxHeap;</span><br><span class="line"><span class="comment">// 向大顶堆中插入元素</span></span><br><span class="line">maxHeap.<span class="built_in">push</span>(<span class="number">5</span>);    maxHeap.<span class="built_in">push</span>(<span class="number">2</span>);    maxHeap.<span class="built_in">push</span>(<span class="number">8</span>);    maxHeap.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 访问堆顶元素（最大值）</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;最大值：&quot;</span> &lt;&lt; maxHeap.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 弹出堆顶元素</span></span><br><span class="line">maxHeap.<span class="built_in">pop</span>(); ；；&#125;</span><br></pre></td></tr></table></figure></li>
<li>实现小顶堆：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="comment">// 创建一个小顶堆</span></span><br><span class="line"><span class="comment">// 第一个参数 int：这是容器中存储的元素的类型，也就是小顶堆中的元素类型。在这里，我们使用 int 类型。</span></span><br><span class="line"><span class="comment">// 第二个参数 vector&lt;int&gt;：这是容器类型，用于存储小顶堆的元素。通常情况下，我们使用 std::vector 作为容器，但你也可以使用其他容器类型，比如 std::deque。</span></span><br><span class="line"><span class="comment">// 第三个参数 greater&lt;int&gt;：这是比较函数对象，用于定义小顶堆的比较规则。在这里，greater&lt;int&gt; 是一个函数对象，它表示比较时采用递增的方式，即根节点的值小于子节点的值。</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; minHeap;</span><br><span class="line"><span class="comment">// 向小顶堆中插入元素</span></span><br><span class="line">minHeap.<span class="built_in">push</span>(<span class="number">5</span>);  minHeap.<span class="built_in">push</span>(<span class="number">2</span>);  minHeap.<span class="built_in">push</span>(<span class="number">8</span>);  minHeap.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 访问堆顶元素（最小值）</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;最小值：&quot;</span> &lt;&lt; minHeap.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 弹出堆顶元素</span></span><br><span class="line">minHeap.<span class="built_in">pop</span>();；；&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><ul>
<li>二叉树（Binary Tree）是一种常见的树状数据结构，其中每个节点最多有两个子节点，通常称为左子节点和右子节点。每个节点都存储一个值，这个值可以是任何类型，取决于树的应用。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left, *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则为满二叉树。</li>
<li>完全二叉树：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。<br>优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。</li>
<li><strong>二叉搜索树 BST：</strong>具有有序性质，适用于快速查找、插入和删除操作。<br>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>它的左、右子树也分别为二叉排序树</li>
<li><strong>平衡二叉搜索树 AVL：</strong> 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。<br>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，所以map、set的增删操作时间时间复杂度是logn。<br>而unordered_map、unordered_set底层实现是哈希表。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/09/06/Cpp%E5%9F%BA%E7%A1%80/" data-id="cmbtnjz1o0000csv5cbe6do6m" data-title="C++ 基础" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/09/08/%E7%AE%97%E6%B3%95/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          数组 / 链表 / 哈希表 / 字符串 / 栈 / 队列 / 二叉树 / 图 / 贪心 / 回溯 / 动态规划
        
      </div>
    </a>
  
  
    <a href="/2020/09/01/Shots/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Shots 📷</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2046/12/">December 2046</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2046/08/">August 2046</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2046/12/30/nice-photo/">Nice Photo</a>
          </li>
        
          <li>
            <a href="/2046/08/27/Guitar/">Guitar 🎸</a>
          </li>
        
          <li>
            <a href="/2024/10/22/Docker_Kubernetes/">Kubernetes</a>
          </li>
        
          <li>
            <a href="/2024/09/22/InfluxDB/">InfluxDB</a>
          </li>
        
          <li>
            <a href="/2024/09/22/Golang/">Golang</a>
          </li>
        
          <li>
            <a href="/2024/08/18/%E7%90%86%E8%B4%A2/">Lic Ai</a>
          </li>
        
          <li>
            <a href="/2024/07/07/%E7%BE%8E%E7%9A%84Midea/">美 的 Midea</a>
          </li>
        
          <li>
            <a href="/2024/05/01/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/">毕 业 设 计</a>
          </li>
        
          <li>
            <a href="/2024/01/11/RabbitMQ/">RabbitMQ</a>
          </li>
        
          <li>
            <a href="/2024/01/07/SpringCloud/">SpringCloud</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 fengcai<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>