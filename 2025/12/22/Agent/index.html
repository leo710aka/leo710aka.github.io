<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Agent | Qué miras Bobo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="AI Agent的本质是能够感知环境、自主决策并执行行动的智能实体。与传统AI系统最大的区别在于Agent具有自主性、反应性、目标导向和学习能力，它不再是简单的工具，而是能够主动规划和完成复杂任务的智能体。从1997年击败国际象棋世界冠军的IBM“深蓝”，到2011年苹果推出的个人助理Siri，都展示了Agent在特定领域的强大能力，关键的转折点发生在2023年左右，大语言模型LLM的出现为Age">
<meta property="og:type" content="article">
<meta property="og:title" content="Agent">
<meta property="og:url" content="http://example.com/2025/12/22/Agent/index.html">
<meta property="og:site_name" content="Qué miras Bobo">
<meta property="og:description" content="AI Agent的本质是能够感知环境、自主决策并执行行动的智能实体。与传统AI系统最大的区别在于Agent具有自主性、反应性、目标导向和学习能力，它不再是简单的工具，而是能够主动规划和完成复杂任务的智能体。从1997年击败国际象棋世界冠军的IBM“深蓝”，到2011年苹果推出的个人助理Siri，都展示了Agent在特定领域的强大能力，关键的转折点发生在2023年左右，大语言模型LLM的出现为Age">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://www.helloimg.com/i/2025/12/14/693ec39628c6f.png">
<meta property="og:image" content="https://github.com/leo710aka/bk/blob/main/agent/agent.png?raw=true">
<meta property="og:image" content="https://github.com/leo710aka/bk/blob/main/agent/98929fe59845837a3299e32d8790adda.png?raw=true">
<meta property="article:published_time" content="2025-12-22T05:34:33.000Z">
<meta property="article:modified_time" content="2025-12-27T14:50:59.034Z">
<meta property="article:author" content="fengcai">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.helloimg.com/i/2025/12/14/693ec39628c6f.png">
  
    <link rel="alternate" href="/atom.xml" title="Qué miras Bobo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="https://github.com/leo710aka/bk/blob/main/DT1.jpg?raw=true">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Qué miras Bobo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Agent" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/12/22/Agent/" class="article-date">
  <time class="dt-published" datetime="2025-12-22T05:34:33.000Z" itemprop="datePublished">2025-12-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Agent
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>AI Agent的本质是能够感知环境、自主决策并执行行动的智能实体。与传统AI系统最大的区别在于Agent具有自主性、反应性、目标导向和学习能力，它不再是简单的工具，而是能够主动规划和完成复杂任务的智能体。从1997年击败国际象棋世界冠军的IBM“深蓝”，到2011年苹果推出的个人助理Siri，都展示了Agent在特定领域的强大能力，关键的转折点发生在2023年左右，大语言模型LLM的出现为Agent提供了强大的通用理解和推理能力，使其不再局限于单一任务。</p>
<h2 id="Agent-架构模式"><a href="#Agent-架构模式" class="headerlink" title="Agent 架构模式"></a>Agent 架构模式</h2><ol>
<li>组成组件<br><strong>Agent</strong>：智能代理，它是一个能够感知环境、做出决策并执行动作的软件实体（比起LLM只能“回答问题”，Agent可以真正地“执行任务”）。在LLM语境中，Agent通常利用LLM作为大脑，来理解用户输入、决定需要执行的动作（比如调用工具）、处理工具返回的结果并生成响应。<br><strong>LLM</strong>（大语言模型）：如GPT系列，是Agent的核心，负责理解自然语言、进行推理和生成文本。<br><strong>Tool</strong>：工具，是Agent可以调用的函数，用于执行特定任务，比如查询数据库、调用API。Tool扩展了Agent的能力，使其能够获取实时信息或执行具体操作。<br><code>Function Calling</code>：函数调用，是LLM的一种能力，允许模型根据用户输入决定何时以及如何调用哪个函数（Tool），并以结构化格式（如JSON）输出函数调用参数。然后由外部系统执行该函数。<br><strong>Prompt</strong>：提示词，是引导LLM生成期望输出的文本。在Agent中，Prompt通常包含系统指令（定义Agent的角色和能力）、用户输入、对话历史以及工具描述等。<br><code>RAG</code>（检索增强生成）：通过从外部知识库检索相关信息，并将其作为上下文提供给LLM，从而生成更准确、更相关的回答。<br><code>MCP</code>（模型上下文协议）：<strong>MCP可以包含本地tools和外部API，但通常 MCP更强调于将工具（无论是本地tools还是外部API）以标准化的上下文协议暴露给AI模型</strong>。MCP可以看作是一个中间层，它将工具抽象成标准的接口，使得AI Agent可以通过统一的协议来调用这些工具，从而实现模型与工具之间的解耦。</li>
<li>一个典型的工作流程如下：<br>用户输入自然语言请求。<br>Agent将用户输入、对话历史、可用的工具描述（通过Function Calling定义）以及系统提示词组合成一个Prompt，发送给LLM。<br>LLM根据Prompt判断是否需要调用工具。如果需要，LLM会返回一个函数调用请求（包括函数名和参数）。<br>Agent解析LLM返回的函数调用请求，并执行对应的工具（Tool）。<br>工具执行后返回结果，Agent将工具执行结果作为上下文，再次调用LLM，生成最终的自然语言响应。<br>Agent将响应返回给用户。<br>在这个过程中，RAG可以在第一步之前或之中介入，通过检索外部知识库来增强Prompt的上下文。<img src="https://www.helloimg.com/i/2025/12/14/693ec39628c6f.png" width="550" height="300" alt="">
<!-- <img src="https://github.com/leo710aka/bk/blob/main/agent/agent.png?raw=true" width="450" height="300" alt=""> --></li>
<li>a demo<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#### main.py</span></span><br><span class="line"><span class="keyword">from</span> pydantic_ai.models.gemini <span class="keyword">import</span> GeminiModel</span><br><span class="line"><span class="keyword">from</span> pydantic_ai <span class="keyword">import</span> Agent</span><br><span class="line"><span class="keyword">from</span> dotenv <span class="keyword">import</span> load_dotenv</span><br><span class="line"><span class="keyword">import</span> tools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型API Key等可以写到.env文件 并加载到环境变量</span></span><br><span class="line">load_dotenv()</span><br><span class="line">model = GeminiModel(<span class="string">&quot;gemini-2.5-flash-preview-04-17&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将llm模型、系统prompt、工具tools “注册” 到 Agent</span></span><br><span class="line">agent = Agent(model,</span><br><span class="line">            system_prompt=<span class="string">&quot;You are an experienced programmer&quot;</span>,</span><br><span class="line">            tools=[tools.read_file, tools.list_files])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    history = []</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># eg. Input: list and read file. base on your konwledge tell me what lang each file use.</span></span><br><span class="line">        user_input = <span class="built_in">input</span>(<span class="string">&quot;Input: &quot;</span>)</span><br><span class="line">        <span class="comment"># 将用户输入、历史对话（上下文）发给 agent 并记录本次对话（短期记忆）</span></span><br><span class="line">        resp = agent.run_sync(user_input,</span><br><span class="line">                            message_history=history)</span><br><span class="line">        history = <span class="built_in">list</span>(resp.all_messages())</span><br><span class="line">        <span class="built_in">print</span>(resp.output)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#### tools.py</span></span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">base_dir = Path(<span class="string">&quot;./test&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_file</span>(<span class="params">name: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="comment"># docstring 帮助模型理解 tools</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return file content. If not exist, return error message.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;(read_file <span class="subst">&#123;name&#125;</span>)&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(base_dir / name, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            content = f.read()</span><br><span class="line">        <span class="keyword">return</span> content</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;An error occurred: <span class="subst">&#123;e&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">list_files</span>() -&gt; <span class="built_in">list</span>[<span class="built_in">str</span>]:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(list_file)&quot;</span>)</span><br><span class="line">    file_list = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> base_dir.rglob(<span class="string">&quot;*&quot;</span>):</span><br><span class="line">        <span class="keyword">if</span> item.is_file():</span><br><span class="line">            file_list.append(<span class="built_in">str</span>(item.relative_to(base_dir)))</span><br><span class="line">    <span class="keyword">return</span> file_list</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="MCP"><a href="#MCP" class="headerlink" title="MCP"></a>MCP</h2><p><code>MCP</code> 可以看作是一个中间层，它将工具抽象成标准的接口，使得AI Agent可以通过统一的协议来调用这些工具，从而实现模型与工具之间的解耦。MCP 可以包含本地tools和外部API，但通常 MCP更强调于将工具（无论是本地tools还是外部API）以标准化的上下文协议暴露给AI模型。</p>
<ol>
<li>Agent通过集成的MCP Client向MCP Server发送请求，调用工具。因此，Agent不再直接调用具体的工具函数，而是可以使用任何符合MCP协议的工具，无论工具是本地还是远程。MCP模式下，我们不再直接注册这些Tools到Agent（如传统框架LangChain），而是注册MCP Client（可以看作是Tools的抽象层），然后Agent通过MCP Client来动态获取MCP Server提供的Tools列表，并在需要时调用它们。<br>示例流程：<br>步骤1：启动一个MCP Server，它提供了一些工具（例如，天气查询、计算器等）。<br>步骤2：在Agent框架中，配置MCP Client，并连接到该MCP Server。<br>步骤3：Agent在需要时，通过MCP Client查询MCP Server提供了哪些工具。<br>步骤4：当用户提问时，Agent决定调用哪个工具，然后通过MCP Client发送调用请求给MCP Server。<br>步骤5：MCP Server执行工具，并将结果返回给MCP Client，然后Agent接收结果并生成最终回答。？</li>
<li>MCP代表了AI应用架构的演进方向，从紧耦合的工具注册转向松耦合的工具治理，特别适合企业级AI应用的复杂集成场景。</li>
</ol>
<h2 id="RAG"><a href="#RAG" class="headerlink" title="RAG"></a>RAG</h2><p>RAG​ 的核心思想是：在让大模型回答问题之前，先从一个外部的、可随时更新的知识库中检索相关信息，然后将这些“新鲜”信息作为上下文和问题一起交给模型，从而引导模型生成更准确、及时且可追溯的答案。它能有效减少模型“幻觉”（即胡编乱造），让AI应用在知识密集型任务中变得真正可靠。以及，它能帮助构建专业领域专家对话机器人。</p>
<p>一个典型的RAG系统工作流程包含三个关键阶段：</p>
<ol>
<li>知识库索引构建（Indexing）<br>这是准备阶段，目的是将您的私有知识库“灌输”进向量数据库。<br>文档解析与分块：首先，系统会解析各种格式的文档（如PDF、Word、HTML），将其转换为纯文本。然后，根据语义或结构将长文本切分成大小适宜的“文本块”（Chunks），以适应模型上下文长度限制。<br>向量化（Embedding）：使用嵌入模型将每个文本块转换为一个高维向量（一组数字）。这个向量就像是文本在数学空间中的“坐标”，语义相近的文本，其向量在空间中的距离也更近。<br>向量存储：将这些向量及其对应的原始文本块、元数据（如来源、标题）一并存入向量数据库。</li>
<li>实时检索（Retrieval）<br>当用户提出问题时，系统执行以下操作：<br>使用相同的嵌入模型将用户问题也转换为一个向量。<br>将这个“问题向量”送入向量数据库，进行相似性搜索。数据库会快速找出与问题向量最相似的K个“文档向量”。<br>为了提高检索质量，常采用混合检索策略，结合语义向量搜索和传统关键词搜索，并利用重排序模型对初步结果进行精细排序，以提升准确性。</li>
<li>增强生成（Generation）<br>提示词增强：将检索到的最相关的文本块作为上下文，与用户的原始问题一起组合成一个结构化的提示词（Prompt）。<br>智能生成：将这个富含信息的提示词发送给LLM，基于您提供的权威上下文，而非仅凭其内部可能过时的知识，来生成最终答案<img src="https://github.com/leo710aka/bk/blob/main/agent/98929fe59845837a3299e32d8790adda.png?raw=true" width="550" height="300" alt=""></li>
</ol>
<h2 id="Agent流程编排"><a href="#Agent流程编排" class="headerlink" title="Agent流程编排"></a>Agent流程编排</h2><p>业务逻辑</p>
<h2 id="LangChain"><a href="#LangChain" class="headerlink" title="LangChain"></a>LangChain</h2><p>LangChain 是一个功能强大的大语言模型应用开发框架。与Spring在Java后端开发中的定位类似。<br><a target="_blank" rel="noopener" href="https://python.langchain.com/docs/concepts/">https://python.langchain.com/docs/concepts/</a><br><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2302.07842">https://arxiv.org/abs/2302.07842</a></p>
<p>LangChain 包：通过 <code>pip</code> 命令（类似于Java的Maven或Gradle）安装到项目中，避免重复造轮子。</p>
<h2 id="LangGraph"><a href="#LangGraph" class="headerlink" title="LangGraph"></a>LangGraph</h2><p>LangGraph 核心认知：<strong>用“有向图”构建智能体的新一代框架</strong>，是 <strong>用于构建有状态、多步骤、多分支智能体（Agent）</strong> 的框架，核心是将 Agent 的行为拆解为<strong>节点（Nodes）</strong> 和<strong>边（Edges）</strong>，用<strong>有向图（Directed Graph）</strong> 替代老版本的“线性循环” 以支持更复杂的流程编排。<br>LangGraph 可以理解为：<strong>给 Agent 设计“流程图”的工具</strong>，而老版本 ReAct Agent 只是这个流程图中最基础的“单循环分支”。<br><a target="_blank" rel="noopener" href="https://docs.langchain.com/oss/python/langgraph/overview">https://docs.langchain.com/oss/python/langgraph/overview</a></p>
<ul>
<li>LangGraph 核心概念解析（多节点、边是关键）<ol>
<li>核心基础：<strong>状态（State）</strong><ul>
<li><strong>作用</strong>：整个图的<strong>“共享内存”</strong>，所有节点都能<strong>读写</strong>这个状态（比如用户问题、LLM 思考结果、工具调用结果、最终回答等）。</li>
<li><strong>举例</strong>：在你之前的 CMDB Agent 中，状态里会包含： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;messages&quot;</span>: [&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;显示运行中的Linux服务器&quot;</span>&#125;, </span><br><span class="line">                &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;ai&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;思考过程+工具调用指令&quot;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;tool&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;工具调用结果&quot;</span>&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>特点</strong>：状态是<strong>持久化</strong>的（通过 Checkpoint 如 <code>InMemorySaver</code>），支持中断、恢复、回溯（比如多轮对话的上下文保留）。</li>
</ul>
</li>
<li>最小执行单元：<strong>节点（Node）</strong><ul>
<li><strong>定义</strong>：图的<strong>最小操作单元</strong>，对应一个具体的功能（比如调用 LLM、调用工具、格式化回答、清洗用户问题）。</li>
<li><strong>类型</strong>（实际开发中常见）：</li>
<li><strong>LLM 节点</strong>：调用大模型生成思考结果或工具调用指令（比如你之前看到的“分析问题+工具选择”）。</li>
<li><strong>工具调用节点</strong>：执行具体的工具函数（比如 <code>cmdb_search</code>、<code>cmdb_query</code>）。</li>
<li><strong>预处理&#x2F;后处理节点</strong>：清洗用户问题、格式化最终回答。</li>
<li><strong>判断节点</strong>：根据状态判断流程走向（比如“是否需要继续调用工具？”）。</li>
<li><strong>多节点的价值</strong>：你可以把 Agent 的复杂行为拆分成多个独立节点，比如：<br> <code>用户输入清洗节点</code> → <code>LLM 思考节点</code> → <code>CMDB 工具节点</code> → <code>日志工具节点</code> → <code>回答格式化节点</code></li>
</ul>
</li>
<li>流程的灵魂：<strong>边（Edge）</strong><ul>
<li><strong>定义</strong>：节点之间的<strong>连接关系</strong>，定义流程的<strong>走向</strong>。LangGraph 支持三种边，这也是“多分支”的核心：</li>
<li><strong>普通边（Direct Edge）</strong>：直接从 A 节点跳转到 B 节点（比如“清洗节点”执行完，直接到“LLM 思考节点”）。</li>
<li><strong>条件边（Conditional Edge）</strong>：根据<strong>状态的内容</strong>判断跳转方向（最核心的“多分支”能力）。<ul>
<li>举例：LLM 输出“需要调用 CMDB 工具”，则跳转到 <code>cmdb_search</code> 节点；如果输出“需要调用日志工具”，则跳转到 <code>log_search</code> 节点；如果输出“无需调用工具”，则跳转到“回答节点”。</li>
</ul>
</li>
<li><strong>入口&#x2F;出口边</strong>：定义图的<strong>开始节点</strong>（比如用户输入节点）和<strong>结束节点</strong>（比如回答节点）。</li>
<li><strong>多边的价值</strong>：打破了老版本“单一循环”的限制，支持<strong>分支、并行、循环</strong>等复杂流程。</li>
</ul>
</li>
<li>关键能力：<strong>检查点（Checkpoint）</strong><ul>
<li><strong>作用</strong>：记录图的执行状态，支持<strong>中断、恢复、回溯</strong>（比如你之前用的 <code>InMemorySaver</code> 就是内存级的检查点，还可以用 Redis、SQL 实现持久化）。</li>
<li><strong>场景</strong>：多轮对话中，用户可以“回退”到上一步，或 Agent 崩溃后恢复执行。</li>
</ul>
</li>
</ol>
</li>
<li>LangGraph 中 Agent 与 Tools 的工作机制（结合你的 CMDB 例子）<br>  以你之前的“显示运行中的 Linux 服务器”为例，LangGraph 的执行流程可以拆解为<strong>一个极简的有向图</strong>：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[入口节点：用户输入] </span><br><span class="line">    ↓（普通边）</span><br><span class="line">[LLM 思考节点]：分析问题，生成工具调用指令（cmdb_search + 入参）</span><br><span class="line">    ↓（条件边：判断需要调用工具）</span><br><span class="line">[工具调用节点]：执行 cmdb_search，将结果写回状态</span><br><span class="line">    ↓（条件边：判断无需继续调用工具）</span><br><span class="line">[LLM 回答节点]：基于工具结果生成最终回答</span><br><span class="line">    ↓（普通边）</span><br><span class="line">[出口节点：输出回答]</span><br></pre></td></tr></table></figure>
  核心细节：<ol>
<li><strong>状态驱动</strong>：所有节点都通过<strong>状态</strong>交互，没有直接的函数调用——LLM 节点从状态中读用户问题，工具节点从状态中读工具调用指令，执行后写回结果。</li>
<li><strong>工具的解耦</strong>：工具本身是独立的函数（如 <code>cmdb_search</code>），LangGraph 只通过<strong>工具调用节点</strong>统一管理，支持多工具的动态选择和调用。</li>
<li><strong>循环执行</strong>：通过<strong>条件边</strong>实现“思考→工具→再思考→再工具”的循环（比如用户问“查生产主机并统计数量”，可能需要先调用 <code>cmdb_search</code>，再调用 <code>cmdb_query</code> 统计）。</li>
</ol>
</li>
<li>LangGraph vs 老版本 ReAct Agent（核心区别）<br>老版本 ReAct Agent（LangChain v0.x 的 <code>AgentExecutor</code>）是 LangGraph 的<strong>简化版</strong>，两者的核心差异在于<strong>流程的编排能力</strong>：<table>
<thead>
<tr>
<th>维度</th>
<th>老版本 ReAct Agent（AgentExecutor）</th>
<th>LangGraph</th>
</tr>
</thead>
<tbody><tr>
<td><strong>架构基础</strong></td>
<td>线性循环（Single Loop）</td>
<td>有向图（Directed Graph）</td>
</tr>
<tr>
<td><strong>节点&#x2F;边</strong></td>
<td>无物理节点拆分，只有“思考→工具”的逻辑两步；无多分支边，只有单一循环。</td>
<td>支持多节点、多类型边（条件边、普通边），可编排复杂流程。</td>
</tr>
<tr>
<td><strong>状态管理</strong></td>
<td>临时状态（每次循环重新生成，无持久化）</td>
<td>统一的状态对象，支持持久化、回溯（Checkpoint）。</td>
</tr>
<tr>
<td><strong>流程灵活性</strong></td>
<td>只能“思考→工具→思考”的单一循环，多工具需按顺序调用（一次一个）。</td>
<td>支持多分支（比如不同工具的并行调用）、条件跳转、中断恢复。</td>
</tr>
<tr>
<td><strong>扩展性</strong></td>
<td>扩展复杂流程（如多工具并行）需要大量自定义代码。</td>
<td>通过图的编排即可实现，无需修改核心逻辑。</td>
</tr>
<tr>
<td>老版本 ReAct Agent 的核心是 <code>AgentExecutor</code> 的<strong>单一循环</strong>：</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">while True:</span><br><span class="line">    # 1. 调用 LLM 生成思考结果和工具调用指令</span><br><span class="line">    llm_output = llm.invoke(状态)</span><br><span class="line">    # 2. 判断是否需要调用工具</span><br><span class="line">    if 需要调用工具：</span><br><span class="line">        tool_result = tool.invoke(llm_output 中的指令)</span><br><span class="line">        # 将工具结果加入状态，继续循环</span><br><span class="line">    else:</span><br><span class="line">        # 生成最终回答，退出循环</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>
它的“节点”只是<strong>逻辑上的两步（思考、工具）</strong>，没有物理上的节点拆分，也没有多分支的边——即使有多个工具，也只能<strong>按顺序单次调用</strong>（一次调一个），无法实现并行或多分支跳转。<br>比如：<br>老版本要实现“查生产主机+查今日告警”，只能先调用 <code>cmdb_search</code>，再调用 <code>alert_search</code>，通过<strong>多次循环</strong>实现。<br>LangGraph 可以通过<strong>多节点和条件边</strong>，甚至<strong>并行执行</strong>这两个工具（比如同时调用 CMDB 和告警工具，提升效率）。</li>
<li>五、总结：为什么需要 LangGraph？<ol>
<li><strong>从“单一循环”到“复杂图”</strong>：老版本 Agent 适合简单的单工具循环场景，而 LangGraph 适合需要<strong>复杂流程编排</strong>的场景（比如多工具、多分支、有状态的智能体）。</li>
<li><strong>可视化与可维护性</strong>：将 Agent 的行为拆解为节点和边，流程更清晰，便于调试和维护（比如你之前看到的“两轮 LLM 调用”，在 LangGraph 中就是两个节点的执行）。</li>
<li><strong>生产级能力</strong>：Checkpoint、状态持久化、中断恢复等能力，让 LangGraph 更适合生产环境的部署。</li>
</ol>
</li>
</ul>
<h2 id="Spring-AI"><a href="#Spring-AI" class="headerlink" title="Spring AI"></a>Spring AI</h2><p>集成到Java</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/12/22/Agent/" data-id="cmjzvj9ly0000hgv5a5m2ds1y" data-title="Agent" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2046/08/27/Guitar/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Guitar 🎸
        
      </div>
    </a>
  
  
    <a href="/2025/12/08/MongoDB/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">MongoDB</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2046/12/">December 2046</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2046/08/">August 2046</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/12/">December 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2046/12/30/nice-photo/">Nice Photo</a>
          </li>
        
          <li>
            <a href="/2046/08/27/Guitar/">Guitar 🎸</a>
          </li>
        
          <li>
            <a href="/2025/12/22/Agent/">Agent</a>
          </li>
        
          <li>
            <a href="/2025/12/08/MongoDB/">MongoDB</a>
          </li>
        
          <li>
            <a href="/2024/10/22/Docker_Kubernetes/">Kubernetes</a>
          </li>
        
          <li>
            <a href="/2024/09/22/InfluxDB/">InfluxDB</a>
          </li>
        
          <li>
            <a href="/2024/09/22/Golang/">Golang</a>
          </li>
        
          <li>
            <a href="/2024/08/18/%E7%90%86%E8%B4%A2/">Lic Ai</a>
          </li>
        
          <li>
            <a href="/2024/07/07/%E7%BE%8E%E7%9A%84Midea/">美 的 Midea</a>
          </li>
        
          <li>
            <a href="/2024/05/01/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/">毕 业 设 计</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2026 fengcai<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>