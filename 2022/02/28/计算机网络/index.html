<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>计 算 机 网 络 | Qué miras Bobo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="OSI 七层模型OSI（开放系统互连）模型是计算机网络领域中的一个概念模型，将网络通信划分为七个层次，每个层次负责特定的功能。每个层次都通过下一层次提供的服务来完成其功能。通过将网络协议和功能划分到不同的层次，OSI 模型使得网络设计和实现更加模块化和灵活，有助于不同厂商和组织开发兼容的网络设备和应用。1、物理层（Physical Layer）: 主要关注网络硬件和物理介质。定义了数据传输的物理特">
<meta property="og:type" content="article">
<meta property="og:title" content="计 算 机 网 络">
<meta property="og:url" content="http://example.com/2022/02/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="Qué miras Bobo">
<meta property="og:description" content="OSI 七层模型OSI（开放系统互连）模型是计算机网络领域中的一个概念模型，将网络通信划分为七个层次，每个层次负责特定的功能。每个层次都通过下一层次提供的服务来完成其功能。通过将网络协议和功能划分到不同的层次，OSI 模型使得网络设计和实现更加模块化和灵活，有助于不同厂商和组织开发兼容的网络设备和应用。1、物理层（Physical Layer）: 主要关注网络硬件和物理介质。定义了数据传输的物理特">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://leo710aka.github.io/bk/net1.png">
<meta property="og:image" content="https://leo710aka.github.io/bk/net0.png">
<meta property="og:image" content="https://leo710aka.github.io/bk/net2.png">
<meta property="og:image" content="https://leo710aka.github.io/bk/net3.png">
<meta property="og:image" content="https://leo710aka.github.io/bk/net6.png">
<meta property="og:image" content="https://leo710aka.github.io/bk/net5.png">
<meta property="og:image" content="https://leo710aka.github.io/bk/net7.png">
<meta property="og:image" content="https://leo710aka.github.io/bk/net8.png">
<meta property="og:image" content="https://leo710aka.github.io/bk/net/21.png">
<meta property="og:image" content="https://leo710aka.github.io/bk/net/22.png">
<meta property="og:image" content="https://leo710aka.github.io/bk/net/23.png">
<meta property="og:image" content="https://leo710aka.github.io/bk/net13.png">
<meta property="og:image" content="https://leo710aka.github.io/bk/net14.png">
<meta property="og:image" content="https://leo710aka.github.io/bk/net11.png">
<meta property="og:image" content="https://leo710aka.github.io/bk/net12.png">
<meta property="og:image" content="https://leo710aka.github.io/bk/net15.png">
<meta property="article:published_time" content="2022-02-28T09:02:15.000Z">
<meta property="article:modified_time" content="2024-03-25T14:51:04.551Z">
<meta property="article:author" content="fengcai">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://leo710aka.github.io/bk/net1.png">
  
    <link rel="alternate" href="/atom.xml" title="Qué miras Bobo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="https://github.com/leo710aka/bk/blob/main/DT1.jpg?raw=true">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Qué miras Bobo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-计算机网络" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/02/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="article-date">
  <time class="dt-published" datetime="2022-02-28T09:02:15.000Z" itemprop="datePublished">2022-02-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      计 算 机 网 络
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h2><p>OSI（开放系统互连）模型是计算机网络领域中的一个概念模型，将网络通信划分为七个层次，每个层次负责特定的功能。<br>每个层次都通过下一层次提供的服务来完成其功能。通过将网络协议和功能划分到不同的层次，OSI 模型使得网络设计和实现更加模块化和灵活，有助于不同厂商和组织开发兼容的网络设备和应用。<br>1、<strong>物理层（Physical Layer）:</strong> 主要关注网络硬件和物理介质。定义了数据传输的物理特性，如电压、电流和传输介质。2、<strong>数据链路层（Data Link Layer）:</strong> 主要负责点对点的直接通信。 提供了物理层的上层接口，确保数据在相邻节点之间的可靠传输。主要包括两个子层：逻辑链路控制（LLC）和介质访问控制（MAC）。3、<strong>网络层（Network Layer）:</strong>  提供了在网络上寻址和路由的机制。负责将数据包从源节点传输到目标节点，可能需要通过多个中间节点。有许多不同的协议在这一层运行，最著名的是 IP。4、<strong>传输层（Transport Layer）:</strong> 主要负责端到端的通信。提供了端到端的可靠数据传输，如 TCP，UDP（不可靠但更高效）5、<strong>会话层（Session Layer）:</strong> 提供了建立、管理和终止会话的机制。管理数据的对话控制，确保通信的顺序性和同步性。6、<strong>表示层（Presentation Layer）:</strong> 负责数据的编码、解码和加密。 提供了在不同系统上进行数据格式转换的机制，以确保应用层能够正确地理解数据。7、<strong>应用层（Application Layer）:</strong> 最高层，直接为用户提供服务。 提供了网络服务和应用软件之间的接口，包括文件传输、电子邮件、远程登录等。</p>
<h2 id="TCP-IP-模型"><a href="#TCP-IP-模型" class="headerlink" title="TCP&#x2F;IP 模型"></a>TCP&#x2F;IP 模型</h2><p>对于不同设备上的进程间通信，就需要⽹络通信。而要兼容多种多样的设备，就协商出了⼀套通⽤的⽹络协议。（OSI也是）<br><strong>TCP&#x2F;IP 模型是实际互联网中最广泛使用的模型</strong>，因为它直接映射到互联网的基本协议，其层次划分与 OSI 模型略有不同。<br>⽹络协议通常是由上到下，分成 5 层，分别是应⽤层，传输层，⽹络层，数据链路层和物理层。</p>
<ol>
<li><strong>应用层：</strong>提供网络服务和应用程序间的接口，使不同软件能够通过网络通信。当两个不同设备的应⽤需要通信的时候，应⽤就把应⽤数据传给下⼀层，也就是传输层；只需要专注于为⽤户提供应⽤功能，不⽤去关⼼数据是如何传输的。<br>⽽且应⽤层是⼯作在操作系统中的⽤户态，传输层及以下则⼯作在内核态。<strong>协议：</strong>HTTP，SMTP，DNS等。</li>
<li><strong>传输层：</strong> 应⽤层的数据包会传给传输层，传输层是为应⽤层提供⽹络⽀持的。提供端到端的通信服务，确保数据的可靠传输。处理数据的分段和重新组装，同时提供错误检测和纠正。<strong>协议：</strong> 主要包括 TCP 和 UDP。<ul>
<li><strong>TCP</strong> 的全称叫传输层控制协议，⼤部分应⽤使⽤的正是 TCP 传输层协议，⽐如 HTTP 应⽤层协议。TCP 相⽐ UDP 多了很多特性，⽐如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对⽅。</li>
<li><strong>UDP</strong> 相对简单，只负责发送数据包，不保证数据包是否能抵达对⽅，但它实时性相对更好，传输效率也⾼。当然，UDP 也可以实现可靠传输，把 TCP 的特性在应⽤层上实现就可以。</li>
<li>应⽤需要传输的数据可能会⾮常⼤，当传输层的数据包⼤⼩超过 MSS（TCP最⼤报⽂段⻓度）就要将数据包分块，这样即使中途有⼀个分块丢失或损坏了，只需要重新发送这⼀个分块⽽不是整个数据包。每个分块称为⼀个 <strong>TCP 段</strong>（TCP Segment）。</li>
<li>当设备作为接收⽅时，传输层则要负责把数据包传给应⽤，但是⼀台设备上可能会有很多应⽤在接收或者传输数据，因此需要⽤⼀个编号将应⽤区分开来，这个编号就是<strong>端⼝</strong>。⽐如 80 端⼝通常是 Web 服务器⽤的，22 端⼝通常是远程登录服务器⽤的。⽽对于浏览器（客户端）中的每个标签栏都是⼀个独⽴的进程，操作系统会为这些进程分配临时的端⼝号。由于传输层的报⽂中会携带端⼝号，因此接收⽅可以识别出该报⽂是发送给哪个应⽤。</li>
</ul>
</li>
<li><strong>网络层：</strong> 处理主机之间的数据包路由，选择最佳路径将数据包从源主机传输到目标主机。<strong>协议：</strong>IP,ICMP,ARP等。<ul>
<li>IP 协议会将传输层的报⽂作为数据部分，再加上 IP 包头组装成 <strong>IP 报⽂</strong>，如果 IP 报⽂⼤⼩超过 MTU（以太⽹中⼀般为1500 字节）就会再次进⾏分⽚，得到⼀个即将发送到⽹络的 IP 报⽂。</li>
<li>⽤ IP地址给设备进⾏编号，对于 IPv4 协议，IP 地址共 32 位，分成四段，每段 8 位。将 IP 地址分成两种意义：⼀个是⽹络号，负责标识该 IP 地址是属于哪个⼦⽹的；⼀个是主机号，负责标识同⼀⼦⽹下的不同主机；这需要配合⼦⽹掩码才能算出 IP 地址 的⽹络号和主机号。那么在寻址的过程中，先匹配到相同的⽹络号，才会去找对应的主机。</li>
<li>除了寻址能⼒， IP 协议还有另⼀个重要的能⼒就是路由。实际场景中，两台设备并不是⽤⼀条⽹线连接起来的，⽽是通过很多⽹关、路由器、交换机等众多⽹络设备连接起来的，那么就会形成很多条⽹络的路径，因此当数据包到达⼀个⽹络节点，就需要通过算法决定下⼀步⾛哪条路径。</li>
<li>所以，IP 协议的<strong>寻址</strong>作⽤是告诉我们去往下⼀个⽬的地该朝哪个⽅向⾛，<strong>路由</strong>则是根据「下⼀个⽬的地」选择路径。寻址更像在导航，路由更像在操作⽅向盘。<img src="https://leo710aka.github.io/bk/net1.png" width="550" height="300" alt=""></li>
</ul>
</li>
<li><strong>链路层：</strong> 需要有⼀个专⻔的层来标识⽹络中的设备，让数据在⼀个链路中传输，这就是数据链路层，它主要为⽹络层提供链路级别传输的服务。（负责在物理网络介质上传输数据帧。它包括了对硬件的驱动程序和操作系统中的网络接口卡（NIC）<ul>
<li><strong>协议：</strong> 以太网、Wi-Fi、PPP 等。</li>
<li>每⼀台设备的⽹卡都会有⼀个 MAC 地址，它就是⽤来唯⼀标识设备的。路由器计算出了下⼀个⽬的地 IP 地址，再通过 ARP 协议找到该⽬的地的 MAC 地址，这样就知道这个 IP 地址是哪个设备的了。</li>
</ul>
</li>
<li><strong>物理层</strong>：当数据准备要从设备发送到⽹络时，需要把数据包转换成电信号，让其可以在物理介质中传输，这⼀层就是物理层，它主要是为数据链路层提供⼆进制传输的服务。<img src="https://leo710aka.github.io/bk/net0.png" width="350" height="300" alt=""></li>
</ol>
<h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><p>网络协议是计算机网络中用于通信的规则和约定的集合。它们定义了在通信系统中数据如何被传输、编码、压缩、路由和解码。网络协议是计算机网络正常运行的基础，它确保了不同设备和应用程序之间的互操作性。以下是一些常见的网络协议：</p>
<ol>
<li><strong>HTTP (Hypertext Transfer Protocol)</strong>:<br><strong>描述</strong>：用于在Web浏览器和Web服务器之间传输超文本的应用层协议。 <strong>特点</strong>：无状态协议，通常基于请求-响应模型。<br><strong>HTTPS (Hypertext Transfer Protocol Secure)</strong>:<br><strong>描述</strong>：HTTP的安全版本，通过使用TLS&#x2F;SSL协议进行加密，提供数据的安全性和隐私。<br><strong>特点</strong>：加密通信，用于保护敏感信息，如登录凭证和支付信息。</li>
<li><strong>TCP (Transmission Control Protocol)</strong>:<br><strong>描述</strong>：面向连接的传输层协议，提供可靠的、有序的、基于字节流的数据传输。<br><strong>特点</strong>：建立连接、数据传输完整性、流量控制、拥塞控制。<br><strong>UDP (User Datagram Protocol)</strong>:<br><strong>描述</strong>：面向无连接的传输层协议，提供不可靠但高效的数据传输。 <strong>特点</strong>：无连接、不提供流控制、不保证数据完整性。</li>
<li><strong>IP (Internet Protocol)</strong>:<br><strong>描述</strong>：定义了在网络上发送和接收数据的方式，是一种网络层协议。 <strong>特点</strong>：用于标识和定位设备，IPv4和IPv6是最常见的版本。</li>
<li><strong>DNS (Domain Name System)</strong>:<br><strong>描述</strong>：用于将域名映射到IP地址的分布式数据库系统。 <strong>特点</strong>：提供域名解析服务，将易记的域名转换为数值型IP地址。</li>
<li><strong>FTP (File Transfer Protocol)</strong>:<br>用于在计算机之间传输文件的标准网络协议。 支持文件上传、下载、删除等操作，可以进行匿名访问或需要身份验证。</li>
<li><strong>SMTP (Simple Mail Transfer Protocol)</strong>: 在计算机网络上传递和传输电子邮件的协议。 定义了邮件的发送规则，常用于发送邮件。<br><strong>POP3 (Post Office Protocol 3)</strong>: 从远程服务器上下载电子邮件到本地计算机的协议。通常用于接收邮件，支持在线和离线模式。<br><strong>IMAP (Internet Message Access Protocol)</strong>: 与POP3类似，也是用于从远程服务器上下载电子邮件的协议，但提供更多的功能。 支持在邮件服务器上管理邮件，可以通过多个设备同步邮件状态。</li>
</ol>
<h3 id="网络攻击"><a href="#网络攻击" class="headerlink" title="网络攻击"></a>网络攻击</h3><ol>
<li><strong>DDoS 攻击 (Distributed Denial of Service):</strong> 攻击者试图通过将大量伪造的请求发送到目标系统，使其超负荷，导致服务不可用。</li>
<li><strong>恶意软件 (Malware):</strong> 恶意软件是一类有意设计用于破坏、干扰计算机系统或窃取信息的软件，包括病毒、蠕虫、木马等。</li>
<li><strong>钓鱼攻击 (Phishing):</strong> 攻击者伪装成可信任的实体，通过虚假的电子邮件、网站等手段，诱导用户揭示敏感信息如用户名、密码等。</li>
<li><strong>社会工程学攻击:</strong> 攻击者利用心理学和人类行为来欺骗、迫使或引导个人执行某些操作，通常涉及人际交往，以获取机密信息。</li>
<li><strong>SQL 注入攻击:</strong> 攻击者通过在用户输入的数据中注入 SQL 代码，从而执行恶意 SQL 查询，破坏数据库的完整性或获取敏感信息。</li>
<li><strong>跨站脚本攻击 (XSS):</strong> 攻击者将恶意脚本注入到网页中，使用户在浏览时执行这些脚本，从而窃取用户信息或劫持用户会话。</li>
<li><strong>跨站请求伪造 (CSRF):</strong> 攻击者通过伪造用户已经认证的请求，利用用户的身份执行未经授权的操作。</li>
<li><strong>中间人攻击 (Man-in-the-Middle):</strong> 攻击者截取和修改通信数据流，使得通信的两个实体认为他们正在直接通信。</li>
<li><strong>DNS 缓存投毒 (DNS Spoofing):</strong> 攻击者通过篡改 DNS 查询结果，将用户导向恶意网站。</li>
</ol>
<hr>


<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="2-1-HTTP-常见面试题"><a href="#2-1-HTTP-常见面试题" class="headerlink" title="2.1 HTTP 常见面试题"></a>2.1 HTTP 常见面试题</h2><h3 id="2-1-1-HTTP-基本概念"><a href="#2-1-1-HTTP-基本概念" class="headerlink" title="2.1.1 HTTP 基本概念"></a>2.1.1 HTTP 基本概念</h3><ul>
<li>HTTP 是？<br>超⽂本传输协议，也就是HyperText Transfer Protocol。<strong>超⽂本</strong>，它就是超越了普通⽂本的⽂本，它是⽂字、图⽚、视频等的混合体，最关键有超链接，能从⼀个超⽂本跳转到另外⼀个超⽂本。HTML 是最常⻅的超⽂本，本身只是纯⽂字⽂件，但内部⽤很多标签定义了图⽚、视频等的链接，再经过浏览器的解释呈现出⼀个⽂字、有画⾯的⽹⻚。<br>HTTP 是⼀个在计算机世界⾥专⻔在「两点」之间「传输」⽂字、图⽚、⾳频、视频等「超⽂本」数据的「约定和规范」。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 请求报文: 由请求行、请求头、空行和请求体组成。</span><br><span class="line">GET /index.html HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line"># 响应报文: 由状态行、响应头、空行和响应体组成。</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 123</span><br></pre></td></tr></table></figure></li>
<li>常见状态码<ul>
<li>1xx：1xx 类状态码属于提示信息，是协议处理中的⼀种中间状态，实际⽤到的⽐较少。</li>
<li>2xx：2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。<br>  「200 OK」是最常⻅的成功状态码，表示⼀切正常。如果是⾮ HEAD 请求，服务器返回的响应头都会有 body  数据。<br>  「204 No Content」也是常⻅的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。<br>  「206 Partial Content」是应⽤于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部⽽是其⼀部分，也是服务器处理成功的状态。</li>
<li>3xx：表示客户端请求的资源发送了变动，需要客户端⽤新的 URL 新发送请求获取资源，也就是<strong>重定向</strong>。<br>  「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改⽤新的 URL 再次访问。<br>  「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要⽤另⼀个 URL 来访问。<br>  301 和 302 都会在响应头⾥使⽤字段 Location ，指明后续要跳转的 URL，浏览器会⾃动重定向新的 URL。<br>  「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲⽂件，也称缓存重定向，⽤于缓存控制。</li>
<li>4xx：表示客户端发送的报⽂有误，服务器⽆法处理，也就是错误码的含义。<br>  「400 Bad Request」表示客户端请求的报⽂有错误，但只是个笼统的错误。<br>  「403 Forbidden」表示服务器禁⽌访问资源，并不是客户端的请求出错。<br>  「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以⽆法提供给客户端。</li>
<li>5xx：表示客户端请求报⽂正确，但是服务器处理时内部发⽣了错误，属于服务器端的错误码。<br>  「500 Internal Server Error」与 400 类型，是个笼统通⽤的错误码，服务器发⽣了什么错误，我们并不知道。<br>  「501 Not Implemented」表示客户端请求的功能还不⽀持，类似“即将开业，敬请期待”的意思。<br>  「502 Bad Gateway」通常是服务器作为⽹关或代理时返回的错误码，表示服务器⾃身⼯作正常，访问后端服务器发⽣错误。<br>  「503 Service Unavailable」表示服务器当前很忙，暂时⽆法响应服务器，类似“⽹络服务正忙，请稍后重试”。</li>
</ul>
</li>
<li>http 常⻅字段有哪些？<ul>
<li>Host 字段：客户端发送请求时，⽤来指定服务器的域名。</li>
<li>Content-Length 字段：服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据⻓度。</li>
<li>Connection 字段：最常⽤于客户端要求服务器使⽤ TCP 持久连接，以便其他请求复⽤。HTTP&#x2F;1.1 版本的默认连接都是持久连接，但为了兼容⽼版本的 HTTP，需要指定 Connection ⾸部字段的值为 Keep-Alive 。<br>Connection: keep-alive，⼀个可以复⽤的 TCP 连接就建⽴了，直到客户端或服务器主动关闭连接。但是这不是标准字段。<img src="https://leo710aka.github.io/bk/net2.png" width="350" height="300" alt=""></li>
<li>Content-Type 字段：⽤于服务器回应时，告诉客户端，本次数据是什么格式。Content-Type: text&#x2F;html; harset&#x3D;utf-8 表明发送的是⽹⻚，⽽且编码是UTF-8。<br>客户端请求的时候，可以使⽤ Accept 字段声明⾃⼰可以接受哪些数据格式。</li>
<li>Content-Encoding 字段：说明数据的压缩⽅法。Content-Encoding: gzip，表示服务器返回的数据采⽤了 gzip ⽅式压缩，告知客户端需要⽤此⽅式解压。<br>客户端在请求时，⽤ Accept-Encoding 字段说明⾃⼰可以接受哪些压缩⽅法。</li>
</ul>
</li>
<li><strong>Cookie和Session</strong>:<ul>
<li><strong>Cookie</strong>:  由服务器发送到浏览器，保存在浏览器上。包含了与用户相关的信息，如用户ID、会话ID等。</li>
<li><strong>Session</strong>:  在服务器端保存用户状态的机制，通常使用Cookie来标识用户。</li>
</ul>
</li>
<li><strong>RESTful API</strong>: 基于HTTP协议设计的一种简洁和统一的Web服务风格。</li>
</ul>
<h3 id="2-1-2-Get-与-Post"><a href="#2-1-2-Get-与-Post" class="headerlink" title="2.1.2 Get 与 Post"></a>2.1.2 Get 与 Post</h3><ul>
<li>GET 和 POST 的区别？<br>Get ⽅法的含义是请求从服务器获取资源，这个资源可以是静态的⽂本、⻚⾯、图⽚视频等。<br>POST ⽅法则是相反操作，它向 URI 指定的资源提交数据，数据就放在报⽂的 body ⾥。</li>
<li>GET 和 POST ⽅法都是安全和幂等的吗？<br>在 HTTP 协议⾥，所谓的「安全」是指请求⽅法不会破坏服务器上的资源，「幂等」意思是多次执⾏相同操作结果都相同。<br>那么很明显 GET ⽅法就是安全且幂等的，因为它是只读操作，⽆论操作多少次，服务器上的数据都是安全的且每结果都相同。<br>因为POST 是新增或提交数据的操作，会修改服务器上的资源，所以不安全，且多次提交数据就会创建多个资源所以不是幂等的。</li>
</ul>
<h3 id="2-1-3-HTTP-特性"><a href="#2-1-3-HTTP-特性" class="headerlink" title="2.1.3 HTTP 特性"></a>2.1.3 HTTP 特性</h3><ul>
<li>HTTP（1.1） 的优点有哪些，怎么体现的？<ol>
<li>简单：HTTP 基本的报⽂格式就是 header + body ，头部信息也是 key-value 简单⽂本的形式，易于理解和使用</li>
<li>灵活和易于扩展：HTTP协议⾥的各类请求⽅法、URI&#x2F;URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发⼈员⾃定义和扩充。同时 HTTP 由于是⼯作在应⽤层（OSI 第七层），则它下层可以随意变化。<br>  HTTPS 也就是在 HTTP 与 TCP 层之间增加了SSL&#x2F;TLS安全传输层，HTTP&#x2F;3甚⾄把 TCP层换成了基于 UDP 的 QUIC。</li>
<li>应⽤⼴泛和跨平台：互联⽹发展⾄今，HTTP 的应⽤范围⾮常的⼴泛，从台式机的浏览器到⼿机上的各种 APP，从看新闻、刷贴吧到购物、理财、吃鸡，HTTP 的应⽤⽚地开花，同时天然具有跨平台的优越性。</li>
</ol>
</li>
<li>HTTP的缺点？<ol>
<li>⽆状态双刃剑：⽆状态的好处，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，把更多的 CPU 和内存⽤来对外提供服务。⽆状态的坏处，既然服务器没有记忆能⼒，它在完成有关联性的操作时会⾮常麻烦。对于⽆状态的问题，解法⽅案有很多种，其中⽐较简单的⽅式⽤ Cookie 技术：通过在请求和响应报⽂中写⼊ Cookie 信息来控制客户端的状态。</li>
<li>明⽂传输双刃剑：明⽂意味着在传输过程中的信息，是可⽅便阅读的，通过浏览器的 F12 控制台或 Wireshark 抓包都可以直接⾁眼查看，为调试⼯作带了极⼤便利。但正是这样，HTTP 的所有信息都暴露在了光天化⽇下，相当于信息裸奔。</li>
<li>不安全：HTTP 的安全问题，可以⽤ HTTPS 的⽅式解决，也就是通过引⼊ SSL&#x2F;TLS 层，使得在安全上达到了极致。<ul>
<li>通信使⽤明⽂（不加密），内容可能会被窃听。⽐如，账号信息容易泄漏，那你号没了。</li>
<li>不验证通信⽅的身份，因此有可能遭遇伪装。⽐如，访问假的淘宝、拼多多，那你钱没了。</li>
<li>⽆法证明报⽂的完整性，所以有可能已遭篡改。⽐如，⽹⻚上植⼊垃圾⼴告，视觉污染，眼没了。</li>
</ul>
</li>
</ol>
</li>
<li>HTTP&#x2F;1.1 的性能如何？<br>  HTTP 协议是基于 TCP&#x2F;IP，并且使⽤了「请求 - 应答」的通信模式，所以性能的关键就在这两点⾥。<ol>
<li>⻓连接：早期 HTTP&#x2F;1.0 性能上的⼀个很⼤的问题，那就是每发起⼀个请求，都要新建⼀次 TCP 连接，⽽且是串⾏请求，做了⽆谓的 TCP 连接建⽴（三次握⼿）和断开（四次挥手）。为了解决上述问题，HTTP&#x2F;1.1 提出了⻓连接的通信⽅式，也叫持久连接，好处在于减少了TCP 连接的重复建⽴和断开所造成的额外开销，减轻了服务器端的负载。<br>  持久连接的特点是，只要任意⼀端没有明确提出断开连接，则保持 TCP 连接状态。</li>
<li>管道⽹络传输：HTTP&#x2F;1.1 采⽤了⻓连接的⽅式，这使得管道（pipeline）⽹络传输成为了可能。即可在同⼀个 TCP 连接⾥⾯，客户端可以发起多个请求，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以减少整体的响应时间。<br>  但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求，可能导致「队头堵塞」。</li>
<li>队头阻塞：「请求 - 应答」的模式加剧了 HTTP 的性能问题。 因为当顺序发送的请求序列中的⼀个请求因为某种原因被阻塞时，在后⾯排队的所有请求也⼀同被阻塞了，会招致客户端⼀直请求不到数据。<br>  总之 HTTP&#x2F;1.1 的性能⼀般般，后续的 HTTP&#x2F;2 和 HTTP&#x2F;3 就是在优化 HTTP 的性能。</li>
</ol>
</li>
</ul>
<h3 id="2-1-4-HTTPS-与-HTTP-小林p27"><a href="#2-1-4-HTTPS-与-HTTP-小林p27" class="headerlink" title="2.1.4 HTTPS 与 HTTP(小林p27)"></a>2.1.4 HTTPS 与 HTTP(小林p27)</h3><ul>
<li>HTTP 与 HTTPS 有哪些区别？<ol>
<li>HTTP 是超⽂本传输协议，信息是明⽂传输，存在安全⻛险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP ⽹络层之间加⼊了 SSL&#x2F;TLS 安全协议，使得报⽂能够加密传输。</li>
<li>HTTP 连接建⽴相对简单，TCP 三次握⼿之后便可进⾏ HTTP 的报⽂传输。⽽ HTTPS 在 TCP 三次握⼿之后，还需进⾏ SSL&#x2F;TLS 的握⼿过程，才可进⼊加密报⽂传输。</li>
<li>HTTP 的端⼝号是 80，HTTPS 的端⼝号是 443。</li>
<li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li>
</ol>
</li>
<li>HTTPS 解决了 HTTP 的哪些问题？<br>  HTTP 由于是明⽂传输，所以安全上存在以下三个⻛险：<ol>
<li>窃听⻛险，⽐如通信链路上可以获取通信内容，⽤户号容易没。</li>
<li>篡改⻛险，⽐如强制植⼊垃圾⼴告，视觉污染，⽤户眼容易瞎。</li>
<li>冒充⻛险，⽐如冒充淘宝⽹站，⽤户钱容易没。<br>  HTTPS 在 HTTP 与 TCP 层之间加⼊了 SSL&#x2F;TLS 协议，可以很好的解决了上述的⻛险。信息加密：交互信息⽆法被窃取；校验机制：⽆法篡改通信内容，篡改了就不能正常显示；身份证书：证明淘宝是真的淘宝⽹。。</li>
</ol>
</li>
<li>HTTPS 是如何解决上⾯的三个⻛险的？<ol>
<li>混合加密：通过混合加密的⽅式可以保证信息的机密性，解决了窃听的⻛险。<br>  ？？？HTTPS 采⽤的是对称加密和⾮对称加密结合的「混合加密」⽅式：在通信建⽴前采⽤⾮对称加密的⽅式交换「会话秘钥」，后续就不再使⽤⾮对称加密； 在通信过程中全部使⽤对称加密的「会话秘钥」的⽅式加密明⽂数据。<br>  采⽤「混合加密」的⽅式的原因：对称加密只使⽤⼀个密钥，运算速度快，密钥必须保密，⽆法做到安全的密钥交换；⾮对称加密使⽤两个密钥：公钥和私钥，公钥可以任意分发⽽私钥保密，解决了密钥交换问题但速度慢。  <img src="https://leo710aka.github.io/bk/net3.png" width="350" height="300" alt=""></li>
<li>摘要算法：摘要算法能够为数据⽣成独⼀⽆⼆的「指纹」，⽤于校验数据的完整性，解决了篡改的⻛险。<br>  客户端在发送明⽂之前会通过摘要算法算出明⽂的「指纹」，发送的时候把「指纹 + 明⽂」⼀同加密成密⽂后，发送给服务器，服务器解密后，⽤相同的摘要算法算出发送过来的明⽂，通过⽐较客户端携带的「指纹」和当前算出的「指纹」做⽐较，若「指纹」相同，说明数据是完整的。</li>
<li>数字证书：客户端先向服务器端索要公钥，然后⽤公钥加密信息，服务器收到密⽂后，⽤⾃⼰的私钥解密。这就存在些问题，如何保证公钥不被篡改和信任度？借助第三⽅权威机构 CA（数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。</li>
</ol>
</li>
<li>？？？HTTPS 是如何建⽴连接的？其间交互了什么？<br>SSL&#x2F;TLS 协议基本流程：客户端向服务器索要并验证服务器的公钥、双⽅协商⽣产「会话秘钥」、双⽅采⽤「会话秘钥」进⾏加密通信。前两步也就是 SSL&#x2F;TLS 的建⽴过程，也就是握⼿阶段。<br>SSL&#x2F;TLS 的「握⼿阶段」涉及四次通信，可⻅下图：p32</li>
<li>“https和http相⽐，就是传输的内容多了对称加密，可以这么理解吗？”<br>建⽴连接时候：https ⽐ http多了 TLS 的握⼿过程；<br>传输内容的时候：https 会把数据进⾏加密，通常是对称加密数据；</li>
<li>“TLS 和 SSL 需要区分吗？”<br>这两实际上是⼀个东⻄。SSL 是 “Secure Sockets Layer 的缩写，中⽂叫做「安全套接层」，SSL 标准化之后的名称改为 TLS（是 “Transport Layer Security” 的缩写），中⽂叫做 「传输层安全协议」；两者可以视作同⼀个东⻄的不同阶段。</li>
<li>？？？“为啥 ssl 的握⼿是 4 次？”<br>SSL&#x2F;TLS 1.2 需要 4 握⼿，需要 2 个 RTT 的时延。把每个交互合在⼀起发送，就是 4 次握⼿：p40</li>
</ul>
<h3 id="2-1-5-HTTP-1-1、HTTP-2、HTTP-3-演变"><a href="#2-1-5-HTTP-1-1、HTTP-2、HTTP-3-演变" class="headerlink" title="2.1.5 HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变"></a>2.1.5 HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变</h3><ul>
<li>说说 HTTP&#x2F;1.1 相⽐ HTTP&#x2F;1.0 提⾼了什么性能？<br>性能上的改进：1、使⽤ TCP ⻓连接的⽅式改善了 HTTP&#x2F;1.0 短连接造成的性能开销。2、⽀持管道（pipeline）⽹络传输，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以减少整体的响应时间。<br>性能瓶颈：1、请求 &#x2F; 响应头部（Header）未经压缩就发送，⾸部信息越多延迟越⼤。只能压缩 Body 的部分；2、发送冗⻓的⾸部。每次互相发送相同的⾸部造成的浪费较多；3、服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端⼀直请求不到数据，也就是队头阻塞；4、没有请求优先级控制；5、请求只能从客户端开始，服务器只能被动响应。</li>
<li>对于上⾯的 HTTP&#x2F;1.1 的性能瓶颈，HTTP&#x2F;2 做了什么优化？<br>  HTTP&#x2F;2 协议是基于 HTTPS 的，所以 HTTP&#x2F;2 的安全性也是有保障的。HTTP&#x2F;2 相⽐ HTTP&#x2F;1.1 性能上的改进：<ol>
<li>头部压缩：HTTP&#x2F;2 会压缩头（Header）如果你同时发出多个请求，他们的头是⼀样的或是相似的，那么，协议会帮你消除重<br>  复的部分。这就是所谓的 HPACK 算法：在客户端和服务器同时维护⼀张头信息表，所有字段都会存⼊这个表，⽣成⼀个索引号，以后就不发送同样字段了，只发送索引号，这样就提⾼速度了。</li>
<li>⼆进制格式：HTTP&#x2F;2 不再像 HTTP&#x2F;1.1 ⾥的纯⽂本形式的报⽂，⽽是全⾯采⽤了⼆进制格式，头信息和数据体都是⼆进制，并且统称为帧（frame）：头信息帧和数据帧。计算机收到报⽂后，⽆需再将明⽂的报⽂转成⼆进制，⽽是直接解析⼆进制报⽂，这增加了数据传输的效率。</li>
<li>数据流：HTTP&#x2F;2 的数据包不是按顺序发送的，同⼀个连接⾥⾯连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。每个请求或回应的所有数据包，称为⼀个数据流（Stream）。每个数据流都标记着⼀个独⼀⽆⼆的编号，其中规定客户端发出的数据流编号为奇数，服务器发出的数据流编号为偶数。<br>  客户端还可以指定数据流的优先级。优先级⾼的请求，服务器就先响应该请求。</li>
<li>多路复⽤：HTTP&#x2F;2 是可以在⼀个连接中并发多个请求或回应，⽽不⽤按照顺序⼀⼀对应。<br>  移除了 HTTP&#x2F;1.1 中的串⾏请求，不需要排队等待，也就不会再出现队头阻塞问题，降低延迟，⼤幅度提⾼连接的利⽤率。</li>
<li>服务器推送：HTTP&#x2F;2 ⼀定程度上改善了传统的「请求 - 应答」⼯作模式，服务不再被动响应，也可主动向客户端发送消息。</li>
</ol>
</li>
<li>HTTP&#x2F;2 有哪些缺陷？HTTP&#x2F;3 做了哪些优化？<br>  HTTP&#x2F;2 主要的问题在于，多个 HTTP 请求在复⽤⼀个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。⼀旦发⽣了丢包，就会触发 TCP 的重传机制，在⼀个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。<ul>
<li>HTTP&#x2F;1.1 中的管道（ pipeline）传输中如果有⼀个请求阻塞了，那么队列后请求也统统被阻塞住了</li>
<li>HTTP&#x2F;2 多个请求复⽤⼀个TCP连接，⼀旦发⽣丢包，就会阻塞住所有的 HTTP 请求。<br>  这都是基于 TCP 传输层的问题，所以 HTTP&#x2F;3 把 HTTP 下层的 TCP 协议改成了 UDP！（⼤家都知道 UDP 是不可靠传输的，但基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输）  <img src="https://leo710aka.github.io/bk/net6.png" width="550" height="300" alt=""></li>
</ul>
</li>
</ul>
<h2 id="2-2-HTTP-1-1如何优化？"><a href="#2-2-HTTP-1-1如何优化？" class="headerlink" title="2.2 HTTP&#x2F;1.1如何优化？"></a>2.2 HTTP&#x2F;1.1如何优化？</h2><p>使⽤ KeepAlive 将 HTTP&#x2F;1.1 从短连接改成⻓链接。这个确实是⼀个优化的⼿段，它是从底层的传输层这⼀⽅向⼊⼿的，通过减少 TCP 连接建⽴和断开的次数，来减少了⽹络传输的延迟，从⽽提⾼ HTTP&#x2F;1.1 协议的传输效率。<br>但其实还可以从其他⽅向来优化 HTTP&#x2F;1.1 协议，⽐如有如下 3 种优化思路：</p>
<ol>
<li>尽量避免发送 HTTP 请求；<br>对于⼀些具有重复性的 HTTP 请求，⽐如每次请求得到的数据都⼀样的，我们可以把这对「请求-响应」的数据都<strong>缓存在本地</strong>，那么下次就直接读取本地的数据，不必在通过⽹络获取服务器的响应了，这样的话 HTTP&#x2F;1.1的性能肯定⾁眼可⻅的提升。<br>所以，避免发送 HTTP 请求的⽅法就是通过缓存技术，HTTP 设计者早在之前就考虑到了这点，因此 HTTP 协议的头部有不少是针对缓存的字段。<br>那缓存是如何做到的呢？客户端会把第⼀次请求以及响应的数据保存在本地磁盘上，其中将请求的 URL 作为 key，⽽响应作为 value，两者形成映射关系。这样当后续发起相同的请求时，就可以先在本地磁盘上通过 key 查到对应的 value，也就是响应，如果找到了，就直接从本地读取该响应。毋庸置疑，读取本次磁盘的速度肯定⽐⽹络请求快得多，如下图：<br>缓存的响应不是最新的？服务器在发送 HTTP 响应时，会估算⼀个过期的时间，并把这个信息放到响应头部中，这样客户端在查看响应头部的信息时，⼀旦发现缓存的响应是过期的，则就会重新发送⽹络请求。<br>如果客户端从第⼀次请求得到的响应头部中发现该响应过期了，客户端重新发送请求，假设服务器上的资源并没有变更，还是⽼样⼦，那么就不用在服务器的响应带上这个资源。只需要客户端在重新发送请求时，在请求的 Etag 头部带上第⼀次请求的响应头部中的摘要，这个摘要是唯⼀标识响应的资源，当服务器收到请求后，会将本地资源的摘要与请求中的摘要做个⽐较。<br>如果不同，那么说明客户端的缓存已经没有价值，服务器在响应中带上最新的资源。如果相同，说明客户端的缓存还是可以继续使⽤的，那么服务器仅返回不含有包体的 304 Not Modified 响应，告诉客户端仍然有效，这样就可以减少响应资源在⽹络中传输的延时。</li>
<li>在需要发送 HTTP 请求时，考虑如何减少请求次数；（p47）<ul>
<li>减少重定向请求次数：如果重定向请求越多，那么客户端就要多次发起 HTTP 请求；另外，服务端这⼀⽅往往不只有⼀台服务器，⽐如源服务器上⼀级是代理服务器，然后代理服务器才与客户端通信，这时客户端重定向就会导致客户端与代理服务器之间需要 2 次消息传递。<br> 如果重定向的⼯作交由代理服务器完成，就能减少 HTTP 请求次数了；⽽且当代理服务器知晓了重定向规则后，可以进⼀步减少消息传递次数</li>
<li>合并请求：如果把多个访问⼩⽂件的请求合并成⼀个⼤的请求，虽然传输的总资源还是⼀样，但是减少请求，也就意味着减少了重复发送的 HTTP 头部。另外由于 HTTP&#x2F;1.1 是请求响应模型，如果第⼀个发送的请求，未收到对应的响应，那么后续的请求就不会发送，于是为了防⽌单个请求的阻塞，所以⼀般浏览器会同时发起 5-6 个请求，每⼀个请求都是不同的 TCP 连接，那么如果合并了请求，也就会减少 TCP 连接的数量，因⽽省去了 TCP 握⼿和慢启动过程耗费的时间。<br> 即合并请求的⽅式就是合并资源，以⼀个⼤资源的请求替换多个⼩资源的请求。但是这样会带来新的问题，当⼤资源中的某⼀个⼩资源发⽣变化后，客户端必须重新下载整个完整的⼤资源⽂件，这显然带来了额外的⽹络消耗。</li>
<li>延迟发送请求：不要⼀⼝⽓吃成⼤胖⼦，⼀般 HTML ⾥会含有很多 HTTP 的 URL，当前不需要的资源，我们没必要也获取过来，于是可以通过「按需获取」的⽅式，来减少第⼀时间的 HTTP 请求次数。请求⽹⻚的时候，没必要把全部资源都获取到，⽽是只获取当前⽤户所看到的⻚⾯资源，当⽤户向下滑动⻚⾯的时候，再向服务器获取接下来的资源，这样就达到了延迟发送请求的效果。</li>
</ul>
</li>
<li>减少服务器的 HTTP 响应的数据⼤⼩；<br> 对响应的资源进⾏压缩，这样就可以减少响应的数据⼤⼩，从⽽提⾼⽹络传输的效率。压缩的⽅式⼀般分为 2 种，分别是：<ul>
<li>⽆损压缩：指资源经过压缩后，信息不被破坏，还能完全恢复到压缩前的原样，适合⽤在txt、exe、程序源代码。<br> gzip 就是⽐较常⻅的⽆损压缩。客户端⽀持的压缩算法，会在 HTTP 请求中通过头部中的 Accept-Encoding: gzip, deflate, br 字段告诉服务器；服务器收到后，会从中选择⼀个服务器⽀持的或者合适的压缩算法，然后使⽤此压缩算法对响应资源进⾏压缩，最后通过响应头部中的 content-encoding: gzip 字段告诉客户端该资源使⽤的压缩算法。</li>
<li>有损压缩：将次要的数据舍弃，牺牲⼀些质量来减少数据量、提⾼压缩⽐，解压的数据会与原始数据不同但是⾮常接近，经常⽤于压缩多媒体数据⽐如⾳频、视频、图⽚。<br> 可以通过 HTTP 请求头部中的 Accept: audio&#x2F;*; q&#x3D;0.2, audio&#x2F;basic，告诉服务器期望的资源质量。<br> 相同图⽚质量下，WebP 格式的图⽚⼤⼩都⽐ Png 格式的图⽚⼩，网站可以考虑使⽤ WebP 格式的图⽚。<br> ⾳视频主要是动态的，每个帧都有时序的关系，通常时间连续的帧之间的变化很⼩。只需在⼀个静态的关键帧，使⽤增量数据来表达后续的帧，这样便减少了很多数据。视频常⻅的编码格式有 H264、H265 等，⾳频常⻅的编码格式有 AAC、AC3。</li>
</ul>
</li>
</ol>
<h2 id="2-3-HTTPS-RSA-握⼿解析（p55）"><a href="#2-3-HTTPS-RSA-握⼿解析（p55）" class="headerlink" title="2.3 HTTPS RSA 握⼿解析（p55）"></a>2.3 HTTPS RSA 握⼿解析（p55）</h2><ul>
<li>？？？TLS 的握⼿过程<br>有了 TLS 协议，能保证 HTTP 通信是安全的了，那么在进⾏ HTTP 通信前，需要先进⾏ TLS 握⼿。，如下图</li>
</ul>
<h2 id="2-4-HTTPS-ECDHE-握⼿解析（p？）"><a href="#2-4-HTTPS-ECDHE-握⼿解析（p？）" class="headerlink" title="2.4 HTTPS ECDHE 握⼿解析（p？）"></a>2.4 HTTPS ECDHE 握⼿解析（p？）</h2><ul>
<li>？？？</li>
</ul>
<h2 id="2-5-HTTPS-如何优化？"><a href="#2-5-HTTPS-如何优化？" class="headerlink" title="2.5 HTTPS 如何优化？"></a>2.5 HTTPS 如何优化？</h2><p>由裸数据传输的 HTTP 协议转成加密数据传输的 HTTPS 协议，给应⽤数据套了个「保护伞」，提⾼安全性的同时也带来了性能消耗。HTTPS 相⽐ HTTP 协议多⼀个 TLS 协议握⼿过程，⽬的是为了通过⾮对称加密握⼿协商或者交换出对称加密密钥，这个过程最⻓可以花费掉 2 RTT，接着后续传输的应⽤数据都得使⽤对称加密密钥来加密&#x2F;解密。<br>⾄今⼤部分⽹址都已从 HTTP 迁移⾄ HTTPS 协议，因此针对HTTPS 的优化是⾮常重要的。<br>。。。</p>
<hr>


<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="3-1-TCP-三次握⼿与四次挥⼿（小林p122）"><a href="#3-1-TCP-三次握⼿与四次挥⼿（小林p122）" class="headerlink" title="3.1 TCP 三次握⼿与四次挥⼿（小林p122）"></a>3.1 TCP 三次握⼿与四次挥⼿（小林p122）</h2><ul>
<li>TCP头格式<ol>
<li>序列号：在建⽴连接时由计算机⽣成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送⼀次数据，就「累加」⼀次该「数据字节数」的⼤⼩。⽤来解决⽹络包乱序问题。</li>
<li>确认应答号：指下⼀次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。⽤来解决不丢包的问题。</li>
<li>控制位：<br>  ACK：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建⽴连接时的 SYN 包之外该位必须设置为 1 。<br>  RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。<br>  SYN：该位为 1 时，表示希望建⽴连接，并在其「序列号」的字段进⾏序列号初始值的设定。<br>  FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双⽅的主机之间就可以相互交换 FIN 位为 1 的 TCP 段。  <img src="https://leo710aka.github.io/bk/net5.png" width="500" height="300" alt=""></li>
</ol>
</li>
<li>为什么需要 TCP 协议？ TCP ⼯作在哪⼀层？<br>IP 层是「不可靠」的，它不保证⽹络包的交付、不保证⽹络包的按序交付、也不保证⽹络包中的数据的完整性。<br>如果需要保障⽹络数据包的可靠性，那么就需要由上层（传输层）的 TCP 协议来负责。TCP 是⼀个⼯作在传输层的可靠数据传输的服务，它能确保接收端接收的⽹络包是⽆损坏、⽆间隔、⾮冗余和按序的。</li>
<li>什么是 TCP ？<br>TCP 是⾯向连接的、可靠的、基于字节流的传输层通信协议。<br>⾯向连接：⼀定是「⼀对⼀」才能连接，不能像 UDP 协议可以⼀个主机同时向多个主机发送消息，也就是⼀对多是⽆法做到的；<br>可靠的：⽆论的⽹络链路中出现了怎样的链路变化，TCP 都可以保证⼀个报⽂⼀定能够到达接收端；<br>字节流：消息是「没有边界」的，所以⽆论我们消息有多⼤都可以进⾏传输。并且消息是「有序的」，当「前⼀个」消息没有收到的时候，即使它先收到了后⾯的字节，那么也不能扔给应⽤层去处理，同时对重复的报⽂会⾃动丢弃</li>
<li>什么是 TCP 连接？<br>简单来说就是，⽤于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗⼝⼤⼩称为连接。<br>建⽴⼀个 TCP 连接是需要客户端与服务器端达成上述三个信息的共识。<br>Socket：由 IP 地址和端⼝号组成；序列号：⽤来解决乱序问题等；窗⼝⼤⼩：⽤来做流量控制</li>
<li>如何唯⼀确定⼀个 TCP 连接呢？<br>TCP 四元组可以唯⼀的确定⼀个连接，四元组包括：源地址、源端⼝、⽬的地址、⽬的端⼝<br>源地址和⽬的地址的字段（32位）是在 IP 头部中，作⽤是通过 IP 协议发送报⽂给对⽅主机。<br>源端⼝和⽬的端⼝的字段（16位）是在 TCP 头部中，作⽤是告诉 TCP 协议应该把报⽂发给哪个进程。</li>
<li>有⼀个 IP 的服务器监听了⼀个端⼝，它的 TCP 的最⼤连接数是多少？<br>服务器通常固定在某个本地端⼝上监听，等待客户端的连接请求。因此，客户端 IP 和 端⼝是可变的，其理论值计算公式如下<br>最大 TCP 连接数 &#x3D; 客户端的 IP 数 * 客户端的端口数</li>
<li>UDP 协议？<br>UDP 不提供复杂的控制机制，利⽤ IP 提供⾯向「⽆连接」的通信服务。UDP 协议非常简单，头部只有 8 个字节（ 64 位），<br>⽬标和源端⼝：主要是告诉 UDP 协议应该把报⽂发给哪个进程。包⻓度：该字段保存了 UDP ⾸部的⻓度跟数据的⻓度之和。校验和：校验和是为了提供可靠的 UDP ⾸部和数据⽽设计。<img src="https://leo710aka.github.io/bk/net7.png" width="500" height="300" alt=""> </li>
<li>UDP 和 TCP 有什么区别呢？<ol>
<li>连接：TCP 是⾯向连接的传输层协议，传输数据前先要建⽴连接。UDP 是不需要连接，即刻传输数据。</li>
<li>服务对象：TCP 是⼀对⼀的两点服务，即⼀条连接只有两个端点。UDP ⽀持⼀对⼀、⼀对多、多对多的交互通信</li>
<li>可靠性：TCP是可靠交付数据的，数据可以⽆差错、不丢失、不重复、按需到达。UDP尽最⼤努⼒，不保证可靠交付数据。</li>
<li>拥塞控制、流量控制：TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。UDP 则没有，即使⽹络⾮常拥堵了，也不会影响 UDP 的发送速率。</li>
<li>⾸部开销：TCP ⾸部⻓度较⻓，会有⼀定的开销，⾸部在没有使⽤「选项」字段时是 20 个字节，如果使⽤了「选项」字段则会变⻓的。UDP ⾸部只有 8 个字节，并且是固定不变的，开销较⼩。</li>
<li>传输⽅式：TCP 是流式传输，没有边界，但保证顺序和可靠。UDP 是⼀个包⼀个包的发送，是有边界的，但可能丢包和乱序。</li>
<li>分⽚不同：<ul>
<li>TCP 的数据⼤⼩如果⼤于 MSS ⼤⼩，则会在传输层进⾏分⽚，⽬标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了⼀个分⽚，只需要传输丢失的这个分⽚。</li>
<li>UDP 的数据⼤⼩如果⼤于 MTU ⼤⼩，则会在 IP 层进⾏分⽚，⽬标主机收到后，在 IP 层组装完数据，接着再传给传输层，但是如果中途丢了⼀个分⽚，在实现可靠传输的 UDP 时则就需要重传所有的数据包，这样传输效率⾮常差，所以通常 UDP 的报⽂应该⼩于 MTU。</li>
</ul>
</li>
</ol>
</li>
<li>TCP 和 UDP 应⽤场景：<br>由于 TCP 是⾯向连接，能保证数据的可靠性交付，因此经常⽤于：FTP ⽂件传输，HTTP &#x2F; HTTPS<br>由于 UDP ⾯向⽆连接，它可以随时发送数据，再加上UDP本身的处理既简单⼜⾼效，因此经常⽤于：包总量较少的通信，如 DNS、 SNMP 等，视频、⾳频等多媒体通信，⼴播通信</li>
<li>为什么 UDP 头部没有「⾸部⻓度」字段，⽽ TCP 头部有「⾸部⻓度」字段呢？<br>原因是 TCP 有可变⻓的「选项」字段，⽽ UDP 头部⻓度则是不会变化的，⽆需多⼀个字段去记录 UDP 的⾸部⻓度。</li>
<li>为什么 UDP 头部有「包⻓度」字段，⽽ TCP 头部则没有「包⻓度」字段呢？<br>先说说 TCP 是如何计算负载数据⻓度：？？？</li>
</ul>
<h3 id="TCP-建立（p131）"><a href="#TCP-建立（p131）" class="headerlink" title="TCP 建立（p131）"></a>TCP 建立（p131）</h3><ul>
<li>TCP 三次握⼿过程和状态变迁<br>  TCP 是⾯向连接的协议，所以使⽤ TCP 前必须先建⽴连接，⽽建⽴连接是通过三次握⼿来进⾏的。 <ol>
<li>⼀开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端⼝，处于 LISTEN 状态</li>
<li>客户端会随机初始化序号(client_isn)，将此序号置于 TCP ⾸部的「序号」字段中，同时把 SYN 标志位置为 1，表示 SYN 报⽂。接着把第⼀个 SYN 报⽂发送给服务端，表示向服务端发起连接，不包含应⽤层数据，之后客户端处于 SYN-SENT 状态。</li>
<li>服务端收到客户端的 SYN 报⽂后，⾸先服务端也随机初始化⾃⼰的序号（server_isn），将此序号填⼊TCP ⾸部的「序号」字段中，其次把 TCP ⾸部的「确认应答号」字段填⼊ client_isn + 1 , 接着把 SYN和 ACK 标志位置为 1 。最后把该报⽂发给客户端，该报⽂也不包含应⽤层数据，之后服务端处于 SYN-RCVD 状态。</li>
<li>客户端收到服务端报⽂后，还要向服务端回应最后⼀个应答报⽂，⾸先该应答报⽂ TCP ⾸部 ACK 标志位置为 1 ，其次「确认应答号」字段填⼊ server_isn + 1 ，最后把报⽂发送给服务端，这次报⽂可以携带客户到服务器的数据，之后客户端处于 ESTABLISHED 状态。（可以发现第三次握⼿是可以携带数据的，前两次握⼿是不可以携带数据的，这也是⾯试常问的题。</li>
<li>服务器收到客户端的应答报⽂后，也进⼊ ESTABLISHED 状态。⼀旦完成三次握⼿，双⽅都处于 ESTABLISHED 状态，此时连接就已建⽴完成，客户端和服务端就可以相互发送数据了。  <img src="https://leo710aka.github.io/bk/net8.png" width="500" height="300" alt=""></li>
</ol>
</li>
</ul>
<h2 id="3-2-TCP-重传、滑动窗口、流量控制、拥塞控制（小林p？）"><a href="#3-2-TCP-重传、滑动窗口、流量控制、拥塞控制（小林p？）" class="headerlink" title="3.2 TCP 重传、滑动窗口、流量控制、拥塞控制（小林p？）"></a>3.2 TCP 重传、滑动窗口、流量控制、拥塞控制（小林p？）</h2><p>- </p>
<h2 id="3-3-TCP-实战抓包分析（小林p？）"><a href="#3-3-TCP-实战抓包分析（小林p？）" class="headerlink" title="3.3 TCP 实战抓包分析（小林p？）"></a>3.3 TCP 实战抓包分析（小林p？）</h2><p>- </p>
<h2 id="3-4-TCP-半链接队列和全连接队列（小林p？）"><a href="#3-4-TCP-半链接队列和全连接队列（小林p？）" class="headerlink" title="3.4 TCP 半链接队列和全连接队列（小林p？）"></a>3.4 TCP 半链接队列和全连接队列（小林p？）</h2><p>- </p>
<h2 id="3-5-TCP-内核参数（小林p？）"><a href="#3-5-TCP-内核参数（小林p？）" class="headerlink" title="3.5 TCP 内核参数（小林p？）"></a>3.5 TCP 内核参数（小林p？）</h2><p>- </p>
<hr>


<h1 id="四、IP"><a href="#四、IP" class="headerlink" title="四、IP"></a>四、IP</h1><h2 id="4-1-IP基础知识"><a href="#4-1-IP基础知识" class="headerlink" title="4.1 IP基础知识"></a>4.1 IP基础知识</h2><h3 id="4-1-1-IP-基本认识（p314"><a href="#4-1-1-IP-基本认识（p314" class="headerlink" title="4.1.1 IP 基本认识（p314"></a>4.1.1 IP 基本认识（p314</h3><ul>
<li><p>⽹络层的主要作⽤是：实现主机与主机之间的通信，也叫点对点（end to end）通信。<br>IP 的作用是在复杂的网络环境中将数据包发送给最终目的主机。</p>
</li>
<li><p>⽹络层与数据链路层有什么关系呢？<br>IP 的作⽤是主机之间通信⽤的，⽽ MAC 的作⽤则是实现「直连」的两个设备之间通信，⽽ IP 则负责在「没有直连」的两个⽹络之间进⾏通信传输。</p>
<img src="https://leo710aka.github.io/bk/net/21.png" width="500" height="300" alt="">
如果⼩林只有⾏程表⽽没有⻋票，就⽆法搭乘交通⼯具到达⽬的地。相反，如果除了⻋票⽽没有⾏程表，恐怕也很难到达⽬的地。因为⼩林不知道该坐什么⻋，也不知道该在哪⾥换乘。因此，只有两者兼备，既有某个区间的⻋票⼜有整个旅⾏的⾏程表，才能保证到达⽬的地。与此类似，计算机⽹络中也需要「数据链路层」和「⽹络层」这个分层才能实现向最终⽬标地址的通信。
还有重要⼀点，旅⾏途中我们虽然不断变化了交通⼯具，但是旅⾏⾏程的起始地址和⽬的地址始终都没变。其实，在⽹络中数据包传输中也是如此，源IP地址和⽬标IP地址在传输过程中是不会变化的，只有源 MAC 地址和⽬标 MAC ⼀直在变化。</li>
</ul>
<h3 id="4-1-2-IP-地址的基础知识"><a href="#4-1-2-IP-地址的基础知识" class="headerlink" title="4.1.2 IP 地址的基础知识"></a>4.1.2 IP 地址的基础知识</h3><ul>
<li><p>在 TCP&#x2F;IP ⽹络通信时，为了保证能正常通信，每个设备都需要配置正确的 IP 地址，否则⽆法实现正常的通信。<br>IP 地址（IPv4 地址）由 32 位正整数来表示，IP 地址在计算机是以⼆进制的⽅式处理的。⽽⼈类为了⽅便记忆采⽤了点分⼗进制的标记⽅式，也就是将 32 位 IP 地址以每 8 位为组，共分为 4 组，每组以「 . 」隔开，再将每组转换成⼗进制。</p>
<img src="https://leo710aka.github.io/bk/net/22.png" width="300" height="300" alt="">
那么，IP 地址最⼤值是 2^32，也即最⼤允许 43 亿台计算机连接到⽹络。
实际上，IP 地址是以⽹卡数来配置的。像服务器、路由器等设备都是有 2 个以上的⽹卡，是会有 2 个以上的 IP 地址；更何况 IP 地址是由「⽹络标识」和「主机标识」这两个部分组成的，所以实际能够连接到⽹络的计算机个数更是少了很多。
根据⼀种可以更换 IP 地址的技术 NAT ，使得可连接计算机数超过 43 亿台。 
</li>
<li><p>IP 地址的分类<br>互联⽹诞⽣之初，IP 地址显得很充裕，于是科学家们设计了 5 种分类地址，分别是 A 类、B 类、C 类、D 类、E 类。<br>下图中⻩⾊部分为分类号，⽤以区分 IP 地址类别</p>
<img src="https://leo710aka.github.io/bk/net/23.png" width="500" height="300" alt="">
</li>
<li><p>什么是 A、B、C 类地址？<br>？？p318</p>
</li>
</ul>
<h3 id="4-1-3-IP-协议相关技术（p340"><a href="#4-1-3-IP-协议相关技术（p340" class="headerlink" title="4.1.3 IP 协议相关技术（p340"></a>4.1.3 IP 协议相关技术（p340</h3><ul>
<li><p>DNS 域名解析<br>  域名⽅便⼈类记忆，使用 DNS 域名解析将域名⽹址⾃动转换为具体的 IP 地址。</p>
<ul>
<li>域名的层级关系<br>  DNS 中的域名都是⽤句点来分隔的，⽐如 <a target="_blank" rel="noopener" href="http://www.server.com/">www.server.com</a> ，这⾥的句点代表了不同层次之间的界限。<br>  在域名中，越靠右的位置表示其层级越⾼，层级关系类似⼀个树状结构：根 DNS 服务器、顶级域 DNS 服务器（com）、权威 DNS 服务器（server.com）  <img src="https://leo710aka.github.io/bk/net13.png" width="300" height="300" alt=""> 
  根域的 DNS 服务器信息保存在互联⽹中所有的 DNS 服务器中。这样⼀来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。因此，客户端只要能够找到任意⼀台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再⼀路顺藤摸⽠找到位于下层的某台⽬标 DNS 服务器</li>
<li>域名解析的⼯作流程<ol>
<li>客户端⾸先会发出⼀个 DNS 请求，问 <a target="_blank" rel="noopener" href="http://www.server.com/">www.server.com</a> 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端 的 TCP&#x2F;IP 设置中填写的 DNS 服务器地址）。</li>
<li>本地域名服务器收到客户端的请求后，如果缓存⾥的表格能找到 <a target="_blank" rel="noopener" href="http://www.server.com,/">www.server.com，</a> 则它直接返回 IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“⽼⼤， 能告诉我 <a target="_blank" rel="noopener" href="http://www.server.com/">www.server.com</a> 的 IP 地址吗？” 根域名服务器是最⾼层次的，它不直接⽤于域名解析，但能指明⼀条道路。</li>
<li>根 DNS 收到来⾃本地 DNS 的请求后，发现后置是 .com，说：“<a target="_blank" rel="noopener" href="http://www.server.com/">www.server.com</a> 这个域名归 .com 区域管    理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”</li>
<li>本地 DNS 收到顶级域名服务器的地址后，发起请求问“⽼⼆， 你能告诉我 <a target="_blank" rel="noopener" href="http://www.server.com/">www.server.com</a> 的 IP 地址吗？”</li>
<li>顶级域名服务器说：“我给你负责 <a target="_blank" rel="noopener" href="http://www.server.com/">www.server.com</a> 区域的权威 DNS 服务器的地址，你去问它应该能问到”。</li>
<li>本地 DNS 于是转向问权威 DNS 服务器：“⽼三，<a target="_blank" rel="noopener" href="http://www.server.com/">www.server.com</a> 对应的IP是啥呀？” server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</li>
<li>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li>
<li>本地 DNS 再将 IP 地址返回客户端，客户端和⽬标建⽴连接。  <img src="https://leo710aka.github.io/bk/net14.png" width="700" height="300" alt=""></li>
</ol>
</li>
</ul>
</li>
<li><p>ARP 与 RARP 协议<br>？？p342</p>
</li>
<li><p>DHCP 动态获取 IP 地址</p>
</li>
</ul>
<p>。。</p>
<ul>
<li>NAT ⽹络地址转换</li>
</ul>
<p>。。</p>
<ul>
<li>ICMP 互联⽹控制报⽂协议</li>
</ul>
<p>。。</p>
<ul>
<li>IGMP 因特⽹组管理协</li>
</ul>
<p>。。</p>
<h2 id="4-2-ping-的工作原理"><a href="#4-2-ping-的工作原理" class="headerlink" title="4.2 ping 的工作原理"></a>4.2 ping 的工作原理</h2><p>- </p>
<hr>


<h1 id="五、网络综合篇"><a href="#五、网络综合篇" class="headerlink" title="五、网络综合篇"></a>五、网络综合篇</h1><h2 id="5-1-键入网址到网页显示，期间发生了什么？"><a href="#5-1-键入网址到网页显示，期间发生了什么？" class="headerlink" title="5.1 键入网址到网页显示，期间发生了什么？"></a>5.1 键入网址到网页显示，期间发生了什么？</h2><img src="https://leo710aka.github.io/bk/net11.png" width="600" height="300" alt=""> 

<h3 id="5-1-1-浏览器做的第⼀步⼯作是解析-URL"><a href="#5-1-1-浏览器做的第⼀步⼯作是解析-URL" class="headerlink" title="5.1.1 浏览器做的第⼀步⼯作是解析 URL"></a>5.1.1 浏览器做的第⼀步⼯作是解析 URL</h3><ul>
<li>⾸先浏览器做的第⼀步⼯作就是要对 URL 进⾏解析，从⽽⽣成发送给 Web 服务器的请求信息。<img src="https://leo710aka.github.io/bk/net12.png" width="500" height="300" alt=""> 
所以图中的⻓⻓的 URL 实际上是请求服务器⾥的⽂件资源。当没有文件路径名时，就代表访问根⽬录下事先设置的默认⽂件，也就是 /index.html 或者 /default.html 这些⽂件。</li>
<li>对 URL 进⾏解析之后，浏览器确定了 Web 服务器和⽂件名，接下来就是根据这些信息来⽣成 HTTP 请求消息了。</li>
</ul>
<h3 id="5-1-2-真实地址查询-——-DNS"><a href="#5-1-2-真实地址查询-——-DNS" class="headerlink" title="5.1.2 真实地址查询 —— DNS"></a>5.1.2 真实地址查询 —— DNS</h3><p>通过浏览器解析 URL 并⽣成 HTTP 消息后，需要委托操作系统将消息发送给 Web 服务器。<br>但在发送之前，还有⼀项⼯作需要完成，那就是查询服务器域名对应的 IP 地址，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。所以，有⼀种服务器就专⻔保存了 Web 服务器域名与 IP 的对应关系，它就是 DNS 服务器。<br>使用 DNS 域名解析将域名⽹址⾃动转换为具体的 IP 地址。</p>
<h3 id="5-1-3-指南好帮⼿-——-协议栈（p379"><a href="#5-1-3-指南好帮⼿-——-协议栈（p379" class="headerlink" title="5.1.3 指南好帮⼿ —— 协议栈（p379"></a>5.1.3 指南好帮⼿ —— 协议栈（p379</h3><p>???</p>
<h3 id="5-1-4-可靠传输-——-TCP"><a href="#5-1-4-可靠传输-——-TCP" class="headerlink" title="5.1.4 可靠传输 —— TCP"></a>5.1.4 可靠传输 —— TCP</h3><p>- </p>
<h3 id="5-1-5-远程定位-——-IP"><a href="#5-1-5-远程定位-——-IP" class="headerlink" title="5.1.5 远程定位 —— IP"></a>5.1.5 远程定位 —— IP</h3><p>TCP 模块在执⾏连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成⽹络包发送给通信对象</p>
<h3 id="5-1-6-两点传输-——-MAC"><a href="#5-1-6-两点传输-——-MAC" class="headerlink" title="5.1.6 两点传输 —— MAC"></a>5.1.6 两点传输 —— MAC</h3><p>⽣成了 IP 头部之后，接下来⽹络包还需要在 IP 头部的前⾯加上 MAC 头部</p>
<h3 id="5-1-7-出⼝-——-⽹卡"><a href="#5-1-7-出⼝-——-⽹卡" class="headerlink" title="5.1.7. 出⼝ —— ⽹卡"></a>5.1.7. 出⼝ —— ⽹卡</h3><p>⽹络包只是存放在内存中的⼀串⼆进制数字信息，没有办法直接发送给对⽅。因此，我们需要将数字信息转换为电<br>信号，才能在⽹线上传输，也就是说，这才是真正的数据发送过程</p>
<h3 id="5-1-8-送别者-——-交换机"><a href="#5-1-8-送别者-——-交换机" class="headerlink" title="5.1.8 送别者 —— 交换机"></a>5.1.8 送别者 —— 交换机</h3><p>下⾯来看⼀下包是如何通过交换机的。交换机的设计是将⽹络包原样转发到⽬的地。交换机⼯作在 MAC 层，也称<br>为⼆层⽹络设备</p>
<h3 id="5-1-9-出境⼤⻔-——-路由器"><a href="#5-1-9-出境⼤⻔-——-路由器" class="headerlink" title="5.1.9 出境⼤⻔ —— 路由器"></a>5.1.9 出境⼤⻔ —— 路由器</h3><p>。。</p>
<h3 id="5-1-10-互相扒⽪-——-服务器-与-客户端"><a href="#5-1-10-互相扒⽪-——-服务器-与-客户端" class="headerlink" title="5.1.10 互相扒⽪ —— 服务器 与 客户端"></a>5.1.10 互相扒⽪ —— 服务器 与 客户端</h3><img src="https://leo710aka.github.io/bk/net15.png" width="450" height="300" alt=""> 


<h2 id="5-2-Linux如何收发网络包？"><a href="#5-2-Linux如何收发网络包？" class="headerlink" title="5.2 Linux如何收发网络包？"></a>5.2 Linux如何收发网络包？</h2><p>电脑与电脑之间通常都是通话⽹卡、交换机、路由器等⽹络设备连接到⼀起，那由于⽹络设备的异构性，国际标准化组织定义了⼀个七层的 OSI ⽹络模型，但是这个模型由于⽐较复杂，实际应⽤中并没有采⽤，⽽是采⽤了更为简化的 TCP&#x2F;IP 模型，Linux ⽹络协议栈就是按照了该模型来实现的。<br>TCP&#x2F;IP 模型主要分为应⽤层、传输层、⽹络层、⽹络接⼝层四层，每⼀层负责的职责都不同，这也是 Linux ⽹络协议栈主要构成部分。<br>当应⽤程序通过 Socket 接⼝发送数据包，数据包会被⽹络协议栈从上到下进⾏逐层处理后，才会被送到⽹卡队列中，随后由⽹卡将⽹络包发送出去。⽽在接收⽹络包时，同样也要先经过⽹络协议栈从下到上的逐层处理，最后才会被送到应⽤程序。</p>
<hr>


<h1 id="六、学习心得"><a href="#六、学习心得" class="headerlink" title="六、学习心得"></a>六、学习心得</h1><p>操作系统和计算机⽹络有多重要呢？如果没有操作系统，我们的⼿机和电脑可以说是废铁了，如果没有计算机⽹络，我们的⼿机和电脑就是⼀座「孤岛」了，孤岛的世界很单调，也没有什么⾊彩，也正是因为计算机⽹络，才创造出这么丰富多彩的互联⽹世界。</p>
<p>身为程序员的我们，那更应该深刻理解和掌握它们，虽然我们⽇常 CURD 的⼯作中，即使不熟悉它们，也不妨碍我们写代码，但是当出现问题时，没有这些基础知识，你是⽆厘头的，根本没有思路下⼿，这时候和别⼈差距就显现出来了，可以说是程序员之间的分⽔岭。事实上，我们⼯作中会有大量的时间都是在排查和解决问题，编码的时间其实⽐较少，如果计算机基础学的很扎实，虽然不敢保证我们能 100% 解决，但是⾄少遇到问题时，我们有⼀个排查的⽅向，或者直接就定位到问题所在，然后再⼀步⼀步尝试解决，解决了问题，⾃然就体现了我们⾃身的实⼒和价值，职场也会越⾛越远。</p>
<p>当然，计算机⽹络最⽜逼的资料，那必定 RFC ⽂档，它可以称为计算机⽹络世界的「法规」，也是最新、最权威和最正确的地⽅了，困惑⼤家的 TCP 为什么三次握⼿和四次挥⼿，其实在 RFC ⽂档⼏句话就说明⽩了。<br>TCP 协议的 RFC ⽂档：<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/rfc1644">https://datatracker.ietf.org/doc/rfc1644</a></p>
<p>实战系列：在学习书籍资料的时候，不管是 TCP、UDP、ICMP、DNS、HTTP、HTTPS 等协议，最好都可以亲⼿尝试抓数据<br>报，接着可以⽤ Wireshark ⼯具看每⼀个数据报⽂的信息，这样你会觉得计算机⽹络没有想象中那么抽象了，因为它们被你「抓」出来了，并毫⽆保留地显现在你⾯前了，于是你就可以肆⽆忌惮地「扒开」它们，看清它们每⼀个头信息。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" data-id="cmbtnkj1l000v5gv5clwx3e71" data-title="计 算 机 网 络" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/03/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          操 作 系 统
        
      </div>
    </a>
  
  
    <a href="/2021/09/12/SpringBoot/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">SpringBoot</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2046/12/">December 2046</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2046/08/">August 2046</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2046/12/30/nice-photo/">Nice Photo</a>
          </li>
        
          <li>
            <a href="/2046/08/27/Guitar/">Guitar 🎸</a>
          </li>
        
          <li>
            <a href="/2024/10/22/Docker_Kubernetes/">Kubernetes</a>
          </li>
        
          <li>
            <a href="/2024/09/22/InfluxDB/">InfluxDB</a>
          </li>
        
          <li>
            <a href="/2024/09/22/Golang/">Golang</a>
          </li>
        
          <li>
            <a href="/2024/08/18/%E7%90%86%E8%B4%A2/">Lic Ai</a>
          </li>
        
          <li>
            <a href="/2024/07/07/%E7%BE%8E%E7%9A%84Midea/">美 的 Midea</a>
          </li>
        
          <li>
            <a href="/2024/05/01/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/">毕 业 设 计</a>
          </li>
        
          <li>
            <a href="/2024/01/11/RabbitMQ/">RabbitMQ</a>
          </li>
        
          <li>
            <a href="/2024/01/07/SpringCloud/">SpringCloud</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 fengcai<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>