<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Redis | Qué miras Bobo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Redis是一种支持 key-value 等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。 默认端口：6379 启动 Redis下载 Windows版 msi文件：https:&#x2F;&#x2F;github.com&#x2F;microsoftarchive&#x2F;redis&#x2F;releases在环境变量中配好 Redis 的安装">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="http://example.com/2022/06/10/Redis/index.html">
<meta property="og:site_name" content="Qué miras Bobo">
<meta property="og:description" content="Redis是一种支持 key-value 等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。 默认端口：6379 启动 Redis下载 Windows版 msi文件：https:&#x2F;&#x2F;github.com&#x2F;microsoftarchive&#x2F;redis&#x2F;releases在环境变量中配好 Redis 的安装">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-06-10T03:49:42.000Z">
<meta property="article:modified_time" content="2024-03-18T12:58:47.234Z">
<meta property="article:author" content="fengcai">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Qué miras Bobo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="https://github.com/leo710aka/bk/blob/main/DT1.jpg?raw=true">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Qué miras Bobo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Redis" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/10/Redis/" class="article-date">
  <time class="dt-published" datetime="2022-06-10T03:49:42.000Z" itemprop="datePublished">2022-06-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Redis
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Redis是一种支持 key-value 等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。 默认端口：<strong>6379</strong></p>
<h2 id="启动-Redis"><a href="#启动-Redis" class="headerlink" title="启动 Redis"></a>启动 Redis</h2><p>下载 Windows版 msi文件：<a target="_blank" rel="noopener" href="https://github.com/microsoftarchive/redis/releases">https://github.com/microsoftarchive/redis/releases</a><br>在环境变量中配好 Redis 的安装目录后，直接打开 cmd，启动 Redis 客户端<br>启动客户端后, 在客户端cmd窗口中测试 Redis 是否正常工作，设置密码（<strong>命令行设置的密码在服务重启后失效</strong>）<br>注意：<strong>在 Windows 环境下，Redis 不支持后台运行模式，因此在启动 Redis 服务器时必须保持 cmd 窗口一直打开</strong>。（如果想要在后台运行 Redis，可以考虑使用虚拟机或者 Linux 环境下的 Redis）</p>
<ul>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\蔡枫&gt;redis-cli   <span class="comment"># 启动 Redis 客户端（默认Redis服务端未关闭）</span></span><br><span class="line">127.0.0.1:6379&gt; ping                                <span class="comment"># 在 Redis 客户端中输入 ping 命令</span></span><br><span class="line">PONG                                                <span class="comment"># 返回 PONG 表示 正常工作</span></span><br><span class="line">127.0.0.1:6379&gt; config <span class="built_in">set</span> requirepass chskj.2020   <span class="comment"># 修改密码</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; auth chskj.2020                     <span class="comment"># 验证密码</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass              <span class="comment"># 查看密码</span></span><br><span class="line">1)<span class="string">&quot;requirepass&quot;</span></span><br><span class="line">2)<span class="string">&quot;chskj.2020&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="启动-重启-Redis-服务器，客户端"><a href="#启动-重启-Redis-服务器，客户端" class="headerlink" title="启动(重启) Redis 服务器，客户端"></a>启动(重启) Redis 服务器，客户端</h3><p>进入 Redis 的安装目录(D:\Redis)，打开 cmd 窗口(地址栏cmd回车)，执行 redis-server.exe redis.windows.conf，即可<strong>启动 Redis 服务器</strong>。<br>启动Redis服务器后，在 Redis 安装目录打开另一个 cmd 窗口，执行 redis-cli.exe，(或直接双击文件夹中的redis-cli.exe)即可<strong>启动（重启）Redis 客户端</strong>。</p>
<h3 id="库"><a href="#库" class="headerlink" title="库"></a>库</h3><p>Redis中有16个数据库（Database），每个数据库都是一个独立的命名空间，用于存储键值对数据。这些数据库被编号为0到15，默认情况下客户端连接到数据库0。可以通过<code>SELECT</code>命令选择数据库来切换不同的数据库空间，每个数据库都是相互隔离的，数据不会互相干扰。<br>每个数据库都可以包含键值对数据，命令和配置，但请注意，Redis的每个数据库是相对较小的，因此可以将不同类型的数据存储在不同的数据库中，以便更好地组织和管理数据。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 1   <span class="comment"># 切换到数据库1</span></span><br></pre></td></tr></table></figure>


<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Redis所有的key（键）都是字符串。我们在<strong>谈基础数据结构时，讨论的是存储值的数据类型</strong>，主要包括常见的5种数据类型，分别是：String、List、Set、Zset、Hash。 三种特殊的数据类型，分别是 HyperLogLogs（基数统计），Bitmaps (位图) 和 geospatial（地理位置）。 Redis5.0 中还增加了一个数据结构Stream，它借鉴了Kafka的设计，是一个新的强大的支持多播的可持久化的消息队列。</p>
<!-- ![](https://pdai.tech/images/db/redis/db-redis-object-2-2.png) -->
<table>
<thead>
<tr>
<th>结构类型</th>
<th>结构存储的值</th>
<th>结构的读写能力</th>
</tr>
</thead>
<tbody><tr>
<td><strong>String字符串</strong></td>
<td>可以是字符串、整数或浮点数</td>
<td>对整个字符串或字符串的一部分进行操作；对整数或浮点数进行自增或自减操作；</td>
</tr>
<tr>
<td><strong>List列表</strong></td>
<td>一个链表，链表上的每个节点都包含一个字符串</td>
<td>对链表的两端进行push和pop操作，读取单个或多个元素；根据值查找或删除元素；</td>
</tr>
<tr>
<td><strong>Set集合包</strong></td>
<td>含字符串的无序集合</td>
<td>字符串的集合，包含基础的方法有看是否存在添加、获取、删除；还包含计算交集、并集、差集等</td>
</tr>
<tr>
<td><strong>Hash散列</strong></td>
<td>包含键值对的无序散列表</td>
<td>包含方法有添加、获取、删除单个元素</td>
</tr>
<tr>
<td><strong>Zset有序集合</strong></td>
<td>和散列一样，用于存储键值对字符串成员与浮点数分数之间的有序映射；元素的排列顺序由分数的大小决定；</td>
<td>包含方法有添加、获取、删除单个元素以及根据分值范围或成员来获取元素</td>
</tr>
</tbody></table>
<h3 id="String字符串"><a href="#String字符串" class="headerlink" title="String字符串"></a>String字符串</h3><ul>
<li>String是redis中最基本的数据类型，一个key对应一个value。</li>
<li>String类型是二进制安全的，意思是 redis 的 string 可以包含任何数据。如数字，字符串，jpg图片或者序列化的对象。</li>
<li>实战场景<ul>
<li>缓存： 经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力。</li>
<li>计数器：redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。session：常见方案spring session + redis实现session共享，</li>
</ul>
</li>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> hello world    <span class="comment"># 设置存储在给定键中的值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get hello          <span class="comment"># 获取存储在给定键中的值</span></span><br><span class="line"><span class="string">&quot;world&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; del hello          <span class="comment"># 删除存储在给定键中的值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> counter 2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get counter       </span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; incr counter       <span class="comment"># 将键存储的值加1</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; get counter</span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; incrby counter 100 <span class="comment"># 将键存储的值加上整数</span></span><br><span class="line">(<span class="built_in">integer</span>) 103</span><br><span class="line">127.0.0.1:6379&gt; get counter</span><br><span class="line"><span class="string">&quot;103&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; decr counter       <span class="comment"># 将键存储的值减1</span></span><br><span class="line">(<span class="built_in">integer</span>) 102</span><br><span class="line">127.0.0.1:6379&gt; get counter</span><br><span class="line"><span class="string">&quot;102&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="List列表"><a href="#List列表" class="headerlink" title="List列表"></a>List列表</h3><ul>
<li>Redis中的List其实就是链表（Redis用双端链表实现List）。</li>
<li>使用List结构，我们可以轻松地实现最新消息排队功能（比如新浪微博的TimeLine）。List的另一个应用就是消息队列，可以利用List的 PUSH 操作，将任务存放在List中，然后工作线程再用 POP 操作将任务取出进行执行。</li>
<li>使用列表的技巧：lpush+lpop&#x3D;Stack(栈)，lpush+rpop&#x3D;Queue（队列），lpush+ltrim&#x3D;Capped Collection（有限集合），lpush+brpop&#x3D;Message Queue（消息队列）</li>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush mylist 1 2 ll <span class="built_in">ls</span> mem   <span class="comment"># 将给定值推入到列表左端，RPUSH 将给定值推入到列表右端</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1           <span class="comment"># 获取列表在给定范围上的所有值</span></span><br><span class="line">1) <span class="string">&quot;mem&quot;</span></span><br><span class="line">2) <span class="string">&quot;ls&quot;</span></span><br><span class="line">3) <span class="string">&quot;ll&quot;</span></span><br><span class="line">4) <span class="string">&quot;2&quot;</span></span><br><span class="line">5) <span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lindex mylist -1             <span class="comment"># 可以使用负数下标，以 -n 表示列表的倒数第n个元素</span></span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; rpop mylist                  <span class="comment"># 从列表的右端弹出一个值，并返回被弹出的值；lpop 从左弹</span></span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lindex mylist 10             <span class="comment"># index不在 mylist 的区间范围内</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><ul>
<li>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</li>
<li>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</li>
<li>实战场景<ul>
<li>标签（tag）,给用户添加标签，或用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人。</li>
<li>点赞，或点踩，收藏等，可以放到set中实现</li>
</ul>
</li>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myset hao hao1 xiaohao hao  <span class="comment"># 向集合添加一个或多个成员	</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; scard myset                      <span class="comment"># 获取集合的成员数	</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; smembers myset                   <span class="comment"># 返回集合中的所有成员	</span></span><br><span class="line">1) <span class="string">&quot;xiaohao&quot;</span></span><br><span class="line">2) <span class="string">&quot;hao1&quot;</span></span><br><span class="line">3) <span class="string">&quot;hao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; sismember myset hao              <span class="comment"># 判断 member 元素是否是集合 key 的成员</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Hash散列"><a href="#Hash散列" class="headerlink" title="Hash散列"></a>Hash散列</h3><ul>
<li>Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</li>
<li>实战场景 - 缓存： 能直观，相比string更节省空间，的维护缓存信息，如用户信息，视频信息等。</li>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset user name1 hao               <span class="comment"># 添加键值对	</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hset user email1 hao@163.com</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall user                      <span class="comment"># 获取散列中包含的所有键值对	</span></span><br><span class="line">1) <span class="string">&quot;name1&quot;</span></span><br><span class="line">2) <span class="string">&quot;hao&quot;</span></span><br><span class="line">3) <span class="string">&quot;email1&quot;</span></span><br><span class="line">4) <span class="string">&quot;hao@163.com&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hget user user                    <span class="comment"># 获取指定散列键的值</span></span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; hget user name1</span><br><span class="line"><span class="string">&quot;hao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hset user name2 xiaohao</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hdel user name1                   <span class="comment"># 如果给定键存在于散列中，那么就移除这个键</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall user</span><br><span class="line">1) <span class="string">&quot;email1&quot;</span></span><br><span class="line">2) <span class="string">&quot;hao@163.com&quot;</span></span><br><span class="line">3) <span class="string">&quot;name2&quot;</span></span><br><span class="line">4) <span class="string">&quot;xiaohao&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Zset有序集合"><a href="#Zset有序集合" class="headerlink" title="Zset有序集合"></a>Zset有序集合</h3><ul>
<li>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。</li>
<li>有序集合的成员是唯一的, 但分数(score)却可以重复。有序集合是通过两种数据结构实现：<ol>
<li>压缩列表(ziplist): ziplist是为了提高存储效率而设计的一种特殊编码的双向链表。它可以存储字符串或者整数，存储整数时是采用整数的二进制而不是字符串形式存储。它能在O(1)的时间复杂度下完成list两端的push和pop操作。但是因为每次操作都需要重新分配ziplist的内存，所以实际复杂度和ziplist的内存使用量相关</li>
<li>跳跃表(zSkiplist): 跳跃表的性能可以保证在查找，删除，添加等操作的时候在对数期望时间内完成，这个性能是可以和平衡树来相比较的，而且在实现方面比平衡树要优雅，这是采用跳跃表的主要原因。跳跃表的复杂度是O(log(n))。</li>
</ol>
</li>
<li>实战场景 - 排行榜：有序集合经典使用场景。例如小说视频等网站需要对用户上传的小说视频做排行榜，榜单可以按照用户关注数，更新时间，字数等打分，做排行。</li>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd myscoreset 100 hao 90 xiaohao  <span class="comment"># 将一个带有给定分值的成员添加到有序集合里面</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myscoreset 0 -1            <span class="comment"># 根据元素在有序集合中所处位置，从有序集合中获取多个元素</span></span><br><span class="line">1) <span class="string">&quot;xiaohao&quot;</span></span><br><span class="line">2) <span class="string">&quot;hao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZSCORE myscoreset hao</span><br><span class="line"><span class="string">&quot;100&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrem myscoreset hao               <span class="comment"># 如果给定元素成员存在于有序集合中，那么就移除这个元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>采用一种基数算法，用于完成独立总数的统计。（同一个人多次访问，只记一访问量）（独立访客）<br>占据空间小，无论统计多少个数据，只占12K的内存空间<br>不精确的统计算法，标准误差为 0.81%。</p>
<h3 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h3><p>不是一种独立的数据结构，实际上就是字符串<br>支持按位存取数据，可以将其看成是byte数组<br>适合存储索大量的连续的数据的布尔值。（记录一个人连续一年每天的签到情况 0&#x2F;1）（日活跃用户）</p>
<hr>


<h2 id="RedisTemplate"><a href="#RedisTemplate" class="headerlink" title="RedisTemplate"></a>RedisTemplate</h2><ul>
<li>Spring Boot提供了<code>RedisTemplate</code>作为与Redis交互的强大工具。通过<code>RedisTemplate</code>，您可以在java项目中执行各种Redis命令来操作数据，包括字符串、列表、集合、散列、有序集合等。以下是一些常见的Redis操作示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储数据：</span></span><br><span class="line">redisTemplate.opsForValue().set(<span class="string">&quot;myKey&quot;</span>, <span class="string">&quot;myValue&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (String) redisTemplate.opsForValue().get(<span class="string">&quot;myKey&quot;</span>);</span><br><span class="line"><span class="comment">// 列表操作：</span></span><br><span class="line">redisTemplate.opsForList().leftPush(<span class="string">&quot;myList&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">List&lt;String&gt; myList = redisTemplate.opsForList().range(<span class="string">&quot;myList&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 集合操作：</span></span><br><span class="line">redisTemplate.opsForSet().add(<span class="string">&quot;mySet&quot;</span>, <span class="string">&quot;member1&quot;</span>, <span class="string">&quot;member2&quot;</span>);</span><br><span class="line">Set&lt;String&gt; mySet = redisTemplate.opsForSet().members(<span class="string">&quot;mySet&quot;</span>);</span><br><span class="line"><span class="comment">// 散列操作：</span></span><br><span class="line">Map&lt;String, String&gt; myHash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">myHash.put(<span class="string">&quot;field1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">myHash.put(<span class="string">&quot;field2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">redisTemplate.opsForHash().putAll(<span class="string">&quot;myHash&quot;</span>, myHash);</span><br><span class="line"><span class="type">String</span> <span class="variable">fieldValue</span> <span class="operator">=</span> (String) redisTemplate.opsForHash().get(<span class="string">&quot;myHash&quot;</span>, <span class="string">&quot;field1&quot;</span>);</span><br><span class="line"><span class="comment">// 有序集合操作：</span></span><br><span class="line">redisTemplate.opsForZSet().add(<span class="string">&quot;myZSet&quot;</span>, <span class="string">&quot;member1&quot;</span>, <span class="number">1.0</span>);</span><br><span class="line">Set&lt;String&gt; myZSet = redisTemplate.opsForZSet().range(<span class="string">&quot;myZSet&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li>
<li>公共命令<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redisTemplate.delete(key);  <span class="comment">// 删除一个数据结构</span></span><br><span class="line">redisTemplate.hasKey(key);  <span class="comment">// 是否存在一个数据结构</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Redis-事务管理"><a href="#Redis-事务管理" class="headerlink" title="Redis 事务管理"></a>Redis 事务管理</h3><ul>
<li>要使用编程式事务<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTransaction</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">SessionCallback</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">execute</span><span class="params">(RedisOperations redisOperations)</span> <span class="keyword">throws</span> DataAccessException &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> <span class="string">&quot;text:tx&quot;</span>;           </span><br><span class="line">            redisOperations.multi();         <span class="comment">// 启用事务</span></span><br><span class="line">            redisOperations.opsForSet().add(redisKey, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">            redisOperations.opsForSet().add(redisKey, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">            redisOperations.opsForSet().add(redisKey, <span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">            <span class="comment">// redis事务内做查询，无效</span></span><br><span class="line">            <span class="comment">// redis事务中的所有代码在事务提交后一起执行</span></span><br><span class="line">            System.out.println(redisOperations.opsForSet().members(redisKey));            </span><br><span class="line">            <span class="keyword">return</span> redisOperations.exec();   <span class="comment">// 提交事务</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>


<h2 id="Redis缓存问题"><a href="#Redis缓存问题" class="headerlink" title="Redis缓存问题"></a>Redis缓存问题</h2><p>在高并发的业务场景下，数据库大多数情况都是用户并发访问最薄弱的环节。所以，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问Mysql等数据库。这样可以大大缓解数据库的压力。<strong>当缓存库出现时，必须要考虑如下问题：</strong></p>
<ol>
<li><strong>缓存穿透</strong><ul>
<li>问题来源<br> 缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求。由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义，<br> 在流量大时，可能DB就挂掉了，要是有人利用不存在的kev频繁攻击我们的应用，这就是漏洞.<br> 如发起为id为”-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</li>
<li>1、接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;&#x3D;0的直接拦截<br> 2、从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒 (设置太长会导致正常情况也没法使用)。这样可以防止攻击用户反复用同一个id暴力攻击<br> 3、布隆过滤器。bloomfilter就类似于一个hash set，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断个key是否存在于某容器，不存在就直接返回。布隆过滤器的关键就在于hash算法和容器大小，</li>
</ul>
</li>
<li><strong>缓存击穿</strong><ul>
<li>问题来源：    缓存击穿是指缓存中没有但数据库中有的数据(一般是缓存时间到期)，这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力.</li>
<li>1、设置热点数据永远不过期<br> 2、接口限流与熔断，降级。重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些 &#x2F;3务不可用时候，进行熔断，失败快速返回机制。<br> 3、加互斥锁</li>
</ul>
</li>
<li><strong>缓存雪崩</strong><ul>
<li>问题来源： 缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</li>
<li>1、缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生<br> 2、如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中<br> 3、设置热点数据永远不过期.</li>
</ul>
</li>
<li><strong>缓存污染(或满了)</strong><ul>
<li>缓存污染问题说的是缓存中一些只会被访问一次或者几次的的数据，被访问完后，再也不会被访问到，但这部分数据依然留存在缓存中，消耗缓存空间.</li>
<li>缓存污染会随着数据的持续增加而逐渐显露，随着服务的不新运行，缓存中会存在大量的永远不会再次被访问的数据。缓存空间是有限的，如果缓存空间满了，再往缓存里写数据时就会有额外开销，影响Redis性能。这部分额外开销主要是指写的时候判断淘汰策略，根据淘汰策略去选择要淘汰的数据，然后进行删除操作。</li>
</ul>
</li>
</ol>
<h3 id="缓存淘汰策略"><a href="#缓存淘汰策略" class="headerlink" title="缓存淘汰策略"></a>缓存淘汰策略</h3><p>Redis共支持八种淘汰策略，分别是noeviction, volatile-random、 volatile-ttl， volatile-ru、 volatile-lfuallkeys-lru、allkeys-Iandom 和 allkevs-lfu 策略。主要看分三类看:</p>
<ul>
<li>不淘汰<br>noeviction (v4.0后默认的)：一旦缓存被写满了，再有写请求来时，Redis 不再提供服务，而是直接返回错误。这种策略不会淘汰数据，所以无法解决缓存污染问题。一般生产环境不建议使用。</li>
<li>对设置了过期时间的数据中进行淘汰<br>随机 volatile-random：在设置了过期时间的键值对中，进行随机删除。因为是随机删除，无法把不再访问的数据筛选出来，所以可能依然会存在缓存污染现象，无法解决<strong>缓存污染</strong>问题。<br>tvolatile-ttl：Redis在筛选需删除的数据时，越早过期的数据越优先被选择。随机删除就无法解决缓存污染问题。<br>volatile-lru：LRU 算法的全称是 Least Recently Used，按照最近最少使用的原则来筛选数据<br>volatile-lfu：LFU 缓存策略是在 LRU 策略基础上，为每个数据增加了一个计数器，来统计这个数据的访问次数。当使用 LFU 策略筛选淘汰数据时，首先会根据数据的访问次数进行筛选，把访问次数最低的数据淘汰出缓存。如果两个数据的访问次数相同，LFU 策略再比较这两个数据的访问时效性，把距离上一次访问时间更久的数据淘汰出缓存。</li>
<li>全部数据进行淘汰<br>随机 allkeys-random：从所有键值对中随机选择并删除数据。<br>allkeys-lru：使用 LRU 算法在所有数据中进行筛选。<br>allkeys-lfu：使用 LFU 算法在所有数据中进行筛选。</li>
</ul>
<h2 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h2><p>Redis 提供了两种主要的持久化方式，用于在系统重启时保持数据的持久性：RDB 持久化和 AOF 持久化。<br>用户可以根据实际需求选择 RDB 持久化、AOF 持久化或两者结合使用。通常情况下，AOF 持久化是更安全的选择，因为它可以提供更好的持久性保障，但也需要更多的磁盘空间。</p>
<ol>
<li><strong>RDB 持久化：</strong><ul>
<li>RDB 持久化是通过在指定的时间间隔内将内存中的数据集快照写入磁盘的方式来实现的。</li>
<li>快照是一个二进制文件，它记录了某个时间点上 Redis 数据集的所有键值对。</li>
<li>RDB 持久化是一个“点对点”操作，它在指定的时间点创建了一个数据快照。</li>
<li>RDB 持久化适用于备份、灾难恢复等场景。<br>RDB 持久化的配置选项可以在 Redis 配置文件中进行设置，例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1      # 表示在 900 秒（15分钟）内，如果至少有 1 个 key 发生了变化，则执行快照操作</span><br><span class="line">save 300 10     # 表示在 300 秒（5分钟）内，如果至少有 10 个 key 发生了变化，则执行快照操作</span><br><span class="line">save 60 10000   # 表示在 60 秒内，如果至少有 10000 个 key 发生了变化，则执行快照操作</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>AOF 持久化：</strong><ul>
<li>AOF（Append Only File）持久化记录了服务器执行的所有写操作指令，以追加的方式将这些指令记录到一个文件中。</li>
<li>AOF 持久化是一个“追加”操作，每个写操作都被追加到文件末尾。</li>
<li>AOF 持久化适用于对数据的实时持久化需求。<br>AOF 持久化的配置选项可以在 Redis 配置文件中进行设置，例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes            # 启用 AOF 持久化</span><br><span class="line">appendfsync everysec      # 每秒钟执行一次 fsync 操作</span><br></pre></td></tr></table></figure></li>
<li><code>appendfsync</code> 选项可以设置 <code>always</code>、<code>everysec</code> 或 <code>no</code>。<code>always</code> 表示每个写命令都会立即被写入磁盘，<code>everysec</code> 表示每秒执行一次 fsync 操作，<code>no</code> 表示由操作系统自行决定何时进行写入磁盘操作。</li>
<li>Redis 还提供了 AOF 重写机制，可以通过 <code>auto-aof-rewrite-percentage</code> 和 <code>auto-aof-rewrite-min-size</code> 选项配置。这允许 Redis 在不停机的情况下优化 AOF 文件的大小。</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/10/Redis/" data-id="cm1dc911n000f54v5ayk3fhpm" data-title="Redis" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/09/01/Python_Anaconda_Django/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Python / Anaconda / Django
        
      </div>
    </a>
  
  
    <a href="/2022/03/12/Mybatis/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Mybatis / Mybatis-Plus</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2046/12/">December 2046</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2046/12/30/nice-photo/">Nice Photo</a>
          </li>
        
          <li>
            <a href="/2024/09/22/InfluxDB/">InfluxDB</a>
          </li>
        
          <li>
            <a href="/2024/09/22/Golang/">Golang</a>
          </li>
        
          <li>
            <a href="/2024/08/27/Guitar/">Guitar 🎸</a>
          </li>
        
          <li>
            <a href="/2024/08/18/%E4%BF%9D%E9%99%A9/">保 险</a>
          </li>
        
          <li>
            <a href="/2024/07/07/%E7%BE%8E%E7%9A%84Midea/">美 的 Midea</a>
          </li>
        
          <li>
            <a href="/2024/05/01/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/">毕 业 设 计</a>
          </li>
        
          <li>
            <a href="/2024/01/11/RabbitMQ/">RabbitMQ</a>
          </li>
        
          <li>
            <a href="/2024/01/07/SpringCloud/">SpringCloud</a>
          </li>
        
          <li>
            <a href="/2024/01/04/%E9%AA%8F%E4%BC%AFJunbo/">骏 伯 Junbo</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 fengcai<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>